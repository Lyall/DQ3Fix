#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Nicola

#include "Basic.hpp"

#include "Paper2D_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Nicola_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "CinematicCamera_classes.hpp"
#include "GameplayCameras_classes.hpp"
#include "ADSound_structs.hpp"
#include "ADSound_classes.hpp"
#include "SequenceCamera_classes.hpp"
#include "CriWareRuntime_structs.hpp"
#include "AIModule_classes.hpp"
#include "MovieScene_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class Nicola.UIDriverBase
// 0x0020 (0x0048 - 0x0028)
class UUIDriverBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNicolaUIManager*                       UIManager;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWidgetManager*                       WidgetManager;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonWindowWidget*                    View;                                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDriverBase">();
	}
	static class UUIDriverBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDriverBase>();
	}
};
static_assert(alignof(UUIDriverBase) == 0x000008, "Wrong alignment on UUIDriverBase");
static_assert(sizeof(UUIDriverBase) == 0x000048, "Wrong size on UUIDriverBase");
static_assert(offsetof(UUIDriverBase, UIManager) == 0x000030, "Member 'UUIDriverBase::UIManager' has a wrong offset!");
static_assert(offsetof(UUIDriverBase, WidgetManager) == 0x000038, "Member 'UUIDriverBase::WidgetManager' has a wrong offset!");
static_assert(offsetof(UUIDriverBase, View) == 0x000040, "Member 'UUIDriverBase::View' has a wrong offset!");

// Class Nicola.UIWindowBase
// 0x0010 (0x0058 - 0x0048)
class UUIWindowBase : public UUIDriverBase
{
public:
	class UUIRootBase*                            Root;                                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowBase">();
	}
	static class UUIWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowBase>();
	}
};
static_assert(alignof(UUIWindowBase) == 0x000008, "Wrong alignment on UUIWindowBase");
static_assert(sizeof(UUIWindowBase) == 0x000058, "Wrong size on UUIWindowBase");
static_assert(offsetof(UUIWindowBase, Root) == 0x000048, "Member 'UUIWindowBase::Root' has a wrong offset!");

// Class Nicola.UICtrlBase
// 0x0018 (0x0070 - 0x0058)
class UUICtrlBase : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIInput*                               UIInput;                                           // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICtrlBase">();
	}
	static class UUICtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICtrlBase>();
	}
};
static_assert(alignof(UUICtrlBase) == 0x000008, "Wrong alignment on UUICtrlBase");
static_assert(sizeof(UUICtrlBase) == 0x000070, "Wrong size on UUICtrlBase");
static_assert(offsetof(UUICtrlBase, UIInput) == 0x000060, "Member 'UUICtrlBase::UIInput' has a wrong offset!");

// Class Nicola.UIListBase
// 0x0038 (0x00A8 - 0x0070)
class UUIListBase : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIListItem*>                    ViewItems;                                         // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UUIWindowItemPage*                      ItemPage;                                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWindowItem*                          ItemNoViewItem;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListBase">();
	}
	static class UUIListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListBase>();
	}
};
static_assert(alignof(UUIListBase) == 0x000008, "Wrong alignment on UUIListBase");
static_assert(sizeof(UUIListBase) == 0x0000A8, "Wrong size on UUIListBase");
static_assert(offsetof(UUIListBase, ViewItems) == 0x000078, "Member 'UUIListBase::ViewItems' has a wrong offset!");
static_assert(offsetof(UUIListBase, ItemPage) == 0x000088, "Member 'UUIListBase::ItemPage' has a wrong offset!");
static_assert(offsetof(UUIListBase, ItemNoViewItem) == 0x000090, "Member 'UUIListBase::ItemNoViewItem' has a wrong offset!");

// Class Nicola.UIListPage
// 0x0028 (0x00D0 - 0x00A8)
class UUIListPage : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListPage">();
	}
	static class UUIListPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListPage>();
	}
};
static_assert(alignof(UUIListPage) == 0x000008, "Wrong alignment on UUIListPage");
static_assert(sizeof(UUIListPage) == 0x0000D0, "Wrong size on UUIListPage");

// Class Nicola.UITestMouseMenuListPage2
// 0x0008 (0x00D8 - 0x00D0)
class UUITestMouseMenuListPage2 final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListPage2">();
	}
	static class UUITestMouseMenuListPage2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListPage2>();
	}
};
static_assert(alignof(UUITestMouseMenuListPage2) == 0x000008, "Wrong alignment on UUITestMouseMenuListPage2");
static_assert(sizeof(UUITestMouseMenuListPage2) == 0x0000D8, "Wrong size on UUITestMouseMenuListPage2");

// Class Nicola.EventActorBase
// 0x0020 (0x0240 - 0x0220)
class AEventActorBase : public AActor
{
public:
	bool                                          bEnableEvent;                                      // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFieldEventActor;                                // 0x0221(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFlagConditionData>             FlagConditionList;                                 // 0x0228(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFlagOperator                                 FlagOperator;                                      // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFlagEnableType                               FlagEnableType;                                    // 0x0239(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventActorBase">();
	}
	static class AEventActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventActorBase>();
	}
};
static_assert(alignof(AEventActorBase) == 0x000008, "Wrong alignment on AEventActorBase");
static_assert(sizeof(AEventActorBase) == 0x000240, "Wrong size on AEventActorBase");
static_assert(offsetof(AEventActorBase, bEnableEvent) == 0x000220, "Member 'AEventActorBase::bEnableEvent' has a wrong offset!");
static_assert(offsetof(AEventActorBase, bIsFieldEventActor) == 0x000221, "Member 'AEventActorBase::bIsFieldEventActor' has a wrong offset!");
static_assert(offsetof(AEventActorBase, FlagConditionList) == 0x000228, "Member 'AEventActorBase::FlagConditionList' has a wrong offset!");
static_assert(offsetof(AEventActorBase, FlagOperator) == 0x000238, "Member 'AEventActorBase::FlagOperator' has a wrong offset!");
static_assert(offsetof(AEventActorBase, FlagEnableType) == 0x000239, "Member 'AEventActorBase::FlagEnableType' has a wrong offset!");

// Class Nicola.TriggerEventActor
// 0x0028 (0x0268 - 0x0240)
class ATriggerEventActor : public AEventActorBase
{
public:
	class FName                                   TriggerActorId;                                    // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEventConditionInfo>            ConditionInfoList;                                 // 0x0248(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EEventTriggerType                             TriggerType;                                       // 0x0258(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorListComponent*                    ActorList;                                         // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	EEventTriggerType GetTriggerType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerEventActor">();
	}
	static class ATriggerEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerEventActor>();
	}
};
static_assert(alignof(ATriggerEventActor) == 0x000008, "Wrong alignment on ATriggerEventActor");
static_assert(sizeof(ATriggerEventActor) == 0x000268, "Wrong size on ATriggerEventActor");
static_assert(offsetof(ATriggerEventActor, TriggerActorId) == 0x000240, "Member 'ATriggerEventActor::TriggerActorId' has a wrong offset!");
static_assert(offsetof(ATriggerEventActor, ConditionInfoList) == 0x000248, "Member 'ATriggerEventActor::ConditionInfoList' has a wrong offset!");
static_assert(offsetof(ATriggerEventActor, TriggerType) == 0x000258, "Member 'ATriggerEventActor::TriggerType' has a wrong offset!");
static_assert(offsetof(ATriggerEventActor, ActorList) == 0x000260, "Member 'ATriggerEventActor::ActorList' has a wrong offset!");

// Class Nicola.TriggerCharaActor
// 0x0088 (0x02F0 - 0x0268)
class ATriggerCharaActor : public ATriggerEventActor
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnNpcGopId;                                     // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcDirectionType                             DirectionType;                                     // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMovePattern                               MovePattern;                                       // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A[0x2];                                      // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnTag;                                          // 0x027C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnScale;                                        // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableInvisibleEvent;                             // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableTransformEvent;                             // 0x0289(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MangaIconId;                                       // 0x028C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMangaIcon;                                  // 0x0294(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295[0x1];                                      // 0x0295(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ELuaFlag                                      DisplayMangaIconFlag;                              // 0x0296(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFlagMangaIcon;                                 // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimationType                                OverrideAnimType;                                  // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAnimation;                                // 0x029A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B[0x1];                                      // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ELuaFlag                                      OverrideAnimFlag;                                  // 0x029C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFlagAnimation;                                 // 0x029E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMoveSpeed                                 OverrideSpeed;                                     // 0x029F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideMoveSpeed;                                // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMoveWaitTime                              OverrideWaitTime;                                  // 0x02A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideMoveWaitTime;                             // 0x02A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableNpcTrigger;                                 // 0x02A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverrideTalkCollisionRadius;                       // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideTalkCollisionRadius;                      // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableSaveNpc;                                   // 0x02A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ANpcAIController>           NpcAIController;                                   // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AlignmentDoorId;                                   // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAlignmentDoor;                              // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableNoDepthTestCharacterBasePass;               // 0x02C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0xE];                                      // 0x02CA(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PatrolVolume;                                      // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaCharacterBase*                   NpcChara;                                          // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerCharaActor">();
	}
	static class ATriggerCharaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerCharaActor>();
	}
};
static_assert(alignof(ATriggerCharaActor) == 0x000008, "Wrong alignment on ATriggerCharaActor");
static_assert(sizeof(ATriggerCharaActor) == 0x0002F0, "Wrong size on ATriggerCharaActor");
static_assert(offsetof(ATriggerCharaActor, SpawnNpcGopId) == 0x000270, "Member 'ATriggerCharaActor::SpawnNpcGopId' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, DirectionType) == 0x000278, "Member 'ATriggerCharaActor::DirectionType' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, MovePattern) == 0x000279, "Member 'ATriggerCharaActor::MovePattern' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, SpawnTag) == 0x00027C, "Member 'ATriggerCharaActor::SpawnTag' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, SpawnScale) == 0x000284, "Member 'ATriggerCharaActor::SpawnScale' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bEnableInvisibleEvent) == 0x000288, "Member 'ATriggerCharaActor::bEnableInvisibleEvent' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bEnableTransformEvent) == 0x000289, "Member 'ATriggerCharaActor::bEnableTransformEvent' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, MangaIconId) == 0x00028C, "Member 'ATriggerCharaActor::MangaIconId' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bEnableMangaIcon) == 0x000294, "Member 'ATriggerCharaActor::bEnableMangaIcon' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, DisplayMangaIconFlag) == 0x000296, "Member 'ATriggerCharaActor::DisplayMangaIconFlag' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bUseFlagMangaIcon) == 0x000298, "Member 'ATriggerCharaActor::bUseFlagMangaIcon' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, OverrideAnimType) == 0x000299, "Member 'ATriggerCharaActor::OverrideAnimType' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bOverrideAnimation) == 0x00029A, "Member 'ATriggerCharaActor::bOverrideAnimation' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, OverrideAnimFlag) == 0x00029C, "Member 'ATriggerCharaActor::OverrideAnimFlag' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bUseFlagAnimation) == 0x00029E, "Member 'ATriggerCharaActor::bUseFlagAnimation' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, OverrideSpeed) == 0x00029F, "Member 'ATriggerCharaActor::OverrideSpeed' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bOverrideMoveSpeed) == 0x0002A0, "Member 'ATriggerCharaActor::bOverrideMoveSpeed' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, OverrideWaitTime) == 0x0002A1, "Member 'ATriggerCharaActor::OverrideWaitTime' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bOverrideMoveWaitTime) == 0x0002A2, "Member 'ATriggerCharaActor::bOverrideMoveWaitTime' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bEnableNpcTrigger) == 0x0002A3, "Member 'ATriggerCharaActor::bEnableNpcTrigger' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, OverrideTalkCollisionRadius) == 0x0002A4, "Member 'ATriggerCharaActor::OverrideTalkCollisionRadius' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bOverrideTalkCollisionRadius) == 0x0002A8, "Member 'ATriggerCharaActor::bOverrideTalkCollisionRadius' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bDisableSaveNpc) == 0x0002A9, "Member 'ATriggerCharaActor::bDisableSaveNpc' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, NpcAIController) == 0x0002B0, "Member 'ATriggerCharaActor::NpcAIController' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, AlignmentDoorId) == 0x0002B8, "Member 'ATriggerCharaActor::AlignmentDoorId' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bEnableAlignmentDoor) == 0x0002C8, "Member 'ATriggerCharaActor::bEnableAlignmentDoor' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, bEnableNoDepthTestCharacterBasePass) == 0x0002C9, "Member 'ATriggerCharaActor::bEnableNoDepthTestCharacterBasePass' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, PatrolVolume) == 0x0002D8, "Member 'ATriggerCharaActor::PatrolVolume' has a wrong offset!");
static_assert(offsetof(ATriggerCharaActor, NpcChara) == 0x0002E0, "Member 'ATriggerCharaActor::NpcChara' has a wrong offset!");

// Class Nicola.UIMedalTradeMenuWindowMessage
// 0x0040 (0x00B0 - 0x0070)
class UUIMedalTradeMenuWindowMessage final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x40];                                      // 0x0070(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalTradeMenuWindowMessage">();
	}
	static class UUIMedalTradeMenuWindowMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalTradeMenuWindowMessage>();
	}
};
static_assert(alignof(UUIMedalTradeMenuWindowMessage) == 0x000008, "Wrong alignment on UUIMedalTradeMenuWindowMessage");
static_assert(sizeof(UUIMedalTradeMenuWindowMessage) == 0x0000B0, "Wrong size on UUIMedalTradeMenuWindowMessage");

// Class Nicola.ActorListMan
// 0x00F0 (0x0118 - 0x0028)
class UActorListMan final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANicolaCharacterBase*>           PartyMembers;                                      // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class AActor*>              eventTemporaryObjects;                             // 0x0058(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         runtimeSpawnObjects;                               // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AActor*                                 lamiaActor;                                        // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 shipActor;                                         // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UActorListMan* GetInstance();

	TArray<class AActor*> GetActorList(EActorType actorType) const;
	TArray<class AActor*> GetActorListInRange(EActorType actorType, const struct FVector& Center, float Radius, bool bIgnoreZ) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorListMan">();
	}
	static class UActorListMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorListMan>();
	}
};
static_assert(alignof(UActorListMan) == 0x000008, "Wrong alignment on UActorListMan");
static_assert(sizeof(UActorListMan) == 0x000118, "Wrong size on UActorListMan");
static_assert(offsetof(UActorListMan, PartyMembers) == 0x000048, "Member 'UActorListMan::PartyMembers' has a wrong offset!");
static_assert(offsetof(UActorListMan, eventTemporaryObjects) == 0x000058, "Member 'UActorListMan::eventTemporaryObjects' has a wrong offset!");
static_assert(offsetof(UActorListMan, runtimeSpawnObjects) == 0x0000F8, "Member 'UActorListMan::runtimeSpawnObjects' has a wrong offset!");
static_assert(offsetof(UActorListMan, lamiaActor) == 0x000108, "Member 'UActorListMan::lamiaActor' has a wrong offset!");
static_assert(offsetof(UActorListMan, shipActor) == 0x000110, "Member 'UActorListMan::shipActor' has a wrong offset!");

// Class Nicola.BurgTriggerCharaActor
// 0x0050 (0x0340 - 0x02F0)
class ABurgTriggerCharaActor final : public ATriggerCharaActor
{
public:
	uint8                                         Pad_2F0[0x50];                                     // 0x02F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BurgTriggerCharaActor">();
	}
	static class ABurgTriggerCharaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABurgTriggerCharaActor>();
	}
};
static_assert(alignof(ABurgTriggerCharaActor) == 0x000008, "Wrong alignment on ABurgTriggerCharaActor");
static_assert(sizeof(ABurgTriggerCharaActor) == 0x000340, "Wrong size on ABurgTriggerCharaActor");

// Class Nicola.UIMemberCreateMenuListJob
// 0x0020 (0x00F0 - 0x00D0)
class UUIMemberCreateMenuListJob : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListJob">();
	}
	static class UUIMemberCreateMenuListJob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListJob>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListJob) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListJob");
static_assert(sizeof(UUIMemberCreateMenuListJob) == 0x0000F0, "Wrong size on UUIMemberCreateMenuListJob");

// Class Nicola.NicolaMapTimeDependingActor
// 0x0018 (0x0238 - 0x0220)
class ANicolaMapTimeDependingActor : public AActor
{
public:
	uint8                                         Pad_220[0xC];                                      // 0x0220(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         changeStartTime;                                   // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         changeEndTime;                                     // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         randomTimeRange;                                   // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaMapTimeDependingActor">();
	}
	static class ANicolaMapTimeDependingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaMapTimeDependingActor>();
	}
};
static_assert(alignof(ANicolaMapTimeDependingActor) == 0x000008, "Wrong alignment on ANicolaMapTimeDependingActor");
static_assert(sizeof(ANicolaMapTimeDependingActor) == 0x000238, "Wrong size on ANicolaMapTimeDependingActor");
static_assert(offsetof(ANicolaMapTimeDependingActor, changeStartTime) == 0x00022C, "Member 'ANicolaMapTimeDependingActor::changeStartTime' has a wrong offset!");
static_assert(offsetof(ANicolaMapTimeDependingActor, changeEndTime) == 0x000230, "Member 'ANicolaMapTimeDependingActor::changeEndTime' has a wrong offset!");
static_assert(offsetof(ANicolaMapTimeDependingActor, randomTimeRange) == 0x000234, "Member 'ANicolaMapTimeDependingActor::randomTimeRange' has a wrong offset!");

// Class Nicola.NicolaParticleActor
// 0x0010 (0x0248 - 0x0238)
class ANicolaParticleActor final : public ANicolaMapTimeDependingActor
{
public:
	class UParticleSystemComponent*               particleComponent;                                 // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            curveEffectScale;                                  // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaParticleActor">();
	}
	static class ANicolaParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaParticleActor>();
	}
};
static_assert(alignof(ANicolaParticleActor) == 0x000008, "Wrong alignment on ANicolaParticleActor");
static_assert(sizeof(ANicolaParticleActor) == 0x000248, "Wrong size on ANicolaParticleActor");
static_assert(offsetof(ANicolaParticleActor, particleComponent) == 0x000238, "Member 'ANicolaParticleActor::particleComponent' has a wrong offset!");
static_assert(offsetof(ANicolaParticleActor, curveEffectScale) == 0x000240, "Member 'ANicolaParticleActor::curveEffectScale' has a wrong offset!");

// Class Nicola.ActorListComponent
// 0x0030 (0x00E0 - 0x00B0)
class UActorListComponent final : public UActorComponent
{
public:
	TArray<EActorType>                            ActorTypes;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EActorType>                            DynamicActorTypes;                                 // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorListComponent">();
	}
	static class UActorListComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorListComponent>();
	}
};
static_assert(alignof(UActorListComponent) == 0x000008, "Wrong alignment on UActorListComponent");
static_assert(sizeof(UActorListComponent) == 0x0000E0, "Wrong size on UActorListComponent");
static_assert(offsetof(UActorListComponent, ActorTypes) == 0x0000B0, "Member 'UActorListComponent::ActorTypes' has a wrong offset!");
static_assert(offsetof(UActorListComponent, DynamicActorTypes) == 0x0000C0, "Member 'UActorListComponent::DynamicActorTypes' has a wrong offset!");

// Class Nicola.NicolaAssetManager
// 0x0068 (0x04E0 - 0x0478)
class UNicolaAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_478[0x68];                                     // 0x0478(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaAssetManager">();
	}
	static class UNicolaAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaAssetManager>();
	}
};
static_assert(alignof(UNicolaAssetManager) == 0x000008, "Wrong alignment on UNicolaAssetManager");
static_assert(sizeof(UNicolaAssetManager) == 0x0004E0, "Wrong size on UNicolaAssetManager");

// Class Nicola.ButtonGuideBase
// 0x0010 (0x0038 - 0x0028)
class UButtonGuideBase : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonGuideBase">();
	}
	static class UButtonGuideBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonGuideBase>();
	}
};
static_assert(alignof(UButtonGuideBase) == 0x000008, "Wrong alignment on UButtonGuideBase");
static_assert(sizeof(UButtonGuideBase) == 0x000038, "Wrong size on UButtonGuideBase");

// Class Nicola.BannedWordsFilterBase
// 0x0008 (0x0030 - 0x0028)
class UBannedWordsFilterBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsFilterBase">();
	}
	static class UBannedWordsFilterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsFilterBase>();
	}
};
static_assert(alignof(UBannedWordsFilterBase) == 0x000008, "Wrong alignment on UBannedWordsFilterBase");
static_assert(sizeof(UBannedWordsFilterBase) == 0x000030, "Wrong size on UBannedWordsFilterBase");

// Class Nicola.UIFieldTacticsStatusMenuWindowStatus
// 0x0018 (0x0070 - 0x0058)
class UUIFieldTacticsStatusMenuWindowStatus final : public UUIWindowBase
{
public:
	TArray<class UUIListItemText2*>               WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFlipbookWidget*                        FlipbookIcon;                                      // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsStatusMenuWindowStatus">();
	}
	static class UUIFieldTacticsStatusMenuWindowStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsStatusMenuWindowStatus>();
	}
};
static_assert(alignof(UUIFieldTacticsStatusMenuWindowStatus) == 0x000008, "Wrong alignment on UUIFieldTacticsStatusMenuWindowStatus");
static_assert(sizeof(UUIFieldTacticsStatusMenuWindowStatus) == 0x000070, "Wrong size on UUIFieldTacticsStatusMenuWindowStatus");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowStatus, WindowItems) == 0x000058, "Member 'UUIFieldTacticsStatusMenuWindowStatus::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowStatus, FlipbookIcon) == 0x000068, "Member 'UUIFieldTacticsStatusMenuWindowStatus::FlipbookIcon' has a wrong offset!");

// Class Nicola.ButtonGuideUI
// 0x0008 (0x0040 - 0x0038)
class UButtonGuideUI final : public UButtonGuideBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonGuideUI">();
	}
	static class UButtonGuideUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonGuideUI>();
	}
};
static_assert(alignof(UButtonGuideUI) == 0x000008, "Wrong alignment on UButtonGuideUI");
static_assert(sizeof(UButtonGuideUI) == 0x000040, "Wrong size on UButtonGuideUI");

// Class Nicola.NicolaMapTransitionFlowTimeCounter
// 0x0018 (0x0040 - 0x0028)
class UNicolaMapTransitionFlowTimeCounter final : public UObject
{
public:
	class UInterpFloat*                           InterpFloatCallbackOnInitialFadeInPostMapTransitionTimer; // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaMapTransitionFlowTimeCounter">();
	}
	static class UNicolaMapTransitionFlowTimeCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaMapTransitionFlowTimeCounter>();
	}
};
static_assert(alignof(UNicolaMapTransitionFlowTimeCounter) == 0x000008, "Wrong alignment on UNicolaMapTransitionFlowTimeCounter");
static_assert(sizeof(UNicolaMapTransitionFlowTimeCounter) == 0x000040, "Wrong size on UNicolaMapTransitionFlowTimeCounter");
static_assert(offsetof(UNicolaMapTransitionFlowTimeCounter, InterpFloatCallbackOnInitialFadeInPostMapTransitionTimer) == 0x000028, "Member 'UNicolaMapTransitionFlowTimeCounter::InterpFloatCallbackOnInitialFadeInPostMapTransitionTimer' has a wrong offset!");

// Class Nicola.BannedWordsFilterPS5
// 0x0000 (0x0030 - 0x0030)
class UBannedWordsFilterPS5 final : public UBannedWordsFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsFilterPS5">();
	}
	static class UBannedWordsFilterPS5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsFilterPS5>();
	}
};
static_assert(alignof(UBannedWordsFilterPS5) == 0x000008, "Wrong alignment on UBannedWordsFilterPS5");
static_assert(sizeof(UBannedWordsFilterPS5) == 0x000030, "Wrong size on UBannedWordsFilterPS5");

// Class Nicola.LevelLoaderActor
// 0x0050 (0x0270 - 0x0220)
class ALevelLoaderActor : public AActor
{
public:
	bool                                          ignoreSwimMode;                                    // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ignoreFlyMode;                                     // 0x0221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           loadLevelIDs;                                      // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          loadLevels;                                        // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class FName>                           prohibitedUnloadIDs;                               // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorListComponent;                                // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UShapeComponent*>                loadCollisions;                                    // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelLoaderActor">();
	}
	static class ALevelLoaderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelLoaderActor>();
	}
};
static_assert(alignof(ALevelLoaderActor) == 0x000008, "Wrong alignment on ALevelLoaderActor");
static_assert(sizeof(ALevelLoaderActor) == 0x000270, "Wrong size on ALevelLoaderActor");
static_assert(offsetof(ALevelLoaderActor, ignoreSwimMode) == 0x000220, "Member 'ALevelLoaderActor::ignoreSwimMode' has a wrong offset!");
static_assert(offsetof(ALevelLoaderActor, ignoreFlyMode) == 0x000221, "Member 'ALevelLoaderActor::ignoreFlyMode' has a wrong offset!");
static_assert(offsetof(ALevelLoaderActor, loadLevelIDs) == 0x000228, "Member 'ALevelLoaderActor::loadLevelIDs' has a wrong offset!");
static_assert(offsetof(ALevelLoaderActor, loadLevels) == 0x000238, "Member 'ALevelLoaderActor::loadLevels' has a wrong offset!");
static_assert(offsetof(ALevelLoaderActor, prohibitedUnloadIDs) == 0x000248, "Member 'ALevelLoaderActor::prohibitedUnloadIDs' has a wrong offset!");
static_assert(offsetof(ALevelLoaderActor, ActorListComponent) == 0x000258, "Member 'ALevelLoaderActor::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ALevelLoaderActor, loadCollisions) == 0x000260, "Member 'ALevelLoaderActor::loadCollisions' has a wrong offset!");

// Class Nicola.ButtonGuideComponent
// 0x0028 (0x00D8 - 0x00B0)
class UButtonGuideComponent final : public UActorComponent
{
public:
	bool                                          bIsOverrideOffset;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideIconOffset;                                // 0x00B4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UButtonGuideBase*>               IconData;                                          // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BP_CloseButtonGuide();
	void BP_ShowButtonGuide(const class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonGuideComponent">();
	}
	static class UButtonGuideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonGuideComponent>();
	}
};
static_assert(alignof(UButtonGuideComponent) == 0x000008, "Wrong alignment on UButtonGuideComponent");
static_assert(sizeof(UButtonGuideComponent) == 0x0000D8, "Wrong size on UButtonGuideComponent");
static_assert(offsetof(UButtonGuideComponent, bIsOverrideOffset) == 0x0000B0, "Member 'UButtonGuideComponent::bIsOverrideOffset' has a wrong offset!");
static_assert(offsetof(UButtonGuideComponent, OverrideIconOffset) == 0x0000B4, "Member 'UButtonGuideComponent::OverrideIconOffset' has a wrong offset!");
static_assert(offsetof(UButtonGuideComponent, IconData) == 0x0000C8, "Member 'UButtonGuideComponent::IconData' has a wrong offset!");

// Class Nicola.UIListSimple
// 0x0018 (0x00C0 - 0x00A8)
class UUIListSimple : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListSimple">();
	}
	static class UUIListSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListSimple>();
	}
};
static_assert(alignof(UUIListSimple) == 0x000008, "Wrong alignment on UUIListSimple");
static_assert(sizeof(UUIListSimple) == 0x0000C0, "Wrong size on UUIListSimple");

// Class Nicola.UITitle2MenuListVoice
// 0x0008 (0x00C8 - 0x00C0)
class UUITitle2MenuListVoice final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListVoice">();
	}
	static class UUITitle2MenuListVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListVoice>();
	}
};
static_assert(alignof(UUITitle2MenuListVoice) == 0x000008, "Wrong alignment on UUITitle2MenuListVoice");
static_assert(sizeof(UUITitle2MenuListVoice) == 0x0000C8, "Wrong size on UUITitle2MenuListVoice");

// Class Nicola.BannedWordsFilterSteam
// 0x0020 (0x0050 - 0x0030)
class UBannedWordsFilterSteam final : public UBannedWordsFilterBase
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsFilterSteam">();
	}
	static class UBannedWordsFilterSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsFilterSteam>();
	}
};
static_assert(alignof(UBannedWordsFilterSteam) == 0x000008, "Wrong alignment on UBannedWordsFilterSteam");
static_assert(sizeof(UBannedWordsFilterSteam) == 0x000050, "Wrong size on UBannedWordsFilterSteam");

// Class Nicola.BannedWordsFilterSwitch
// 0x0000 (0x0030 - 0x0030)
class UBannedWordsFilterSwitch final : public UBannedWordsFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsFilterSwitch">();
	}
	static class UBannedWordsFilterSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsFilterSwitch>();
	}
};
static_assert(alignof(UBannedWordsFilterSwitch) == 0x000008, "Wrong alignment on UBannedWordsFilterSwitch");
static_assert(sizeof(UBannedWordsFilterSwitch) == 0x000030, "Wrong size on UBannedWordsFilterSwitch");

// Class Nicola.BannedWordsFilterWinGDK
// 0x0000 (0x0030 - 0x0030)
class UBannedWordsFilterWinGDK final : public UBannedWordsFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsFilterWinGDK">();
	}
	static class UBannedWordsFilterWinGDK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsFilterWinGDK>();
	}
};
static_assert(alignof(UBannedWordsFilterWinGDK) == 0x000008, "Wrong alignment on UBannedWordsFilterWinGDK");
static_assert(sizeof(UBannedWordsFilterWinGDK) == 0x000030, "Wrong size on UBannedWordsFilterWinGDK");

// Class Nicola.NicolaPaperFlipbookComponent
// 0x0210 (0x06E0 - 0x04D0)
class UNicolaPaperFlipbookComponent final : public UPaperFlipbookComponent
{
public:
	class UMaterialInterface*                     DefaultMaterial;                                   // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterMaterial                     CharacterMaterial;                                 // 0x04D8(0x0088)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EFlipbookUseType                              UseType;                                           // 0x0560(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFlipbookMirroringType                        MirroringType;                                     // 0x0561(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_562[0x2];                                      // 0x0562(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MIDParamNameMirrorRFlag;                           // 0x0564(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MIDParamNameMirrorGFlag;                           // 0x056C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableMirrorNormalR;                               // 0x0574(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableMirrorNormalG;                               // 0x0575(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDummyShadow;                                      // 0x0576(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_577[0x1];                                      // 0x0577(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraOffset;                                      // 0x0578(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x104];                                    // 0x057C(0x0104)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           overrideCameraOffsetTarget;                        // 0x0680(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x30];                                     // 0x0688(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperFlipbook*                         ReservedFlipbook;                                  // 0x06B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C0[0x20];                                     // 0x06C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayNewFlipbook(class UPaperFlipbook* NewFlipbook, bool bLoop, bool bReverse, int32 mReservedStartFrame, float mReservedPlayRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPaperFlipbookComponent">();
	}
	static class UNicolaPaperFlipbookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaPaperFlipbookComponent>();
	}
};
static_assert(alignof(UNicolaPaperFlipbookComponent) == 0x000010, "Wrong alignment on UNicolaPaperFlipbookComponent");
static_assert(sizeof(UNicolaPaperFlipbookComponent) == 0x0006E0, "Wrong size on UNicolaPaperFlipbookComponent");
static_assert(offsetof(UNicolaPaperFlipbookComponent, DefaultMaterial) == 0x0004D0, "Member 'UNicolaPaperFlipbookComponent::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, CharacterMaterial) == 0x0004D8, "Member 'UNicolaPaperFlipbookComponent::CharacterMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, UseType) == 0x000560, "Member 'UNicolaPaperFlipbookComponent::UseType' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, MirroringType) == 0x000561, "Member 'UNicolaPaperFlipbookComponent::MirroringType' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, MIDParamNameMirrorRFlag) == 0x000564, "Member 'UNicolaPaperFlipbookComponent::MIDParamNameMirrorRFlag' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, MIDParamNameMirrorGFlag) == 0x00056C, "Member 'UNicolaPaperFlipbookComponent::MIDParamNameMirrorGFlag' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, EnableMirrorNormalR) == 0x000574, "Member 'UNicolaPaperFlipbookComponent::EnableMirrorNormalR' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, EnableMirrorNormalG) == 0x000575, "Member 'UNicolaPaperFlipbookComponent::EnableMirrorNormalG' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, bDummyShadow) == 0x000576, "Member 'UNicolaPaperFlipbookComponent::bDummyShadow' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, CameraOffset) == 0x000578, "Member 'UNicolaPaperFlipbookComponent::CameraOffset' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, overrideCameraOffsetTarget) == 0x000680, "Member 'UNicolaPaperFlipbookComponent::overrideCameraOffsetTarget' has a wrong offset!");
static_assert(offsetof(UNicolaPaperFlipbookComponent, ReservedFlipbook) == 0x0006B8, "Member 'UNicolaPaperFlipbookComponent::ReservedFlipbook' has a wrong offset!");

// Class Nicola.BannedWordsFilterXBOX
// 0x0000 (0x0030 - 0x0030)
class UBannedWordsFilterXBOX final : public UBannedWordsFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsFilterXBOX">();
	}
	static class UBannedWordsFilterXBOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsFilterXBOX>();
	}
};
static_assert(alignof(UBannedWordsFilterXBOX) == 0x000008, "Wrong alignment on UBannedWordsFilterXBOX");
static_assert(sizeof(UBannedWordsFilterXBOX) == 0x000030, "Wrong size on UBannedWordsFilterXBOX");

// Class Nicola.BannedWordsUtility
// 0x02C8 (0x02F8 - 0x0030)
class UBannedWordsUtility final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBannedWordsFilterBase*                 BannedWordsFilter;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x288];                                     // 0x0070(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannedWordsUtility">();
	}
	static class UBannedWordsUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannedWordsUtility>();
	}
};
static_assert(alignof(UBannedWordsUtility) == 0x000008, "Wrong alignment on UBannedWordsUtility");
static_assert(sizeof(UBannedWordsUtility) == 0x0002F8, "Wrong size on UBannedWordsUtility");
static_assert(offsetof(UBannedWordsUtility, BannedWordsFilter) == 0x000068, "Member 'UBannedWordsUtility::BannedWordsFilter' has a wrong offset!");

// Class Nicola.NicolaPlatformDebugFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaPlatformDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static bool DebugGetDlcFlags(int32 ID);
	static void DebugSetDisplayTestConsoleCommand(class UObject* WorldContextObject, const class FString& InCmd, int32 InQuality);
	static void DebugSetDlcFlags(int32 ID, bool InFlag);
	static void DebugSetMaxFps(class UObject* WorldContextObject, int32 FPS);
	static void DebugSetMouseCursorVisibility(class UObject* WorldContextObject, bool InFlag);
	static void DebugSetMouseLockMode(class UObject* WorldContextObject, bool InFlag);
	static void DebugSetShowMouseCursorAlways(class UObject* WorldContextObject, bool InFlag);
	static void DebugSetUnfocusPadEnable(class UObject* WorldContextObject, bool InFlag);
	static void DebugSetUnfocusSoundEnable(bool InFlag);
	static void DebugSetVSync(class UObject* WorldContextObject, bool InFlag);
	static void DebugSetWindowMode(EWindowMode InMode);
	static void DebugSetWindowResolution(const struct FIntPoint& InResolution);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlatformDebugFL">();
	}
	static class UNicolaPlatformDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaPlatformDebugFL>();
	}
};
static_assert(alignof(UNicolaPlatformDebugFL) == 0x000008, "Wrong alignment on UNicolaPlatformDebugFL");
static_assert(sizeof(UNicolaPlatformDebugFL) == 0x000028, "Wrong size on UNicolaPlatformDebugFL");

// Class Nicola.BattleActionDataManager
// 0x0060 (0x0090 - 0x0030)
class UBattleActionDataManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleActionDataManager">();
	}
	static class UBattleActionDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleActionDataManager>();
	}
};
static_assert(alignof(UBattleActionDataManager) == 0x000008, "Wrong alignment on UBattleActionDataManager");
static_assert(sizeof(UBattleActionDataManager) == 0x000090, "Wrong size on UBattleActionDataManager");

// Class Nicola.UITitleDemoMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUITitleDemoMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleDemoMenuListTop">();
	}
	static class UUITitleDemoMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleDemoMenuListTop>();
	}
};
static_assert(alignof(UUITitleDemoMenuListTop) == 0x000008, "Wrong alignment on UUITitleDemoMenuListTop");
static_assert(sizeof(UUITitleDemoMenuListTop) == 0x0000D8, "Wrong size on UUITitleDemoMenuListTop");

// Class Nicola.BattleAIActionCountManager
// 0x0060 (0x0090 - 0x0030)
class UBattleAIActionCountManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleAIActionCountManager">();
	}
	static class UBattleAIActionCountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleAIActionCountManager>();
	}
};
static_assert(alignof(UBattleAIActionCountManager) == 0x000008, "Wrong alignment on UBattleAIActionCountManager");
static_assert(sizeof(UBattleAIActionCountManager) == 0x000090, "Wrong size on UBattleAIActionCountManager");

// Class Nicola.NicolaMiscFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaMiscFL final : public UBlueprintFunctionLibrary
{
public:
	static class FString ExecConsoleCommand(class UObject* WorldContextObject, const class FString& Command, int32 PlayerId);
	static class ULevel* GetActorLevel(class AActor* TARGET);
	static int32 GetMeshNumTriangles(class UStaticMesh* Mesh, int32 lod);
	static bool HasActorBegunPlay(class AActor* TARGET);
	static bool IsEditing(const class UObject* InWorldContextObject);
	static bool IsVisibleLevel(class ULevel* Level);
	static bool IsWithEditor();
	static void SetVisibleActor(class AActor* TARGET, bool IsVisible);
	static TArray<class FString> SortStringArray(const TArray<class FString>& Values);
	static void SplitPath(const class FString& Path, class FString* DirPart, class FString* FilenamePart, class FString* ExtensionPart);
	static TArray<class FText> StringArrayToTextArray(const TArray<class FString>& Values);
	static TArray<class FString> StringSetToSortedArray(const TSet<class FString>& Values);
	static TArray<class FString> TextArrayToStringArray(const TArray<class FText>& Values);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaMiscFL">();
	}
	static class UNicolaMiscFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaMiscFL>();
	}
};
static_assert(alignof(UNicolaMiscFL) == 0x000008, "Wrong alignment on UNicolaMiscFL");
static_assert(sizeof(UNicolaMiscFL) == 0x000028, "Wrong size on UNicolaMiscFL");

// Class Nicola.BattleAttachDataFL
// 0x0000 (0x0028 - 0x0028)
class UBattleAttachDataFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleAttachDataFL">();
	}
	static class UBattleAttachDataFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleAttachDataFL>();
	}
};
static_assert(alignof(UBattleAttachDataFL) == 0x000008, "Wrong alignment on UBattleAttachDataFL");
static_assert(sizeof(UBattleAttachDataFL) == 0x000028, "Wrong size on UBattleAttachDataFL");

// Class Nicola.BattleBlendActor
// 0x0020 (0x0240 - 0x0220)
class ABattleBlendActor final : public AActor
{
public:
	class ACameraActor*                           TargetActor;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           StartActor;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           EndActor;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnable(bool menable);
	void SetRate(float mrate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBlendActor">();
	}
	static class ABattleBlendActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleBlendActor>();
	}
};
static_assert(alignof(ABattleBlendActor) == 0x000008, "Wrong alignment on ABattleBlendActor");
static_assert(sizeof(ABattleBlendActor) == 0x000240, "Wrong size on ABattleBlendActor");
static_assert(offsetof(ABattleBlendActor, TargetActor) == 0x000220, "Member 'ABattleBlendActor::TargetActor' has a wrong offset!");
static_assert(offsetof(ABattleBlendActor, StartActor) == 0x000228, "Member 'ABattleBlendActor::StartActor' has a wrong offset!");
static_assert(offsetof(ABattleBlendActor, EndActor) == 0x000230, "Member 'ABattleBlendActor::EndActor' has a wrong offset!");
static_assert(offsetof(ABattleBlendActor, Rate) == 0x000238, "Member 'ABattleBlendActor::Rate' has a wrong offset!");
static_assert(offsetof(ABattleBlendActor, Enable) == 0x00023C, "Member 'ABattleBlendActor::Enable' has a wrong offset!");

// Class Nicola.NicolaPlayerStateBase
// 0x0000 (0x0320 - 0x0320)
class ANicolaPlayerStateBase final : public APlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlayerStateBase">();
	}
	static class ANicolaPlayerStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaPlayerStateBase>();
	}
};
static_assert(alignof(ANicolaPlayerStateBase) == 0x000008, "Wrong alignment on ANicolaPlayerStateBase");
static_assert(sizeof(ANicolaPlayerStateBase) == 0x000320, "Wrong size on ANicolaPlayerStateBase");

// Class Nicola.BattleCameraControl
// 0x02A0 (0x04C0 - 0x0220)
class alignas(0x10) ABattleCameraControl final : public AActor
{
public:
	TArray<class ABattlePositionLine*>            PositionLines;                                     // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsFree;                                            // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAddFOV;                                          // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSubFOV;                                          // 0x0232(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBillboard;                                       // 0x0233(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsScaleGopLooks;                                   // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CameraIndex;                                       // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleCameraSettingType                      CameraSettingType;                                 // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceRate;                                      // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x5C];                                     // 0x0244(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	class ASequenceBattleCameraManager*           SequenceBattleCameraManager;                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x1D0];                                    // 0x02A8(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 monsterRootActor;                                  // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 playerRootActor;                                   // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 cameraFocusTargetActor;                            // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaBattleCameraActor*               battleCameraActor;                                 // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x28];                                     // 0x0498(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABattleCameraControl* GetInstance();

	void AllLoadCameraSetting_BP();
	void AllSaveCameraSetting_BP();
	void ChangeBattleCameraByIndex(int32 typeIndex, float BlendTime, bool misFree);
	void ChangeBillboad_BP();
	void ChangeBillboard();
	void ChangeDebugVisible_BP();
	void ChangeScale();
	void ChangeScale_BP();
	void ChangeScaleMode(EBattleTestActorMode Mode);
	void ChangeUI_BP();
	void DebugGetMonsterLocation(int32 SlotIndex, struct FVector* outWorldLocation, struct FVector* outRelativeLocation);
	void DebugGetPlayerLocation(int32 formationIndex, struct FVector* outWorldLocation, struct FVector* outRelativeLocation);
	void FreeCameraToCurrentCamera();
	class ACameraActor* GetCameraActor(EBattleCameraSettingType Type);
	class ABattlePositionLine* GetEnemyBattlePositionLine();
	void GetPositionLines();
	void Init_BP();
	void LoadSetting(const class FString& settingFile, EBattleCameraSettingType Type);
	void OnChangeCamera_BP();
	void OnChangeFreeCamera(bool Enable);
	void OnInput(class FName Message);
	void PlaySequenceBackToFront(bool GoToEndAndStop, bool isDragon, bool doCrossFade);
	void PlaySequenceFrontToBack(bool GoToEndAndStop, bool isDragon, bool doCrossFade);
	void SaveSetting(const class FString& settingFile, EBattleCameraSettingType Type);
	void UpdateActionInput();
	void UpdateDistanceRate(bool isForce);

	bool IsOpenDebugMenu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCameraControl">();
	}
	static class ABattleCameraControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCameraControl>();
	}
};
static_assert(alignof(ABattleCameraControl) == 0x000010, "Wrong alignment on ABattleCameraControl");
static_assert(sizeof(ABattleCameraControl) == 0x0004C0, "Wrong size on ABattleCameraControl");
static_assert(offsetof(ABattleCameraControl, PositionLines) == 0x000220, "Member 'ABattleCameraControl::PositionLines' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, IsFree) == 0x000230, "Member 'ABattleCameraControl::IsFree' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, IsAddFOV) == 0x000231, "Member 'ABattleCameraControl::IsAddFOV' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, IsSubFOV) == 0x000232, "Member 'ABattleCameraControl::IsSubFOV' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, IsBillboard) == 0x000233, "Member 'ABattleCameraControl::IsBillboard' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, IsScaleGopLooks) == 0x000234, "Member 'ABattleCameraControl::IsScaleGopLooks' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, CameraIndex) == 0x000238, "Member 'ABattleCameraControl::CameraIndex' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, CameraSettingType) == 0x00023C, "Member 'ABattleCameraControl::CameraSettingType' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, DistanceRate) == 0x000240, "Member 'ABattleCameraControl::DistanceRate' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, SequenceBattleCameraManager) == 0x0002A0, "Member 'ABattleCameraControl::SequenceBattleCameraManager' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, monsterRootActor) == 0x000478, "Member 'ABattleCameraControl::monsterRootActor' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, playerRootActor) == 0x000480, "Member 'ABattleCameraControl::playerRootActor' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, cameraFocusTargetActor) == 0x000488, "Member 'ABattleCameraControl::cameraFocusTargetActor' has a wrong offset!");
static_assert(offsetof(ABattleCameraControl, battleCameraActor) == 0x000490, "Member 'ABattleCameraControl::battleCameraActor' has a wrong offset!");

// Class Nicola.BattleCameraSequenceControl
// 0x00E0 (0x0300 - 0x0220)
class ABattleCameraSequenceControl final : public AActor
{
public:
	TSoftObjectPtr<class ULevelSequence>          BackToFrontSequence;                               // 0x0220(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          FrontToBackSequence;                               // 0x0248(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelSequence>>  SequenceCache;                                     // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class ACameraActor*                           FrontCamera;                                       // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           BackCamera;                                        // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           SequenceCamera;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABattleBlendActor*                      BlendActor;                                        // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelSequenceActor*                    curSequencePlayerActor;                            // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequencePlayer*                   curSequencePlayer;                                 // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class AActor*>            BindActorMap;                                      // 0x02B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class ABattleCameraSequenceControl* GetInstance();

	void OnPlaySequenceFinished();
	void PlaySequence(TSoftObjectPtr<class ULevelSequence> sequenceSoftObjectPtr, bool GoToEndAndStop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCameraSequenceControl">();
	}
	static class ABattleCameraSequenceControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCameraSequenceControl>();
	}
};
static_assert(alignof(ABattleCameraSequenceControl) == 0x000008, "Wrong alignment on ABattleCameraSequenceControl");
static_assert(sizeof(ABattleCameraSequenceControl) == 0x000300, "Wrong size on ABattleCameraSequenceControl");
static_assert(offsetof(ABattleCameraSequenceControl, BackToFrontSequence) == 0x000220, "Member 'ABattleCameraSequenceControl::BackToFrontSequence' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, FrontToBackSequence) == 0x000248, "Member 'ABattleCameraSequenceControl::FrontToBackSequence' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, SequenceCache) == 0x000270, "Member 'ABattleCameraSequenceControl::SequenceCache' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, FrontCamera) == 0x000280, "Member 'ABattleCameraSequenceControl::FrontCamera' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, BackCamera) == 0x000288, "Member 'ABattleCameraSequenceControl::BackCamera' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, SequenceCamera) == 0x000290, "Member 'ABattleCameraSequenceControl::SequenceCamera' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, BlendActor) == 0x000298, "Member 'ABattleCameraSequenceControl::BlendActor' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, curSequencePlayerActor) == 0x0002A0, "Member 'ABattleCameraSequenceControl::curSequencePlayerActor' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, curSequencePlayer) == 0x0002A8, "Member 'ABattleCameraSequenceControl::curSequencePlayer' has a wrong offset!");
static_assert(offsetof(ABattleCameraSequenceControl, BindActorMap) == 0x0002B0, "Member 'ABattleCameraSequenceControl::BindActorMap' has a wrong offset!");

// Class Nicola.UIRootBase
// 0x0008 (0x0078 - 0x0070)
class UUIRootBase : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRootBase">();
	}
	static class UUIRootBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRootBase>();
	}
};
static_assert(alignof(UUIRootBase) == 0x000008, "Wrong alignment on UUIRootBase");
static_assert(sizeof(UUIRootBase) == 0x000078, "Wrong size on UUIRootBase");

// Class Nicola.UIKeyboardNameMenu
// 0x0020 (0x0098 - 0x0078)
class UUIKeyboardNameMenu : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIKeyboardNameMenuListInput*           ListInput;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIKeyboardNameMenuWindowDisplay*       WindowDisplay;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenu">();
	}
	static class UUIKeyboardNameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenu>();
	}
};
static_assert(alignof(UUIKeyboardNameMenu) == 0x000008, "Wrong alignment on UUIKeyboardNameMenu");
static_assert(sizeof(UUIKeyboardNameMenu) == 0x000098, "Wrong size on UUIKeyboardNameMenu");
static_assert(offsetof(UUIKeyboardNameMenu, ListInput) == 0x000088, "Member 'UUIKeyboardNameMenu::ListInput' has a wrong offset!");
static_assert(offsetof(UUIKeyboardNameMenu, WindowDisplay) == 0x000090, "Member 'UUIKeyboardNameMenu::WindowDisplay' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuKeyboard
// 0x0018 (0x00B0 - 0x0098)
class UUIKeyboardNameMenuKeyboard : public UUIKeyboardNameMenu
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIKeyboardNameMenuKeyboardListTop*     ListTop;                                           // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIKeyboardNameMenuWindowDisplay*       DispText;                                          // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuKeyboard">();
	}
	static class UUIKeyboardNameMenuKeyboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuKeyboard>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuKeyboard) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuKeyboard");
static_assert(sizeof(UUIKeyboardNameMenuKeyboard) == 0x0000B0, "Wrong size on UUIKeyboardNameMenuKeyboard");
static_assert(offsetof(UUIKeyboardNameMenuKeyboard, ListTop) == 0x0000A0, "Member 'UUIKeyboardNameMenuKeyboard::ListTop' has a wrong offset!");
static_assert(offsetof(UUIKeyboardNameMenuKeyboard, DispText) == 0x0000A8, "Member 'UUIKeyboardNameMenuKeyboard::DispText' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuKeyboardReal
// 0x0000 (0x00B0 - 0x00B0)
class UUIKeyboardNameMenuKeyboardReal final : public UUIKeyboardNameMenuKeyboard
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuKeyboardReal">();
	}
	static class UUIKeyboardNameMenuKeyboardReal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuKeyboardReal>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuKeyboardReal) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuKeyboardReal");
static_assert(sizeof(UUIKeyboardNameMenuKeyboardReal) == 0x0000B0, "Wrong size on UUIKeyboardNameMenuKeyboardReal");

// Class Nicola.NicolaLevelBase
// 0x0038 (0x0260 - 0x0228)
class ANicolaLevelBase : public ALevelScriptActor
{
public:
	class FString                                 LuaScriptName;                                     // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GameProgress;                                      // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TestLevel;                                         // 0x0239(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A[0xB];                                      // 0x023A(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          unloadSublevel;                                    // 0x0245(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246[0x1A];                                     // 0x0246(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLevelBase">();
	}
	static class ANicolaLevelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaLevelBase>();
	}
};
static_assert(alignof(ANicolaLevelBase) == 0x000008, "Wrong alignment on ANicolaLevelBase");
static_assert(sizeof(ANicolaLevelBase) == 0x000260, "Wrong size on ANicolaLevelBase");
static_assert(offsetof(ANicolaLevelBase, LuaScriptName) == 0x000228, "Member 'ANicolaLevelBase::LuaScriptName' has a wrong offset!");
static_assert(offsetof(ANicolaLevelBase, GameProgress) == 0x000238, "Member 'ANicolaLevelBase::GameProgress' has a wrong offset!");
static_assert(offsetof(ANicolaLevelBase, TestLevel) == 0x000239, "Member 'ANicolaLevelBase::TestLevel' has a wrong offset!");
static_assert(offsetof(ANicolaLevelBase, unloadSublevel) == 0x000245, "Member 'ANicolaLevelBase::unloadSublevel' has a wrong offset!");

// Class Nicola.NicolaResearchLevel
// 0x0050 (0x02B0 - 0x0260)
class ANicolaResearchLevel final : public ANicolaLevelBase
{
public:
	uint8                                         Pad_260[0x28];                                     // 0x0260(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                preLoadingEffectAssets;                            // 0x0288(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class ULanternManager*                        LanternManager;                                    // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeightFogDensity;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensBloomIntensity;                                // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mapIdInEditor;                                     // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnVisibleLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchLevel">();
	}
	static class ANicolaResearchLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchLevel>();
	}
};
static_assert(alignof(ANicolaResearchLevel) == 0x000008, "Wrong alignment on ANicolaResearchLevel");
static_assert(sizeof(ANicolaResearchLevel) == 0x0002B0, "Wrong size on ANicolaResearchLevel");
static_assert(offsetof(ANicolaResearchLevel, preLoadingEffectAssets) == 0x000288, "Member 'ANicolaResearchLevel::preLoadingEffectAssets' has a wrong offset!");
static_assert(offsetof(ANicolaResearchLevel, LanternManager) == 0x000298, "Member 'ANicolaResearchLevel::LanternManager' has a wrong offset!");
static_assert(offsetof(ANicolaResearchLevel, HeightFogDensity) == 0x0002A0, "Member 'ANicolaResearchLevel::HeightFogDensity' has a wrong offset!");
static_assert(offsetof(ANicolaResearchLevel, LensBloomIntensity) == 0x0002A4, "Member 'ANicolaResearchLevel::LensBloomIntensity' has a wrong offset!");
static_assert(offsetof(ANicolaResearchLevel, mapIdInEditor) == 0x0002A8, "Member 'ANicolaResearchLevel::mapIdInEditor' has a wrong offset!");

// Class Nicola.BattleCameraSettingFL
// 0x0000 (0x0028 - 0x0028)
class UBattleCameraSettingFL final : public UBlueprintFunctionLibrary
{
public:
	static TMap<class FName, struct FBattleCameraSetting> CameraSettingToMap();
	static class FString GetCameraSettingDirPath();
	static float GetDistanceRate(const struct FVector& Start, const struct FVector& End, const struct FVector& Now);
	static void LoadCameraSetting(EBattleCameraSettingType Type, struct FBattleCameraSetting* OutCameraSetting, bool* Success);
	static void LoadCameraSettingByFile(EBattleCameraSettingType Type, const class FString& SettingFilePath, struct FBattleCameraSetting* OutCameraSetting, bool* Success);
	static void LoadCameraSettingByFileOrAsset(EBattleCameraSettingType Type, const class FString& SettingFilePath, struct FBattleCameraSetting* OutCameraSetting, bool* Success);
	static void SaveCameraSetting(const struct FBattleCameraSetting& InCameraSetting, bool* Success);
	static void SaveCameraSettingByFile(const struct FBattleCameraSetting& InCameraSetting, const class FString& SettingFilePath, bool* Success);
	static void TextFileLoad(const class FString& FilePath, class FString* FileData, bool* Success);
	static void TextFileSave(const class FString& FilePath, const class FString& FileData, bool* Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCameraSettingFL">();
	}
	static class UBattleCameraSettingFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleCameraSettingFL>();
	}
};
static_assert(alignof(UBattleCameraSettingFL) == 0x000008, "Wrong alignment on UBattleCameraSettingFL");
static_assert(sizeof(UBattleCameraSettingFL) == 0x000028, "Wrong size on UBattleCameraSettingFL");

// Class Nicola.BattleCharaOpacity
// 0x0008 (0x0228 - 0x0220)
class ABattleCharaOpacity final : public AActor
{
public:
	float                                         Opacity;                                           // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnable(bool menable);
	void SetOpacity(float mopacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharaOpacity">();
	}
	static class ABattleCharaOpacity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCharaOpacity>();
	}
};
static_assert(alignof(ABattleCharaOpacity) == 0x000008, "Wrong alignment on ABattleCharaOpacity");
static_assert(sizeof(ABattleCharaOpacity) == 0x000228, "Wrong size on ABattleCharaOpacity");
static_assert(offsetof(ABattleCharaOpacity, Opacity) == 0x000220, "Member 'ABattleCharaOpacity::Opacity' has a wrong offset!");
static_assert(offsetof(ABattleCharaOpacity, Enable) == 0x000224, "Member 'ABattleCharaOpacity::Enable' has a wrong offset!");

// Class Nicola.NicolaProfilingFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaProfilingFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaProfilingFL">();
	}
	static class UNicolaProfilingFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaProfilingFL>();
	}
};
static_assert(alignof(UNicolaProfilingFL) == 0x000008, "Wrong alignment on UNicolaProfilingFL");
static_assert(sizeof(UNicolaProfilingFL) == 0x000028, "Wrong size on UNicolaProfilingFL");

// Class Nicola.UIInitialMenu
// 0x0040 (0x00B8 - 0x0078)
class UUIInitialMenu final : public UUIRootBase
{
public:
	class UUIInitialMenuFlowMain*                 FlowMain;                                          // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIInitialMenuFlowSaveData*             FlowSaveData;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIInitialMenuWindowLogo*               WindowLogo;                                        // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FUIInitialLogoData>             LogoDatas;                                         // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUILoadableTexture>             Textures;                                          // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInitialMenu">();
	}
	static class UUIInitialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInitialMenu>();
	}
};
static_assert(alignof(UUIInitialMenu) == 0x000008, "Wrong alignment on UUIInitialMenu");
static_assert(sizeof(UUIInitialMenu) == 0x0000B8, "Wrong size on UUIInitialMenu");
static_assert(offsetof(UUIInitialMenu, FlowMain) == 0x000078, "Member 'UUIInitialMenu::FlowMain' has a wrong offset!");
static_assert(offsetof(UUIInitialMenu, FlowSaveData) == 0x000080, "Member 'UUIInitialMenu::FlowSaveData' has a wrong offset!");
static_assert(offsetof(UUIInitialMenu, WindowLogo) == 0x000088, "Member 'UUIInitialMenu::WindowLogo' has a wrong offset!");
static_assert(offsetof(UUIInitialMenu, LogoDatas) == 0x000090, "Member 'UUIInitialMenu::LogoDatas' has a wrong offset!");
static_assert(offsetof(UUIInitialMenu, Textures) == 0x0000A0, "Member 'UUIInitialMenu::Textures' has a wrong offset!");

// Class Nicola.BattleCoffin
// 0x0020 (0x0240 - 0x0220)
class ABattleCoffin final : public AActor
{
public:
	class USphereComponent*                       SphereComponent;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorListComponent*                    ActorListComponent;                                // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialInstanceDynamic;                           // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCoffin">();
	}
	static class ABattleCoffin* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCoffin>();
	}
};
static_assert(alignof(ABattleCoffin) == 0x000008, "Wrong alignment on ABattleCoffin");
static_assert(sizeof(ABattleCoffin) == 0x000240, "Wrong size on ABattleCoffin");
static_assert(offsetof(ABattleCoffin, SphereComponent) == 0x000220, "Member 'ABattleCoffin::SphereComponent' has a wrong offset!");
static_assert(offsetof(ABattleCoffin, StaticMesh) == 0x000228, "Member 'ABattleCoffin::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABattleCoffin, ActorListComponent) == 0x000230, "Member 'ABattleCoffin::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ABattleCoffin, MaterialInstanceDynamic) == 0x000238, "Member 'ABattleCoffin::MaterialInstanceDynamic' has a wrong offset!");

// Class Nicola.UIShopMenuWindowCountSelect
// 0x0038 (0x00A8 - 0x0070)
class UUIShopMenuWindowCountSelect final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGopTextBlock*                          TextCount;                                         // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextTotal;                                         // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageArrowRight;                                   // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageArrowLeft;                                    // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuWindowCountSelect">();
	}
	static class UUIShopMenuWindowCountSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuWindowCountSelect>();
	}
};
static_assert(alignof(UUIShopMenuWindowCountSelect) == 0x000008, "Wrong alignment on UUIShopMenuWindowCountSelect");
static_assert(sizeof(UUIShopMenuWindowCountSelect) == 0x0000A8, "Wrong size on UUIShopMenuWindowCountSelect");
static_assert(offsetof(UUIShopMenuWindowCountSelect, TextCount) == 0x000088, "Member 'UUIShopMenuWindowCountSelect::TextCount' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowCountSelect, TextTotal) == 0x000090, "Member 'UUIShopMenuWindowCountSelect::TextTotal' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowCountSelect, ImageArrowRight) == 0x000098, "Member 'UUIShopMenuWindowCountSelect::ImageArrowRight' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowCountSelect, ImageArrowLeft) == 0x0000A0, "Member 'UUIShopMenuWindowCountSelect::ImageArrowLeft' has a wrong offset!");

// Class Nicola.BattleDamageFL
// 0x0000 (0x0028 - 0x0028)
class UBattleDamageFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDamageFL">();
	}
	static class UBattleDamageFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDamageFL>();
	}
};
static_assert(alignof(UBattleDamageFL) == 0x000008, "Wrong alignment on UBattleDamageFL");
static_assert(sizeof(UBattleDamageFL) == 0x000028, "Wrong size on UBattleDamageFL");

// Class Nicola.NicolaPlayerInput
// 0x0068 (0x0090 - 0x0028)
class UNicolaPlayerInput final : public UObject
{
public:
	float                                         DefaultRepeatStartTime;                            // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultRepeatSpanTime;                             // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlayerInput">();
	}
	static class UNicolaPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaPlayerInput>();
	}
};
static_assert(alignof(UNicolaPlayerInput) == 0x000008, "Wrong alignment on UNicolaPlayerInput");
static_assert(sizeof(UNicolaPlayerInput) == 0x000090, "Wrong size on UNicolaPlayerInput");
static_assert(offsetof(UNicolaPlayerInput, DefaultRepeatStartTime) == 0x000028, "Member 'UNicolaPlayerInput::DefaultRepeatStartTime' has a wrong offset!");
static_assert(offsetof(UNicolaPlayerInput, DefaultRepeatSpanTime) == 0x00002C, "Member 'UNicolaPlayerInput::DefaultRepeatSpanTime' has a wrong offset!");

// Class Nicola.BattleDebugFL
// 0x0000 (0x0028 - 0x0028)
class UBattleDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static void GetBattleEncountIdMonsterNameMap(TMap<class FString, class FName>* outMap);
	static void GetBattleEncountIds(TArray<class FName>* outArray);
	static void GetBattleFieldIds(TArray<class FName>* outArray);
	static void GetBattleMonsterIdsFromEncountId(class FName encountId, TArray<class FName>* outArray, TArray<class FString>* outMonsterNames);
	static void StartDebugBattle(const struct FBattleEncountInfo& Info, EMapTimeFrame Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDebugFL">();
	}
	static class UBattleDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDebugFL>();
	}
};
static_assert(alignof(UBattleDebugFL) == 0x000008, "Wrong alignment on UBattleDebugFL");
static_assert(sizeof(UBattleDebugFL) == 0x000028, "Wrong size on UBattleDebugFL");

// Class Nicola.DebugMenuCustomMan
// 0x0060 (0x0088 - 0x0028)
class UDebugMenuCustomMan : public UObject
{
public:
	TMap<class FString, class UDebugMenuCategoryData*> Categories;                                        // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuCustomMan">();
	}
	static class UDebugMenuCustomMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuCustomMan>();
	}
};
static_assert(alignof(UDebugMenuCustomMan) == 0x000008, "Wrong alignment on UDebugMenuCustomMan");
static_assert(sizeof(UDebugMenuCustomMan) == 0x000088, "Wrong size on UDebugMenuCustomMan");
static_assert(offsetof(UDebugMenuCustomMan, Categories) == 0x000028, "Member 'UDebugMenuCustomMan::Categories' has a wrong offset!");

// Class Nicola.NicolaResearchComponentInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaResearchComponentInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchComponentInterface">();
	}
	static class INicolaResearchComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaResearchComponentInterface>();
	}
};
static_assert(alignof(INicolaResearchComponentInterface) == 0x000008, "Wrong alignment on INicolaResearchComponentInterface");
static_assert(sizeof(INicolaResearchComponentInterface) == 0x000028, "Wrong size on INicolaResearchComponentInterface");

// Class Nicola.BattleDebugMan
// 0x0338 (0x03C0 - 0x0088)
class alignas(0x10) UBattleDebugMan final : public UDebugMenuCustomMan
{
public:
	TArray<class ANicolaCharacterBase*>           selectCharacters;                                  // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EAnimationType>                        autoAnimationTypes;                                // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ANicolaCharacterBase*>           autoAnimationCharacters;                           // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x308];                                     // 0x00B8(0x0308)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDebugMan">();
	}
	static class UBattleDebugMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDebugMan>();
	}
};
static_assert(alignof(UBattleDebugMan) == 0x000010, "Wrong alignment on UBattleDebugMan");
static_assert(sizeof(UBattleDebugMan) == 0x0003C0, "Wrong size on UBattleDebugMan");
static_assert(offsetof(UBattleDebugMan, selectCharacters) == 0x000088, "Member 'UBattleDebugMan::selectCharacters' has a wrong offset!");
static_assert(offsetof(UBattleDebugMan, autoAnimationTypes) == 0x000098, "Member 'UBattleDebugMan::autoAnimationTypes' has a wrong offset!");
static_assert(offsetof(UBattleDebugMan, autoAnimationCharacters) == 0x0000A8, "Member 'UBattleDebugMan::autoAnimationCharacters' has a wrong offset!");

// Class Nicola.BattleEffectManager
// 0x0168 (0x0198 - 0x0030)
class UBattleEffectManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     moveEndLocationEffect;                             // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            moveEndLocationCurve;                              // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     currentMoveEffect;                                 // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFXSystemComponent*>             playingFxSystemCompList;                           // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSwitchEffectInfo>              statusEffectInfoList;                              // 0x0100(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSwitchEffectInfo>              buffDebuffInfoList;                                // 0x0110(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     darkAuraEffect;                                    // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     sphereOfLightEffect;                               // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     blackFogEffect;                                    // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x50];                                     // 0x0138(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFXSystemComponent*>             ordealFxCompList;                                  // 0x0188(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnEndTransitionBattle();
	class UFXSystemComponent* PlayEffectAtLocation(class UFXSystemAsset* Particle, const struct FVector& Location, const struct FRotator& Rotation, float Scale);
	class UFXSystemComponent* PlayEffectOnUnit(class UFXSystemAsset* Particle, EBattleUnitType unitType, class ANicolaCharacterBase* Character, int32 formationIndex, EBattleEffectLocationType LocationType, float Scale, bool bAttach);
	class UFXSystemComponent* PlayMovingEndLocationEffect(class UFXSystemAsset* Particle, const struct FVector& StartLocation, const struct FVector& EndLocation, const struct FVector& moveTargetLocation, float moveSec, float waitSec);
	class UFXSystemComponent* PlayUnitToAllEffect(class UFXSystemAsset* Particle, EBattleUnitType startUnitType, const class ANicolaCharacterBase* startCharacter, int32 startCharacterFormationIndex, EBattleEffectLocationType startLocationType, bool bTargetIsUserSide);
	class UFXSystemComponent* PlayUnitToUnitEffect(class UFXSystemAsset* Particle, EBattleUnitType startUnitType, class ANicolaCharacterBase* startCharacter, int32 startCharacterFormationIndex, EBattleEffectLocationType startLocationType, EBattleUnitType endUnitType, class ANicolaCharacterBase* endCharacter, int32 endCharacterFormationIndex, EBattleEffectLocationType endLocationType);
	void UpdateActionCameraPlayerLocation(int32 partyMembaerNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleEffectManager">();
	}
	static class UBattleEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleEffectManager>();
	}
};
static_assert(alignof(UBattleEffectManager) == 0x000008, "Wrong alignment on UBattleEffectManager");
static_assert(sizeof(UBattleEffectManager) == 0x000198, "Wrong size on UBattleEffectManager");
static_assert(offsetof(UBattleEffectManager, moveEndLocationEffect) == 0x0000C0, "Member 'UBattleEffectManager::moveEndLocationEffect' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, moveEndLocationCurve) == 0x0000C8, "Member 'UBattleEffectManager::moveEndLocationCurve' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, currentMoveEffect) == 0x0000D0, "Member 'UBattleEffectManager::currentMoveEffect' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, playingFxSystemCompList) == 0x0000E8, "Member 'UBattleEffectManager::playingFxSystemCompList' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, statusEffectInfoList) == 0x000100, "Member 'UBattleEffectManager::statusEffectInfoList' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, buffDebuffInfoList) == 0x000110, "Member 'UBattleEffectManager::buffDebuffInfoList' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, darkAuraEffect) == 0x000120, "Member 'UBattleEffectManager::darkAuraEffect' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, sphereOfLightEffect) == 0x000128, "Member 'UBattleEffectManager::sphereOfLightEffect' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, blackFogEffect) == 0x000130, "Member 'UBattleEffectManager::blackFogEffect' has a wrong offset!");
static_assert(offsetof(UBattleEffectManager, ordealFxCompList) == 0x000188, "Member 'UBattleEffectManager::ordealFxCompList' has a wrong offset!");

// Class Nicola.BattleEncountFL
// 0x0000 (0x0028 - 0x0028)
class UBattleEncountFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleEncountFL">();
	}
	static class UBattleEncountFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleEncountFL>();
	}
};
static_assert(alignof(UBattleEncountFL) == 0x000008, "Wrong alignment on UBattleEncountFL");
static_assert(sizeof(UBattleEncountFL) == 0x000028, "Wrong size on UBattleEncountFL");

// Class Nicola.BattleEncountManager
// 0x00B0 (0x00E0 - 0x0030)
class UBattleEncountManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class ANicolaEncountCalcActor*                CalcActor;                                         // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleEncountManager">();
	}
	static class UBattleEncountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleEncountManager>();
	}
};
static_assert(alignof(UBattleEncountManager) == 0x000008, "Wrong alignment on UBattleEncountManager");
static_assert(sizeof(UBattleEncountManager) == 0x0000E0, "Wrong size on UBattleEncountManager");
static_assert(offsetof(UBattleEncountManager, CalcActor) == 0x0000D8, "Member 'UBattleEncountManager::CalcActor' has a wrong offset!");

// Class Nicola.UIInput
// 0x0E70 (0x0E98 - 0x0028)
class UUIInput final : public UObject
{
public:
	class ANicolaPlayerController*                NPC;                                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RepSecArray;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0xE50];                                     // 0x0048(0x0E50)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInput">();
	}
	static class UUIInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInput>();
	}
};
static_assert(alignof(UUIInput) == 0x000008, "Wrong alignment on UUIInput");
static_assert(sizeof(UUIInput) == 0x000E98, "Wrong size on UUIInput");
static_assert(offsetof(UUIInput, NPC) == 0x000028, "Member 'UUIInput::NPC' has a wrong offset!");
static_assert(offsetof(UUIInput, RepSecArray) == 0x000038, "Member 'UUIInput::RepSecArray' has a wrong offset!");

// Class Nicola.BattleFL
// 0x0000 (0x0028 - 0x0028)
class UBattleFL final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetPrevBattleEncountMonsterId();
	static bool IsRunningBattle();
	static void StartBattle(const struct FBattleEncountInfo& encountInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleFL">();
	}
	static class UBattleFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleFL>();
	}
};
static_assert(alignof(UBattleFL) == 0x000008, "Wrong alignment on UBattleFL");
static_assert(sizeof(UBattleFL) == 0x000028, "Wrong size on UBattleFL");

// Class Nicola.UIWindowItem
// 0x0018 (0x0040 - 0x0028)
class UUIWindowItem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonItemWidget*                      View;                                              // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem;                                          // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItem">();
	}
	static class UUIWindowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItem>();
	}
};
static_assert(alignof(UUIWindowItem) == 0x000008, "Wrong alignment on UUIWindowItem");
static_assert(sizeof(UUIWindowItem) == 0x000040, "Wrong size on UUIWindowItem");
static_assert(offsetof(UUIWindowItem, View) == 0x000030, "Member 'UUIWindowItem::View' has a wrong offset!");
static_assert(offsetof(UUIWindowItem, TextItem) == 0x000038, "Member 'UUIWindowItem::TextItem' has a wrong offset!");

// Class Nicola.UIListItem
// 0x0018 (0x0058 - 0x0040)
class UUIListItem : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageCursor;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageCursorNF;                                     // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItem">();
	}
	static class UUIListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItem>();
	}
};
static_assert(alignof(UUIListItem) == 0x000008, "Wrong alignment on UUIListItem");
static_assert(sizeof(UUIListItem) == 0x000058, "Wrong size on UUIListItem");
static_assert(offsetof(UUIListItem, ImageCursor) == 0x000048, "Member 'UUIListItem::ImageCursor' has a wrong offset!");
static_assert(offsetof(UUIListItem, ImageCursorNF) == 0x000050, "Member 'UUIListItem::ImageCursorNF' has a wrong offset!");

// Class Nicola.UITestCommonListItemTest
// 0x0008 (0x0060 - 0x0058)
class UUITestCommonListItemTest final : public UUIListItem
{
public:
	class UMultiIconImage2*                       ImageIcon;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommonListItemTest">();
	}
	static class UUITestCommonListItemTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommonListItemTest>();
	}
};
static_assert(alignof(UUITestCommonListItemTest) == 0x000008, "Wrong alignment on UUITestCommonListItemTest");
static_assert(sizeof(UUITestCommonListItemTest) == 0x000060, "Wrong size on UUITestCommonListItemTest");
static_assert(offsetof(UUITestCommonListItemTest, ImageIcon) == 0x000058, "Member 'UUITestCommonListItemTest::ImageIcon' has a wrong offset!");

// Class Nicola.BattleLogic
// 0x0200 (0x0228 - 0x0028)
class UBattleLogic final : public UObject
{
public:
	uint8                                         Pad_28[0x200];                                     // 0x0028(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleLogic">();
	}
	static class UBattleLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleLogic>();
	}
};
static_assert(alignof(UBattleLogic) == 0x000008, "Wrong alignment on UBattleLogic");
static_assert(sizeof(UBattleLogic) == 0x000228, "Wrong size on UBattleLogic");

// Class Nicola.NicolaCameraActor
// 0x0010 (0x0820 - 0x0810)
class ANicolaCameraActor : public ACineCameraActor
{
public:
	class UNicolaSpringArmComponent*              cameraBoom;                                        // 0x0810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANicolaPlayerCameraManager*             PlayerCameraManager;                               // 0x0818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float SetAperture(float Value);
	void SetCameraRotation(const struct FRotator& Rotation);
	void SetCameraTargetDistance(float Distance);
	void SetCameraTargetOffset(const struct FVector& Offset);
	float SetDepthBlurAmount(float Value);
	float SetDepthBlurRadius(float Value);
	float SetFieldOfView(float FOV);
	float SetNearDOFPower(float Value);

	float CalcFieldOfViewFromFocalLength(float FocalLength) const;
	float CalcFocalLengthFromFieldOfView(float FOV) const;
	float GetAperture() const;
	struct FRotator GetCameraRotation() const;
	float GetCameraTargetDistance() const;
	struct FVector GetCameraTargetLocation() const;
	struct FVector GetCameraTargetOffset() const;
	float GetDepthBlurAmount() const;
	float GetDepthBlurRadius() const;
	float GetFieldOfView() const;
	float GetNearDOFPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraActor">();
	}
	static class ANicolaCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCameraActor>();
	}
};
static_assert(alignof(ANicolaCameraActor) == 0x000010, "Wrong alignment on ANicolaCameraActor");
static_assert(sizeof(ANicolaCameraActor) == 0x000820, "Wrong size on ANicolaCameraActor");
static_assert(offsetof(ANicolaCameraActor, cameraBoom) == 0x000810, "Member 'ANicolaCameraActor::cameraBoom' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActor, PlayerCameraManager) == 0x000818, "Member 'ANicolaCameraActor::PlayerCameraManager' has a wrong offset!");

// Class Nicola.NicolaCameraActorControllable
// 0x0090 (0x08B0 - 0x0820)
#pragma pack(push, 0x1)
class alignas(0x10) ANicolaCameraActorControllable : public ANicolaCameraActor
{
public:
	uint8                                         Pad_820[0x4];                                      // 0x0820(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNicolaCameraRestrictInfo              CameraRestrictInfo;                                // 0x0824(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_83C[0x3C];                                     // 0x083C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialCameraAngleElevation;                       // 0x0878(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraTargetDistance;                       // 0x087C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraTargetOffsetZ;                        // 0x0880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialFocalLength;                                // 0x0884(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMinFStop;                                   // 0x0888(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMaxFStop;                                   // 0x088C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture;                                   // 0x0890(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurAmount;                            // 0x0894(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurRadius;                            // 0x0898(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialDiaphragmBladeCount;                        // 0x089C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialNearDOFPower;                               // 0x08A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDebugControlFlag(bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraActorControllable">();
	}
	static class ANicolaCameraActorControllable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCameraActorControllable>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANicolaCameraActorControllable) == 0x000010, "Wrong alignment on ANicolaCameraActorControllable");
static_assert(sizeof(ANicolaCameraActorControllable) == 0x0008B0, "Wrong size on ANicolaCameraActorControllable");
static_assert(offsetof(ANicolaCameraActorControllable, CameraRestrictInfo) == 0x000824, "Member 'ANicolaCameraActorControllable::CameraRestrictInfo' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialCameraAngleElevation) == 0x000878, "Member 'ANicolaCameraActorControllable::InitialCameraAngleElevation' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialCameraTargetDistance) == 0x00087C, "Member 'ANicolaCameraActorControllable::InitialCameraTargetDistance' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialCameraTargetOffsetZ) == 0x000880, "Member 'ANicolaCameraActorControllable::InitialCameraTargetOffsetZ' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialFocalLength) == 0x000884, "Member 'ANicolaCameraActorControllable::InitialFocalLength' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialMinFStop) == 0x000888, "Member 'ANicolaCameraActorControllable::InitialMinFStop' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialMaxFStop) == 0x00088C, "Member 'ANicolaCameraActorControllable::InitialMaxFStop' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialAperture) == 0x000890, "Member 'ANicolaCameraActorControllable::InitialAperture' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialDepthBlurAmount) == 0x000894, "Member 'ANicolaCameraActorControllable::InitialDepthBlurAmount' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialDepthBlurRadius) == 0x000898, "Member 'ANicolaCameraActorControllable::InitialDepthBlurRadius' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialDiaphragmBladeCount) == 0x00089C, "Member 'ANicolaCameraActorControllable::InitialDiaphragmBladeCount' has a wrong offset!");
static_assert(offsetof(ANicolaCameraActorControllable, InitialNearDOFPower) == 0x0008A0, "Member 'ANicolaCameraActorControllable::InitialNearDOFPower' has a wrong offset!");

// Class Nicola.NicolaResearchCameraBase
// 0x0210 (0x0AC0 - 0x08B0)
class ANicolaResearchCameraBase : public ANicolaCameraActorControllable
{
public:
	float                                         InitialCameraMovingForwardOffset;                  // 0x08A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraMovingBackOffset;                     // 0x08AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraMovingStartOffsetTime;                // 0x08B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraMovingInterpolationTime;              // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraMovingReturnToOriginTime;             // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraMovingDeadZoneAngleDegreeY;           // 0x08BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitialCameraMovingShouldReturnToOrigin;           // 0x08C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C1[0x37];                                     // 0x08C1(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveFloatChangeCameraCollision;                   // 0x08F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_900[0x1C0];                                    // 0x0900(0x01C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchCameraBase">();
	}
	static class ANicolaResearchCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchCameraBase>();
	}
};
static_assert(alignof(ANicolaResearchCameraBase) == 0x000010, "Wrong alignment on ANicolaResearchCameraBase");
static_assert(sizeof(ANicolaResearchCameraBase) == 0x000AC0, "Wrong size on ANicolaResearchCameraBase");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingForwardOffset) == 0x0008A8, "Member 'ANicolaResearchCameraBase::InitialCameraMovingForwardOffset' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingBackOffset) == 0x0008AC, "Member 'ANicolaResearchCameraBase::InitialCameraMovingBackOffset' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingStartOffsetTime) == 0x0008B0, "Member 'ANicolaResearchCameraBase::InitialCameraMovingStartOffsetTime' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingInterpolationTime) == 0x0008B4, "Member 'ANicolaResearchCameraBase::InitialCameraMovingInterpolationTime' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingReturnToOriginTime) == 0x0008B8, "Member 'ANicolaResearchCameraBase::InitialCameraMovingReturnToOriginTime' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingDeadZoneAngleDegreeY) == 0x0008BC, "Member 'ANicolaResearchCameraBase::InitialCameraMovingDeadZoneAngleDegreeY' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, InitialCameraMovingShouldReturnToOrigin) == 0x0008C0, "Member 'ANicolaResearchCameraBase::InitialCameraMovingShouldReturnToOrigin' has a wrong offset!");
static_assert(offsetof(ANicolaResearchCameraBase, curveFloatChangeCameraCollision) == 0x0008F8, "Member 'ANicolaResearchCameraBase::curveFloatChangeCameraCollision' has a wrong offset!");

// Class Nicola.NicolaResearchCameraActor
// 0x0000 (0x0AC0 - 0x0AC0)
class ANicolaResearchCameraActor final : public ANicolaResearchCameraBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchCameraActor">();
	}
	static class ANicolaResearchCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchCameraActor>();
	}
};
static_assert(alignof(ANicolaResearchCameraActor) == 0x000010, "Wrong alignment on ANicolaResearchCameraActor");
static_assert(sizeof(ANicolaResearchCameraActor) == 0x000AC0, "Wrong size on ANicolaResearchCameraActor");

// Class Nicola.BattleLuaFL
// 0x0000 (0x0028 - 0x0028)
class UBattleLuaFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleLuaFL">();
	}
	static class UBattleLuaFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleLuaFL>();
	}
};
static_assert(alignof(UBattleLuaFL) == 0x000008, "Wrong alignment on UBattleLuaFL");
static_assert(sizeof(UBattleLuaFL) == 0x000028, "Wrong size on UBattleLuaFL");

// Class Nicola.NicolaParameterCollectionBase
// 0x0060 (0x0088 - 0x0028)
class UNicolaParameterCollectionBase : public UObject
{
public:
	TSoftObjectPtr<class UMaterialParameterCollection> mpcObjPtr;                                         // 0x0028(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MPC;                                               // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraParameterCollection> npcObjPtr;                                         // 0x0058(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraParameterCollection*            NPC;                                               // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaParameterCollectionBase">();
	}
	static class UNicolaParameterCollectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaParameterCollectionBase>();
	}
};
static_assert(alignof(UNicolaParameterCollectionBase) == 0x000008, "Wrong alignment on UNicolaParameterCollectionBase");
static_assert(sizeof(UNicolaParameterCollectionBase) == 0x000088, "Wrong size on UNicolaParameterCollectionBase");
static_assert(offsetof(UNicolaParameterCollectionBase, mpcObjPtr) == 0x000028, "Member 'UNicolaParameterCollectionBase::mpcObjPtr' has a wrong offset!");
static_assert(offsetof(UNicolaParameterCollectionBase, MPC) == 0x000050, "Member 'UNicolaParameterCollectionBase::MPC' has a wrong offset!");
static_assert(offsetof(UNicolaParameterCollectionBase, npcObjPtr) == 0x000058, "Member 'UNicolaParameterCollectionBase::npcObjPtr' has a wrong offset!");
static_assert(offsetof(UNicolaParameterCollectionBase, NPC) == 0x000080, "Member 'UNicolaParameterCollectionBase::NPC' has a wrong offset!");

// Class Nicola.BattleMapParameterCollection
// 0x0000 (0x0088 - 0x0088)
class UBattleMapParameterCollection final : public UNicolaParameterCollectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleMapParameterCollection">();
	}
	static class UBattleMapParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleMapParameterCollection>();
	}
};
static_assert(alignof(UBattleMapParameterCollection) == 0x000008, "Wrong alignment on UBattleMapParameterCollection");
static_assert(sizeof(UBattleMapParameterCollection) == 0x000088, "Wrong size on UBattleMapParameterCollection");

// Class Nicola.BattlePositionLine
// 0x0048 (0x0268 - 0x0220)
class ABattlePositionLine final : public AActor
{
public:
	bool                                          IsTraceActor;                                      // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ParentActor;                                       // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBattlePositionLineSetting             LineSetting;                                       // 0x0230(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ControlActors;                                     // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UActorListComponent*                    ActorListComponent;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetChildAll(class AActor* TARGET, TArray<class AActor*>* arr);
	void Setup();
	void SetupFromActors(const TArray<class AActor*>& Actors);
	void SetupFromCharacters();
	void UpdatePositionLine(float Rate);
	void UpdateRootTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePositionLine">();
	}
	static class ABattlePositionLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlePositionLine>();
	}
};
static_assert(alignof(ABattlePositionLine) == 0x000008, "Wrong alignment on ABattlePositionLine");
static_assert(sizeof(ABattlePositionLine) == 0x000268, "Wrong size on ABattlePositionLine");
static_assert(offsetof(ABattlePositionLine, IsTraceActor) == 0x000220, "Member 'ABattlePositionLine::IsTraceActor' has a wrong offset!");
static_assert(offsetof(ABattlePositionLine, ParentActor) == 0x000228, "Member 'ABattlePositionLine::ParentActor' has a wrong offset!");
static_assert(offsetof(ABattlePositionLine, LineSetting) == 0x000230, "Member 'ABattlePositionLine::LineSetting' has a wrong offset!");
static_assert(offsetof(ABattlePositionLine, ControlActors) == 0x000250, "Member 'ABattlePositionLine::ControlActors' has a wrong offset!");
static_assert(offsetof(ABattlePositionLine, ActorListComponent) == 0x000260, "Member 'ABattlePositionLine::ActorListComponent' has a wrong offset!");

// Class Nicola.NicolaSkillManager
// 0x0070 (0x0098 - 0x0028)
class UNicolaSkillManager final : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSkillManager">();
	}
	static class UNicolaSkillManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSkillManager>();
	}
};
static_assert(alignof(UNicolaSkillManager) == 0x000008, "Wrong alignment on UNicolaSkillManager");
static_assert(sizeof(UNicolaSkillManager) == 0x000098, "Wrong size on UNicolaSkillManager");

// Class Nicola.BattleRoadFL
// 0x0000 (0x0028 - 0x0028)
class UBattleRoadFL final : public UBlueprintFunctionLibrary
{
public:
	static void OnWhiteOutWhenBattleStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleRoadFL">();
	}
	static class UBattleRoadFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleRoadFL>();
	}
};
static_assert(alignof(UBattleRoadFL) == 0x000008, "Wrong alignment on UBattleRoadFL");
static_assert(sizeof(UBattleRoadFL) == 0x000028, "Wrong size on UBattleRoadFL");

// Class Nicola.BattleRoadStartEffectManager
// 0x0048 (0x0268 - 0x0220)
class ABattleRoadStartEffectManager final : public AActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABattleSceneCapture2D*                  BattleSceneCapture2D;                              // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 playerRootActor;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 monsterRootActor;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           playerReferenceCamera;                             // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x20];                                     // 0x0248(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABattleRoadStartEffectManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleRoadStartEffectManager">();
	}
	static class ABattleRoadStartEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleRoadStartEffectManager>();
	}
};
static_assert(alignof(ABattleRoadStartEffectManager) == 0x000008, "Wrong alignment on ABattleRoadStartEffectManager");
static_assert(sizeof(ABattleRoadStartEffectManager) == 0x000268, "Wrong size on ABattleRoadStartEffectManager");
static_assert(offsetof(ABattleRoadStartEffectManager, ActorListComponent) == 0x000220, "Member 'ABattleRoadStartEffectManager::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ABattleRoadStartEffectManager, BattleSceneCapture2D) == 0x000228, "Member 'ABattleRoadStartEffectManager::BattleSceneCapture2D' has a wrong offset!");
static_assert(offsetof(ABattleRoadStartEffectManager, playerRootActor) == 0x000230, "Member 'ABattleRoadStartEffectManager::playerRootActor' has a wrong offset!");
static_assert(offsetof(ABattleRoadStartEffectManager, monsterRootActor) == 0x000238, "Member 'ABattleRoadStartEffectManager::monsterRootActor' has a wrong offset!");
static_assert(offsetof(ABattleRoadStartEffectManager, playerReferenceCamera) == 0x000240, "Member 'ABattleRoadStartEffectManager::playerReferenceCamera' has a wrong offset!");

// Class Nicola.UIWindowItemButtonIcon
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemButtonIcon : public UUIWindowItem
{
public:
	class UButtonIconWidget*                      ButtonIcon;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemButtonIcon">();
	}
	static class UUIWindowItemButtonIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemButtonIcon>();
	}
};
static_assert(alignof(UUIWindowItemButtonIcon) == 0x000008, "Wrong alignment on UUIWindowItemButtonIcon");
static_assert(sizeof(UUIWindowItemButtonIcon) == 0x000048, "Wrong size on UUIWindowItemButtonIcon");
static_assert(offsetof(UUIWindowItemButtonIcon, ButtonIcon) == 0x000040, "Member 'UUIWindowItemButtonIcon::ButtonIcon' has a wrong offset!");

// Class Nicola.NicolaRichTextBlock
// 0x0028 (0x06A0 - 0x0678)
class UNicolaRichTextBlock final : public URichTextBlock
{
public:
	uint8                                         Pad_678[0x8];                                      // 0x0678(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FontTableDefault;                                  // 0x0680(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             FontTableBattle;                                   // 0x0688(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              RubyOffset;                                        // 0x0690(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaRichTextBlock">();
	}
	static class UNicolaRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaRichTextBlock>();
	}
};
static_assert(alignof(UNicolaRichTextBlock) == 0x000008, "Wrong alignment on UNicolaRichTextBlock");
static_assert(sizeof(UNicolaRichTextBlock) == 0x0006A0, "Wrong size on UNicolaRichTextBlock");
static_assert(offsetof(UNicolaRichTextBlock, FontTableDefault) == 0x000680, "Member 'UNicolaRichTextBlock::FontTableDefault' has a wrong offset!");
static_assert(offsetof(UNicolaRichTextBlock, FontTableBattle) == 0x000688, "Member 'UNicolaRichTextBlock::FontTableBattle' has a wrong offset!");
static_assert(offsetof(UNicolaRichTextBlock, RubyOffset) == 0x000690, "Member 'UNicolaRichTextBlock::RubyOffset' has a wrong offset!");

// Class Nicola.BattleSceneCapture2D
// 0x0000 (0x0238 - 0x0238)
class ABattleSceneCapture2D final : public ASceneCapture2D
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSceneCapture2D">();
	}
	static class ABattleSceneCapture2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleSceneCapture2D>();
	}
};
static_assert(alignof(ABattleSceneCapture2D) == 0x000008, "Wrong alignment on ABattleSceneCapture2D");
static_assert(sizeof(ABattleSceneCapture2D) == 0x000238, "Wrong size on ABattleSceneCapture2D");

// Class Nicola.UIWindowItemButtonIconText
// 0x0010 (0x0050 - 0x0040)
class UUIWindowItemButtonIconText : public UUIWindowItem
{
public:
	class UUIWindowItemButtonIcon*                ItemIcon;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageItem;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemButtonIconText">();
	}
	static class UUIWindowItemButtonIconText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemButtonIconText>();
	}
};
static_assert(alignof(UUIWindowItemButtonIconText) == 0x000008, "Wrong alignment on UUIWindowItemButtonIconText");
static_assert(sizeof(UUIWindowItemButtonIconText) == 0x000050, "Wrong size on UUIWindowItemButtonIconText");
static_assert(offsetof(UUIWindowItemButtonIconText, ItemIcon) == 0x000040, "Member 'UUIWindowItemButtonIconText::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIWindowItemButtonIconText, ImageItem) == 0x000048, "Member 'UUIWindowItemButtonIconText::ImageItem' has a wrong offset!");

// Class Nicola.UIWindowItemButtonIcon2Text
// 0x0008 (0x0058 - 0x0050)
class UUIWindowItemButtonIcon2Text : public UUIWindowItemButtonIconText
{
public:
	class UUIWindowItemButtonIcon*                ItemIcon2;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemButtonIcon2Text">();
	}
	static class UUIWindowItemButtonIcon2Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemButtonIcon2Text>();
	}
};
static_assert(alignof(UUIWindowItemButtonIcon2Text) == 0x000008, "Wrong alignment on UUIWindowItemButtonIcon2Text");
static_assert(sizeof(UUIWindowItemButtonIcon2Text) == 0x000058, "Wrong size on UUIWindowItemButtonIcon2Text");
static_assert(offsetof(UUIWindowItemButtonIcon2Text, ItemIcon2) == 0x000050, "Member 'UUIWindowItemButtonIcon2Text::ItemIcon2' has a wrong offset!");

// Class Nicola.UIWindowItemButtonIcon3Text
// 0x0008 (0x0060 - 0x0058)
class UUIWindowItemButtonIcon3Text : public UUIWindowItemButtonIcon2Text
{
public:
	class UUIWindowItemButtonIcon*                ItemIcon3;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemButtonIcon3Text">();
	}
	static class UUIWindowItemButtonIcon3Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemButtonIcon3Text>();
	}
};
static_assert(alignof(UUIWindowItemButtonIcon3Text) == 0x000008, "Wrong alignment on UUIWindowItemButtonIcon3Text");
static_assert(sizeof(UUIWindowItemButtonIcon3Text) == 0x000060, "Wrong size on UUIWindowItemButtonIcon3Text");
static_assert(offsetof(UUIWindowItemButtonIcon3Text, ItemIcon3) == 0x000058, "Member 'UUIWindowItemButtonIcon3Text::ItemIcon3' has a wrong offset!");

// Class Nicola.UIWindowItemButtonIcon4Text
// 0x0008 (0x0068 - 0x0060)
class UUIWindowItemButtonIcon4Text final : public UUIWindowItemButtonIcon3Text
{
public:
	class UUIWindowItemButtonIcon*                ItemIcon4;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemButtonIcon4Text">();
	}
	static class UUIWindowItemButtonIcon4Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemButtonIcon4Text>();
	}
};
static_assert(alignof(UUIWindowItemButtonIcon4Text) == 0x000008, "Wrong alignment on UUIWindowItemButtonIcon4Text");
static_assert(sizeof(UUIWindowItemButtonIcon4Text) == 0x000068, "Wrong size on UUIWindowItemButtonIcon4Text");
static_assert(offsetof(UUIWindowItemButtonIcon4Text, ItemIcon4) == 0x000060, "Member 'UUIWindowItemButtonIcon4Text::ItemIcon4' has a wrong offset!");

// Class Nicola.NicolaSizeBox
// 0x0010 (0x0168 - 0x0158)
class UNicolaSizeBox final : public USizeBox
{
public:
	bool                                          bApplyWidth;                                       // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemWidthS;                                        // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemWidthL;                                        // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSizeBox">();
	}
	static class UNicolaSizeBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSizeBox>();
	}
};
static_assert(alignof(UNicolaSizeBox) == 0x000008, "Wrong alignment on UNicolaSizeBox");
static_assert(sizeof(UNicolaSizeBox) == 0x000168, "Wrong size on UNicolaSizeBox");
static_assert(offsetof(UNicolaSizeBox, bApplyWidth) == 0x000158, "Member 'UNicolaSizeBox::bApplyWidth' has a wrong offset!");
static_assert(offsetof(UNicolaSizeBox, ItemWidthS) == 0x00015C, "Member 'UNicolaSizeBox::ItemWidthS' has a wrong offset!");
static_assert(offsetof(UNicolaSizeBox, ItemWidthL) == 0x000160, "Member 'UNicolaSizeBox::ItemWidthL' has a wrong offset!");

// Class Nicola.BattleSimpleMenu
// 0x0078 (0x02D8 - 0x0260)
class UBattleSimpleMenu final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           ContentRoot;                                       // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x28];                                     // 0x0278(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUserWidget*>                    widgets;                                           // 0x02A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimpleMenu">();
	}
	static class UBattleSimpleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSimpleMenu>();
	}
};
static_assert(alignof(UBattleSimpleMenu) == 0x000008, "Wrong alignment on UBattleSimpleMenu");
static_assert(sizeof(UBattleSimpleMenu) == 0x0002D8, "Wrong size on UBattleSimpleMenu");
static_assert(offsetof(UBattleSimpleMenu, ContentRoot) == 0x000270, "Member 'UBattleSimpleMenu::ContentRoot' has a wrong offset!");
static_assert(offsetof(UBattleSimpleMenu, widgets) == 0x0002A0, "Member 'UBattleSimpleMenu::widgets' has a wrong offset!");

// Class Nicola.UITitleMenu
// 0x0248 (0x02C0 - 0x0078)
class UUITitleMenu final : public UUIRootBase
{
public:
	class UUITitleMenuListTop*                    ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitleMenuListStartQuest*             ListStartQuest;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveLoadList*                        ListSaveLoadStartQuest;                            // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveLoadList*                        ListSaveLoadTop;                                   // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x228];                                     // 0x0098(0x0228)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenu">();
	}
	static class UUITitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenu>();
	}
};
static_assert(alignof(UUITitleMenu) == 0x000008, "Wrong alignment on UUITitleMenu");
static_assert(sizeof(UUITitleMenu) == 0x0002C0, "Wrong size on UUITitleMenu");
static_assert(offsetof(UUITitleMenu, ListTop) == 0x000078, "Member 'UUITitleMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, ListStartQuest) == 0x000080, "Member 'UUITitleMenu::ListStartQuest' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, ListSaveLoadStartQuest) == 0x000088, "Member 'UUITitleMenu::ListSaveLoadStartQuest' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, ListSaveLoadTop) == 0x000090, "Member 'UUITitleMenu::ListSaveLoadTop' has a wrong offset!");

// Class Nicola.BattleSimpleMenuButton
// 0x0028 (0x0288 - 0x0260)
class UBattleSimpleMenuButton final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x28];                                     // 0x0260(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimpleMenuButton">();
	}
	static class UBattleSimpleMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSimpleMenuButton>();
	}
};
static_assert(alignof(UBattleSimpleMenuButton) == 0x000008, "Wrong alignment on UBattleSimpleMenuButton");
static_assert(sizeof(UBattleSimpleMenuButton) == 0x000288, "Wrong size on UBattleSimpleMenuButton");

// Class Nicola.NicolaSoundFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaSoundFL final : public UBlueprintFunctionLibrary
{
public:
	static void FadeIn(const struct FADSoundPlaybackId& PlaybackId, float DurationSec);
	static void FadeInCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec);
	static void FadeOut(const struct FADSoundPlaybackId& PlaybackId, float DurationSec, bool bAutoStop);
	static void FadeOutCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec, bool bAutoStop);
	static void GetSEGopList_Event(TArray<class FName>* GopIdList);
	static void GetSEGopList_Magic(TArray<class FName>* GopIdList);
	static void GetSEGopList_System(TArray<class FName>* GopIdList);
	static void GetSEGopList_Weapon(TArray<class FName>* GopIdList);
	static void GetSoundGopList(ENicolaSoundDataTableType DataType, TArray<class FName>* GopIdList);
	static bool IsLoop(const struct FADSoundPlaybackId& PlaybackId);
	static bool IsPaused(const struct FADSoundPlaybackId& PlaybackId);
	static bool IsPlaying(const struct FADSoundPlaybackId& PlaybackId);
	static bool IsPlayingBgm();
	static bool IsPlayingJingle();
	static void Pause(const struct FADSoundPlaybackId& PlaybackId, bool bPause);
	static void PauseMainBGM(bool bPause, float FadeSec);
	static void PlayBattleBGM(class FName GopId, float fadeOutSec);
	static void PlayBGM(class FName GopId, float FadeSec);
	static void PlayMainBGM(class FName GopId, float FadeSec);
	static struct FADSoundPlaybackId PlaySE(const class FName& GopId, const struct FVector& Location, const class UObject* Owner);
	static struct FADSoundPlaybackId PlaySE2D(const class FName& GopId, const class UObject* Owner);
	static struct FADSoundPlaybackId PlaySEEvent(const class FName& GopId);
	static struct FADSoundPlaybackId PlaySEMagic(const class FName& GopId);
	static struct FADSoundPlaybackId PlaySEUI(const class FName& GopId);
	static struct FADSoundPlaybackId PlaySEWeapon(const class FName& GopId);
	static struct FADSoundPlaybackId PlayVoice(class FName GopVoiceId);
	static void RequestPlayJingle(const class FName& JingleGopIDSoundBgm, EBgmPlayerManagerMEPlayRequestType BgmPlayerManagerMEPlayRequestType, float CurrentBgmFadeOutSec, EBgmPlayerManagerLineTypeOnMEEnd BgmPlayerManagerLineTypeOnMEEnd, float NextBgmFadeInSec, const class FName& NextGopIDSoundBgm);
	static void RequestPlayJingleTemporary(const class FName& JingleGopIDSoundBgm, float CurrentBgmFadeOutSec, float NextBgmFadeInSec);
	static void RequestPlayJingleTemporaryDefaultFade(const class FName& JingleGopIDSoundBgm);
	static void SetAisacParamById(const struct FADSoundPlaybackId& PlaybackId, int32 AisacId, float AisacValue);
	static void SetCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float TargetRate);
	static void SetDebugDrawFlag_AttenuationShapeAll(bool bEnable);
	static void SetMuteByCategory(const ENicolaSoundCategory SoundCategory, bool bMute);
	static void SetVolumeRate(const struct FADSoundPlaybackId& PlaybackId, float TargetRate);
	static void Stop(const struct FADSoundPlaybackId& PlaybackId);
	static void StopAll();
	static void StopBattleBGM(float fadeOutSec);
	static void StopBGM(float fadeOutSec);
	static void StopByCategory(const ENicolaSoundCategory SoundCategory);
	static void StopMainBGM(float fadeOutSec);
	static void TransitionCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float TargetRate, float DurationSec);
	static void TransitionVolumeRate(const struct FADSoundPlaybackId& PlaybackId, float TargetRate, float DurationSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundFL">();
	}
	static class UNicolaSoundFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundFL>();
	}
};
static_assert(alignof(UNicolaSoundFL) == 0x000008, "Wrong alignment on UNicolaSoundFL");
static_assert(sizeof(UNicolaSoundFL) == 0x000028, "Wrong size on UNicolaSoundFL");

// Class Nicola.BattleSimpleMenuInput
// 0x0000 (0x0028 - 0x0028)
class IBattleSimpleMenuInput final : public IInterface
{
public:
	void OnCancel();
	void OnDown();
	void OnEnter();
	void OnLeft();
	void OnRight();
	void OnUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimpleMenuInput">();
	}
	static class IBattleSimpleMenuInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleSimpleMenuInput>();
	}
};
static_assert(alignof(IBattleSimpleMenuInput) == 0x000008, "Wrong alignment on IBattleSimpleMenuInput");
static_assert(sizeof(IBattleSimpleMenuInput) == 0x000028, "Wrong size on IBattleSimpleMenuInput");

// Class Nicola.BattleSimpleMenuInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleSimpleMenuInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimpleMenuInterface">();
	}
	static class IBattleSimpleMenuInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleSimpleMenuInterface>();
	}
};
static_assert(alignof(IBattleSimpleMenuInterface) == 0x000008, "Wrong alignment on IBattleSimpleMenuInterface");
static_assert(sizeof(IBattleSimpleMenuInterface) == 0x000028, "Wrong size on IBattleSimpleMenuInterface");

// Class Nicola.NicolaSoundAmbientCoastAreaActor
// 0x0008 (0x0228 - 0x0220)
class ANicolaSoundAmbientCoastAreaActor final : public AActor
{
public:
	ESoundAmbientCoastType                        SoundAmbientCoastType;                             // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapOther(const class AActor* Other);
	void OnEndOverlapOther(const class AActor* Other);

	struct FVector GetAreaCollisionCentralAxis() const;
	class UCapsuleComponent* GetAreaCollisionComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundAmbientCoastAreaActor">();
	}
	static class ANicolaSoundAmbientCoastAreaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaSoundAmbientCoastAreaActor>();
	}
};
static_assert(alignof(ANicolaSoundAmbientCoastAreaActor) == 0x000008, "Wrong alignment on ANicolaSoundAmbientCoastAreaActor");
static_assert(sizeof(ANicolaSoundAmbientCoastAreaActor) == 0x000228, "Wrong size on ANicolaSoundAmbientCoastAreaActor");
static_assert(offsetof(ANicolaSoundAmbientCoastAreaActor, SoundAmbientCoastType) == 0x000220, "Member 'ANicolaSoundAmbientCoastAreaActor::SoundAmbientCoastType' has a wrong offset!");

// Class Nicola.BattleSimpleMenuItemInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleSimpleMenuItemInterface final : public IInterface
{
public:
	void OnFocus();
	void OnOutFocus();
	void OnSelect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimpleMenuItemInterface">();
	}
	static class IBattleSimpleMenuItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleSimpleMenuItemInterface>();
	}
};
static_assert(alignof(IBattleSimpleMenuItemInterface) == 0x000008, "Wrong alignment on IBattleSimpleMenuItemInterface");
static_assert(sizeof(IBattleSimpleMenuItemInterface) == 0x000028, "Wrong size on IBattleSimpleMenuItemInterface");

// Class Nicola.UIListCrossH
// 0x0040 (0x00E8 - 0x00A8)
class UUIListCrossH : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListCrossH">();
	}
	static class UUIListCrossH* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListCrossH>();
	}
};
static_assert(alignof(UUIListCrossH) == 0x000008, "Wrong alignment on UUIListCrossH");
static_assert(sizeof(UUIListCrossH) == 0x0000E8, "Wrong size on UUIListCrossH");

// Class Nicola.UIMemberCreateMenuListLooks
// 0x0040 (0x0128 - 0x00E8)
class UUIMemberCreateMenuListLooks final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x40];                                      // 0x00E8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListLooks">();
	}
	static class UUIMemberCreateMenuListLooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListLooks>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListLooks) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListLooks");
static_assert(sizeof(UUIMemberCreateMenuListLooks) == 0x000128, "Wrong size on UUIMemberCreateMenuListLooks");

// Class Nicola.BattleSpeedInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleSpeedInterface final : public IInterface
{
public:
	void OnChangeBattleSpeed(float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSpeedInterface">();
	}
	static class IBattleSpeedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleSpeedInterface>();
	}
};
static_assert(alignof(IBattleSpeedInterface) == 0x000008, "Wrong alignment on IBattleSpeedInterface");
static_assert(sizeof(IBattleSpeedInterface) == 0x000028, "Wrong size on IBattleSpeedInterface");

// Class Nicola.BattleSubsystem
// 0x00D8 (0x0108 - 0x0030)
class UBattleSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleLogic*                           Logic;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  prevPawn;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  battlePawn;                                        // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANicolaCharacterBase*>           playerActors;                                      // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ANicolaCharacterBase*>           enemyActors;                                       // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IBattleSpeedInterface>> speedObservers;                                    // 0x00B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x40];                                      // 0x00C8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSubsystem">();
	}
	static class UBattleSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSubsystem>();
	}
};
static_assert(alignof(UBattleSubsystem) == 0x000008, "Wrong alignment on UBattleSubsystem");
static_assert(sizeof(UBattleSubsystem) == 0x000108, "Wrong size on UBattleSubsystem");
static_assert(offsetof(UBattleSubsystem, Logic) == 0x000038, "Member 'UBattleSubsystem::Logic' has a wrong offset!");
static_assert(offsetof(UBattleSubsystem, prevPawn) == 0x000068, "Member 'UBattleSubsystem::prevPawn' has a wrong offset!");
static_assert(offsetof(UBattleSubsystem, battlePawn) == 0x000070, "Member 'UBattleSubsystem::battlePawn' has a wrong offset!");
static_assert(offsetof(UBattleSubsystem, playerActors) == 0x000098, "Member 'UBattleSubsystem::playerActors' has a wrong offset!");
static_assert(offsetof(UBattleSubsystem, enemyActors) == 0x0000A8, "Member 'UBattleSubsystem::enemyActors' has a wrong offset!");
static_assert(offsetof(UBattleSubsystem, speedObservers) == 0x0000B8, "Member 'UBattleSubsystem::speedObservers' has a wrong offset!");

// Class Nicola.BattleSystemActor
// 0x0000 (0x0220 - 0x0220)
class ABattleSystemActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSystemActor">();
	}
	static class ABattleSystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleSystemActor>();
	}
};
static_assert(alignof(ABattleSystemActor) == 0x000008, "Wrong alignment on ABattleSystemActor");
static_assert(sizeof(ABattleSystemActor) == 0x000220, "Wrong size on ABattleSystemActor");

// Class Nicola.UIWindowItemMoneyBank
// 0x0010 (0x0050 - 0x0040)
class UUIWindowItemMoneyBank final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemMoneyBank">();
	}
	static class UUIWindowItemMoneyBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemMoneyBank>();
	}
};
static_assert(alignof(UUIWindowItemMoneyBank) == 0x000008, "Wrong alignment on UUIWindowItemMoneyBank");
static_assert(sizeof(UUIWindowItemMoneyBank) == 0x000050, "Wrong size on UUIWindowItemMoneyBank");
static_assert(offsetof(UUIWindowItemMoneyBank, TextItem2) == 0x000040, "Member 'UUIWindowItemMoneyBank::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIWindowItemMoneyBank, TextItem3) == 0x000048, "Member 'UUIWindowItemMoneyBank::TextItem3' has a wrong offset!");

// Class Nicola.NicolaSoundDeviceWatcher
// 0x0000 (0x0030 - 0x0030)
class UNicolaSoundDeviceWatcher final : public UADSoundDeviceWatcher
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundDeviceWatcher">();
	}
	static class UNicolaSoundDeviceWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundDeviceWatcher>();
	}
};
static_assert(alignof(UNicolaSoundDeviceWatcher) == 0x000008, "Wrong alignment on UNicolaSoundDeviceWatcher");
static_assert(sizeof(UNicolaSoundDeviceWatcher) == 0x000030, "Wrong size on UNicolaSoundDeviceWatcher");

// Class Nicola.BattleTestCharaActor
// 0x0080 (0x02A0 - 0x0220)
class ABattleTestCharaActor final : public AActor
{
public:
	class ANicolaCharacterBase*                   Character;                                         // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAutoSpawn;                                       // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SpawnBP;                                           // 0x0230(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnGopId;                                        // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnTag;                                          // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdditionalCharacter;                             // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x37];                                     // 0x0269(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyCharacter();
	void SetAnimation(EAnimationType animationType, bool IsLoop);
	void SpawnCharacter(class FName GopId, class FName Tag);
	void SpawnCharacterFromBP(TSoftClassPtr<class UClass> loadAssetPtr, class FName Tag);
	bool UpdateScaleFromGopUnitLooks(bool isEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleTestCharaActor">();
	}
	static class ABattleTestCharaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleTestCharaActor>();
	}
};
static_assert(alignof(ABattleTestCharaActor) == 0x000008, "Wrong alignment on ABattleTestCharaActor");
static_assert(sizeof(ABattleTestCharaActor) == 0x0002A0, "Wrong size on ABattleTestCharaActor");
static_assert(offsetof(ABattleTestCharaActor, Character) == 0x000220, "Member 'ABattleTestCharaActor::Character' has a wrong offset!");
static_assert(offsetof(ABattleTestCharaActor, IsAutoSpawn) == 0x000228, "Member 'ABattleTestCharaActor::IsAutoSpawn' has a wrong offset!");
static_assert(offsetof(ABattleTestCharaActor, SpawnBP) == 0x000230, "Member 'ABattleTestCharaActor::SpawnBP' has a wrong offset!");
static_assert(offsetof(ABattleTestCharaActor, SpawnGopId) == 0x000258, "Member 'ABattleTestCharaActor::SpawnGopId' has a wrong offset!");
static_assert(offsetof(ABattleTestCharaActor, SpawnTag) == 0x000260, "Member 'ABattleTestCharaActor::SpawnTag' has a wrong offset!");
static_assert(offsetof(ABattleTestCharaActor, IsAdditionalCharacter) == 0x000268, "Member 'ABattleTestCharaActor::IsAdditionalCharacter' has a wrong offset!");

// Class Nicola.UIShopMenuWindowSub
// 0x0010 (0x0068 - 0x0058)
class UUIShopMenuWindowSub final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextExplanation;                                   // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemText2*                       ItemCount;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuWindowSub">();
	}
	static class UUIShopMenuWindowSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuWindowSub>();
	}
};
static_assert(alignof(UUIShopMenuWindowSub) == 0x000008, "Wrong alignment on UUIShopMenuWindowSub");
static_assert(sizeof(UUIShopMenuWindowSub) == 0x000068, "Wrong size on UUIShopMenuWindowSub");
static_assert(offsetof(UUIShopMenuWindowSub, TextExplanation) == 0x000058, "Member 'UUIShopMenuWindowSub::TextExplanation' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowSub, ItemCount) == 0x000060, "Member 'UUIShopMenuWindowSub::ItemCount' has a wrong offset!");

// Class Nicola.BattleTestWidget
// 0x0038 (0x0298 - 0x0260)
class UBattleTestWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleSimpleMenu*                      Menu;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleTestWidget">();
	}
	static class UBattleTestWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleTestWidget>();
	}
};
static_assert(alignof(UBattleTestWidget) == 0x000008, "Wrong alignment on UBattleTestWidget");
static_assert(sizeof(UBattleTestWidget) == 0x000298, "Wrong size on UBattleTestWidget");
static_assert(offsetof(UBattleTestWidget, Menu) == 0x000278, "Member 'UBattleTestWidget::Menu' has a wrong offset!");

// Class Nicola.NicolaSoundSourceInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaSoundSourceInterface final : public IInterface
{
public:
	void OnStopAllSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundSourceInterface">();
	}
	static class INicolaSoundSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaSoundSourceInterface>();
	}
};
static_assert(alignof(INicolaSoundSourceInterface) == 0x000008, "Wrong alignment on INicolaSoundSourceInterface");
static_assert(sizeof(INicolaSoundSourceInterface) == 0x000028, "Wrong size on INicolaSoundSourceInterface");

// Class Nicola.BattleUIDrawer
// 0x0000 (0x0028 - 0x0028)
class IBattleUIDrawer final : public IInterface
{
public:
	void ClearMessage();
	void DestroyWidget();
	void InitWidget();
	void OpenSelectHowToUse(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectItem(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectPartyCommand(const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectSkill(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectTactics(const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectTarget(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectText(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void OpenSelectUnitCommand(int32 charaIndex, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void SetVisibleWidget(bool flag);
	void ShowMessage(const TArray<class FString>& messages, const TScriptInterface<class IBattleUIReceiver>& receiver);
	void UpdateCharaInfo(int32 charaIndex, const struct FBattleCharaInfoViewData& viewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleUIDrawer">();
	}
	static class IBattleUIDrawer* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleUIDrawer>();
	}
};
static_assert(alignof(IBattleUIDrawer) == 0x000008, "Wrong alignment on IBattleUIDrawer");
static_assert(sizeof(IBattleUIDrawer) == 0x000028, "Wrong size on IBattleUIDrawer");

// Class Nicola.BattleUIReceiver
// 0x0000 (0x0028 - 0x0028)
class IBattleUIReceiver final : public IInterface
{
public:
	void OnCancel();
	void OnCompleteShowMessage();
	void OnSelectId(class FName selectId);
	void OnSelectIndex(int32 selectIndex);
	void OnSelectPartyCommand(EBattlePartyCommand Command);
	void OnSelectTactics(EBattleTactics tactics);
	void OnSelectUnitCommand(EBattleUnitCommand Command);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleUIReceiver">();
	}
	static class IBattleUIReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleUIReceiver>();
	}
};
static_assert(alignof(IBattleUIReceiver) == 0x000008, "Wrong alignment on IBattleUIReceiver");
static_assert(sizeof(IBattleUIReceiver) == 0x000028, "Wrong size on IBattleUIReceiver");

// Class Nicola.BattleUnitInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleUnitInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleUnitInterface">();
	}
	static class IBattleUnitInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleUnitInterface>();
	}
};
static_assert(alignof(IBattleUnitInterface) == 0x000008, "Wrong alignment on IBattleUnitInterface");
static_assert(sizeof(IBattleUnitInterface) == 0x000028, "Wrong size on IBattleUnitInterface");

// Class Nicola.UITestWindowMenuList3
// 0x0000 (0x00D0 - 0x00D0)
class UUITestWindowMenuList3 final : public UUIListPage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenuList3">();
	}
	static class UUITestWindowMenuList3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenuList3>();
	}
};
static_assert(alignof(UUITestWindowMenuList3) == 0x000008, "Wrong alignment on UUITestWindowMenuList3");
static_assert(sizeof(UUITestWindowMenuList3) == 0x0000D0, "Wrong size on UUITestWindowMenuList3");

// Class Nicola.BgmPlayer
// 0x0078 (0x00A0 - 0x0028)
class alignas(0x10) UBgmPlayer final : public UObject
{
public:
	class UInterpFloat*                           TimerDelayCall;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDelayCallback*                         DelayCallbackOnCompletePlay;                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgmPlayer">();
	}
	static class UBgmPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgmPlayer>();
	}
};
static_assert(alignof(UBgmPlayer) == 0x000010, "Wrong alignment on UBgmPlayer");
static_assert(sizeof(UBgmPlayer) == 0x0000A0, "Wrong size on UBgmPlayer");
static_assert(offsetof(UBgmPlayer, TimerDelayCall) == 0x000028, "Member 'UBgmPlayer::TimerDelayCall' has a wrong offset!");
static_assert(offsetof(UBgmPlayer, DelayCallbackOnCompletePlay) == 0x000030, "Member 'UBgmPlayer::DelayCallbackOnCompletePlay' has a wrong offset!");

// Class Nicola.UIWindowItemStatusMain
// 0x0038 (0x0090 - 0x0058)
class UUIWindowItemStatusMain final : public UUIWindowBase
{
public:
	class UFlipbookWidget*                        FlipbookCharacter;                                 // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLevelTitle;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLevelParam;                                    // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextName;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemStatusGauge*               GaugeHP;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemStatusGauge*               GaugeMP;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFieldStatusEffectWidget*               StatusEffectWidget;                                // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemStatusMain">();
	}
	static class UUIWindowItemStatusMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemStatusMain>();
	}
};
static_assert(alignof(UUIWindowItemStatusMain) == 0x000008, "Wrong alignment on UUIWindowItemStatusMain");
static_assert(sizeof(UUIWindowItemStatusMain) == 0x000090, "Wrong size on UUIWindowItemStatusMain");
static_assert(offsetof(UUIWindowItemStatusMain, FlipbookCharacter) == 0x000058, "Member 'UUIWindowItemStatusMain::FlipbookCharacter' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusMain, TextLevelTitle) == 0x000060, "Member 'UUIWindowItemStatusMain::TextLevelTitle' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusMain, TextLevelParam) == 0x000068, "Member 'UUIWindowItemStatusMain::TextLevelParam' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusMain, TextName) == 0x000070, "Member 'UUIWindowItemStatusMain::TextName' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusMain, GaugeHP) == 0x000078, "Member 'UUIWindowItemStatusMain::GaugeHP' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusMain, GaugeMP) == 0x000080, "Member 'UUIWindowItemStatusMain::GaugeMP' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusMain, StatusEffectWidget) == 0x000088, "Member 'UUIWindowItemStatusMain::StatusEffectWidget' has a wrong offset!");

// Class Nicola.NicolaSoundComponent
// 0x00A0 (0x02A0 - 0x0200)
class UNicolaSoundComponent : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopId;                                             // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIDProgressAmbient;                              // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFieldTimeFrame, class FName>            GopIdsSoundSE;                                     // 0x0220(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         BeginPlayDelay;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                cullingSrcObject;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpFloat*                           InterpWaitSoundPlayable;                           // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x18];                                     // 0x0288(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundComponent">();
	}
	static class UNicolaSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundComponent>();
	}
};
static_assert(alignof(UNicolaSoundComponent) == 0x000010, "Wrong alignment on UNicolaSoundComponent");
static_assert(sizeof(UNicolaSoundComponent) == 0x0002A0, "Wrong size on UNicolaSoundComponent");
static_assert(offsetof(UNicolaSoundComponent, GopId) == 0x000210, "Member 'UNicolaSoundComponent::GopId' has a wrong offset!");
static_assert(offsetof(UNicolaSoundComponent, GopIDProgressAmbient) == 0x000218, "Member 'UNicolaSoundComponent::GopIDProgressAmbient' has a wrong offset!");
static_assert(offsetof(UNicolaSoundComponent, GopIdsSoundSE) == 0x000220, "Member 'UNicolaSoundComponent::GopIdsSoundSE' has a wrong offset!");
static_assert(offsetof(UNicolaSoundComponent, BeginPlayDelay) == 0x000270, "Member 'UNicolaSoundComponent::BeginPlayDelay' has a wrong offset!");
static_assert(offsetof(UNicolaSoundComponent, cullingSrcObject) == 0x000278, "Member 'UNicolaSoundComponent::cullingSrcObject' has a wrong offset!");
static_assert(offsetof(UNicolaSoundComponent, InterpWaitSoundPlayable) == 0x000280, "Member 'UNicolaSoundComponent::InterpWaitSoundPlayable' has a wrong offset!");

// Class Nicola.NicolaEnvSoundComponent
// 0x0000 (0x02A0 - 0x02A0)
class UNicolaEnvSoundComponent final : public UNicolaSoundComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEnvSoundComponent">();
	}
	static class UNicolaEnvSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaEnvSoundComponent>();
	}
};
static_assert(alignof(UNicolaEnvSoundComponent) == 0x000010, "Wrong alignment on UNicolaEnvSoundComponent");
static_assert(sizeof(UNicolaEnvSoundComponent) == 0x0002A0, "Wrong size on UNicolaEnvSoundComponent");

// Class Nicola.BgmPlayerManager
// 0x0068 (0x0090 - 0x0028)
class alignas(0x10) UBgmPlayerManager final : public UObject
{
public:
	TMap<EBgmType, class UBgmPlayer*>             BgmPlayers;                                        // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	class UDelayCallback*                         DelayCallbackOnJinglePlayEnd;                      // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BgmPlayerManager">();
	}
	static class UBgmPlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBgmPlayerManager>();
	}
};
static_assert(alignof(UBgmPlayerManager) == 0x000010, "Wrong alignment on UBgmPlayerManager");
static_assert(sizeof(UBgmPlayerManager) == 0x000090, "Wrong size on UBgmPlayerManager");
static_assert(offsetof(UBgmPlayerManager, BgmPlayers) == 0x000028, "Member 'UBgmPlayerManager::BgmPlayers' has a wrong offset!");
static_assert(offsetof(UBgmPlayerManager, DelayCallbackOnJinglePlayEnd) == 0x000078, "Member 'UBgmPlayerManager::DelayCallbackOnJinglePlayEnd' has a wrong offset!");

// Class Nicola.PlayerBase
// 0x0110 (0x05D0 - 0x04C0)
class APlayerBase : public ACharacter
{
public:
	uint8                                         Pad_4B8[0xD8];                                     // 0x04B8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UButtonGuideComponent*                  ButtonGuideComponent;                              // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x28];                                     // 0x0598(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         movePerSec;                                        // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         dashPerSec;                                        // 0x05C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         movePerStep;                                       // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void onChangedMovementMode(class ACharacter* Character, EMovementMode prevMode, uint8 PrevCustomMode);
	void onUpdateMovement(float Delta, const struct FVector& OldLocation, const struct FVector& OldVelocity);

	float GetDashPerSec() const;
	float GetMovePerSec() const;
	class FString GetPartyMemberLog_Debug(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerBase">();
	}
	static class APlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerBase>();
	}
};
static_assert(alignof(APlayerBase) == 0x000010, "Wrong alignment on APlayerBase");
static_assert(sizeof(APlayerBase) == 0x0005D0, "Wrong size on APlayerBase");
static_assert(offsetof(APlayerBase, ButtonGuideComponent) == 0x000590, "Member 'APlayerBase::ButtonGuideComponent' has a wrong offset!");
static_assert(offsetof(APlayerBase, movePerSec) == 0x0005C0, "Member 'APlayerBase::movePerSec' has a wrong offset!");
static_assert(offsetof(APlayerBase, dashPerSec) == 0x0005C4, "Member 'APlayerBase::dashPerSec' has a wrong offset!");
static_assert(offsetof(APlayerBase, movePerStep) == 0x0005C8, "Member 'APlayerBase::movePerStep' has a wrong offset!");

// Class Nicola.UIWindowItemText2
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemText2 : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemText2">();
	}
	static class UUIWindowItemText2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemText2>();
	}
};
static_assert(alignof(UUIWindowItemText2) == 0x000008, "Wrong alignment on UUIWindowItemText2");
static_assert(sizeof(UUIWindowItemText2) == 0x000048, "Wrong size on UUIWindowItemText2");
static_assert(offsetof(UUIWindowItemText2, TextItem2) == 0x000040, "Member 'UUIWindowItemText2::TextItem2' has a wrong offset!");

// Class Nicola.UIWindowItemText2Icon
// 0x0008 (0x0050 - 0x0048)
class UUIWindowItemText2Icon final : public UUIWindowItemText2
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemText2Icon">();
	}
	static class UUIWindowItemText2Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemText2Icon>();
	}
};
static_assert(alignof(UUIWindowItemText2Icon) == 0x000008, "Wrong alignment on UUIWindowItemText2Icon");
static_assert(sizeof(UUIWindowItemText2Icon) == 0x000050, "Wrong size on UUIWindowItemText2Icon");
static_assert(offsetof(UUIWindowItemText2Icon, ItemIcon) == 0x000048, "Member 'UUIWindowItemText2Icon::ItemIcon' has a wrong offset!");

// Class Nicola.NicolaSoundManagerComponentFieldAmbientBase
// 0x0028 (0x0050 - 0x0028)
class UNicolaSoundManagerComponentFieldAmbientBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpFloat*                           InterpFloatWaitSoundPlayableTimer;                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundManagerComponentFieldAmbientBase">();
	}
	static class UNicolaSoundManagerComponentFieldAmbientBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundManagerComponentFieldAmbientBase>();
	}
};
static_assert(alignof(UNicolaSoundManagerComponentFieldAmbientBase) == 0x000008, "Wrong alignment on UNicolaSoundManagerComponentFieldAmbientBase");
static_assert(sizeof(UNicolaSoundManagerComponentFieldAmbientBase) == 0x000050, "Wrong size on UNicolaSoundManagerComponentFieldAmbientBase");
static_assert(offsetof(UNicolaSoundManagerComponentFieldAmbientBase, InterpFloatWaitSoundPlayableTimer) == 0x000030, "Member 'UNicolaSoundManagerComponentFieldAmbientBase::InterpFloatWaitSoundPlayableTimer' has a wrong offset!");

// Class Nicola.NicolaSoundManagerComponentFieldAmbientLand
// 0x0000 (0x0050 - 0x0050)
class UNicolaSoundManagerComponentFieldAmbientLand final : public UNicolaSoundManagerComponentFieldAmbientBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundManagerComponentFieldAmbientLand">();
	}
	static class UNicolaSoundManagerComponentFieldAmbientLand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundManagerComponentFieldAmbientLand>();
	}
};
static_assert(alignof(UNicolaSoundManagerComponentFieldAmbientLand) == 0x000008, "Wrong alignment on UNicolaSoundManagerComponentFieldAmbientLand");
static_assert(sizeof(UNicolaSoundManagerComponentFieldAmbientLand) == 0x000050, "Wrong size on UNicolaSoundManagerComponentFieldAmbientLand");

// Class Nicola.PlayerHumanBase
// 0x0010 (0x05E0 - 0x05D0)
class APlayerHumanBase : public APlayerBase
{
public:
	class UNicolaResearchCommandComponent*        ResearchCommandComp;                               // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHumanBase">();
	}
	static class APlayerHumanBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerHumanBase>();
	}
};
static_assert(alignof(APlayerHumanBase) == 0x000010, "Wrong alignment on APlayerHumanBase");
static_assert(sizeof(APlayerHumanBase) == 0x0005E0, "Wrong size on APlayerHumanBase");
static_assert(offsetof(APlayerHumanBase, ResearchCommandComp) == 0x0005D0, "Member 'APlayerHumanBase::ResearchCommandComp' has a wrong offset!");

// Class Nicola.UITestCommonWindow2
// 0x0008 (0x0060 - 0x0058)
class UUITestCommonWindow2 final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommonWindow2">();
	}
	static class UUITestCommonWindow2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommonWindow2>();
	}
};
static_assert(alignof(UUITestCommonWindow2) == 0x000008, "Wrong alignment on UUITestCommonWindow2");
static_assert(sizeof(UUITestCommonWindow2) == 0x000060, "Wrong size on UUITestCommonWindow2");

// Class Nicola.Breadcrumbman
// 0x0050 (0x0630 - 0x05E0)
class ABreadcrumbman : public APlayerHumanBase
{
public:
	uint8                                         Pad_5E0[0x40];                                     // 0x05E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Interval;                                          // 0x0620(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPosAndAlignment(const struct FVector& Pos, EDirectionOnMap dirAlignment, EDirectionOnMap dirLeader);
	void Together(const struct FVector& Pos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Breadcrumbman">();
	}
	static class ABreadcrumbman* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreadcrumbman>();
	}
};
static_assert(alignof(ABreadcrumbman) == 0x000010, "Wrong alignment on ABreadcrumbman");
static_assert(sizeof(ABreadcrumbman) == 0x000630, "Wrong size on ABreadcrumbman");
static_assert(offsetof(ABreadcrumbman, Interval) == 0x000620, "Member 'ABreadcrumbman::Interval' has a wrong offset!");

// Class Nicola.UIInitialMenuFlowSaveData
// 0x0010 (0x0080 - 0x0070)
class UUIInitialMenuFlowSaveData final : public UUICtrlBase
{
public:
	class UNicolaSaveGameManager*                 SaveManager;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInitialMenuFlowSaveData">();
	}
	static class UUIInitialMenuFlowSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInitialMenuFlowSaveData>();
	}
};
static_assert(alignof(UUIInitialMenuFlowSaveData) == 0x000008, "Wrong alignment on UUIInitialMenuFlowSaveData");
static_assert(sizeof(UUIInitialMenuFlowSaveData) == 0x000080, "Wrong size on UUIInitialMenuFlowSaveData");
static_assert(offsetof(UUIInitialMenuFlowSaveData, SaveManager) == 0x000070, "Member 'UUIInitialMenuFlowSaveData::SaveManager' has a wrong offset!");

// Class Nicola.NicolaManaMovieActor
// 0x0030 (0x0250 - 0x0220)
class ANicolaManaMovieActor final : public AActor
{
public:
	class UManaComponent*                         ManaComponent;                                     // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x28];                                     // 0x0228(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void onManaComponentStatusChanged(EManaComponentStatus InManaComponentStatus, class UManaComponent* InManaComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaManaMovieActor">();
	}
	static class ANicolaManaMovieActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaManaMovieActor>();
	}
};
static_assert(alignof(ANicolaManaMovieActor) == 0x000008, "Wrong alignment on ANicolaManaMovieActor");
static_assert(sizeof(ANicolaManaMovieActor) == 0x000250, "Wrong size on ANicolaManaMovieActor");
static_assert(offsetof(ANicolaManaMovieActor, ManaComponent) == 0x000220, "Member 'ANicolaManaMovieActor::ManaComponent' has a wrong offset!");

// Class Nicola.BuildingWithJumpPoint
// 0x00B8 (0x02D8 - 0x0220)
class ABuildingWithJumpPoint : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FJumpPointInformation> JumpPointInformation;                              // 0x0228(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class ALuaTriggerBox*, class FName>      triggerBoxMap;                                     // 0x0278(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorListComponent;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetJumpMapLevelAndStart(const class FName jumpPointKey, const class FName mapLevelId, const class FName playerStartId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWithJumpPoint">();
	}
	static class ABuildingWithJumpPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWithJumpPoint>();
	}
};
static_assert(alignof(ABuildingWithJumpPoint) == 0x000008, "Wrong alignment on ABuildingWithJumpPoint");
static_assert(sizeof(ABuildingWithJumpPoint) == 0x0002D8, "Wrong size on ABuildingWithJumpPoint");
static_assert(offsetof(ABuildingWithJumpPoint, JumpPointInformation) == 0x000228, "Member 'ABuildingWithJumpPoint::JumpPointInformation' has a wrong offset!");
static_assert(offsetof(ABuildingWithJumpPoint, triggerBoxMap) == 0x000278, "Member 'ABuildingWithJumpPoint::triggerBoxMap' has a wrong offset!");
static_assert(offsetof(ABuildingWithJumpPoint, ActorListComponent) == 0x0002C8, "Member 'ABuildingWithJumpPoint::ActorListComponent' has a wrong offset!");

// Class Nicola.BuildingWithJumpPointFlagOverride
// 0x0010 (0x02E8 - 0x02D8)
class ABuildingWithJumpPointFlagOverride final : public ABuildingWithJumpPoint
{
public:
	TArray<struct FJumpPointOverrideInformation>  jumpPointOverrideInformations;                     // 0x02D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWithJumpPointFlagOverride">();
	}
	static class ABuildingWithJumpPointFlagOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWithJumpPointFlagOverride>();
	}
};
static_assert(alignof(ABuildingWithJumpPointFlagOverride) == 0x000008, "Wrong alignment on ABuildingWithJumpPointFlagOverride");
static_assert(sizeof(ABuildingWithJumpPointFlagOverride) == 0x0002E8, "Wrong size on ABuildingWithJumpPointFlagOverride");
static_assert(offsetof(ABuildingWithJumpPointFlagOverride, jumpPointOverrideInformations) == 0x0002D8, "Member 'ABuildingWithJumpPointFlagOverride::jumpPointOverrideInformations' has a wrong offset!");

// Class Nicola.NicolaListenerPositioningActor
// 0x0000 (0x0220 - 0x0220)
class ANicolaListenerPositioningActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaListenerPositioningActor">();
	}
	static class ANicolaListenerPositioningActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaListenerPositioningActor>();
	}
};
static_assert(alignof(ANicolaListenerPositioningActor) == 0x000008, "Wrong alignment on ANicolaListenerPositioningActor");
static_assert(sizeof(ANicolaListenerPositioningActor) == 0x000220, "Wrong size on ANicolaListenerPositioningActor");

// Class Nicola.BuildingWithJumpPointForFieldSymbol
// 0x0008 (0x02E0 - 0x02D8)
class ABuildingWithJumpPointForFieldSymbol final : public ABuildingWithJumpPoint
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWithJumpPointForFieldSymbol">();
	}
	static class ABuildingWithJumpPointForFieldSymbol* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWithJumpPointForFieldSymbol>();
	}
};
static_assert(alignof(ABuildingWithJumpPointForFieldSymbol) == 0x000008, "Wrong alignment on ABuildingWithJumpPointForFieldSymbol");
static_assert(sizeof(ABuildingWithJumpPointForFieldSymbol) == 0x0002E0, "Wrong size on ABuildingWithJumpPointForFieldSymbol");
static_assert(offsetof(ABuildingWithJumpPointForFieldSymbol, BoxComponent) == 0x0002D8, "Member 'ABuildingWithJumpPointForFieldSymbol::BoxComponent' has a wrong offset!");

// Class Nicola.UITitle2MenuListLanguageText
// 0x0010 (0x00D0 - 0x00C0)
class UUITitle2MenuListLanguageText final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListLanguageText">();
	}
	static class UUITitle2MenuListLanguageText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListLanguageText>();
	}
};
static_assert(alignof(UUITitle2MenuListLanguageText) == 0x000008, "Wrong alignment on UUITitle2MenuListLanguageText");
static_assert(sizeof(UUITitle2MenuListLanguageText) == 0x0000D0, "Wrong size on UUITitle2MenuListLanguageText");

// Class Nicola.BuildingWithReturnPoint
// 0x0070 (0x0290 - 0x0220)
class ABuildingWithReturnPoint final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FReturnPointInformation> ReturnPointInformation;                            // 0x0228(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class ALuaTriggerBox*>                 triggerBoxes;                                      // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UActorListComponent*                    ActorListComponent;                                // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWithReturnPoint">();
	}
	static class ABuildingWithReturnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWithReturnPoint>();
	}
};
static_assert(alignof(ABuildingWithReturnPoint) == 0x000008, "Wrong alignment on ABuildingWithReturnPoint");
static_assert(sizeof(ABuildingWithReturnPoint) == 0x000290, "Wrong size on ABuildingWithReturnPoint");
static_assert(offsetof(ABuildingWithReturnPoint, ReturnPointInformation) == 0x000228, "Member 'ABuildingWithReturnPoint::ReturnPointInformation' has a wrong offset!");
static_assert(offsetof(ABuildingWithReturnPoint, triggerBoxes) == 0x000278, "Member 'ABuildingWithReturnPoint::triggerBoxes' has a wrong offset!");
static_assert(offsetof(ABuildingWithReturnPoint, ActorListComponent) == 0x000288, "Member 'ABuildingWithReturnPoint::ActorListComponent' has a wrong offset!");

// Class Nicola.BuildingWithShortcutPoint
// 0x0050 (0x0328 - 0x02D8)
class ABuildingWithShortcutPoint final : public ABuildingWithJumpPoint
{
public:
	TMap<class FName, struct FJumpPointShortcatExtension> shortcutExtension;                                 // 0x02D8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWithShortcutPoint">();
	}
	static class ABuildingWithShortcutPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWithShortcutPoint>();
	}
};
static_assert(alignof(ABuildingWithShortcutPoint) == 0x000008, "Wrong alignment on ABuildingWithShortcutPoint");
static_assert(sizeof(ABuildingWithShortcutPoint) == 0x000328, "Wrong size on ABuildingWithShortcutPoint");
static_assert(offsetof(ABuildingWithShortcutPoint, shortcutExtension) == 0x0002D8, "Member 'ABuildingWithShortcutPoint::shortcutExtension' has a wrong offset!");

// Class Nicola.NicolaLocalizeFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaLocalizeFL final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeNicolaLanguage(ENicolaLanguage NicolaLanguage, ENicolaLanguageChangeFlag NicolaLanguageChangeFlags);
	static ENicolaLanguage GetCurrentLanguageText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLocalizeFL">();
	}
	static class UNicolaLocalizeFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaLocalizeFL>();
	}
};
static_assert(alignof(UNicolaLocalizeFL) == 0x000008, "Wrong alignment on UNicolaLocalizeFL");
static_assert(sizeof(UNicolaLocalizeFL) == 0x000028, "Wrong size on UNicolaLocalizeFL");

// Class Nicola.CommonBaseWidget
// 0x00C8 (0x0328 - 0x0260)
class UCommonBaseWidget : public UUserWidget
{
public:
	class UCommonBaseWidget*                      ParentWidget;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UWidget*>             ChildWidgetList;                                   // 0x0268(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FComonBaseAnimInfo>  AnimationList;                                     // 0x02B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           CBW_CanvasPanelRoot;                               // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool PauseAnim(class FName InAnimationName);
	bool PlayAnim(class FName InAnimationName, bool bSamePrefixExclusion, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool InNoWarn);
	bool PlayAnimR(class FName InAnimationName, bool bSamePrefixExclusion, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	bool PlayAnimTo(class FName InAnimationName, bool bSamePrefixExclusion, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	bool StopAnim(class FName InAnimationName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonBaseWidget">();
	}
	static class UCommonBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonBaseWidget>();
	}
};
static_assert(alignof(UCommonBaseWidget) == 0x000008, "Wrong alignment on UCommonBaseWidget");
static_assert(sizeof(UCommonBaseWidget) == 0x000328, "Wrong size on UCommonBaseWidget");
static_assert(offsetof(UCommonBaseWidget, ParentWidget) == 0x000260, "Member 'UCommonBaseWidget::ParentWidget' has a wrong offset!");
static_assert(offsetof(UCommonBaseWidget, ChildWidgetList) == 0x000268, "Member 'UCommonBaseWidget::ChildWidgetList' has a wrong offset!");
static_assert(offsetof(UCommonBaseWidget, AnimationList) == 0x0002B8, "Member 'UCommonBaseWidget::AnimationList' has a wrong offset!");
static_assert(offsetof(UCommonBaseWidget, CBW_CanvasPanelRoot) == 0x000320, "Member 'UCommonBaseWidget::CBW_CanvasPanelRoot' has a wrong offset!");

// Class Nicola.UITestMouseMenuListPageTmp
// 0x0020 (0x00F0 - 0x00D0)
class UUITestMouseMenuListPageTmp final : public UUIListPage
{
public:
	TArray<class UGopTextBlock*>                  Texts;                                             // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageClick;                                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListPageTmp">();
	}
	static class UUITestMouseMenuListPageTmp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListPageTmp>();
	}
};
static_assert(alignof(UUITestMouseMenuListPageTmp) == 0x000008, "Wrong alignment on UUITestMouseMenuListPageTmp");
static_assert(sizeof(UUITestMouseMenuListPageTmp) == 0x0000F0, "Wrong size on UUITestMouseMenuListPageTmp");
static_assert(offsetof(UUITestMouseMenuListPageTmp, Texts) == 0x0000D0, "Member 'UUITestMouseMenuListPageTmp::Texts' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuListPageTmp, ImageClick) == 0x0000E0, "Member 'UUITestMouseMenuListPageTmp::ImageClick' has a wrong offset!");

// Class Nicola.CommonItemWidget
// 0x0000 (0x0328 - 0x0328)
class UCommonItemWidget : public UCommonBaseWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonItemWidget">();
	}
	static class UCommonItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonItemWidget>();
	}
};
static_assert(alignof(UCommonItemWidget) == 0x000008, "Wrong alignment on UCommonItemWidget");
static_assert(sizeof(UCommonItemWidget) == 0x000328, "Wrong size on UCommonItemWidget");

// Class Nicola.UIJobChangeMenuListTop
// 0x0020 (0x00F0 - 0x00D0)
class UUIJobChangeMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIJobChangeMenuListTop">();
	}
	static class UUIJobChangeMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIJobChangeMenuListTop>();
	}
};
static_assert(alignof(UUIJobChangeMenuListTop) == 0x000008, "Wrong alignment on UUIJobChangeMenuListTop");
static_assert(sizeof(UUIJobChangeMenuListTop) == 0x0000F0, "Wrong size on UUIJobChangeMenuListTop");

// Class Nicola.ButtonIconWidget
// 0x0038 (0x0360 - 0x0328)
class UButtonIconWidget : public UCommonItemWidget
{
public:
	uint8                                         Pad_328[0x20];                                     // 0x0328(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 IconPad;                                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconKey;                                           // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonWindowWidget*                    TickerWidget;                                      // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonIconWidget">();
	}
	static class UButtonIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonIconWidget>();
	}
};
static_assert(alignof(UButtonIconWidget) == 0x000008, "Wrong alignment on UButtonIconWidget");
static_assert(sizeof(UButtonIconWidget) == 0x000360, "Wrong size on UButtonIconWidget");
static_assert(offsetof(UButtonIconWidget, IconPad) == 0x000348, "Member 'UButtonIconWidget::IconPad' has a wrong offset!");
static_assert(offsetof(UButtonIconWidget, IconKey) == 0x000350, "Member 'UButtonIconWidget::IconKey' has a wrong offset!");
static_assert(offsetof(UButtonIconWidget, TickerWidget) == 0x000358, "Member 'UButtonIconWidget::TickerWidget' has a wrong offset!");

// Class Nicola.NicolaAnimationData
// 0x0050 (0x0080 - 0x0030)
class UNicolaAnimationData final : public UDataAsset
{
public:
	TMap<EFlipbookUseType, struct FNicolaAnimationDataInner> Data;                                              // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaAnimationData">();
	}
	static class UNicolaAnimationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaAnimationData>();
	}
};
static_assert(alignof(UNicolaAnimationData) == 0x000008, "Wrong alignment on UNicolaAnimationData");
static_assert(sizeof(UNicolaAnimationData) == 0x000080, "Wrong size on UNicolaAnimationData");
static_assert(offsetof(UNicolaAnimationData, Data) == 0x000030, "Member 'UNicolaAnimationData::Data' has a wrong offset!");

// Class Nicola.ButtonIconLongPressWidget
// 0x0030 (0x0390 - 0x0360)
class UButtonIconLongPressWidget : public UButtonIconWidget
{
public:
	struct FButtonIconLongPress                   ItemPadLP;                                         // 0x0360(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FButtonIconLongPress                   ItemKeyLP;                                         // 0x0378(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonIconLongPressWidget">();
	}
	static class UButtonIconLongPressWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonIconLongPressWidget>();
	}
};
static_assert(alignof(UButtonIconLongPressWidget) == 0x000008, "Wrong alignment on UButtonIconLongPressWidget");
static_assert(sizeof(UButtonIconLongPressWidget) == 0x000390, "Wrong size on UButtonIconLongPressWidget");
static_assert(offsetof(UButtonIconLongPressWidget, ItemPadLP) == 0x000360, "Member 'UButtonIconLongPressWidget::ItemPadLP' has a wrong offset!");
static_assert(offsetof(UButtonIconLongPressWidget, ItemKeyLP) == 0x000378, "Member 'UButtonIconLongPressWidget::ItemKeyLP' has a wrong offset!");

// Class Nicola.PlayerControllableGimmick
// 0x0008 (0x0228 - 0x0220)
class APlayerControllableGimmick : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllableGimmick">();
	}
	static class APlayerControllableGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllableGimmick>();
	}
};
static_assert(alignof(APlayerControllableGimmick) == 0x000008, "Wrong alignment on APlayerControllableGimmick");
static_assert(sizeof(APlayerControllableGimmick) == 0x000228, "Wrong size on APlayerControllableGimmick");

// Class Nicola.PlayerTriggerVolume
// 0x0000 (0x0258 - 0x0258)
class APlayerTriggerVolume : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerTriggerVolume">();
	}
	static class APlayerTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerTriggerVolume>();
	}
};
static_assert(alignof(APlayerTriggerVolume) == 0x000008, "Wrong alignment on APlayerTriggerVolume");
static_assert(sizeof(APlayerTriggerVolume) == 0x000258, "Wrong size on APlayerTriggerVolume");

// Class Nicola.LanternVolume
// 0x0008 (0x0260 - 0x0258)
class ALanternVolume final : public APlayerTriggerVolume
{
public:
	bool                                          LanternOnOff;                                      // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternVolume">();
	}
	static class ALanternVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternVolume>();
	}
};
static_assert(alignof(ALanternVolume) == 0x000008, "Wrong alignment on ALanternVolume");
static_assert(sizeof(ALanternVolume) == 0x000260, "Wrong size on ALanternVolume");
static_assert(offsetof(ALanternVolume, LanternOnOff) == 0x000258, "Member 'ALanternVolume::LanternOnOff' has a wrong offset!");

// Class Nicola.LadderGimmickBase
// 0x0038 (0x0260 - 0x0228)
class ALadderGimmickBase : public APlayerControllableGimmick
{
public:
	class UBoxComponent*                          Collision;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x30];                                     // 0x0230(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderGimmickBase">();
	}
	static class ALadderGimmickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadderGimmickBase>();
	}
};
static_assert(alignof(ALadderGimmickBase) == 0x000008, "Wrong alignment on ALadderGimmickBase");
static_assert(sizeof(ALadderGimmickBase) == 0x000260, "Wrong size on ALadderGimmickBase");
static_assert(offsetof(ALadderGimmickBase, Collision) == 0x000228, "Member 'ALadderGimmickBase::Collision' has a wrong offset!");

// Class Nicola.UIFieldTacticsTutorialMenu
// 0x0010 (0x0088 - 0x0078)
class UUIFieldTacticsTutorialMenu final : public UUIRootBase
{
public:
	class UUIFieldTacticsTutorialMenuListTop*     ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsTutorialMenuWindowExplainParent* WindowExplain;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTutorialMenu">();
	}
	static class UUIFieldTacticsTutorialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTutorialMenu>();
	}
};
static_assert(alignof(UUIFieldTacticsTutorialMenu) == 0x000008, "Wrong alignment on UUIFieldTacticsTutorialMenu");
static_assert(sizeof(UUIFieldTacticsTutorialMenu) == 0x000088, "Wrong size on UUIFieldTacticsTutorialMenu");
static_assert(offsetof(UUIFieldTacticsTutorialMenu, ListTop) == 0x000078, "Member 'UUIFieldTacticsTutorialMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenu, WindowExplain) == 0x000080, "Member 'UUIFieldTacticsTutorialMenu::WindowExplain' has a wrong offset!");

// Class Nicola.CableGimmick
// 0x0008 (0x0268 - 0x0260)
class ACableGimmick final : public ALadderGimmickBase
{
public:
	class UCableComponent*                        Cable;                                             // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CableGimmick">();
	}
	static class ACableGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACableGimmick>();
	}
};
static_assert(alignof(ACableGimmick) == 0x000008, "Wrong alignment on ACableGimmick");
static_assert(sizeof(ACableGimmick) == 0x000268, "Wrong size on ACableGimmick");
static_assert(offsetof(ACableGimmick, Cable) == 0x000260, "Member 'ACableGimmick::Cable' has a wrong offset!");

// Class Nicola.LuaBlueprints
// 0x0000 (0x0028 - 0x0028)
class ULuaBlueprints final : public UBlueprintFunctionLibrary
{
public:
	static void RunLua(const class ULuaAsset* LuaAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaBlueprints">();
	}
	static class ULuaBlueprints* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaBlueprints>();
	}
};
static_assert(alignof(ULuaBlueprints) == 0x000008, "Wrong alignment on ULuaBlueprints");
static_assert(sizeof(ULuaBlueprints) == 0x000028, "Wrong size on ULuaBlueprints");

// Class Nicola.CameraCollision
// 0x0100 (0x0320 - 0x0220)
class alignas(0x10) ACameraCollision final : public AActor
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0xC8];                                     // 0x0228(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	ENicolaCameraCollisionType                    eCollisionType;                                    // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ENicolaCameraCollisionInterpolationType       eInterpolationType;                                // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F2[0x2];                                      // 0x02F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doUseThisForCorrectingCameraOffset;                // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doUsePositionRangeX;                               // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doUsePositionRangeY;                               // 0x02FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doUsePositionRangeZ;                               // 0x02FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                positionRangeMax;                                  // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                positionRangeMin;                                  // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutXPosBound;                                // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutXNegBound;                                // 0x0315(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutYPosBound;                                // 0x0316(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutYNegBound;                                // 0x0317(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutZPosBound;                                // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutZNegBound;                                // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraCollision">();
	}
	static class ACameraCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraCollision>();
	}
};
static_assert(alignof(ACameraCollision) == 0x000010, "Wrong alignment on ACameraCollision");
static_assert(sizeof(ACameraCollision) == 0x000320, "Wrong size on ACameraCollision");
static_assert(offsetof(ACameraCollision, BoxCollision) == 0x000220, "Member 'ACameraCollision::BoxCollision' has a wrong offset!");
static_assert(offsetof(ACameraCollision, eCollisionType) == 0x0002F0, "Member 'ACameraCollision::eCollisionType' has a wrong offset!");
static_assert(offsetof(ACameraCollision, eInterpolationType) == 0x0002F1, "Member 'ACameraCollision::eInterpolationType' has a wrong offset!");
static_assert(offsetof(ACameraCollision, Priority) == 0x0002F4, "Member 'ACameraCollision::Priority' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doUseThisForCorrectingCameraOffset) == 0x0002F8, "Member 'ACameraCollision::doUseThisForCorrectingCameraOffset' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doUsePositionRangeX) == 0x0002F9, "Member 'ACameraCollision::doUsePositionRangeX' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doUsePositionRangeY) == 0x0002FA, "Member 'ACameraCollision::doUsePositionRangeY' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doUsePositionRangeZ) == 0x0002FB, "Member 'ACameraCollision::doUsePositionRangeZ' has a wrong offset!");
static_assert(offsetof(ACameraCollision, positionRangeMax) == 0x0002FC, "Member 'ACameraCollision::positionRangeMax' has a wrong offset!");
static_assert(offsetof(ACameraCollision, positionRangeMin) == 0x000308, "Member 'ACameraCollision::positionRangeMin' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doKeepOutXPosBound) == 0x000314, "Member 'ACameraCollision::doKeepOutXPosBound' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doKeepOutXNegBound) == 0x000315, "Member 'ACameraCollision::doKeepOutXNegBound' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doKeepOutYPosBound) == 0x000316, "Member 'ACameraCollision::doKeepOutYPosBound' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doKeepOutYNegBound) == 0x000317, "Member 'ACameraCollision::doKeepOutYNegBound' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doKeepOutZPosBound) == 0x000318, "Member 'ACameraCollision::doKeepOutZPosBound' has a wrong offset!");
static_assert(offsetof(ACameraCollision, doKeepOutZNegBound) == 0x000319, "Member 'ACameraCollision::doKeepOutZNegBound' has a wrong offset!");

// Class Nicola.CameraKeepOut
// 0x00B0 (0x02D0 - 0x0220)
class alignas(0x10) ACameraKeepOut final : public AActor
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x98];                                     // 0x0228(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          doKeepOutForPlayerMoving;                          // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          doKeepOutForCollisionResolving;                    // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ENicolaCameraKeepOutDirection                 eKeepOutDirection;                                 // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C3[0xD];                                      // 0x02C3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraKeepOut">();
	}
	static class ACameraKeepOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraKeepOut>();
	}
};
static_assert(alignof(ACameraKeepOut) == 0x000010, "Wrong alignment on ACameraKeepOut");
static_assert(sizeof(ACameraKeepOut) == 0x0002D0, "Wrong size on ACameraKeepOut");
static_assert(offsetof(ACameraKeepOut, BoxCollision) == 0x000220, "Member 'ACameraKeepOut::BoxCollision' has a wrong offset!");
static_assert(offsetof(ACameraKeepOut, doKeepOutForPlayerMoving) == 0x0002C0, "Member 'ACameraKeepOut::doKeepOutForPlayerMoving' has a wrong offset!");
static_assert(offsetof(ACameraKeepOut, doKeepOutForCollisionResolving) == 0x0002C1, "Member 'ACameraKeepOut::doKeepOutForCollisionResolving' has a wrong offset!");
static_assert(offsetof(ACameraKeepOut, eKeepOutDirection) == 0x0002C2, "Member 'ACameraKeepOut::eKeepOutDirection' has a wrong offset!");

// Class Nicola.LevelLoadingManager
// 0x0220 (0x0250 - 0x0030)
class ULevelLoadingManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FMapLevelInfo>       LoadingInfoMap;                                    // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FLevelLoadingRequest>           LoadingRequests;                                   // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x28];                                      // 0x0098(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSubLevelInfoArray>  GopTownDungeonSublevel;                            // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0xB8];                                     // 0x0110(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubLevelInfo>                  PendingLoadLevels;                                 // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x78];                                     // 0x01D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelLoadingManager">();
	}
	static class ULevelLoadingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelLoadingManager>();
	}
};
static_assert(alignof(ULevelLoadingManager) == 0x000008, "Wrong alignment on ULevelLoadingManager");
static_assert(sizeof(ULevelLoadingManager) == 0x000250, "Wrong size on ULevelLoadingManager");
static_assert(offsetof(ULevelLoadingManager, LoadingInfoMap) == 0x000038, "Member 'ULevelLoadingManager::LoadingInfoMap' has a wrong offset!");
static_assert(offsetof(ULevelLoadingManager, LoadingRequests) == 0x000088, "Member 'ULevelLoadingManager::LoadingRequests' has a wrong offset!");
static_assert(offsetof(ULevelLoadingManager, GopTownDungeonSublevel) == 0x0000C0, "Member 'ULevelLoadingManager::GopTownDungeonSublevel' has a wrong offset!");
static_assert(offsetof(ULevelLoadingManager, PendingLoadLevels) == 0x0001C8, "Member 'ULevelLoadingManager::PendingLoadLevels' has a wrong offset!");

// Class Nicola.CaptureSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UCaptureSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             captureTexture;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ASceneCapture2D*                        SceneCapture;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x58];                                      // 0x0088(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* GetCaptureTexture();
	class UTexture2D* LoadTextureByteData(int32 captureNo);
	void OnComplateSaveTexture(bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureSubsystem">();
	}
	static class UCaptureSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptureSubsystem>();
	}
};
static_assert(alignof(UCaptureSubsystem) == 0x000008, "Wrong alignment on UCaptureSubsystem");
static_assert(sizeof(UCaptureSubsystem) == 0x0000E0, "Wrong size on UCaptureSubsystem");
static_assert(offsetof(UCaptureSubsystem, captureTexture) == 0x000038, "Member 'UCaptureSubsystem::captureTexture' has a wrong offset!");
static_assert(offsetof(UCaptureSubsystem, SceneCapture) == 0x000080, "Member 'UCaptureSubsystem::SceneCapture' has a wrong offset!");

// Class Nicola.UIKeyboardMonthMenu
// 0x0008 (0x0080 - 0x0078)
class UUIKeyboardMonthMenu : public UUIRootBase
{
public:
	class UUIKeyboardDateMenuListTop*             ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardMonthMenu">();
	}
	static class UUIKeyboardMonthMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardMonthMenu>();
	}
};
static_assert(alignof(UUIKeyboardMonthMenu) == 0x000008, "Wrong alignment on UUIKeyboardMonthMenu");
static_assert(sizeof(UUIKeyboardMonthMenu) == 0x000080, "Wrong size on UUIKeyboardMonthMenu");
static_assert(offsetof(UUIKeyboardMonthMenu, ListTop) == 0x000078, "Member 'UUIKeyboardMonthMenu::ListTop' has a wrong offset!");

// Class Nicola.UIKeyboardMonthMenuEN
// 0x0000 (0x0080 - 0x0080)
class UUIKeyboardMonthMenuEN final : public UUIKeyboardMonthMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardMonthMenuEN">();
	}
	static class UUIKeyboardMonthMenuEN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardMonthMenuEN>();
	}
};
static_assert(alignof(UUIKeyboardMonthMenuEN) == 0x000008, "Wrong alignment on UUIKeyboardMonthMenuEN");
static_assert(sizeof(UUIKeyboardMonthMenuEN) == 0x000080, "Wrong size on UUIKeyboardMonthMenuEN");

// Class Nicola.CommentAsset
// 0x0008 (0x0038 - 0x0030)
class UCommentAsset final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentAsset">();
	}
	static class UCommentAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentAsset>();
	}
};
static_assert(alignof(UCommentAsset) == 0x000008, "Wrong alignment on UCommentAsset");
static_assert(sizeof(UCommentAsset) == 0x000038, "Wrong size on UCommentAsset");

// Class Nicola.LandingAttributeVolume
// 0x0008 (0x0260 - 0x0258)
class ALandingAttributeVolume : public APlayerTriggerVolume
{
public:
	bool                                          overrideLamia;                                     // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          canLandLamia;                                      // 0x0259(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          overrideShip;                                      // 0x025A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          canLandShip;                                       // 0x025B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingAttributeVolume">();
	}
	static class ALandingAttributeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandingAttributeVolume>();
	}
};
static_assert(alignof(ALandingAttributeVolume) == 0x000008, "Wrong alignment on ALandingAttributeVolume");
static_assert(sizeof(ALandingAttributeVolume) == 0x000260, "Wrong size on ALandingAttributeVolume");
static_assert(offsetof(ALandingAttributeVolume, overrideLamia) == 0x000258, "Member 'ALandingAttributeVolume::overrideLamia' has a wrong offset!");
static_assert(offsetof(ALandingAttributeVolume, canLandLamia) == 0x000259, "Member 'ALandingAttributeVolume::canLandLamia' has a wrong offset!");
static_assert(offsetof(ALandingAttributeVolume, overrideShip) == 0x00025A, "Member 'ALandingAttributeVolume::overrideShip' has a wrong offset!");
static_assert(offsetof(ALandingAttributeVolume, canLandShip) == 0x00025B, "Member 'ALandingAttributeVolume::canLandShip' has a wrong offset!");

// Class Nicola.LandingAttributeVolumeForFieldSymbolBase
// 0x0008 (0x0268 - 0x0260)
class ALandingAttributeVolumeForFieldSymbolBase : public ALandingAttributeVolume
{
public:
	class UShapeComponent*                        collisionComponent;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingAttributeVolumeForFieldSymbolBase">();
	}
	static class ALandingAttributeVolumeForFieldSymbolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandingAttributeVolumeForFieldSymbolBase>();
	}
};
static_assert(alignof(ALandingAttributeVolumeForFieldSymbolBase) == 0x000008, "Wrong alignment on ALandingAttributeVolumeForFieldSymbolBase");
static_assert(sizeof(ALandingAttributeVolumeForFieldSymbolBase) == 0x000268, "Wrong size on ALandingAttributeVolumeForFieldSymbolBase");
static_assert(offsetof(ALandingAttributeVolumeForFieldSymbolBase, collisionComponent) == 0x000260, "Member 'ALandingAttributeVolumeForFieldSymbolBase::collisionComponent' has a wrong offset!");

// Class Nicola.LandingAttributeVolumeForFieldSymbolSphere
// 0x0000 (0x0268 - 0x0268)
class ALandingAttributeVolumeForFieldSymbolSphere final : public ALandingAttributeVolumeForFieldSymbolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingAttributeVolumeForFieldSymbolSphere">();
	}
	static class ALandingAttributeVolumeForFieldSymbolSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandingAttributeVolumeForFieldSymbolSphere>();
	}
};
static_assert(alignof(ALandingAttributeVolumeForFieldSymbolSphere) == 0x000008, "Wrong alignment on ALandingAttributeVolumeForFieldSymbolSphere");
static_assert(sizeof(ALandingAttributeVolumeForFieldSymbolSphere) == 0x000268, "Wrong size on ALandingAttributeVolumeForFieldSymbolSphere");

// Class Nicola.CommonWindowWidget
// 0x0088 (0x03B0 - 0x0328)
class UCommonWindowWidget : public UCommonItemWidget
{
public:
	uint8                                         Pad_328[0x38];                                     // 0x0328(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UUIMouseClickData*>         MouseClickDatas;                                   // 0x0360(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonWindowWidget">();
	}
	static class UCommonWindowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonWindowWidget>();
	}
};
static_assert(alignof(UCommonWindowWidget) == 0x000008, "Wrong alignment on UCommonWindowWidget");
static_assert(sizeof(UCommonWindowWidget) == 0x0003B0, "Wrong size on UCommonWindowWidget");
static_assert(offsetof(UCommonWindowWidget, MouseClickDatas) == 0x000360, "Member 'UCommonWindowWidget::MouseClickDatas' has a wrong offset!");

// Class Nicola.CommonListWidget
// 0x0000 (0x03B0 - 0x03B0)
class UCommonListWidget : public UCommonWindowWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonListWidget">();
	}
	static class UCommonListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonListWidget>();
	}
};
static_assert(alignof(UCommonListWidget) == 0x000008, "Wrong alignment on UCommonListWidget");
static_assert(sizeof(UCommonListWidget) == 0x0003B0, "Wrong size on UCommonListWidget");

// Class Nicola.LoopSoundManager
// 0x0050 (0x0078 - 0x0028)
class ULoopSoundManager final : public UObject
{
public:
	TMap<class UObject*, struct FLoopSoundInfos>  ManagedSounds;                                     // 0x0028(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoopSoundManager">();
	}
	static class ULoopSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoopSoundManager>();
	}
};
static_assert(alignof(ULoopSoundManager) == 0x000008, "Wrong alignment on ULoopSoundManager");
static_assert(sizeof(ULoopSoundManager) == 0x000078, "Wrong size on ULoopSoundManager");
static_assert(offsetof(ULoopSoundManager, ManagedSounds) == 0x000028, "Member 'ULoopSoundManager::ManagedSounds' has a wrong offset!");

// Class Nicola.CommonMiniMapWidget
// 0x0008 (0x03B8 - 0x03B0)
class UCommonMiniMapWidget : public UCommonWindowWidget
{
public:
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonMiniMapWidget">();
	}
	static class UCommonMiniMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonMiniMapWidget>();
	}
};
static_assert(alignof(UCommonMiniMapWidget) == 0x000008, "Wrong alignment on UCommonMiniMapWidget");
static_assert(sizeof(UCommonMiniMapWidget) == 0x0003B8, "Wrong size on UCommonMiniMapWidget");
static_assert(offsetof(UCommonMiniMapWidget, TextureRenderTarget) == 0x0003B0, "Member 'UCommonMiniMapWidget::TextureRenderTarget' has a wrong offset!");

// Class Nicola.UIMapMenuWindowKeyGuide
// 0x0010 (0x0068 - 0x0058)
class UUIMapMenuWindowKeyGuide final : public UUIWindowBase
{
public:
	TArray<class UUIListItem*>                    ListItems;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuWindowKeyGuide">();
	}
	static class UUIMapMenuWindowKeyGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuWindowKeyGuide>();
	}
};
static_assert(alignof(UUIMapMenuWindowKeyGuide) == 0x000008, "Wrong alignment on UUIMapMenuWindowKeyGuide");
static_assert(sizeof(UUIMapMenuWindowKeyGuide) == 0x000068, "Wrong size on UUIMapMenuWindowKeyGuide");
static_assert(offsetof(UUIMapMenuWindowKeyGuide, ListItems) == 0x000058, "Member 'UUIMapMenuWindowKeyGuide::ListItems' has a wrong offset!");

// Class Nicola.CommonRootWidget
// 0x0010 (0x03C0 - 0x03B0)
class UCommonRootWidget : public UCommonWindowWidget
{
public:
	TArray<class UCommonWindowWidget*>            ChildWidgets;                                      // 0x03B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonRootWidget">();
	}
	static class UCommonRootWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonRootWidget>();
	}
};
static_assert(alignof(UCommonRootWidget) == 0x000008, "Wrong alignment on UCommonRootWidget");
static_assert(sizeof(UCommonRootWidget) == 0x0003C0, "Wrong size on UCommonRootWidget");
static_assert(offsetof(UCommonRootWidget, ChildWidgets) == 0x0003B0, "Member 'UCommonRootWidget::ChildWidgets' has a wrong offset!");

// Class Nicola.DebugMenuResource
// 0x0020 (0x0048 - 0x0028)
class UDebugMenuResource final : public UObject
{
public:
	TArray<class UDebugMenuItem*>                 menuItems;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 title;                                             // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuResource">();
	}
	static class UDebugMenuResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuResource>();
	}
};
static_assert(alignof(UDebugMenuResource) == 0x000008, "Wrong alignment on UDebugMenuResource");
static_assert(sizeof(UDebugMenuResource) == 0x000048, "Wrong size on UDebugMenuResource");
static_assert(offsetof(UDebugMenuResource, menuItems) == 0x000028, "Member 'UDebugMenuResource::menuItems' has a wrong offset!");
static_assert(offsetof(UDebugMenuResource, title) == 0x000038, "Member 'UDebugMenuResource::title' has a wrong offset!");

// Class Nicola.CrossFadeManager
// 0x0000 (0x0028 - 0x0028)
class UCrossFadeManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossFadeManager">();
	}
	static class UCrossFadeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossFadeManager>();
	}
};
static_assert(alignof(UCrossFadeManager) == 0x000008, "Wrong alignment on UCrossFadeManager");
static_assert(sizeof(UCrossFadeManager) == 0x000028, "Wrong size on UCrossFadeManager");

// Class Nicola.CustomPlayerStartComponent
// 0x0010 (0x00C0 - 0x00B0)
class UCustomPlayerStartComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EStartPointType                               Type;                                              // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x1];                                       // 0x00B9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGOPEnumSpecialEntranceType                   entranceType;                                      // 0x00BA(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPlayerStartComponent">();
	}
	static class UCustomPlayerStartComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPlayerStartComponent>();
	}
};
static_assert(alignof(UCustomPlayerStartComponent) == 0x000008, "Wrong alignment on UCustomPlayerStartComponent");
static_assert(sizeof(UCustomPlayerStartComponent) == 0x0000C0, "Wrong size on UCustomPlayerStartComponent");
static_assert(offsetof(UCustomPlayerStartComponent, Type) == 0x0000B8, "Member 'UCustomPlayerStartComponent::Type' has a wrong offset!");
static_assert(offsetof(UCustomPlayerStartComponent, entranceType) == 0x0000BA, "Member 'UCustomPlayerStartComponent::entranceType' has a wrong offset!");

// Class Nicola.CustomPlayerStartAreaComponent
// 0x0010 (0x0490 - 0x0480)
class UCustomPlayerStartAreaComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EStartPointType                               Type;                                              // 0x0488(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489[0x1];                                      // 0x0489(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGOPEnumSpecialEntranceType                   entranceType;                                      // 0x048A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPlayerStartAreaComponent">();
	}
	static class UCustomPlayerStartAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPlayerStartAreaComponent>();
	}
};
static_assert(alignof(UCustomPlayerStartAreaComponent) == 0x000010, "Wrong alignment on UCustomPlayerStartAreaComponent");
static_assert(sizeof(UCustomPlayerStartAreaComponent) == 0x000490, "Wrong size on UCustomPlayerStartAreaComponent");
static_assert(offsetof(UCustomPlayerStartAreaComponent, Type) == 0x000488, "Member 'UCustomPlayerStartAreaComponent::Type' has a wrong offset!");
static_assert(offsetof(UCustomPlayerStartAreaComponent, entranceType) == 0x00048A, "Member 'UCustomPlayerStartAreaComponent::entranceType' has a wrong offset!");

// Class Nicola.DebugAutoSystem
// 0x0050 (0x0080 - 0x0030)
class UDebugAutoSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartDoorListOutput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugAutoSystem">();
	}
	static class UDebugAutoSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugAutoSystem>();
	}
};
static_assert(alignof(UDebugAutoSystem) == 0x000008, "Wrong alignment on UDebugAutoSystem");
static_assert(sizeof(UDebugAutoSystem) == 0x000080, "Wrong size on UDebugAutoSystem");

// Class Nicola.LuaScriptMgrBase
// 0x0160 (0x0188 - 0x0028)
class ULuaScriptMgrBase : public UObject
{
public:
	uint8                                         Pad_28[0x158];                                     // 0x0028(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugMenuResource*                     TopMenuResource;                                   // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaScriptMgrBase">();
	}
	static class ULuaScriptMgrBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaScriptMgrBase>();
	}
};
static_assert(alignof(ULuaScriptMgrBase) == 0x000008, "Wrong alignment on ULuaScriptMgrBase");
static_assert(sizeof(ULuaScriptMgrBase) == 0x000188, "Wrong size on ULuaScriptMgrBase");
static_assert(offsetof(ULuaScriptMgrBase, TopMenuResource) == 0x000180, "Member 'ULuaScriptMgrBase::TopMenuResource' has a wrong offset!");

// Class Nicola.LuaScriptMgr
// 0x00D8 (0x0260 - 0x0188)
class ULuaScriptMgr final : public ULuaScriptMgrBase
{
public:
	uint8                                         Pad_188[0xD8];                                     // 0x0188(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BP_ReloadRequestExecuteEvent(bool bBaseScriptReload);
	static void BP_RequestExecuteEvent(class FName MapName, class FName luaFileName, class FName luaEventName);
	static TArray<class UDebugMenuFlag*> GetFlagList();
	static TArray<class FName> GetTriggerList();

	bool BP_ReloadBaseScript(const class FName& BaseScriptName);
	void BP_RequestExecuteTrigger(class FName TriggerName);
	void BP_RequestReoadCurrentLevelScript();
	void BP_RequestReoadLevelScript(const class FName& szLuaFileName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaScriptMgr">();
	}
	static class ULuaScriptMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaScriptMgr>();
	}
};
static_assert(alignof(ULuaScriptMgr) == 0x000008, "Wrong alignment on ULuaScriptMgr");
static_assert(sizeof(ULuaScriptMgr) == 0x000260, "Wrong size on ULuaScriptMgr");

// Class Nicola.DebugBattleLocationWidget
// 0x0000 (0x0260 - 0x0260)
class UDebugBattleLocationWidget final : public UUserWidget
{
public:
	void UpdateLocationText(class ABattleCameraControl* battleCameraControll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugBattleLocationWidget">();
	}
	static class UDebugBattleLocationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugBattleLocationWidget>();
	}
};
static_assert(alignof(UDebugBattleLocationWidget) == 0x000008, "Wrong alignment on UDebugBattleLocationWidget");
static_assert(sizeof(UDebugBattleLocationWidget) == 0x000260, "Wrong size on UDebugBattleLocationWidget");

// Class Nicola.UIMBRBattleTacticsListUnit
// 0x0010 (0x00E0 - 0x00D0)
class UUIMBRBattleTacticsListUnit final : public UUIListPage
{
public:
	class UGopTextBlock*                          TextGuide;                                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleTacticsListUnit">();
	}
	static class UUIMBRBattleTacticsListUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleTacticsListUnit>();
	}
};
static_assert(alignof(UUIMBRBattleTacticsListUnit) == 0x000008, "Wrong alignment on UUIMBRBattleTacticsListUnit");
static_assert(sizeof(UUIMBRBattleTacticsListUnit) == 0x0000E0, "Wrong size on UUIMBRBattleTacticsListUnit");
static_assert(offsetof(UUIMBRBattleTacticsListUnit, TextGuide) == 0x0000D0, "Member 'UUIMBRBattleTacticsListUnit::TextGuide' has a wrong offset!");

// Class Nicola.DebugMenuCategoryData
// 0x01C0 (0x01E8 - 0x0028)
class UDebugMenuCategoryData final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugMenuCustomItem>           Items;                                             // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x190];                                     // 0x0058(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetItems(TArray<struct FDebugMenuCustomItem>* outItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuCategoryData">();
	}
	static class UDebugMenuCategoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuCategoryData>();
	}
};
static_assert(alignof(UDebugMenuCategoryData) == 0x000008, "Wrong alignment on UDebugMenuCategoryData");
static_assert(sizeof(UDebugMenuCategoryData) == 0x0001E8, "Wrong size on UDebugMenuCategoryData");
static_assert(offsetof(UDebugMenuCategoryData, Items) == 0x000048, "Member 'UDebugMenuCategoryData::Items' has a wrong offset!");

// Class Nicola.LuaTriggerSphere
// 0x0030 (0x0258 - 0x0228)
class ALuaTriggerSphere final : public ATriggerSphere
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FunctionName;                                      // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Arguments;                                         // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OnTalkOverLapEventCompatible;                      // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaTriggerSphere">();
	}
	static class ALuaTriggerSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALuaTriggerSphere>();
	}
};
static_assert(alignof(ALuaTriggerSphere) == 0x000008, "Wrong alignment on ALuaTriggerSphere");
static_assert(sizeof(ALuaTriggerSphere) == 0x000258, "Wrong size on ALuaTriggerSphere");
static_assert(offsetof(ALuaTriggerSphere, FunctionName) == 0x000230, "Member 'ALuaTriggerSphere::FunctionName' has a wrong offset!");
static_assert(offsetof(ALuaTriggerSphere, Arguments) == 0x000240, "Member 'ALuaTriggerSphere::Arguments' has a wrong offset!");
static_assert(offsetof(ALuaTriggerSphere, OnTalkOverLapEventCompatible) == 0x000250, "Member 'ALuaTriggerSphere::OnTalkOverLapEventCompatible' has a wrong offset!");

// Class Nicola.DebugMenuFL
// 0x0000 (0x0028 - 0x0028)
class UDebugMenuFL final : public UBlueprintFunctionLibrary
{
public:
	static void ExecCommandByName(const class FString& Category, const class FString& Name_0);
	static void ExecCommandChangeSelectItemByName(const class FString& Category, const class FString& Name_0, int32 Index_0);
	static void ExecCommandChangeToggleByName(const class FString& Category, const class FString& Name_0, bool flag);
	static void ExecCommandChangeValueByName(const class FString& Category, const class FString& Name_0, int32 Value);
	static void OnCloseDebugMenu(const class FString& Category);
	static void OnGetCheckBoxState(const class FString& Category, const class FString& Name_0, bool* OutValue);
	static void OnGetSelectItem(const class FString& Category, const class FString& Name_0, TArray<class FText>* outItems, int32* OutIndex);
	static void OnInitSpinValue(const class FString& Category, const class FString& Name_0, int32* OutValue, int32* outMin, int32* outMax, int32* outFixedPointColumn, bool* outLoop);
	static class UDebugMenuCategoryData* OnOpenDebugMenu(const class FString& Category);
	static void RegisterDebugMenuCloseAllMenu(const class FString& Category, const TDelegate<void()>& closeAllMenuDelegate);
	static void RegisterDebugMenuCloseMenu(const class FString& Category, const TDelegate<void()>& closeThisMenuDelegate);
	static void RegisterDebugMenuGetSelectIndex(const class FString& Category, const TDelegate<void()>& menuDelegate);
	static void RegisterDebugMenuOpenSubMenu(const class FString& Category, const TDelegate<void(const class FString& Category)>& openSubMenuDelegate);
	static void RegisterDebugMenuSetSelectIndex(const class FString& Category, const TDelegate<void(int32 Index)>& menuDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuFL">();
	}
	static class UDebugMenuFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuFL>();
	}
};
static_assert(alignof(UDebugMenuFL) == 0x000008, "Wrong alignment on UDebugMenuFL");
static_assert(sizeof(UDebugMenuFL) == 0x000028, "Wrong size on UDebugMenuFL");

// Class Nicola.DebugMenuLogLevel
// 0x0000 (0x0088 - 0x0088)
class UDebugMenuLogLevel final : public UDebugMenuCustomMan
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuLogLevel">();
	}
	static class UDebugMenuLogLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuLogLevel>();
	}
};
static_assert(alignof(UDebugMenuLogLevel) == 0x000008, "Wrong alignment on UDebugMenuLogLevel");
static_assert(sizeof(UDebugMenuLogLevel) == 0x000088, "Wrong size on UDebugMenuLogLevel");

// Class Nicola.DebugMenuLua
// 0x00A0 (0x0128 - 0x0088)
class UDebugMenuLua final : public UDebugMenuCustomMan
{
public:
	uint8                                         Pad_88[0xA0];                                      // 0x0088(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuLua">();
	}
	static class UDebugMenuLua* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuLua>();
	}
};
static_assert(alignof(UDebugMenuLua) == 0x000008, "Wrong alignment on UDebugMenuLua");
static_assert(sizeof(UDebugMenuLua) == 0x000128, "Wrong size on UDebugMenuLua");

// Class Nicola.UIFieldTacticsRecordMenuMonsterDetail
// 0x00D8 (0x0148 - 0x0070)
class UUIFieldTacticsRecordMenuMonsterDetail final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemText3*                     TextItemMonsterNum;                                // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          TextSoatType;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuWindowItem*    StatusTexts;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemText4*                     WindowItemHabitat;                                 // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemText2*                     WindowSub;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuMonsterDetailFlipbook* MonsterGraphic;                                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0xA0];                                      // 0x00A8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuMonsterDetail">();
	}
	static class UUIFieldTacticsRecordMenuMonsterDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuMonsterDetail>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuMonsterDetail) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuMonsterDetail");
static_assert(sizeof(UUIFieldTacticsRecordMenuMonsterDetail) == 0x000148, "Wrong size on UUIFieldTacticsRecordMenuMonsterDetail");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetail, TextItemMonsterNum) == 0x000078, "Member 'UUIFieldTacticsRecordMenuMonsterDetail::TextItemMonsterNum' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetail, TextSoatType) == 0x000080, "Member 'UUIFieldTacticsRecordMenuMonsterDetail::TextSoatType' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetail, StatusTexts) == 0x000088, "Member 'UUIFieldTacticsRecordMenuMonsterDetail::StatusTexts' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetail, WindowItemHabitat) == 0x000090, "Member 'UUIFieldTacticsRecordMenuMonsterDetail::WindowItemHabitat' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetail, WindowSub) == 0x000098, "Member 'UUIFieldTacticsRecordMenuMonsterDetail::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetail, MonsterGraphic) == 0x0000A0, "Member 'UUIFieldTacticsRecordMenuMonsterDetail::MonsterGraphic' has a wrong offset!");

// Class Nicola.DebugMenuMan
// 0x00C0 (0x00F0 - 0x0030)
class UDebugMenuMan final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, class UDebugMenuCustomMan*> menus;                                             // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UDebugMenuCategoryData*> Categories;                                        // 0x0090(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuMan">();
	}
	static class UDebugMenuMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuMan>();
	}
};
static_assert(alignof(UDebugMenuMan) == 0x000008, "Wrong alignment on UDebugMenuMan");
static_assert(sizeof(UDebugMenuMan) == 0x0000F0, "Wrong size on UDebugMenuMan");
static_assert(offsetof(UDebugMenuMan, menus) == 0x000030, "Member 'UDebugMenuMan::menus' has a wrong offset!");
static_assert(offsetof(UDebugMenuMan, Categories) == 0x000090, "Member 'UDebugMenuMan::Categories' has a wrong offset!");

// Class Nicola.DebugMenuInfoFlag
// 0x0020 (0x0048 - 0x0028)
class UDebugMenuInfoFlag final : public UObject
{
public:
	int32                                         Index_0;                                           // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Key;                                               // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuInfoFlag">();
	}
	static class UDebugMenuInfoFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuInfoFlag>();
	}
};
static_assert(alignof(UDebugMenuInfoFlag) == 0x000008, "Wrong alignment on UDebugMenuInfoFlag");
static_assert(sizeof(UDebugMenuInfoFlag) == 0x000048, "Wrong size on UDebugMenuInfoFlag");
static_assert(offsetof(UDebugMenuInfoFlag, Index_0) == 0x000028, "Member 'UDebugMenuInfoFlag::Index_0' has a wrong offset!");
static_assert(offsetof(UDebugMenuInfoFlag, Key) == 0x000030, "Member 'UDebugMenuInfoFlag::Key' has a wrong offset!");
static_assert(offsetof(UDebugMenuInfoFlag, Value) == 0x000040, "Member 'UDebugMenuInfoFlag::Value' has a wrong offset!");

// Class Nicola.DebugMenuPersonality
// 0x0000 (0x0088 - 0x0088)
class UDebugMenuPersonality final : public UDebugMenuCustomMan
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuPersonality">();
	}
	static class UDebugMenuPersonality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuPersonality>();
	}
};
static_assert(alignof(UDebugMenuPersonality) == 0x000008, "Wrong alignment on UDebugMenuPersonality");
static_assert(sizeof(UDebugMenuPersonality) == 0x000088, "Wrong size on UDebugMenuPersonality");

// Class Nicola.DebugMenuRecollection
// 0x0010 (0x0098 - 0x0088)
class UDebugMenuRecollection final : public UDebugMenuCustomMan
{
public:
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuRecollection">();
	}
	static class UDebugMenuRecollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuRecollection>();
	}
};
static_assert(alignof(UDebugMenuRecollection) == 0x000008, "Wrong alignment on UDebugMenuRecollection");
static_assert(sizeof(UDebugMenuRecollection) == 0x000098, "Wrong size on UDebugMenuRecollection");

// Class Nicola.DebugMenuRentalUnit
// 0x0000 (0x0088 - 0x0088)
class UDebugMenuRentalUnit final : public UDebugMenuCustomMan
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuRentalUnit">();
	}
	static class UDebugMenuRentalUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuRentalUnit>();
	}
};
static_assert(alignof(UDebugMenuRentalUnit) == 0x000008, "Wrong alignment on UDebugMenuRentalUnit");
static_assert(sizeof(UDebugMenuRentalUnit) == 0x000088, "Wrong size on UDebugMenuRentalUnit");

// Class Nicola.UIListFlexibleH
// 0x0040 (0x00E8 - 0x00A8)
class UUIListFlexibleH : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListFlexibleH">();
	}
	static class UUIListFlexibleH* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListFlexibleH>();
	}
};
static_assert(alignof(UUIListFlexibleH) == 0x000008, "Wrong alignment on UUIListFlexibleH");
static_assert(sizeof(UUIListFlexibleH) == 0x0000E8, "Wrong size on UUIListFlexibleH");

// Class Nicola.UIKeyboardDateMenuListTop
// 0x0008 (0x00F0 - 0x00E8)
class UUIKeyboardDateMenuListTop final : public UUIListFlexibleH
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardDateMenuListTop">();
	}
	static class UUIKeyboardDateMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardDateMenuListTop>();
	}
};
static_assert(alignof(UUIKeyboardDateMenuListTop) == 0x000008, "Wrong alignment on UUIKeyboardDateMenuListTop");
static_assert(sizeof(UUIKeyboardDateMenuListTop) == 0x0000F0, "Wrong size on UUIKeyboardDateMenuListTop");

// Class Nicola.DebugMenuSkill
// 0x0000 (0x0088 - 0x0088)
class UDebugMenuSkill final : public UDebugMenuCustomMan
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuSkill">();
	}
	static class UDebugMenuSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuSkill>();
	}
};
static_assert(alignof(UDebugMenuSkill) == 0x000008, "Wrong alignment on UDebugMenuSkill");
static_assert(sizeof(UDebugMenuSkill) == 0x000088, "Wrong size on UDebugMenuSkill");

// Class Nicola.MapTimeManager
// 0x0030 (0x0060 - 0x0030)
class UMapTimeManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugSetMapTime(float Time);
	struct FMapTimeForBP GetMapTimeForBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTimeManager">();
	}
	static class UMapTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapTimeManager>();
	}
};
static_assert(alignof(UMapTimeManager) == 0x000008, "Wrong alignment on UMapTimeManager");
static_assert(sizeof(UMapTimeManager) == 0x000060, "Wrong size on UMapTimeManager");

// Class Nicola.UITestMouseMenu
// 0x0038 (0x00B0 - 0x0078)
class UUITestMouseMenu final : public UUIRootBase
{
public:
	class UUITestMouseMenuListPage1*              ListPage1;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMouseMenuListPage2*              ListPage2;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMouseMenuListCrossV1*            ListCrossV1;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMouseMenuListCrossH1*            ListCrossH1;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMouseMenuListSimple1*            ListSimple1;                                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMouseMenuWindowSort*             WindowSort;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMouseMenuWindowInfo*             WindowInfo;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenu">();
	}
	static class UUITestMouseMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenu>();
	}
};
static_assert(alignof(UUITestMouseMenu) == 0x000008, "Wrong alignment on UUITestMouseMenu");
static_assert(sizeof(UUITestMouseMenu) == 0x0000B0, "Wrong size on UUITestMouseMenu");
static_assert(offsetof(UUITestMouseMenu, ListPage1) == 0x000078, "Member 'UUITestMouseMenu::ListPage1' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenu, ListPage2) == 0x000080, "Member 'UUITestMouseMenu::ListPage2' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenu, ListCrossV1) == 0x000088, "Member 'UUITestMouseMenu::ListCrossV1' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenu, ListCrossH1) == 0x000090, "Member 'UUITestMouseMenu::ListCrossH1' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenu, ListSimple1) == 0x000098, "Member 'UUITestMouseMenu::ListSimple1' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenu, WindowSort) == 0x0000A0, "Member 'UUITestMouseMenu::WindowSort' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenu, WindowInfo) == 0x0000A8, "Member 'UUITestMouseMenu::WindowInfo' has a wrong offset!");

// Class Nicola.DebugMenuSound
// 0x0020 (0x00A8 - 0x0088)
class UDebugMenuSound final : public UDebugMenuCustomMan
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSoundSuperVisionTop*             SuperVisionTopWidget;                              // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuSound">();
	}
	static class UDebugMenuSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuSound>();
	}
};
static_assert(alignof(UDebugMenuSound) == 0x000008, "Wrong alignment on UDebugMenuSound");
static_assert(sizeof(UDebugMenuSound) == 0x0000A8, "Wrong size on UDebugMenuSound");
static_assert(offsetof(UDebugMenuSound, SuperVisionTopWidget) == 0x000090, "Member 'UDebugMenuSound::SuperVisionTopWidget' has a wrong offset!");

// Class Nicola.DebugParameterCollection
// 0x0000 (0x0088 - 0x0088)
class UDebugParameterCollection final : public UNicolaParameterCollectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugParameterCollection">();
	}
	static class UDebugParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugParameterCollection>();
	}
};
static_assert(alignof(UDebugParameterCollection) == 0x000008, "Wrong alignment on UDebugParameterCollection");
static_assert(sizeof(UDebugParameterCollection) == 0x000088, "Wrong size on UDebugParameterCollection");

// Class Nicola.DebugResearchCursorMan
// 0x0088 (0x02A8 - 0x0220)
class ADebugResearchCursorMan final : public AActor
{
public:
	TSubclassOf<class UUserWidget>                DebugCameraInfoWidgetClass;                        // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x80];                                     // 0x0228(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugResearchCursorMan">();
	}
	static class ADebugResearchCursorMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugResearchCursorMan>();
	}
};
static_assert(alignof(ADebugResearchCursorMan) == 0x000008, "Wrong alignment on ADebugResearchCursorMan");
static_assert(sizeof(ADebugResearchCursorMan) == 0x0002A8, "Wrong size on ADebugResearchCursorMan");
static_assert(offsetof(ADebugResearchCursorMan, DebugCameraInfoWidgetClass) == 0x000220, "Member 'ADebugResearchCursorMan::DebugCameraInfoWidgetClass' has a wrong offset!");

// Class Nicola.DelayCallback
// 0x0050 (0x0078 - 0x0028)
class UDelayCallback final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelayCallback">();
	}
	static class UDelayCallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelayCallback>();
	}
};
static_assert(alignof(UDelayCallback) == 0x000008, "Wrong alignment on UDelayCallback");
static_assert(sizeof(UDelayCallback) == 0x000078, "Wrong size on UDelayCallback");

// Class Nicola.DlcBase
// 0x0008 (0x0030 - 0x0028)
class UDlcBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcBase">();
	}
	static class UDlcBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcBase>();
	}
};
static_assert(alignof(UDlcBase) == 0x000008, "Wrong alignment on UDlcBase");
static_assert(sizeof(UDlcBase) == 0x000030, "Wrong size on UDlcBase");

// Class Nicola.DLCBoxEvent
// 0x0030 (0x0270 - 0x0240)
class ADLCBoxEvent : public AEventActorBase
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorListComponent*                    ActorListComp;                                     // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDLCEventTrigger*                       EventTrigger;                                      // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ObjectMesh;                                        // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        OpenAnimation;                                     // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        CloseAnimation;                                    // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEndDLCBoxEffect(bool IsEndPlay);
	void OnStartDLCBoxEffect(bool IsBeginPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCBoxEvent">();
	}
	static class ADLCBoxEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADLCBoxEvent>();
	}
};
static_assert(alignof(ADLCBoxEvent) == 0x000008, "Wrong alignment on ADLCBoxEvent");
static_assert(sizeof(ADLCBoxEvent) == 0x000270, "Wrong size on ADLCBoxEvent");
static_assert(offsetof(ADLCBoxEvent, ActorListComp) == 0x000248, "Member 'ADLCBoxEvent::ActorListComp' has a wrong offset!");
static_assert(offsetof(ADLCBoxEvent, EventTrigger) == 0x000250, "Member 'ADLCBoxEvent::EventTrigger' has a wrong offset!");
static_assert(offsetof(ADLCBoxEvent, ObjectMesh) == 0x000258, "Member 'ADLCBoxEvent::ObjectMesh' has a wrong offset!");
static_assert(offsetof(ADLCBoxEvent, OpenAnimation) == 0x000260, "Member 'ADLCBoxEvent::OpenAnimation' has a wrong offset!");
static_assert(offsetof(ADLCBoxEvent, CloseAnimation) == 0x000268, "Member 'ADLCBoxEvent::CloseAnimation' has a wrong offset!");

// Class Nicola.MapParameterCollectionManager
// 0x0070 (0x0098 - 0x0028)
class UMapParameterCollectionManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFieldMapParameterCollection*           FieldMapParameterCollection;                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTownDungeonMapParameterCollection*     TownDungeonMapParameterCollection;                 // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleMapParameterCollection*          BattleMapParameterCollection;                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMapParameterCollectionManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapParameterCollectionManager">();
	}
	static class UMapParameterCollectionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapParameterCollectionManager>();
	}
};
static_assert(alignof(UMapParameterCollectionManager) == 0x000008, "Wrong alignment on UMapParameterCollectionManager");
static_assert(sizeof(UMapParameterCollectionManager) == 0x000098, "Wrong size on UMapParameterCollectionManager");
static_assert(offsetof(UMapParameterCollectionManager, FieldMapParameterCollection) == 0x000030, "Member 'UMapParameterCollectionManager::FieldMapParameterCollection' has a wrong offset!");
static_assert(offsetof(UMapParameterCollectionManager, TownDungeonMapParameterCollection) == 0x000038, "Member 'UMapParameterCollectionManager::TownDungeonMapParameterCollection' has a wrong offset!");
static_assert(offsetof(UMapParameterCollectionManager, BattleMapParameterCollection) == 0x000040, "Member 'UMapParameterCollectionManager::BattleMapParameterCollection' has a wrong offset!");

// Class Nicola.EventTriggerComponentBase
// 0x0048 (0x00F8 - 0x00B0)
class UEventTriggerComponentBase : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LuaCommandName;                                    // 0x00B8(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           Tags;                                              // 0x00C8(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           Args;                                              // 0x00D8(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	EEventActorType                               actorType;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x1];                                       // 0x00E9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEditCondition;                                    // 0x00EA(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB[0x5];                                       // 0x00EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventMangaIconComponent*               MangaIconComp;                                     // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTriggerComponentBase">();
	}
	static class UEventTriggerComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventTriggerComponentBase>();
	}
};
static_assert(alignof(UEventTriggerComponentBase) == 0x000008, "Wrong alignment on UEventTriggerComponentBase");
static_assert(sizeof(UEventTriggerComponentBase) == 0x0000F8, "Wrong size on UEventTriggerComponentBase");
static_assert(offsetof(UEventTriggerComponentBase, LuaCommandName) == 0x0000B8, "Member 'UEventTriggerComponentBase::LuaCommandName' has a wrong offset!");
static_assert(offsetof(UEventTriggerComponentBase, Tags) == 0x0000C8, "Member 'UEventTriggerComponentBase::Tags' has a wrong offset!");
static_assert(offsetof(UEventTriggerComponentBase, Args) == 0x0000D8, "Member 'UEventTriggerComponentBase::Args' has a wrong offset!");
static_assert(offsetof(UEventTriggerComponentBase, actorType) == 0x0000E8, "Member 'UEventTriggerComponentBase::actorType' has a wrong offset!");
static_assert(offsetof(UEventTriggerComponentBase, bEditCondition) == 0x0000EA, "Member 'UEventTriggerComponentBase::bEditCondition' has a wrong offset!");
static_assert(offsetof(UEventTriggerComponentBase, MangaIconComp) == 0x0000F0, "Member 'UEventTriggerComponentBase::MangaIconComp' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuKeyboardListItemTextBox
// 0x0010 (0x0068 - 0x0058)
class UUIKeyboardNameMenuKeyboardListItemTextBox final : public UUIListItem
{
public:
	class UOverlay*                               PanelTextBox;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEditableText*                          TextBox;                                           // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuKeyboardListItemTextBox">();
	}
	static class UUIKeyboardNameMenuKeyboardListItemTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuKeyboardListItemTextBox>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuKeyboardListItemTextBox) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuKeyboardListItemTextBox");
static_assert(sizeof(UUIKeyboardNameMenuKeyboardListItemTextBox) == 0x000068, "Wrong size on UUIKeyboardNameMenuKeyboardListItemTextBox");
static_assert(offsetof(UUIKeyboardNameMenuKeyboardListItemTextBox, PanelTextBox) == 0x000058, "Member 'UUIKeyboardNameMenuKeyboardListItemTextBox::PanelTextBox' has a wrong offset!");
static_assert(offsetof(UUIKeyboardNameMenuKeyboardListItemTextBox, TextBox) == 0x000060, "Member 'UUIKeyboardNameMenuKeyboardListItemTextBox::TextBox' has a wrong offset!");

// Class Nicola.DLCEventTrigger
// 0x0000 (0x00F8 - 0x00F8)
class UDLCEventTrigger final : public UEventTriggerComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCEventTrigger">();
	}
	static class UDLCEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCEventTrigger>();
	}
};
static_assert(alignof(UDLCEventTrigger) == 0x000008, "Wrong alignment on UDLCEventTrigger");
static_assert(sizeof(UDLCEventTrigger) == 0x0000F8, "Wrong size on UDLCEventTrigger");

// Class Nicola.MBRSphereComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRSphereComponent : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRSphereComponent">();
	}
	static class UMBRSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRSphereComponent>();
	}
};
static_assert(alignof(UMBRSphereComponent) == 0x000010, "Wrong alignment on UMBRSphereComponent");
static_assert(sizeof(UMBRSphereComponent) == 0x000480, "Wrong size on UMBRSphereComponent");

// Class Nicola.MBRSuccessSphereComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRSuccessSphereComponent final : public UMBRSphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRSuccessSphereComponent">();
	}
	static class UMBRSuccessSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRSuccessSphereComponent>();
	}
};
static_assert(alignof(UMBRSuccessSphereComponent) == 0x000010, "Wrong alignment on UMBRSuccessSphereComponent");
static_assert(sizeof(UMBRSuccessSphereComponent) == 0x000480, "Wrong size on UMBRSuccessSphereComponent");

// Class Nicola.UITestMouseMenuWindowInfo
// 0x0030 (0x00A0 - 0x0070)
class UUITestMouseMenuWindowInfo final : public UUICtrlBase
{
public:
	TArray<class UGopTextBlock*>                  Texts;                                             // 0x0070(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCommonItemWidget*                      WidgetMouse;                                       // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMouse;                                        // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageClick;                                        // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonWindowWidget*                    SpeedChange;                                       // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuWindowInfo">();
	}
	static class UUITestMouseMenuWindowInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuWindowInfo>();
	}
};
static_assert(alignof(UUITestMouseMenuWindowInfo) == 0x000008, "Wrong alignment on UUITestMouseMenuWindowInfo");
static_assert(sizeof(UUITestMouseMenuWindowInfo) == 0x0000A0, "Wrong size on UUITestMouseMenuWindowInfo");
static_assert(offsetof(UUITestMouseMenuWindowInfo, Texts) == 0x000070, "Member 'UUITestMouseMenuWindowInfo::Texts' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowInfo, WidgetMouse) == 0x000080, "Member 'UUITestMouseMenuWindowInfo::WidgetMouse' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowInfo, ImageMouse) == 0x000088, "Member 'UUITestMouseMenuWindowInfo::ImageMouse' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowInfo, ImageClick) == 0x000090, "Member 'UUITestMouseMenuWindowInfo::ImageClick' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowInfo, SpeedChange) == 0x000098, "Member 'UUITestMouseMenuWindowInfo::SpeedChange' has a wrong offset!");

// Class Nicola.DlcManager
// 0x0038 (0x0068 - 0x0030)
class UDlcManager final : public UGameInstanceSubsystem
{
public:
	class UDlcBase*                               DlcBase;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcManager">();
	}
	static class UDlcManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcManager>();
	}
};
static_assert(alignof(UDlcManager) == 0x000008, "Wrong alignment on UDlcManager");
static_assert(sizeof(UDlcManager) == 0x000068, "Wrong size on UDlcManager");
static_assert(offsetof(UDlcManager, DlcBase) == 0x000030, "Member 'UDlcManager::DlcBase' has a wrong offset!");

// Class Nicola.DlcPS5
// 0x0000 (0x0030 - 0x0030)
class UDlcPS5 final : public UDlcBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcPS5">();
	}
	static class UDlcPS5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcPS5>();
	}
};
static_assert(alignof(UDlcPS5) == 0x000008, "Wrong alignment on UDlcPS5");
static_assert(sizeof(UDlcPS5) == 0x000030, "Wrong size on UDlcPS5");

// Class Nicola.UIShopMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIShopMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuListTop">();
	}
	static class UUIShopMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuListTop>();
	}
};
static_assert(alignof(UUIShopMenuListTop) == 0x000008, "Wrong alignment on UUIShopMenuListTop");
static_assert(sizeof(UUIShopMenuListTop) == 0x0000D8, "Wrong size on UUIShopMenuListTop");

// Class Nicola.MBRBoxComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRBoxComponent : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRBoxComponent">();
	}
	static class UMBRBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRBoxComponent>();
	}
};
static_assert(alignof(UMBRBoxComponent) == 0x000010, "Wrong alignment on UMBRBoxComponent");
static_assert(sizeof(UMBRBoxComponent) == 0x000480, "Wrong size on UMBRBoxComponent");

// Class Nicola.DlcSteam
// 0x0028 (0x0058 - 0x0030)
class UDlcSteam final : public UDlcBase
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcSteam">();
	}
	static class UDlcSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcSteam>();
	}
};
static_assert(alignof(UDlcSteam) == 0x000008, "Wrong alignment on UDlcSteam");
static_assert(sizeof(UDlcSteam) == 0x000058, "Wrong size on UDlcSteam");

// Class Nicola.DlcSwitch
// 0x0000 (0x0030 - 0x0030)
class UDlcSwitch final : public UDlcBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcSwitch">();
	}
	static class UDlcSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcSwitch>();
	}
};
static_assert(alignof(UDlcSwitch) == 0x000008, "Wrong alignment on UDlcSwitch");
static_assert(sizeof(UDlcSwitch) == 0x000030, "Wrong size on UDlcSwitch");

// Class Nicola.MangaIconActorBase
// 0x0018 (0x0238 - 0x0220)
class AMangaIconActorBase : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEventMangaIconComponent*               MangaIconComp;                                     // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorListComp;                                     // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CloseMangaIcon();
	void ShowMangaIcon(const class FName& IconID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangaIconActorBase">();
	}
	static class AMangaIconActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMangaIconActorBase>();
	}
};
static_assert(alignof(AMangaIconActorBase) == 0x000008, "Wrong alignment on AMangaIconActorBase");
static_assert(sizeof(AMangaIconActorBase) == 0x000238, "Wrong size on AMangaIconActorBase");
static_assert(offsetof(AMangaIconActorBase, Root) == 0x000220, "Member 'AMangaIconActorBase::Root' has a wrong offset!");
static_assert(offsetof(AMangaIconActorBase, MangaIconComp) == 0x000228, "Member 'AMangaIconActorBase::MangaIconComp' has a wrong offset!");
static_assert(offsetof(AMangaIconActorBase, ActorListComp) == 0x000230, "Member 'AMangaIconActorBase::ActorListComp' has a wrong offset!");

// Class Nicola.GuideIconDisplayActor
// 0x0000 (0x0238 - 0x0238)
class AGuideIconDisplayActor final : public AMangaIconActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuideIconDisplayActor">();
	}
	static class AGuideIconDisplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuideIconDisplayActor>();
	}
};
static_assert(alignof(AGuideIconDisplayActor) == 0x000008, "Wrong alignment on AGuideIconDisplayActor");
static_assert(sizeof(AGuideIconDisplayActor) == 0x000238, "Wrong size on AGuideIconDisplayActor");

// Class Nicola.DlcWinGDK
// 0x0008 (0x0038 - 0x0030)
class UDlcWinGDK : public UDlcBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcWinGDK">();
	}
	static class UDlcWinGDK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcWinGDK>();
	}
};
static_assert(alignof(UDlcWinGDK) == 0x000008, "Wrong alignment on UDlcWinGDK");
static_assert(sizeof(UDlcWinGDK) == 0x000038, "Wrong size on UDlcWinGDK");

// Class Nicola.DlcXSX
// 0x0000 (0x0038 - 0x0038)
class UDlcXSX final : public UDlcWinGDK
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcXSX">();
	}
	static class UDlcXSX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcXSX>();
	}
};
static_assert(alignof(UDlcXSX) == 0x000008, "Wrong alignment on UDlcXSX");
static_assert(sizeof(UDlcXSX) == 0x000038, "Wrong size on UDlcXSX");

// Class Nicola.DoorEventTrigger
// 0x0000 (0x00F8 - 0x00F8)
class UDoorEventTrigger final : public UEventTriggerComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorEventTrigger">();
	}
	static class UDoorEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorEventTrigger>();
	}
};
static_assert(alignof(UDoorEventTrigger) == 0x000008, "Wrong alignment on UDoorEventTrigger");
static_assert(sizeof(UDoorEventTrigger) == 0x0000F8, "Wrong size on UDoorEventTrigger");

// Class Nicola.UIFieldTacticsRecordMenuListItem
// 0x0030 (0x0100 - 0x00D0)
class UUIFieldTacticsRecordMenuListItem final : public UUIListPage
{
public:
	class UUIFieldTacticsRecordMenuWindowSort*    ItemSort;                                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuListItem">();
	}
	static class UUIFieldTacticsRecordMenuListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuListItem>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuListItem) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuListItem");
static_assert(sizeof(UUIFieldTacticsRecordMenuListItem) == 0x000100, "Wrong size on UUIFieldTacticsRecordMenuListItem");
static_assert(offsetof(UUIFieldTacticsRecordMenuListItem, ItemSort) == 0x0000D0, "Member 'UUIFieldTacticsRecordMenuListItem::ItemSort' has a wrong offset!");

// Class Nicola.DoorGimmick
// 0x0050 (0x0278 - 0x0228)
class ADoorGimmick : public APlayerControllableGimmick
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELockType                                     lockType;                                          // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELockType                                     lockTypeEvening;                                   // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELockType                                     lockTypeNight;                                     // 0x0232(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_233[0x5];                                      // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          Collision;                                         // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USearchObjEventTrigger*                 EventTrigger;                                      // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        OpenFront;                                         // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        OpenBack;                                          // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDoorSeType                                   seType;                                            // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   customSeId;                                        // 0x0264(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGOPEnumDoorType                              UniqueId;                                          // 0x026C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorListComponent*                    ActorListComp;                                     // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorGimmick">();
	}
	static class ADoorGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorGimmick>();
	}
};
static_assert(alignof(ADoorGimmick) == 0x000008, "Wrong alignment on ADoorGimmick");
static_assert(sizeof(ADoorGimmick) == 0x000278, "Wrong size on ADoorGimmick");
static_assert(offsetof(ADoorGimmick, lockType) == 0x000230, "Member 'ADoorGimmick::lockType' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, lockTypeEvening) == 0x000231, "Member 'ADoorGimmick::lockTypeEvening' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, lockTypeNight) == 0x000232, "Member 'ADoorGimmick::lockTypeNight' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, Collision) == 0x000238, "Member 'ADoorGimmick::Collision' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, Mesh) == 0x000240, "Member 'ADoorGimmick::Mesh' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, EventTrigger) == 0x000248, "Member 'ADoorGimmick::EventTrigger' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, OpenFront) == 0x000250, "Member 'ADoorGimmick::OpenFront' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, OpenBack) == 0x000258, "Member 'ADoorGimmick::OpenBack' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, seType) == 0x000260, "Member 'ADoorGimmick::seType' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, customSeId) == 0x000264, "Member 'ADoorGimmick::customSeId' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, UniqueId) == 0x00026C, "Member 'ADoorGimmick::UniqueId' has a wrong offset!");
static_assert(offsetof(ADoorGimmick, ActorListComp) == 0x000270, "Member 'ADoorGimmick::ActorListComp' has a wrong offset!");

// Class Nicola.NicolaCharacterComponentBase
// 0x0008 (0x00B8 - 0x00B0)
class UNicolaCharacterComponentBase : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterComponentBase">();
	}
	static class UNicolaCharacterComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCharacterComponentBase>();
	}
};
static_assert(alignof(UNicolaCharacterComponentBase) == 0x000008, "Wrong alignment on UNicolaCharacterComponentBase");
static_assert(sizeof(UNicolaCharacterComponentBase) == 0x0000B8, "Wrong size on UNicolaCharacterComponentBase");

// Class Nicola.LightDoorGimmick
// 0x0060 (0x02D8 - 0x0278)
class ALightDoorGimmick final : public ADoorGimmick
{
public:
	EDoorLightType                                lightType;                                         // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            openFadeCurve;                                     // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            closeFadeCurve;                                    // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   pointLight1;                                       // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   pointLight2;                                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpotLightComponent*                    spotLight1;                                        // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpotLightComponent*                    spotLight2;                                        // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightDoorGimmick">();
	}
	static class ALightDoorGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightDoorGimmick>();
	}
};
static_assert(alignof(ALightDoorGimmick) == 0x000008, "Wrong alignment on ALightDoorGimmick");
static_assert(sizeof(ALightDoorGimmick) == 0x0002D8, "Wrong size on ALightDoorGimmick");
static_assert(offsetof(ALightDoorGimmick, lightType) == 0x000278, "Member 'ALightDoorGimmick::lightType' has a wrong offset!");
static_assert(offsetof(ALightDoorGimmick, openFadeCurve) == 0x000280, "Member 'ALightDoorGimmick::openFadeCurve' has a wrong offset!");
static_assert(offsetof(ALightDoorGimmick, closeFadeCurve) == 0x000288, "Member 'ALightDoorGimmick::closeFadeCurve' has a wrong offset!");
static_assert(offsetof(ALightDoorGimmick, pointLight1) == 0x000290, "Member 'ALightDoorGimmick::pointLight1' has a wrong offset!");
static_assert(offsetof(ALightDoorGimmick, pointLight2) == 0x000298, "Member 'ALightDoorGimmick::pointLight2' has a wrong offset!");
static_assert(offsetof(ALightDoorGimmick, spotLight1) == 0x0002A0, "Member 'ALightDoorGimmick::spotLight1' has a wrong offset!");
static_assert(offsetof(ALightDoorGimmick, spotLight2) == 0x0002A8, "Member 'ALightDoorGimmick::spotLight2' has a wrong offset!");

// Class Nicola.EffectAssetMan
// 0x0020 (0x0048 - 0x0028)
class UEffectAssetMan final : public UObject
{
public:
	TArray<class UFXSystemAsset*>                 loadedEffectEffectAssets;                          // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAssetMan">();
	}
	static class UEffectAssetMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAssetMan>();
	}
};
static_assert(alignof(UEffectAssetMan) == 0x000008, "Wrong alignment on UEffectAssetMan");
static_assert(sizeof(UEffectAssetMan) == 0x000048, "Wrong size on UEffectAssetMan");
static_assert(offsetof(UEffectAssetMan, loadedEffectEffectAssets) == 0x000028, "Member 'UEffectAssetMan::loadedEffectEffectAssets' has a wrong offset!");

// Class Nicola.UITestCommon
// 0x0030 (0x00A8 - 0x0078)
class UUITestCommon final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITestCommonListTop*                   ListTop;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestCommonListPage*                  ListPage;                                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestCommonListCross*                 ListCross;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestCommonWindow1*                   Window1;                                           // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestCommonWindow2*                   Window2;                                           // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommon">();
	}
	static class UUITestCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommon>();
	}
};
static_assert(alignof(UUITestCommon) == 0x000008, "Wrong alignment on UUITestCommon");
static_assert(sizeof(UUITestCommon) == 0x0000A8, "Wrong size on UUITestCommon");
static_assert(offsetof(UUITestCommon, ListTop) == 0x000080, "Member 'UUITestCommon::ListTop' has a wrong offset!");
static_assert(offsetof(UUITestCommon, ListPage) == 0x000088, "Member 'UUITestCommon::ListPage' has a wrong offset!");
static_assert(offsetof(UUITestCommon, ListCross) == 0x000090, "Member 'UUITestCommon::ListCross' has a wrong offset!");
static_assert(offsetof(UUITestCommon, Window1) == 0x000098, "Member 'UUITestCommon::Window1' has a wrong offset!");
static_assert(offsetof(UUITestCommon, Window2) == 0x0000A0, "Member 'UUITestCommon::Window2' has a wrong offset!");

// Class Nicola.MBRCapsuleComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRCapsuleComponent : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRCapsuleComponent">();
	}
	static class UMBRCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRCapsuleComponent>();
	}
};
static_assert(alignof(UMBRCapsuleComponent) == 0x000010, "Wrong alignment on UMBRCapsuleComponent");
static_assert(sizeof(UMBRCapsuleComponent) == 0x000480, "Wrong size on UMBRCapsuleComponent");

// Class Nicola.EffectBaseActor
// 0x0008 (0x0228 - 0x0220)
class AEffectBaseActor : public AActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBaseActor">();
	}
	static class AEffectBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectBaseActor>();
	}
};
static_assert(alignof(AEffectBaseActor) == 0x000008, "Wrong alignment on AEffectBaseActor");
static_assert(sizeof(AEffectBaseActor) == 0x000228, "Wrong size on AEffectBaseActor");
static_assert(offsetof(AEffectBaseActor, ActorListComponent) == 0x000220, "Member 'AEffectBaseActor::ActorListComponent' has a wrong offset!");

// Class Nicola.EffectFL
// 0x0000 (0x0028 - 0x0028)
class UEffectFL final : public UBlueprintFunctionLibrary
{
public:
	static void SpawnEffectByGopId(const class FName& GopId, const struct FVector& Location, const struct FRotator& Rotator, const struct FVector& Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectFL">();
	}
	static class UEffectFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectFL>();
	}
};
static_assert(alignof(UEffectFL) == 0x000008, "Wrong alignment on UEffectFL");
static_assert(sizeof(UEffectFL) == 0x000028, "Wrong size on UEffectFL");

// Class Nicola.MBRSuccessBoxComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRSuccessBoxComponent final : public UMBRBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRSuccessBoxComponent">();
	}
	static class UMBRSuccessBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRSuccessBoxComponent>();
	}
};
static_assert(alignof(UMBRSuccessBoxComponent) == 0x000010, "Wrong alignment on UMBRSuccessBoxComponent");
static_assert(sizeof(UMBRSuccessBoxComponent) == 0x000480, "Wrong size on UMBRSuccessBoxComponent");

// Class Nicola.EffectParameterCollection
// 0x0000 (0x0088 - 0x0088)
class UEffectParameterCollection final : public UNicolaParameterCollectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectParameterCollection">();
	}
	static class UEffectParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectParameterCollection>();
	}
};
static_assert(alignof(UEffectParameterCollection) == 0x000008, "Wrong alignment on UEffectParameterCollection");
static_assert(sizeof(UEffectParameterCollection) == 0x000088, "Wrong size on UEffectParameterCollection");

// Class Nicola.EffectTimeManageComponent
// 0x0010 (0x00C0 - 0x00B0)
class UEffectTimeManageComponent final : public UActorComponent
{
public:
	class UFXSystemComponent*                     EffectComp;                                        // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectTimeManageComponent">();
	}
	static class UEffectTimeManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectTimeManageComponent>();
	}
};
static_assert(alignof(UEffectTimeManageComponent) == 0x000008, "Wrong alignment on UEffectTimeManageComponent");
static_assert(sizeof(UEffectTimeManageComponent) == 0x0000C0, "Wrong size on UEffectTimeManageComponent");
static_assert(offsetof(UEffectTimeManageComponent, EffectComp) == 0x0000B0, "Member 'UEffectTimeManageComponent::EffectComp' has a wrong offset!");

// Class Nicola.MultiIconImage2
// 0x0038 (0x0248 - 0x0210)
class UMultiIconImage2 final : public UImage
{
public:
	uint8                                         Pad_210[0x18];                                     // 0x0210(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Indexs;                                            // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UCommonWindowWidget*                    ParentWidget;                                      // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiIconImage2">();
	}
	static class UMultiIconImage2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiIconImage2>();
	}
};
static_assert(alignof(UMultiIconImage2) == 0x000008, "Wrong alignment on UMultiIconImage2");
static_assert(sizeof(UMultiIconImage2) == 0x000248, "Wrong size on UMultiIconImage2");
static_assert(offsetof(UMultiIconImage2, Indexs) == 0x000228, "Member 'UMultiIconImage2::Indexs' has a wrong offset!");
static_assert(offsetof(UMultiIconImage2, ParentWidget) == 0x000238, "Member 'UMultiIconImage2::ParentWidget' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuWindowSort
// 0x0028 (0x0080 - 0x0058)
class UUIFieldTacticsRecordMenuWindowSort final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemButtonIcon*                ImageButtonL;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWindowItemButtonIcon*                ImageButtonR;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          ItemText;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuWindowSort">();
	}
	static class UUIFieldTacticsRecordMenuWindowSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuWindowSort>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuWindowSort) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuWindowSort");
static_assert(sizeof(UUIFieldTacticsRecordMenuWindowSort) == 0x000080, "Wrong size on UUIFieldTacticsRecordMenuWindowSort");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowSort, ImageButtonL) == 0x000060, "Member 'UUIFieldTacticsRecordMenuWindowSort::ImageButtonL' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowSort, ImageButtonR) == 0x000068, "Member 'UUIFieldTacticsRecordMenuWindowSort::ImageButtonR' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowSort, ItemText) == 0x000070, "Member 'UUIFieldTacticsRecordMenuWindowSort::ItemText' has a wrong offset!");

// Class Nicola.EncountVolume
// 0x0010 (0x0268 - 0x0258)
class AEncountVolume final : public APlayerTriggerVolume
{
public:
	bool                                          bNoEncount;                                        // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncountBackgroundID;                               // 0x025C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncountVolume">();
	}
	static class AEncountVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEncountVolume>();
	}
};
static_assert(alignof(AEncountVolume) == 0x000008, "Wrong alignment on AEncountVolume");
static_assert(sizeof(AEncountVolume) == 0x000268, "Wrong size on AEncountVolume");
static_assert(offsetof(AEncountVolume, bNoEncount) == 0x000258, "Member 'AEncountVolume::bNoEncount' has a wrong offset!");
static_assert(offsetof(AEncountVolume, EncountBackgroundID) == 0x00025C, "Member 'AEncountVolume::EncountBackgroundID' has a wrong offset!");

// Class Nicola.EnumUtilFL
// 0x0000 (0x0028 - 0x0028)
class UEnumUtilFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnumUtilFL">();
	}
	static class UEnumUtilFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnumUtilFL>();
	}
};
static_assert(alignof(UEnumUtilFL) == 0x000008, "Wrong alignment on UEnumUtilFL");
static_assert(sizeof(UEnumUtilFL) == 0x000028, "Wrong size on UEnumUtilFL");

// Class Nicola.EventCommandInterface
// 0x0000 (0x0028 - 0x0028)
class IEventCommandInterface final : public IInterface
{
public:
	void GetScriptInfo(class FString* CommandName, TArray<class FName>* TagList, TArray<class FName>* Args);

	bool ExistScriptCommand() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCommandInterface">();
	}
	static class IEventCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventCommandInterface>();
	}
};
static_assert(alignof(IEventCommandInterface) == 0x000008, "Wrong alignment on IEventCommandInterface");
static_assert(sizeof(IEventCommandInterface) == 0x000028, "Wrong size on IEventCommandInterface");

// Class Nicola.UITestMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUITestMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMenuListTop">();
	}
	static class UUITestMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMenuListTop>();
	}
};
static_assert(alignof(UUITestMenuListTop) == 0x000008, "Wrong alignment on UUITestMenuListTop");
static_assert(sizeof(UUITestMenuListTop) == 0x0000D8, "Wrong size on UUITestMenuListTop");

// Class Nicola.NicolaActionInputMan
// 0x0050 (0x0078 - 0x0028)
class UNicolaActionInputMan final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  eInputModeFlags;                                   // 0x0068(0x0010)(EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaActionInputMan">();
	}
	static class UNicolaActionInputMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaActionInputMan>();
	}
};
static_assert(alignof(UNicolaActionInputMan) == 0x000008, "Wrong alignment on UNicolaActionInputMan");
static_assert(sizeof(UNicolaActionInputMan) == 0x000078, "Wrong size on UNicolaActionInputMan");
static_assert(offsetof(UNicolaActionInputMan, eInputModeFlags) == 0x000068, "Member 'UNicolaActionInputMan::eInputModeFlags' has a wrong offset!");

// Class Nicola.EventEffectManagementActor
// 0x0010 (0x0230 - 0x0220)
class AEventEffectManagementActor : public AActor
{
public:
	class UActorListComponent*                    ActorList;                                         // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEffectManagementActor">();
	}
	static class AEventEffectManagementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventEffectManagementActor>();
	}
};
static_assert(alignof(AEventEffectManagementActor) == 0x000008, "Wrong alignment on AEventEffectManagementActor");
static_assert(sizeof(AEventEffectManagementActor) == 0x000230, "Wrong size on AEventEffectManagementActor");
static_assert(offsetof(AEventEffectManagementActor, ActorList) == 0x000220, "Member 'AEventEffectManagementActor::ActorList' has a wrong offset!");

// Class Nicola.UIInitialMenuWindowLogo
// 0x0030 (0x00A0 - 0x0070)
class UUIInitialMenuWindowLogo final : public UUICtrlBase
{
public:
	class UImage*                                 ImageLogo;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInitialMenuWindowLogo">();
	}
	static class UUIInitialMenuWindowLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInitialMenuWindowLogo>();
	}
};
static_assert(alignof(UUIInitialMenuWindowLogo) == 0x000008, "Wrong alignment on UUIInitialMenuWindowLogo");
static_assert(sizeof(UUIInitialMenuWindowLogo) == 0x0000A0, "Wrong size on UUIInitialMenuWindowLogo");
static_assert(offsetof(UUIInitialMenuWindowLogo, ImageLogo) == 0x000070, "Member 'UUIInitialMenuWindowLogo::ImageLogo' has a wrong offset!");

// Class Nicola.CameraEffectManagerActor
// 0x0028 (0x0258 - 0x0230)
class ACameraEffectManagerActor final : public AEventEffectManagementActor
{
public:
	class FName                                   CameraEffectIdDayTime;                             // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraEffectIdEvening;                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraEffectIdNight;                               // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGOPEnumProgressType                          ShowProgressFlag;                                  // 0x0248(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseShowProgressFlag;                              // 0x024A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B[0xD];                                      // 0x024B(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraEffectManagerActor">();
	}
	static class ACameraEffectManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraEffectManagerActor>();
	}
};
static_assert(alignof(ACameraEffectManagerActor) == 0x000008, "Wrong alignment on ACameraEffectManagerActor");
static_assert(sizeof(ACameraEffectManagerActor) == 0x000258, "Wrong size on ACameraEffectManagerActor");
static_assert(offsetof(ACameraEffectManagerActor, CameraEffectIdDayTime) == 0x000230, "Member 'ACameraEffectManagerActor::CameraEffectIdDayTime' has a wrong offset!");
static_assert(offsetof(ACameraEffectManagerActor, CameraEffectIdEvening) == 0x000238, "Member 'ACameraEffectManagerActor::CameraEffectIdEvening' has a wrong offset!");
static_assert(offsetof(ACameraEffectManagerActor, CameraEffectIdNight) == 0x000240, "Member 'ACameraEffectManagerActor::CameraEffectIdNight' has a wrong offset!");
static_assert(offsetof(ACameraEffectManagerActor, ShowProgressFlag) == 0x000248, "Member 'ACameraEffectManagerActor::ShowProgressFlag' has a wrong offset!");
static_assert(offsetof(ACameraEffectManagerActor, bUseShowProgressFlag) == 0x00024A, "Member 'ACameraEffectManagerActor::bUseShowProgressFlag' has a wrong offset!");

// Class Nicola.MBRSuccessCapsuleComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRSuccessCapsuleComponent final : public UMBRCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRSuccessCapsuleComponent">();
	}
	static class UMBRSuccessCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRSuccessCapsuleComponent>();
	}
};
static_assert(alignof(UMBRSuccessCapsuleComponent) == 0x000010, "Wrong alignment on UMBRSuccessCapsuleComponent");
static_assert(sizeof(UMBRSuccessCapsuleComponent) == 0x000480, "Wrong size on UMBRSuccessCapsuleComponent");

// Class Nicola.BattleCameraEffectManagerActor
// 0x0028 (0x0258 - 0x0230)
class ABattleCameraEffectManagerActor final : public AEventEffectManagementActor
{
public:
	class FName                                   CameraEffectIdDayTime;                             // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraEffectIdEvening;                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraEffectIdNight;                               // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGOPEnumProgressType                          ShowProgressFlag;                                  // 0x0248(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseShowProgressFlag;                              // 0x024A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B[0xD];                                      // 0x024B(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCameraEffectManagerActor">();
	}
	static class ABattleCameraEffectManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCameraEffectManagerActor>();
	}
};
static_assert(alignof(ABattleCameraEffectManagerActor) == 0x000008, "Wrong alignment on ABattleCameraEffectManagerActor");
static_assert(sizeof(ABattleCameraEffectManagerActor) == 0x000258, "Wrong size on ABattleCameraEffectManagerActor");
static_assert(offsetof(ABattleCameraEffectManagerActor, CameraEffectIdDayTime) == 0x000230, "Member 'ABattleCameraEffectManagerActor::CameraEffectIdDayTime' has a wrong offset!");
static_assert(offsetof(ABattleCameraEffectManagerActor, CameraEffectIdEvening) == 0x000238, "Member 'ABattleCameraEffectManagerActor::CameraEffectIdEvening' has a wrong offset!");
static_assert(offsetof(ABattleCameraEffectManagerActor, CameraEffectIdNight) == 0x000240, "Member 'ABattleCameraEffectManagerActor::CameraEffectIdNight' has a wrong offset!");
static_assert(offsetof(ABattleCameraEffectManagerActor, ShowProgressFlag) == 0x000248, "Member 'ABattleCameraEffectManagerActor::ShowProgressFlag' has a wrong offset!");
static_assert(offsetof(ABattleCameraEffectManagerActor, bUseShowProgressFlag) == 0x00024A, "Member 'ABattleCameraEffectManagerActor::bUseShowProgressFlag' has a wrong offset!");

// Class Nicola.CurseGoldenClawsEffectActor
// 0x0030 (0x0260 - 0x0230)
class ACurseGoldenClawsEffectActor final : public AEventEffectManagementActor
{
public:
	class AActor*                                 CurseEffectCoffinActor;                            // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               CurseEffectRotation;                               // 0x0238(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASearchEventGimmick*                    CurseCoffinSearchObject;                           // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     CoffinEffectComp;                                  // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurseGoldenClawsEffectActor">();
	}
	static class ACurseGoldenClawsEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurseGoldenClawsEffectActor>();
	}
};
static_assert(alignof(ACurseGoldenClawsEffectActor) == 0x000008, "Wrong alignment on ACurseGoldenClawsEffectActor");
static_assert(sizeof(ACurseGoldenClawsEffectActor) == 0x000260, "Wrong size on ACurseGoldenClawsEffectActor");
static_assert(offsetof(ACurseGoldenClawsEffectActor, CurseEffectCoffinActor) == 0x000230, "Member 'ACurseGoldenClawsEffectActor::CurseEffectCoffinActor' has a wrong offset!");
static_assert(offsetof(ACurseGoldenClawsEffectActor, CurseEffectRotation) == 0x000238, "Member 'ACurseGoldenClawsEffectActor::CurseEffectRotation' has a wrong offset!");
static_assert(offsetof(ACurseGoldenClawsEffectActor, CurseCoffinSearchObject) == 0x000248, "Member 'ACurseGoldenClawsEffectActor::CurseCoffinSearchObject' has a wrong offset!");
static_assert(offsetof(ACurseGoldenClawsEffectActor, CoffinEffectComp) == 0x000250, "Member 'ACurseGoldenClawsEffectActor::CoffinEffectComp' has a wrong offset!");

// Class Nicola.ProduceSequencerBase
// 0x0000 (0x0220 - 0x0220)
class AProduceSequencerBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerBase">();
	}
	static class AProduceSequencerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerBase>();
	}
};
static_assert(alignof(AProduceSequencerBase) == 0x000008, "Wrong alignment on AProduceSequencerBase");
static_assert(sizeof(AProduceSequencerBase) == 0x000220, "Wrong size on AProduceSequencerBase");

// Class Nicola.ProduceSequencerMessage
// 0x0010 (0x0230 - 0x0220)
class AProduceSequencerMessage final : public AProduceSequencerBase
{
public:
	EMessageWindowType                            WindowType;                                        // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMessageWindowPositionType                    PositionType;                                      // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AResearchSequenceCamera*                eventSequenceCamera;                               // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseMessageWindow();
	void PlayMessage(const class FString& MessageId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerMessage">();
	}
	static class AProduceSequencerMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerMessage>();
	}
};
static_assert(alignof(AProduceSequencerMessage) == 0x000008, "Wrong alignment on AProduceSequencerMessage");
static_assert(sizeof(AProduceSequencerMessage) == 0x000230, "Wrong size on AProduceSequencerMessage");
static_assert(offsetof(AProduceSequencerMessage, WindowType) == 0x000220, "Member 'AProduceSequencerMessage::WindowType' has a wrong offset!");
static_assert(offsetof(AProduceSequencerMessage, PositionType) == 0x000221, "Member 'AProduceSequencerMessage::PositionType' has a wrong offset!");
static_assert(offsetof(AProduceSequencerMessage, eventSequenceCamera) == 0x000228, "Member 'AProduceSequencerMessage::eventSequenceCamera' has a wrong offset!");

// Class Nicola.NicolaDataAssetBase
// 0x0000 (0x0030 - 0x0030)
class UNicolaDataAssetBase : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetBase">();
	}
	static class UNicolaDataAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetBase>();
	}
};
static_assert(alignof(UNicolaDataAssetBase) == 0x000008, "Wrong alignment on UNicolaDataAssetBase");
static_assert(sizeof(UNicolaDataAssetBase) == 0x000030, "Wrong size on UNicolaDataAssetBase");

// Class Nicola.NicolaDataAssetPlayerActor
// 0x01C8 (0x01F8 - 0x0030)
class UNicolaDataAssetPlayerActor final : public UNicolaDataAssetBase
{
public:
	float                                         LamiaFlySpeed;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaFallSpeedHigh;                                // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaFallSpeedLow;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaFadeDistance;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            LamiaFadeCurve;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaWaitTime;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaTakeOffHeight;                                // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaTakeOffTime;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaMemberSpeed;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaLandingHeight;                                // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaLandingDistance;                              // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaSearchRadius;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaPCCharacterFadeTime;                          // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaTurnAnimTimeHigh;                             // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaBrakeCoeffHigh;                               // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            LamiaBrakeCurveHigh;                               // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaLandingHeightHigh;                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaLandingTimeHigh;                              // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaTurnAnimTimeLow;                              // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaBrakeCoeffLow;                                // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            LamiaBrakeCurveLow;                                // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaLandingHeightLow;                             // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LamiaLandingTimeLow;                               // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShipMoveSpeed;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShipFadeDistance;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ShipFadeCurve;                                     // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShipMemberSpeed;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShipSearchRadius;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraHoverTime;                                     // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraHoverHeight;                                   // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraFlyTime;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraFlySpeed;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraFallTime;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraFallSpeed;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraBrightWaitTime;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RuraShipFlyTime;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RiremitoStartWaitTime;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RiremitoEndWaitTime;                               // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RiremitoPos;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RiremitoSearch;                                    // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   fieldParty;                                        // 0x00E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   townParty;                                         // 0x0108(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   lamia;                                             // 0x0130(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   Ship;                                              // 0x0158(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   king;                                              // 0x0180(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   monster;                                           // 0x01A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   vehicleSearchObject;                               // 0x01D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetPlayerActor">();
	}
	static class UNicolaDataAssetPlayerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetPlayerActor>();
	}
};
static_assert(alignof(UNicolaDataAssetPlayerActor) == 0x000008, "Wrong alignment on UNicolaDataAssetPlayerActor");
static_assert(sizeof(UNicolaDataAssetPlayerActor) == 0x0001F8, "Wrong size on UNicolaDataAssetPlayerActor");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaFlySpeed) == 0x000030, "Member 'UNicolaDataAssetPlayerActor::LamiaFlySpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaFallSpeedHigh) == 0x000034, "Member 'UNicolaDataAssetPlayerActor::LamiaFallSpeedHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaFallSpeedLow) == 0x000038, "Member 'UNicolaDataAssetPlayerActor::LamiaFallSpeedLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaFadeDistance) == 0x00003C, "Member 'UNicolaDataAssetPlayerActor::LamiaFadeDistance' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaFadeCurve) == 0x000040, "Member 'UNicolaDataAssetPlayerActor::LamiaFadeCurve' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaWaitTime) == 0x000048, "Member 'UNicolaDataAssetPlayerActor::LamiaWaitTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaTakeOffHeight) == 0x00004C, "Member 'UNicolaDataAssetPlayerActor::LamiaTakeOffHeight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaTakeOffTime) == 0x000050, "Member 'UNicolaDataAssetPlayerActor::LamiaTakeOffTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaMemberSpeed) == 0x000054, "Member 'UNicolaDataAssetPlayerActor::LamiaMemberSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaLandingHeight) == 0x000058, "Member 'UNicolaDataAssetPlayerActor::LamiaLandingHeight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaLandingDistance) == 0x00005C, "Member 'UNicolaDataAssetPlayerActor::LamiaLandingDistance' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaSearchRadius) == 0x000060, "Member 'UNicolaDataAssetPlayerActor::LamiaSearchRadius' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaPCCharacterFadeTime) == 0x000064, "Member 'UNicolaDataAssetPlayerActor::LamiaPCCharacterFadeTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaTurnAnimTimeHigh) == 0x000068, "Member 'UNicolaDataAssetPlayerActor::LamiaTurnAnimTimeHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaBrakeCoeffHigh) == 0x00006C, "Member 'UNicolaDataAssetPlayerActor::LamiaBrakeCoeffHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaBrakeCurveHigh) == 0x000070, "Member 'UNicolaDataAssetPlayerActor::LamiaBrakeCurveHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaLandingHeightHigh) == 0x000078, "Member 'UNicolaDataAssetPlayerActor::LamiaLandingHeightHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaLandingTimeHigh) == 0x00007C, "Member 'UNicolaDataAssetPlayerActor::LamiaLandingTimeHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaTurnAnimTimeLow) == 0x000080, "Member 'UNicolaDataAssetPlayerActor::LamiaTurnAnimTimeLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaBrakeCoeffLow) == 0x000084, "Member 'UNicolaDataAssetPlayerActor::LamiaBrakeCoeffLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaBrakeCurveLow) == 0x000088, "Member 'UNicolaDataAssetPlayerActor::LamiaBrakeCurveLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaLandingHeightLow) == 0x000090, "Member 'UNicolaDataAssetPlayerActor::LamiaLandingHeightLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, LamiaLandingTimeLow) == 0x000094, "Member 'UNicolaDataAssetPlayerActor::LamiaLandingTimeLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, ShipMoveSpeed) == 0x000098, "Member 'UNicolaDataAssetPlayerActor::ShipMoveSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, ShipFadeDistance) == 0x00009C, "Member 'UNicolaDataAssetPlayerActor::ShipFadeDistance' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, ShipFadeCurve) == 0x0000A0, "Member 'UNicolaDataAssetPlayerActor::ShipFadeCurve' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, ShipMemberSpeed) == 0x0000A8, "Member 'UNicolaDataAssetPlayerActor::ShipMemberSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, ShipSearchRadius) == 0x0000AC, "Member 'UNicolaDataAssetPlayerActor::ShipSearchRadius' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraHoverTime) == 0x0000B0, "Member 'UNicolaDataAssetPlayerActor::RuraHoverTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraHoverHeight) == 0x0000B4, "Member 'UNicolaDataAssetPlayerActor::RuraHoverHeight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraFlyTime) == 0x0000B8, "Member 'UNicolaDataAssetPlayerActor::RuraFlyTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraFlySpeed) == 0x0000BC, "Member 'UNicolaDataAssetPlayerActor::RuraFlySpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraFallTime) == 0x0000C0, "Member 'UNicolaDataAssetPlayerActor::RuraFallTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraFallSpeed) == 0x0000C4, "Member 'UNicolaDataAssetPlayerActor::RuraFallSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraBrightWaitTime) == 0x0000C8, "Member 'UNicolaDataAssetPlayerActor::RuraBrightWaitTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RuraShipFlyTime) == 0x0000CC, "Member 'UNicolaDataAssetPlayerActor::RuraShipFlyTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RiremitoStartWaitTime) == 0x0000D0, "Member 'UNicolaDataAssetPlayerActor::RiremitoStartWaitTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RiremitoEndWaitTime) == 0x0000D4, "Member 'UNicolaDataAssetPlayerActor::RiremitoEndWaitTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RiremitoPos) == 0x0000D8, "Member 'UNicolaDataAssetPlayerActor::RiremitoPos' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, RiremitoSearch) == 0x0000DC, "Member 'UNicolaDataAssetPlayerActor::RiremitoSearch' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, fieldParty) == 0x0000E0, "Member 'UNicolaDataAssetPlayerActor::fieldParty' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, townParty) == 0x000108, "Member 'UNicolaDataAssetPlayerActor::townParty' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, lamia) == 0x000130, "Member 'UNicolaDataAssetPlayerActor::lamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, Ship) == 0x000158, "Member 'UNicolaDataAssetPlayerActor::Ship' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, king) == 0x000180, "Member 'UNicolaDataAssetPlayerActor::king' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, monster) == 0x0001A8, "Member 'UNicolaDataAssetPlayerActor::monster' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetPlayerActor, vehicleSearchObject) == 0x0001D0, "Member 'UNicolaDataAssetPlayerActor::vehicleSearchObject' has a wrong offset!");

// Class Nicola.BattleCurseGoldenClawsEffectActor
// 0x0008 (0x0238 - 0x0230)
class ABattleCurseGoldenClawsEffectActor final : public AEventEffectManagementActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCurseGoldenClawsEffectActor">();
	}
	static class ABattleCurseGoldenClawsEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCurseGoldenClawsEffectActor>();
	}
};
static_assert(alignof(ABattleCurseGoldenClawsEffectActor) == 0x000008, "Wrong alignment on ABattleCurseGoldenClawsEffectActor");
static_assert(sizeof(ABattleCurseGoldenClawsEffectActor) == 0x000238, "Wrong size on ABattleCurseGoldenClawsEffectActor");

// Class Nicola.UIMap2MenuCtrlTop
// 0x0068 (0x00D8 - 0x0070)
class UUIMap2MenuCtrlTop final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x50];                                      // 0x0070(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMap2MenuWindowItemKeyGuide*          ItemMap;                                           // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowItemKeyGuide*          ItemRura;                                          // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuCtrlTop">();
	}
	static class UUIMap2MenuCtrlTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuCtrlTop>();
	}
};
static_assert(alignof(UUIMap2MenuCtrlTop) == 0x000008, "Wrong alignment on UUIMap2MenuCtrlTop");
static_assert(sizeof(UUIMap2MenuCtrlTop) == 0x0000D8, "Wrong size on UUIMap2MenuCtrlTop");
static_assert(offsetof(UUIMap2MenuCtrlTop, ItemMap) == 0x0000C0, "Member 'UUIMap2MenuCtrlTop::ItemMap' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuCtrlTop, ItemRura) == 0x0000C8, "Member 'UUIMap2MenuCtrlTop::ItemRura' has a wrong offset!");

// Class Nicola.EventManagementActor
// 0x0098 (0x02B8 - 0x0220)
class AEventManagementActor final : public AActor
{
public:
	class FString                                 EventScriptPath;                                   // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGopEventType                                 GopType;                                           // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapName;                                           // 0x0234(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              EventGop;                                          // 0x0240(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              TalkGop;                                           // 0x0268(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              SearchGop;                                         // 0x0290(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManagementActor">();
	}
	static class AEventManagementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventManagementActor>();
	}
};
static_assert(alignof(AEventManagementActor) == 0x000008, "Wrong alignment on AEventManagementActor");
static_assert(sizeof(AEventManagementActor) == 0x0002B8, "Wrong size on AEventManagementActor");
static_assert(offsetof(AEventManagementActor, EventScriptPath) == 0x000220, "Member 'AEventManagementActor::EventScriptPath' has a wrong offset!");
static_assert(offsetof(AEventManagementActor, GopType) == 0x000230, "Member 'AEventManagementActor::GopType' has a wrong offset!");
static_assert(offsetof(AEventManagementActor, MapName) == 0x000234, "Member 'AEventManagementActor::MapName' has a wrong offset!");
static_assert(offsetof(AEventManagementActor, EventGop) == 0x000240, "Member 'AEventManagementActor::EventGop' has a wrong offset!");
static_assert(offsetof(AEventManagementActor, TalkGop) == 0x000268, "Member 'AEventManagementActor::TalkGop' has a wrong offset!");
static_assert(offsetof(AEventManagementActor, SearchGop) == 0x000290, "Member 'AEventManagementActor::SearchGop' has a wrong offset!");

// Class Nicola.MangaIconBase
// 0x0020 (0x0048 - 0x0028)
class UMangaIconBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        OwnerComponent;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangaIconBase">();
	}
	static class UMangaIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMangaIconBase>();
	}
};
static_assert(alignof(UMangaIconBase) == 0x000008, "Wrong alignment on UMangaIconBase");
static_assert(sizeof(UMangaIconBase) == 0x000048, "Wrong size on UMangaIconBase");
static_assert(offsetof(UMangaIconBase, OwnerComponent) == 0x000030, "Member 'UMangaIconBase::OwnerComponent' has a wrong offset!");

// Class Nicola.MangaIconUI
// 0x0018 (0x0060 - 0x0048)
class UMangaIconUI : public UMangaIconBase
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangaIconUI">();
	}
	static class UMangaIconUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMangaIconUI>();
	}
};
static_assert(alignof(UMangaIconUI) == 0x000008, "Wrong alignment on UMangaIconUI");
static_assert(sizeof(UMangaIconUI) == 0x000060, "Wrong size on UMangaIconUI");

// Class Nicola.NicolaDebugFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static void GetMemoryInfoString(class FString* outUsed, class FString* outAvailable);
	static void OnChangeDebugActionFlag(EDebugActionFlags DebugActionFlag);
	static void OnChangeDebugEtcFlag(EDebugEtcFlags DebugEtcFlag);
	static void UpdateDebugParameterCollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDebugFL">();
	}
	static class UNicolaDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDebugFL>();
	}
};
static_assert(alignof(UNicolaDebugFL) == 0x000008, "Wrong alignment on UNicolaDebugFL");
static_assert(sizeof(UNicolaDebugFL) == 0x000028, "Wrong size on UNicolaDebugFL");

// Class Nicola.MangaIconGuideUI
// 0x0000 (0x0060 - 0x0060)
class UMangaIconGuideUI final : public UMangaIconUI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangaIconGuideUI">();
	}
	static class UMangaIconGuideUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMangaIconGuideUI>();
	}
};
static_assert(alignof(UMangaIconGuideUI) == 0x000008, "Wrong alignment on UMangaIconGuideUI");
static_assert(sizeof(UMangaIconGuideUI) == 0x000060, "Wrong size on UMangaIconGuideUI");

// Class Nicola.UIMBRCommonFlowReward
// 0x0048 (0x00B8 - 0x0070)
class UUIMBRCommonFlowReward final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x48];                                      // 0x0070(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonFlowReward">();
	}
	static class UUIMBRCommonFlowReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonFlowReward>();
	}
};
static_assert(alignof(UUIMBRCommonFlowReward) == 0x000008, "Wrong alignment on UUIMBRCommonFlowReward");
static_assert(sizeof(UUIMBRCommonFlowReward) == 0x0000B8, "Wrong size on UUIMBRCommonFlowReward");

// Class Nicola.MangaIconEffect
// 0x0008 (0x0050 - 0x0048)
class UMangaIconEffect final : public UMangaIconBase
{
public:
	class UFXSystemComponent*                     EffectMangaIconComp;                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangaIconEffect">();
	}
	static class UMangaIconEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMangaIconEffect>();
	}
};
static_assert(alignof(UMangaIconEffect) == 0x000008, "Wrong alignment on UMangaIconEffect");
static_assert(sizeof(UMangaIconEffect) == 0x000050, "Wrong size on UMangaIconEffect");
static_assert(offsetof(UMangaIconEffect, EffectMangaIconComp) == 0x000048, "Member 'UMangaIconEffect::EffectMangaIconComp' has a wrong offset!");

// Class Nicola.EventMangaIconComponent
// 0x0048 (0x00F8 - 0x00B0)
class UEventMangaIconComponent final : public UActorComponent
{
public:
	bool                                          bIsOverrideOffset;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideIconOffset;                                // 0x00B4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMangaIconBase*>                 IconData;                                          // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MangaIconOffsetWidth;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconOffsetHeight;                             // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetDebugMangaIconOffsetHeight();
	static float GetDebugManpuBaseScale();
	static bool GetDebugMenuManpuId(class FName* OutId);
	static bool IsEnableDebugIconBaseScale();
	static bool IsEnableDebugMangaIconOffset();
	static void SetDebugMangaIconOffsetHeight(float Offset);
	static void SetDebugManpuBaseScale(float Scale);
	static void SetDebugMenuManpuId(const class FName& ID);
	static void SetEnableDebugIconBaseScale(bool flag);
	static void SetEnableDebugMangaIconOffset(bool IsEnabled);

	void BP_CloseMangaIcon();
	void BP_ForceAllCloseMangaIcon();
	void BP_ShowMangaIcon(const class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventMangaIconComponent">();
	}
	static class UEventMangaIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventMangaIconComponent>();
	}
};
static_assert(alignof(UEventMangaIconComponent) == 0x000008, "Wrong alignment on UEventMangaIconComponent");
static_assert(sizeof(UEventMangaIconComponent) == 0x0000F8, "Wrong size on UEventMangaIconComponent");
static_assert(offsetof(UEventMangaIconComponent, bIsOverrideOffset) == 0x0000B0, "Member 'UEventMangaIconComponent::bIsOverrideOffset' has a wrong offset!");
static_assert(offsetof(UEventMangaIconComponent, OverrideIconOffset) == 0x0000B4, "Member 'UEventMangaIconComponent::OverrideIconOffset' has a wrong offset!");
static_assert(offsetof(UEventMangaIconComponent, IconData) == 0x0000C0, "Member 'UEventMangaIconComponent::IconData' has a wrong offset!");
static_assert(offsetof(UEventMangaIconComponent, MangaIconOffsetWidth) == 0x0000D8, "Member 'UEventMangaIconComponent::MangaIconOffsetWidth' has a wrong offset!");
static_assert(offsetof(UEventMangaIconComponent, MangaIconOffsetHeight) == 0x0000DC, "Member 'UEventMangaIconComponent::MangaIconOffsetHeight' has a wrong offset!");

// Class Nicola.ProduceSequencerME
// 0x0020 (0x0240 - 0x0220)
class AProduceSequencerME final : public AProduceSequencerBase
{
public:
	EBgmPlayerManagerMEPlayRequestType            MEPlayRequestType;                                 // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentBgmFadeOutSec;                              // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBgmPlayerManagerLineTypeOnMEEnd              MEEndType;                                         // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextBgmFadeInSec;                                  // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NextGopIDSoundBgm;                                 // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayME(class FName MEGopId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerME">();
	}
	static class AProduceSequencerME* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerME>();
	}
};
static_assert(alignof(AProduceSequencerME) == 0x000008, "Wrong alignment on AProduceSequencerME");
static_assert(sizeof(AProduceSequencerME) == 0x000240, "Wrong size on AProduceSequencerME");
static_assert(offsetof(AProduceSequencerME, MEPlayRequestType) == 0x000220, "Member 'AProduceSequencerME::MEPlayRequestType' has a wrong offset!");
static_assert(offsetof(AProduceSequencerME, CurrentBgmFadeOutSec) == 0x000224, "Member 'AProduceSequencerME::CurrentBgmFadeOutSec' has a wrong offset!");
static_assert(offsetof(AProduceSequencerME, MEEndType) == 0x000228, "Member 'AProduceSequencerME::MEEndType' has a wrong offset!");
static_assert(offsetof(AProduceSequencerME, NextBgmFadeInSec) == 0x00022C, "Member 'AProduceSequencerME::NextBgmFadeInSec' has a wrong offset!");
static_assert(offsetof(AProduceSequencerME, NextGopIDSoundBgm) == 0x000230, "Member 'AProduceSequencerME::NextGopIDSoundBgm' has a wrong offset!");

// Class Nicola.NicolaDataAssetMaterial
// 0x0050 (0x0080 - 0x0030)
class UNicolaDataAssetMaterial final : public UNicolaDataAssetBase
{
public:
	TMap<ECharacterMaterialType, TSoftObjectPtr<class UMaterialInstance>> characterMaterials;                                // 0x0030(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetMaterial">();
	}
	static class UNicolaDataAssetMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetMaterial>();
	}
};
static_assert(alignof(UNicolaDataAssetMaterial) == 0x000008, "Wrong alignment on UNicolaDataAssetMaterial");
static_assert(sizeof(UNicolaDataAssetMaterial) == 0x000080, "Wrong size on UNicolaDataAssetMaterial");
static_assert(offsetof(UNicolaDataAssetMaterial, characterMaterials) == 0x000030, "Member 'UNicolaDataAssetMaterial::characterMaterials' has a wrong offset!");

// Class Nicola.EventProgressFL
// 0x0000 (0x0028 - 0x0028)
class UEventProgressFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventProgressFL">();
	}
	static class UEventProgressFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventProgressFL>();
	}
};
static_assert(alignof(UEventProgressFL) == 0x000008, "Wrong alignment on UEventProgressFL");
static_assert(sizeof(UEventProgressFL) == 0x000028, "Wrong size on UEventProgressFL");

// Class Nicola.NicolaGameModeBase
// 0x0000 (0x02C0 - 0x02C0)
class ANicolaGameModeBase : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameModeBase">();
	}
	static class ANicolaGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaGameModeBase>();
	}
};
static_assert(alignof(ANicolaGameModeBase) == 0x000008, "Wrong alignment on ANicolaGameModeBase");
static_assert(sizeof(ANicolaGameModeBase) == 0x0002C0, "Wrong size on ANicolaGameModeBase");

// Class Nicola.EventTestWidget
// 0x0020 (0x0348 - 0x0328)
class UEventTestWidget final : public UCommonBaseWidget
{
public:
	class UTextBlock*                             TextWidget;                                        // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTestWidget">();
	}
	static class UEventTestWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventTestWidget>();
	}
};
static_assert(alignof(UEventTestWidget) == 0x000008, "Wrong alignment on UEventTestWidget");
static_assert(sizeof(UEventTestWidget) == 0x000348, "Wrong size on UEventTestWidget");
static_assert(offsetof(UEventTestWidget, TextWidget) == 0x000328, "Member 'UEventTestWidget::TextWidget' has a wrong offset!");

// Class Nicola.UIMap2MenuWindowWorldMap
// 0x0300 (0x0358 - 0x0058)
class UUIMap2MenuWindowWorldMap final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           CanvasIcon;                                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImagePlayer;                                       // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageTownIcons;                                    // 0x0090(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageDungeonIcons;                                 // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageOtherIcons;                                   // 0x00B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageTargetIcons;                                  // 0x00C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageVehicleShip;                                  // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageVehicleLamia;                                 // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageVehicleGhostShip;                             // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageEchoFluteIcons;                               // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageGuideMainIcons;                               // 0x00F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageGuideSubIcons;                                // 0x0108(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageCrossMarkIcons;                               // 0x0118(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasIconTown;                                    // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasIconDungeon;                                 // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasIconOther;                                   // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasIconCrossMark;                               // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageCursor;                                       // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap;                                          // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap2;                                         // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap3;                                         // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasMap;                                         // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemTownMapArrow*                ItemArrow;                                         // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageTimeFrame;                                    // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMiniMapMenuWindowDrawMap*            WindowDetails;                                     // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemPlayerEffect;                                  // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x20];                                     // 0x0190(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMiniMapDrawIconData                   drawIconDataPlayer;                                // 0x01B0(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataLocation;                              // 0x01F8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataTarget;                                // 0x0208(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconDataShip;                                  // 0x0218(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconDataLamia;                                 // 0x0260(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconDataGhostShip;                             // 0x02A8(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataEchoFlute;                             // 0x02F0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataGuideMain;                             // 0x0300(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataGuideSub;                              // 0x0310(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataCrossMark;                             // 0x0320(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x28];                                     // 0x0330(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowWorldMap">();
	}
	static class UUIMap2MenuWindowWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowWorldMap>();
	}
};
static_assert(alignof(UUIMap2MenuWindowWorldMap) == 0x000008, "Wrong alignment on UUIMap2MenuWindowWorldMap");
static_assert(sizeof(UUIMap2MenuWindowWorldMap) == 0x000358, "Wrong size on UUIMap2MenuWindowWorldMap");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, CanvasIcon) == 0x000080, "Member 'UUIMap2MenuWindowWorldMap::CanvasIcon' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImagePlayer) == 0x000088, "Member 'UUIMap2MenuWindowWorldMap::ImagePlayer' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageTownIcons) == 0x000090, "Member 'UUIMap2MenuWindowWorldMap::ImageTownIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageDungeonIcons) == 0x0000A0, "Member 'UUIMap2MenuWindowWorldMap::ImageDungeonIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageOtherIcons) == 0x0000B0, "Member 'UUIMap2MenuWindowWorldMap::ImageOtherIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageTargetIcons) == 0x0000C0, "Member 'UUIMap2MenuWindowWorldMap::ImageTargetIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageVehicleShip) == 0x0000D0, "Member 'UUIMap2MenuWindowWorldMap::ImageVehicleShip' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageVehicleLamia) == 0x0000D8, "Member 'UUIMap2MenuWindowWorldMap::ImageVehicleLamia' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageVehicleGhostShip) == 0x0000E0, "Member 'UUIMap2MenuWindowWorldMap::ImageVehicleGhostShip' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageEchoFluteIcons) == 0x0000E8, "Member 'UUIMap2MenuWindowWorldMap::ImageEchoFluteIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageGuideMainIcons) == 0x0000F8, "Member 'UUIMap2MenuWindowWorldMap::ImageGuideMainIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageGuideSubIcons) == 0x000108, "Member 'UUIMap2MenuWindowWorldMap::ImageGuideSubIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageCrossMarkIcons) == 0x000118, "Member 'UUIMap2MenuWindowWorldMap::ImageCrossMarkIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, CanvasIconTown) == 0x000128, "Member 'UUIMap2MenuWindowWorldMap::CanvasIconTown' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, CanvasIconDungeon) == 0x000130, "Member 'UUIMap2MenuWindowWorldMap::CanvasIconDungeon' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, CanvasIconOther) == 0x000138, "Member 'UUIMap2MenuWindowWorldMap::CanvasIconOther' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, CanvasIconCrossMark) == 0x000140, "Member 'UUIMap2MenuWindowWorldMap::CanvasIconCrossMark' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageCursor) == 0x000148, "Member 'UUIMap2MenuWindowWorldMap::ImageCursor' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageMap) == 0x000150, "Member 'UUIMap2MenuWindowWorldMap::ImageMap' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageMap2) == 0x000158, "Member 'UUIMap2MenuWindowWorldMap::ImageMap2' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageMap3) == 0x000160, "Member 'UUIMap2MenuWindowWorldMap::ImageMap3' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, CanvasMap) == 0x000168, "Member 'UUIMap2MenuWindowWorldMap::CanvasMap' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ItemArrow) == 0x000170, "Member 'UUIMap2MenuWindowWorldMap::ItemArrow' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ImageTimeFrame) == 0x000178, "Member 'UUIMap2MenuWindowWorldMap::ImageTimeFrame' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, WindowDetails) == 0x000180, "Member 'UUIMap2MenuWindowWorldMap::WindowDetails' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, ItemPlayerEffect) == 0x000188, "Member 'UUIMap2MenuWindowWorldMap::ItemPlayerEffect' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataPlayer) == 0x0001B0, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataPlayer' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataLocation) == 0x0001F8, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataLocation' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataTarget) == 0x000208, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataTarget' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataShip) == 0x000218, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataShip' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataLamia) == 0x000260, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataLamia' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataGhostShip) == 0x0002A8, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataGhostShip' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataEchoFlute) == 0x0002F0, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataEchoFlute' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataGuideMain) == 0x000300, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataGuideMain' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataGuideSub) == 0x000310, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataGuideSub' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowWorldMap, drawIconDataCrossMark) == 0x000320, "Member 'UUIMap2MenuWindowWorldMap::drawIconDataCrossMark' has a wrong offset!");

// Class Nicola.FadeSubsystemData
// 0x0008 (0x0030 - 0x0028)
class UFadeSubsystemData : public UObject
{
public:
	TSubclassOf<class UCommonBaseWidget>          FadingWidgetClass;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeSubsystemData">();
	}
	static class UFadeSubsystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeSubsystemData>();
	}
};
static_assert(alignof(UFadeSubsystemData) == 0x000008, "Wrong alignment on UFadeSubsystemData");
static_assert(sizeof(UFadeSubsystemData) == 0x000030, "Wrong size on UFadeSubsystemData");
static_assert(offsetof(UFadeSubsystemData, FadingWidgetClass) == 0x000028, "Member 'UFadeSubsystemData::FadingWidgetClass' has a wrong offset!");

// Class Nicola.FadeSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UFadeSubsystem final : public UGameInstanceSubsystem
{
public:
	TSubclassOf<class UFadeSubsystemData>         FadeSubsystemDataClass;                            // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFadeSubsystemData*                     FadeSubsystemData;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFadingWidget*>                  FadingWidget;                                      // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeIn(EFadingPriority EFadingPriority, float Timer, bool InForce);
	void FadeOut(EFadingPriority EFadingPriority, float Timer);
	void Fading(bool bFadeIn, float Timer, EAfterFadeOut InAfterFadeOut, const struct FLinearColor& FadeColor, bool InForce);
	bool IsFadeInEnd(EFadingPriority EFadingPriority);
	bool IsFadeOutEnd(EFadingPriority EFadingPriority);
	bool IsInFading(EFadingPriority EFadingPriority);
	void NowloadEnd(float Timer);
	void NowloadStart(float Timer, bool tips);
	struct FLinearColor SetFadeColor(EFadingPriority EFadingPriority, const struct FLinearColor& FadeColor);

	struct FLinearColor GetFadeColor(EFadingPriority EFadingPriority) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeSubsystem">();
	}
	static class UFadeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeSubsystem>();
	}
};
static_assert(alignof(UFadeSubsystem) == 0x000008, "Wrong alignment on UFadeSubsystem");
static_assert(sizeof(UFadeSubsystem) == 0x0000A0, "Wrong size on UFadeSubsystem");
static_assert(offsetof(UFadeSubsystem, FadeSubsystemDataClass) == 0x000030, "Member 'UFadeSubsystem::FadeSubsystemDataClass' has a wrong offset!");
static_assert(offsetof(UFadeSubsystem, FadeSubsystemData) == 0x000038, "Member 'UFadeSubsystem::FadeSubsystemData' has a wrong offset!");
static_assert(offsetof(UFadeSubsystem, FadingWidget) == 0x000040, "Member 'UFadeSubsystem::FadingWidget' has a wrong offset!");

// Class Nicola.FadingWidget
// 0x0030 (0x0358 - 0x0328)
class UFadingWidget : public UCommonBaseWidget
{
public:
	class UImage*                                 BGImage;                                           // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x28];                                     // 0x0330(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadingWidget">();
	}
	static class UFadingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadingWidget>();
	}
};
static_assert(alignof(UFadingWidget) == 0x000008, "Wrong alignment on UFadingWidget");
static_assert(sizeof(UFadingWidget) == 0x000358, "Wrong size on UFadingWidget");
static_assert(offsetof(UFadingWidget, BGImage) == 0x000328, "Member 'UFadingWidget::BGImage' has a wrong offset!");

// Class Nicola.NicolaTownDungeonLevel
// 0x0000 (0x0260 - 0x0260)
class ANicolaTownDungeonLevel : public ANicolaLevelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaTownDungeonLevel">();
	}
	static class ANicolaTownDungeonLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaTownDungeonLevel>();
	}
};
static_assert(alignof(ANicolaTownDungeonLevel) == 0x000008, "Wrong alignment on ANicolaTownDungeonLevel");
static_assert(sizeof(ANicolaTownDungeonLevel) == 0x000260, "Wrong size on ANicolaTownDungeonLevel");

// Class Nicola.FallVolume
// 0x0150 (0x03A8 - 0x0258)
class AFallVolume final : public APlayerTriggerVolume
{
public:
	class FString                                 MapId;                                             // 0x0258(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 playerStartId;                                     // 0x0268(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FadeTime;                                          // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoSave;                                         // 0x027C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          NotPlayBGM;                                        // 0x027D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          NotPlaySE;                                         // 0x027E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27F[0x1];                                      // 0x027F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 fallSeId;                                          // 0x0280(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     curveX;                                            // 0x0290(0x0088)(Edit, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     curveZ;                                            // 0x0318(0x0088)(Edit, NativeAccessSpecifierPrivate)
	float                                         maxX;                                              // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallVolume">();
	}
	static class AFallVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFallVolume>();
	}
};
static_assert(alignof(AFallVolume) == 0x000008, "Wrong alignment on AFallVolume");
static_assert(sizeof(AFallVolume) == 0x0003A8, "Wrong size on AFallVolume");
static_assert(offsetof(AFallVolume, MapId) == 0x000258, "Member 'AFallVolume::MapId' has a wrong offset!");
static_assert(offsetof(AFallVolume, playerStartId) == 0x000268, "Member 'AFallVolume::playerStartId' has a wrong offset!");
static_assert(offsetof(AFallVolume, FadeTime) == 0x000278, "Member 'AFallVolume::FadeTime' has a wrong offset!");
static_assert(offsetof(AFallVolume, bAutoSave) == 0x00027C, "Member 'AFallVolume::bAutoSave' has a wrong offset!");
static_assert(offsetof(AFallVolume, NotPlayBGM) == 0x00027D, "Member 'AFallVolume::NotPlayBGM' has a wrong offset!");
static_assert(offsetof(AFallVolume, NotPlaySE) == 0x00027E, "Member 'AFallVolume::NotPlaySE' has a wrong offset!");
static_assert(offsetof(AFallVolume, fallSeId) == 0x000280, "Member 'AFallVolume::fallSeId' has a wrong offset!");
static_assert(offsetof(AFallVolume, curveX) == 0x000290, "Member 'AFallVolume::curveX' has a wrong offset!");
static_assert(offsetof(AFallVolume, curveZ) == 0x000318, "Member 'AFallVolume::curveZ' has a wrong offset!");
static_assert(offsetof(AFallVolume, maxX) == 0x0003A0, "Member 'AFallVolume::maxX' has a wrong offset!");

// Class Nicola.UIMBRCommonWindowStatusItem
// 0x0010 (0x0050 - 0x0040)
class UUIMBRCommonWindowStatusItem final : public UUIWindowItem
{
public:
	TArray<class UUIWindowItemText2*>             StatusItems;                                       // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonWindowStatusItem">();
	}
	static class UUIMBRCommonWindowStatusItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonWindowStatusItem>();
	}
};
static_assert(alignof(UUIMBRCommonWindowStatusItem) == 0x000008, "Wrong alignment on UUIMBRCommonWindowStatusItem");
static_assert(sizeof(UUIMBRCommonWindowStatusItem) == 0x000050, "Wrong size on UUIMBRCommonWindowStatusItem");
static_assert(offsetof(UUIMBRCommonWindowStatusItem, StatusItems) == 0x000040, "Member 'UUIMBRCommonWindowStatusItem::StatusItems' has a wrong offset!");

// Class Nicola.FieldGridRoot
// 0x0000 (0x0220 - 0x0220)
class AFieldGridRoot final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldGridRoot">();
	}
	static class AFieldGridRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldGridRoot>();
	}
};
static_assert(alignof(AFieldGridRoot) == 0x000008, "Wrong alignment on AFieldGridRoot");
static_assert(sizeof(AFieldGridRoot) == 0x000220, "Wrong size on AFieldGridRoot");

// Class Nicola.FieldMapParameterCollection
// 0x0000 (0x0088 - 0x0088)
class UFieldMapParameterCollection final : public UNicolaParameterCollectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldMapParameterCollection">();
	}
	static class UFieldMapParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldMapParameterCollection>();
	}
};
static_assert(alignof(UFieldMapParameterCollection) == 0x000008, "Wrong alignment on UFieldMapParameterCollection");
static_assert(sizeof(UFieldMapParameterCollection) == 0x000088, "Wrong size on UFieldMapParameterCollection");

// Class Nicola.ResearchCommandInterface
// 0x0000 (0x0028 - 0x0028)
class IResearchCommandInterface final : public IInterface
{
public:
	void OnCallCommand();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResearchCommandInterface">();
	}
	static class IResearchCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IResearchCommandInterface>();
	}
};
static_assert(alignof(IResearchCommandInterface) == 0x000008, "Wrong alignment on IResearchCommandInterface");
static_assert(sizeof(IResearchCommandInterface) == 0x000028, "Wrong size on IResearchCommandInterface");

// Class Nicola.FieldMarkerActor
// 0x0030 (0x0250 - 0x0220)
class AFieldMarkerActor final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DecalComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       staticMeshMIDArray;                                // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               decalMID;                                          // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldMarkerActor">();
	}
	static class AFieldMarkerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldMarkerActor>();
	}
};
static_assert(alignof(AFieldMarkerActor) == 0x000008, "Wrong alignment on AFieldMarkerActor");
static_assert(sizeof(AFieldMarkerActor) == 0x000250, "Wrong size on AFieldMarkerActor");
static_assert(offsetof(AFieldMarkerActor, StaticMeshComponent) == 0x000228, "Member 'AFieldMarkerActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AFieldMarkerActor, DecalComponent) == 0x000230, "Member 'AFieldMarkerActor::DecalComponent' has a wrong offset!");
static_assert(offsetof(AFieldMarkerActor, staticMeshMIDArray) == 0x000238, "Member 'AFieldMarkerActor::staticMeshMIDArray' has a wrong offset!");
static_assert(offsetof(AFieldMarkerActor, decalMID) == 0x000248, "Member 'AFieldMarkerActor::decalMID' has a wrong offset!");

// Class Nicola.RockGimmick
// 0x00A0 (0x02C8 - 0x0228)
class ARockGimmick : public APlayerControllableGimmick
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          MoveCollision;                                     // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          OverlapCollision;                                  // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorListComponent*                    ActorList;                                         // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HoldOnTime;                                        // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovableFloorAngle;                                 // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Puzzle;                                            // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntervalTime;                                      // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x38];                                     // 0x0268(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FallWaterEffectId;                                 // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsApplyEffectHeightOffset;                        // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FallWaterEventSEId;                                // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARockPuzzleGimmickActor*                PuzzleGimmickActor;                                // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockGimmick">();
	}
	static class ARockGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockGimmick>();
	}
};
static_assert(alignof(ARockGimmick) == 0x000008, "Wrong alignment on ARockGimmick");
static_assert(sizeof(ARockGimmick) == 0x0002C8, "Wrong size on ARockGimmick");
static_assert(offsetof(ARockGimmick, MoveCollision) == 0x000238, "Member 'ARockGimmick::MoveCollision' has a wrong offset!");
static_assert(offsetof(ARockGimmick, OverlapCollision) == 0x000240, "Member 'ARockGimmick::OverlapCollision' has a wrong offset!");
static_assert(offsetof(ARockGimmick, StaticMeshComponent) == 0x000248, "Member 'ARockGimmick::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ARockGimmick, ActorList) == 0x000250, "Member 'ARockGimmick::ActorList' has a wrong offset!");
static_assert(offsetof(ARockGimmick, HoldOnTime) == 0x000258, "Member 'ARockGimmick::HoldOnTime' has a wrong offset!");
static_assert(offsetof(ARockGimmick, MovableFloorAngle) == 0x00025C, "Member 'ARockGimmick::MovableFloorAngle' has a wrong offset!");
static_assert(offsetof(ARockGimmick, Puzzle) == 0x000260, "Member 'ARockGimmick::Puzzle' has a wrong offset!");
static_assert(offsetof(ARockGimmick, IntervalTime) == 0x000264, "Member 'ARockGimmick::IntervalTime' has a wrong offset!");
static_assert(offsetof(ARockGimmick, FallWaterEffectId) == 0x0002A0, "Member 'ARockGimmick::FallWaterEffectId' has a wrong offset!");
static_assert(offsetof(ARockGimmick, bIsApplyEffectHeightOffset) == 0x0002A8, "Member 'ARockGimmick::bIsApplyEffectHeightOffset' has a wrong offset!");
static_assert(offsetof(ARockGimmick, FallWaterEventSEId) == 0x0002AC, "Member 'ARockGimmick::FallWaterEventSEId' has a wrong offset!");
static_assert(offsetof(ARockGimmick, PuzzleGimmickActor) == 0x0002B8, "Member 'ARockGimmick::PuzzleGimmickActor' has a wrong offset!");

// Class Nicola.NicolaPlayerCameraManagerBase
// 0x0000 (0x2820 - 0x2820)
#pragma pack(push, 0x1)
class alignas(0x10) ANicolaPlayerCameraManagerBase : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlayerCameraManagerBase">();
	}
	static class ANicolaPlayerCameraManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaPlayerCameraManagerBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANicolaPlayerCameraManagerBase) == 0x000010, "Wrong alignment on ANicolaPlayerCameraManagerBase");
static_assert(sizeof(ANicolaPlayerCameraManagerBase) == 0x002820, "Wrong size on ANicolaPlayerCameraManagerBase");

// Class Nicola.NicolaPlayerCameraManager
// 0x00E0 (0x2900 - 0x2820)
class ANicolaPlayerCameraManager : public ANicolaPlayerCameraManagerBase
{
public:
	TArray<TScriptInterface<class INicolaCameraModeReceiverInterface>> ModeReceivers;                                     // 0x2818(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   CameraActorClass;                                  // 0x2828(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BattleCameraActorClass;                            // 0x2850(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   StageCameraActorClass;                             // 0x2878(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANicolaCameraActor*                     actorTraceCamera;                                  // 0x28A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaCameraActor*                     actorTraceCameraSub;                               // 0x28A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaCameraActor*                     actorBattleCamera;                                 // 0x28B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28B8[0x18];                                    // 0x28B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANicolaStageCameraActor*>        stageCameras;                                      // 0x28D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E0[0x8];                                     // 0x28E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AResearchSequenceCamera*                eventSequenceCamera;                               // 0x28E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28F0[0x8];                                     // 0x28F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatineeCameraShake*                    LuaCameraShake;                                    // 0x28F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DebugMenuResetCamera();
	void PlayEventSequence(int32 Index_0, bool isInvisibleNpc, bool isJumpToEnd);

	class ANicolaCameraActor* GetBattleCamera() const;
	class ANicolaCameraActor* GetCurrentTraceCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlayerCameraManager">();
	}
	static class ANicolaPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaPlayerCameraManager>();
	}
};
static_assert(alignof(ANicolaPlayerCameraManager) == 0x000010, "Wrong alignment on ANicolaPlayerCameraManager");
static_assert(sizeof(ANicolaPlayerCameraManager) == 0x002900, "Wrong size on ANicolaPlayerCameraManager");
static_assert(offsetof(ANicolaPlayerCameraManager, ModeReceivers) == 0x002818, "Member 'ANicolaPlayerCameraManager::ModeReceivers' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, CameraActorClass) == 0x002828, "Member 'ANicolaPlayerCameraManager::CameraActorClass' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, BattleCameraActorClass) == 0x002850, "Member 'ANicolaPlayerCameraManager::BattleCameraActorClass' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, StageCameraActorClass) == 0x002878, "Member 'ANicolaPlayerCameraManager::StageCameraActorClass' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, actorTraceCamera) == 0x0028A0, "Member 'ANicolaPlayerCameraManager::actorTraceCamera' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, actorTraceCameraSub) == 0x0028A8, "Member 'ANicolaPlayerCameraManager::actorTraceCameraSub' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, actorBattleCamera) == 0x0028B0, "Member 'ANicolaPlayerCameraManager::actorBattleCamera' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, stageCameras) == 0x0028D0, "Member 'ANicolaPlayerCameraManager::stageCameras' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, eventSequenceCamera) == 0x0028E8, "Member 'ANicolaPlayerCameraManager::eventSequenceCamera' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerCameraManager, LuaCameraShake) == 0x0028F8, "Member 'ANicolaPlayerCameraManager::LuaCameraShake' has a wrong offset!");

// Class Nicola.FieldPlayerActor
// 0x0000 (0x0630 - 0x0630)
class AFieldPlayerActor : public ABreadcrumbman
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldPlayerActor">();
	}
	static class AFieldPlayerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldPlayerActor>();
	}
};
static_assert(alignof(AFieldPlayerActor) == 0x000010, "Wrong alignment on AFieldPlayerActor");
static_assert(sizeof(AFieldPlayerActor) == 0x000630, "Wrong size on AFieldPlayerActor");

// Class Nicola.ProduceSequencerItemGetIcon
// 0x0008 (0x0228 - 0x0220)
class AProduceSequencerItemGetIcon final : public AProduceSequencerBase
{
public:
	bool                                          bEnableRenderPrePass;                              // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayItemGetIcon(const class FName ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerItemGetIcon">();
	}
	static class AProduceSequencerItemGetIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerItemGetIcon>();
	}
};
static_assert(alignof(AProduceSequencerItemGetIcon) == 0x000008, "Wrong alignment on AProduceSequencerItemGetIcon");
static_assert(sizeof(AProduceSequencerItemGetIcon) == 0x000228, "Wrong size on AProduceSequencerItemGetIcon");
static_assert(offsetof(AProduceSequencerItemGetIcon, bEnableRenderPrePass) == 0x000220, "Member 'AProduceSequencerItemGetIcon::bEnableRenderPrePass' has a wrong offset!");

// Class Nicola.UIMemberCreateMenuWindowInfo
// 0x0058 (0x00B0 - 0x0058)
class UUIMemberCreateMenuWindowInfo final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UImage*                                 ItemIcon;                                          // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ItemIcon2;                                         // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlipbookWidget*                        ItemFlipbook;                                      // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlipbookWidget*                        ItemFlipbook2;                                     // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuWindowInfo">();
	}
	static class UUIMemberCreateMenuWindowInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuWindowInfo>();
	}
};
static_assert(alignof(UUIMemberCreateMenuWindowInfo) == 0x000008, "Wrong alignment on UUIMemberCreateMenuWindowInfo");
static_assert(sizeof(UUIMemberCreateMenuWindowInfo) == 0x0000B0, "Wrong size on UUIMemberCreateMenuWindowInfo");
static_assert(offsetof(UUIMemberCreateMenuWindowInfo, WindowItems) == 0x000080, "Member 'UUIMemberCreateMenuWindowInfo::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuWindowInfo, ItemIcon) == 0x000090, "Member 'UUIMemberCreateMenuWindowInfo::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuWindowInfo, ItemIcon2) == 0x000098, "Member 'UUIMemberCreateMenuWindowInfo::ItemIcon2' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuWindowInfo, ItemFlipbook) == 0x0000A0, "Member 'UUIMemberCreateMenuWindowInfo::ItemFlipbook' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuWindowInfo, ItemFlipbook2) == 0x0000A8, "Member 'UUIMemberCreateMenuWindowInfo::ItemFlipbook2' has a wrong offset!");

// Class Nicola.FieldStatusEffectWidget
// 0x0038 (0x0060 - 0x0028)
class UFieldStatusEffectWidget final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBattleStatusIconItem*                ItemStatusIcon;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldStatusEffectWidget">();
	}
	static class UFieldStatusEffectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldStatusEffectWidget>();
	}
};
static_assert(alignof(UFieldStatusEffectWidget) == 0x000008, "Wrong alignment on UFieldStatusEffectWidget");
static_assert(sizeof(UFieldStatusEffectWidget) == 0x000060, "Wrong size on UFieldStatusEffectWidget");
static_assert(offsetof(UFieldStatusEffectWidget, ItemStatusIcon) == 0x000030, "Member 'UFieldStatusEffectWidget::ItemStatusIcon' has a wrong offset!");

// Class Nicola.NicolaSequencerPostProcessVolumeBase
// 0x0000 (0x07D0 - 0x07D0)
class ANicolaSequencerPostProcessVolumeBase : public APostProcessVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSequencerPostProcessVolumeBase">();
	}
	static class ANicolaSequencerPostProcessVolumeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaSequencerPostProcessVolumeBase>();
	}
};
static_assert(alignof(ANicolaSequencerPostProcessVolumeBase) == 0x000010, "Wrong alignment on ANicolaSequencerPostProcessVolumeBase");
static_assert(sizeof(ANicolaSequencerPostProcessVolumeBase) == 0x0007D0, "Wrong size on ANicolaSequencerPostProcessVolumeBase");

// Class Nicola.NicolaBattleSequencerPostProcessVolume
// 0x0000 (0x07D0 - 0x07D0)
class ANicolaBattleSequencerPostProcessVolume : public ANicolaSequencerPostProcessVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattleSequencerPostProcessVolume">();
	}
	static class ANicolaBattleSequencerPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaBattleSequencerPostProcessVolume>();
	}
};
static_assert(alignof(ANicolaBattleSequencerPostProcessVolume) == 0x000010, "Wrong alignment on ANicolaBattleSequencerPostProcessVolume");
static_assert(sizeof(ANicolaBattleSequencerPostProcessVolume) == 0x0007D0, "Wrong size on ANicolaBattleSequencerPostProcessVolume");

// Class Nicola.FileUtilFL
// 0x0000 (0x0028 - 0x0028)
class UFileUtilFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FileUtilFL">();
	}
	static class UFileUtilFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFileUtilFL>();
	}
};
static_assert(alignof(UFileUtilFL) == 0x000008, "Wrong alignment on UFileUtilFL");
static_assert(sizeof(UFileUtilFL) == 0x000028, "Wrong size on UFileUtilFL");

// Class Nicola.FixedRangeNpcEventTrigger
// 0x0010 (0x0108 - 0x00F8)
class UFixedRangeNpcEventTrigger final : public UEventTriggerComponentBase
{
public:
	class AActor*                                 NpcActor;                                          // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADoorGimmick*                           AlignmentDoor;                                     // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedRangeNpcEventTrigger">();
	}
	static class UFixedRangeNpcEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedRangeNpcEventTrigger>();
	}
};
static_assert(alignof(UFixedRangeNpcEventTrigger) == 0x000008, "Wrong alignment on UFixedRangeNpcEventTrigger");
static_assert(sizeof(UFixedRangeNpcEventTrigger) == 0x000108, "Wrong size on UFixedRangeNpcEventTrigger");
static_assert(offsetof(UFixedRangeNpcEventTrigger, NpcActor) == 0x0000F8, "Member 'UFixedRangeNpcEventTrigger::NpcActor' has a wrong offset!");
static_assert(offsetof(UFixedRangeNpcEventTrigger, AlignmentDoor) == 0x000100, "Member 'UFixedRangeNpcEventTrigger::AlignmentDoor' has a wrong offset!");

// Class Nicola.NicolaPlayerControllerBase
// 0x0020 (0x05A0 - 0x0580)
class ANicolaPlayerControllerBase : public APlayerController
{
public:
	class UNicolaPlayerInput*                     gamePlayerInput;                                   // 0x0580(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNicolaActionInputMan*                  actionInputMan;                                    // 0x0588(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x10];                                     // 0x0590(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearActionInput();
	void ResetActionInput();
	void SetActionInputMode(ENicolaInputMode inputMode, bool flag);

	ENicolaInputMode GetActionInputMode() const;
	const struct FVector2D GetAnalogStickL(ENicolaInputMode inputMode) const;
	const struct FVector2D GetAnalogStickR(ENicolaInputMode inputMode) const;
	bool IsActionInputModeGamePlayWithoutNoInput() const;
	bool IsActionOn(ENicolaInputMode inputMode, ENicolaAction action) const;
	bool IsActionRelease(ENicolaInputMode inputMode, ENicolaAction action) const;
	bool IsActionTrigger(ENicolaInputMode inputMode, ENicolaAction action) const;
	bool IsActionTriggerRepeat(ENicolaInputMode inputMode, ENicolaAction action) const;
	bool IsButtonOn(ENicolaButton Button) const;
	bool IsButtonRelease(ENicolaButton Button) const;
	bool IsButtonTrigger(ENicolaButton Button) const;
	bool IsButtonTriggerRepeat(ENicolaButton Button) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlayerControllerBase">();
	}
	static class ANicolaPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaPlayerControllerBase>();
	}
};
static_assert(alignof(ANicolaPlayerControllerBase) == 0x000008, "Wrong alignment on ANicolaPlayerControllerBase");
static_assert(sizeof(ANicolaPlayerControllerBase) == 0x0005A0, "Wrong size on ANicolaPlayerControllerBase");
static_assert(offsetof(ANicolaPlayerControllerBase, gamePlayerInput) == 0x000580, "Member 'ANicolaPlayerControllerBase::gamePlayerInput' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerControllerBase, actionInputMan) == 0x000588, "Member 'ANicolaPlayerControllerBase::actionInputMan' has a wrong offset!");

// Class Nicola.NicolaFlipbookNotifyBase
// 0x0000 (0x0030 - 0x0030)
class UNicolaFlipbookNotifyBase : public UPaperFlipbookNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFlipbookNotifyBase">();
	}
	static class UNicolaFlipbookNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaFlipbookNotifyBase>();
	}
};
static_assert(alignof(UNicolaFlipbookNotifyBase) == 0x000008, "Wrong alignment on UNicolaFlipbookNotifyBase");
static_assert(sizeof(UNicolaFlipbookNotifyBase) == 0x000030, "Wrong size on UNicolaFlipbookNotifyBase");

// Class Nicola.UIMBREntryMenuListRank
// 0x0010 (0x00E0 - 0x00D0)
class UUIMBREntryMenuListRank final : public UUIListPage
{
public:
	class UUIWindowItemMoney*                     ItemMoney;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuListRank">();
	}
	static class UUIMBREntryMenuListRank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuListRank>();
	}
};
static_assert(alignof(UUIMBREntryMenuListRank) == 0x000008, "Wrong alignment on UUIMBREntryMenuListRank");
static_assert(sizeof(UUIMBREntryMenuListRank) == 0x0000E0, "Wrong size on UUIMBREntryMenuListRank");
static_assert(offsetof(UUIMBREntryMenuListRank, ItemMoney) == 0x0000D0, "Member 'UUIMBREntryMenuListRank::ItemMoney' has a wrong offset!");

// Class Nicola.FlipbookNotifyCircleShadowScaling
// 0x0010 (0x0040 - 0x0030)
class UFlipbookNotifyCircleShadowScaling final : public UNicolaFlipbookNotifyBase
{
public:
	struct FVector                                Scaling;                                           // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyCircleShadowScaling">();
	}
	static class UFlipbookNotifyCircleShadowScaling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyCircleShadowScaling>();
	}
};
static_assert(alignof(UFlipbookNotifyCircleShadowScaling) == 0x000008, "Wrong alignment on UFlipbookNotifyCircleShadowScaling");
static_assert(sizeof(UFlipbookNotifyCircleShadowScaling) == 0x000040, "Wrong size on UFlipbookNotifyCircleShadowScaling");
static_assert(offsetof(UFlipbookNotifyCircleShadowScaling, Scaling) == 0x000030, "Member 'UFlipbookNotifyCircleShadowScaling::Scaling' has a wrong offset!");

// Class Nicola.FlipbookNotifyPauseAndResume
// 0x0008 (0x0038 - 0x0030)
class UFlipbookNotifyPauseAndResume final : public UNicolaFlipbookNotifyBase
{
public:
	float                                         resumeTimer;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         pauseFrame;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyPauseAndResume">();
	}
	static class UFlipbookNotifyPauseAndResume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyPauseAndResume>();
	}
};
static_assert(alignof(UFlipbookNotifyPauseAndResume) == 0x000008, "Wrong alignment on UFlipbookNotifyPauseAndResume");
static_assert(sizeof(UFlipbookNotifyPauseAndResume) == 0x000038, "Wrong size on UFlipbookNotifyPauseAndResume");
static_assert(offsetof(UFlipbookNotifyPauseAndResume, resumeTimer) == 0x000030, "Member 'UFlipbookNotifyPauseAndResume::resumeTimer' has a wrong offset!");
static_assert(offsetof(UFlipbookNotifyPauseAndResume, pauseFrame) == 0x000034, "Member 'UFlipbookNotifyPauseAndResume::pauseFrame' has a wrong offset!");

// Class Nicola.RichTextBlockRubyDecorator
// 0x0040 (0x0068 - 0x0028)
class URichTextBlockRubyDecorator final : public URichTextBlockDecorator
{
public:
	class FString                                 ParseTagName;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AttributeLabelName;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AttributeStyleName;                                // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RubyTextStyleNameFormat;                           // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RubyOffset;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockRubyDecorator">();
	}
	static class URichTextBlockRubyDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockRubyDecorator>();
	}
};
static_assert(alignof(URichTextBlockRubyDecorator) == 0x000008, "Wrong alignment on URichTextBlockRubyDecorator");
static_assert(sizeof(URichTextBlockRubyDecorator) == 0x000068, "Wrong size on URichTextBlockRubyDecorator");
static_assert(offsetof(URichTextBlockRubyDecorator, ParseTagName) == 0x000028, "Member 'URichTextBlockRubyDecorator::ParseTagName' has a wrong offset!");
static_assert(offsetof(URichTextBlockRubyDecorator, AttributeLabelName) == 0x000038, "Member 'URichTextBlockRubyDecorator::AttributeLabelName' has a wrong offset!");
static_assert(offsetof(URichTextBlockRubyDecorator, AttributeStyleName) == 0x000048, "Member 'URichTextBlockRubyDecorator::AttributeStyleName' has a wrong offset!");
static_assert(offsetof(URichTextBlockRubyDecorator, RubyTextStyleNameFormat) == 0x000058, "Member 'URichTextBlockRubyDecorator::RubyTextStyleNameFormat' has a wrong offset!");
static_assert(offsetof(URichTextBlockRubyDecorator, RubyOffset) == 0x000060, "Member 'URichTextBlockRubyDecorator::RubyOffset' has a wrong offset!");

// Class Nicola.FlipbookNotifyPlayDeathEffect
// 0x0000 (0x0030 - 0x0030)
class UFlipbookNotifyPlayDeathEffect final : public UNicolaFlipbookNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyPlayDeathEffect">();
	}
	static class UFlipbookNotifyPlayDeathEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyPlayDeathEffect>();
	}
};
static_assert(alignof(UFlipbookNotifyPlayDeathEffect) == 0x000008, "Wrong alignment on UFlipbookNotifyPlayDeathEffect");
static_assert(sizeof(UFlipbookNotifyPlayDeathEffect) == 0x000030, "Wrong size on UFlipbookNotifyPlayDeathEffect");

// Class Nicola.SearchEventGimmick
// 0x0038 (0x0278 - 0x0240)
class ASearchEventGimmick : public AEventActorBase
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESearchOpenedCheckType                        OpenedCheckType;                                   // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x1];                                      // 0x0249(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ELuaFlag                                      OpenedTargetFlag;                                  // 0x024A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         OpenedBehaviour;                                   // 0x024C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorListComponent*                    ActorListComp;                                     // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USearchObjEventTrigger*                 EventTrigger;                                      // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEventMangaIconComponent*               MangaIconComp;                                     // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEffectTimeManageComponent*             EffectTimeManageComp;                              // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ItemGetStartLocationComponent;                     // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEndEffectSearchObject();
	void OnPostChangeLevelBlueprint();
	void OpenedBehaviourBlueprint();
	void PlayEffectSearchObjectBP(class FName PlayEffectName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchEventGimmick">();
	}
	static class ASearchEventGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchEventGimmick>();
	}
};
static_assert(alignof(ASearchEventGimmick) == 0x000008, "Wrong alignment on ASearchEventGimmick");
static_assert(sizeof(ASearchEventGimmick) == 0x000278, "Wrong size on ASearchEventGimmick");
static_assert(offsetof(ASearchEventGimmick, OpenedCheckType) == 0x000248, "Member 'ASearchEventGimmick::OpenedCheckType' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, OpenedTargetFlag) == 0x00024A, "Member 'ASearchEventGimmick::OpenedTargetFlag' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, OpenedBehaviour) == 0x00024C, "Member 'ASearchEventGimmick::OpenedBehaviour' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, ActorListComp) == 0x000250, "Member 'ASearchEventGimmick::ActorListComp' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, EventTrigger) == 0x000258, "Member 'ASearchEventGimmick::EventTrigger' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, MangaIconComp) == 0x000260, "Member 'ASearchEventGimmick::MangaIconComp' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, EffectTimeManageComp) == 0x000268, "Member 'ASearchEventGimmick::EffectTimeManageComp' has a wrong offset!");
static_assert(offsetof(ASearchEventGimmick, ItemGetStartLocationComponent) == 0x000270, "Member 'ASearchEventGimmick::ItemGetStartLocationComponent' has a wrong offset!");

// Class Nicola.SearchEvent
// 0x0008 (0x0280 - 0x0278)
class ASearchEvent : public ASearchEventGimmick
{
public:
	class UStaticMeshComponent*                   ObjectMesh;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchEvent">();
	}
	static class ASearchEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchEvent>();
	}
};
static_assert(alignof(ASearchEvent) == 0x000008, "Wrong alignment on ASearchEvent");
static_assert(sizeof(ASearchEvent) == 0x000280, "Wrong size on ASearchEvent");
static_assert(offsetof(ASearchEvent, ObjectMesh) == 0x000278, "Member 'ASearchEvent::ObjectMesh' has a wrong offset!");

// Class Nicola.ShipTrapSearchEvent
// 0x0000 (0x0280 - 0x0280)
class AShipTrapSearchEvent final : public ASearchEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShipTrapSearchEvent">();
	}
	static class AShipTrapSearchEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShipTrapSearchEvent>();
	}
};
static_assert(alignof(AShipTrapSearchEvent) == 0x000008, "Wrong alignment on AShipTrapSearchEvent");
static_assert(sizeof(AShipTrapSearchEvent) == 0x000280, "Wrong size on AShipTrapSearchEvent");

// Class Nicola.ProduceSequencerEnding
// 0x0000 (0x0220 - 0x0220)
class AProduceSequencerEnding final : public AProduceSequencerBase
{
public:
	void ChangeAnimationLogo();
	void StartAnimationLogo();
	void StartFadeOut(float FadeSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerEnding">();
	}
	static class AProduceSequencerEnding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerEnding>();
	}
};
static_assert(alignof(AProduceSequencerEnding) == 0x000008, "Wrong alignment on AProduceSequencerEnding");
static_assert(sizeof(AProduceSequencerEnding) == 0x000220, "Wrong size on AProduceSequencerEnding");

// Class Nicola.FlipbookNotifyPlayEffectLocation
// 0x0018 (0x0048 - 0x0030)
class UFlipbookNotifyPlayEffectLocation final : public UNicolaFlipbookNotifyBase
{
public:
	class FName                                   EffectId;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyPlayEffectLocation">();
	}
	static class UFlipbookNotifyPlayEffectLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyPlayEffectLocation>();
	}
};
static_assert(alignof(UFlipbookNotifyPlayEffectLocation) == 0x000008, "Wrong alignment on UFlipbookNotifyPlayEffectLocation");
static_assert(sizeof(UFlipbookNotifyPlayEffectLocation) == 0x000048, "Wrong size on UFlipbookNotifyPlayEffectLocation");
static_assert(offsetof(UFlipbookNotifyPlayEffectLocation, EffectId) == 0x000030, "Member 'UFlipbookNotifyPlayEffectLocation::EffectId' has a wrong offset!");
static_assert(offsetof(UFlipbookNotifyPlayEffectLocation, LocationOffset) == 0x000038, "Member 'UFlipbookNotifyPlayEffectLocation::LocationOffset' has a wrong offset!");

// Class Nicola.RecollectionSubsystem
// 0x0018 (0x0048 - 0x0030)
class URecollectionSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionSubsystem">();
	}
	static class URecollectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionSubsystem>();
	}
};
static_assert(alignof(URecollectionSubsystem) == 0x000008, "Wrong alignment on URecollectionSubsystem");
static_assert(sizeof(URecollectionSubsystem) == 0x000048, "Wrong size on URecollectionSubsystem");

// Class Nicola.UIMiniMapMenu
// 0x0060 (0x00D8 - 0x0078)
class UUIMiniMapMenu final : public UUIRootBase
{
public:
	class UUIMiniMapMenuWindowMain*               WindowMain;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconLocation;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconFacility;                                 // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconTarget;                                   // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconVehicle;                                  // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconGhostShip;                                // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconRemirama;                                 // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconEchoFlute;                                // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconGuideMain;                                // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconGuideSub;                                 // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageIconDoorKey;                                  // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMapMenu">();
	}
	static class UUIMiniMapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMapMenu>();
	}
};
static_assert(alignof(UUIMiniMapMenu) == 0x000008, "Wrong alignment on UUIMiniMapMenu");
static_assert(sizeof(UUIMiniMapMenu) == 0x0000D8, "Wrong size on UUIMiniMapMenu");
static_assert(offsetof(UUIMiniMapMenu, WindowMain) == 0x000078, "Member 'UUIMiniMapMenu::WindowMain' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconLocation) == 0x000080, "Member 'UUIMiniMapMenu::ImageIconLocation' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconFacility) == 0x000088, "Member 'UUIMiniMapMenu::ImageIconFacility' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconTarget) == 0x000090, "Member 'UUIMiniMapMenu::ImageIconTarget' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconVehicle) == 0x000098, "Member 'UUIMiniMapMenu::ImageIconVehicle' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconGhostShip) == 0x0000A0, "Member 'UUIMiniMapMenu::ImageIconGhostShip' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconRemirama) == 0x0000A8, "Member 'UUIMiniMapMenu::ImageIconRemirama' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconEchoFlute) == 0x0000B0, "Member 'UUIMiniMapMenu::ImageIconEchoFlute' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconGuideMain) == 0x0000B8, "Member 'UUIMiniMapMenu::ImageIconGuideMain' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconGuideSub) == 0x0000C0, "Member 'UUIMiniMapMenu::ImageIconGuideSub' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenu, ImageIconDoorKey) == 0x0000C8, "Member 'UUIMiniMapMenu::ImageIconDoorKey' has a wrong offset!");

// Class Nicola.FlipbookNotifyPlaySoundSE
// 0x0010 (0x0040 - 0x0030)
class UFlipbookNotifyPlaySoundSE final : public UNicolaFlipbookNotifyBase
{
public:
	class FName                                   GopId;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SEIndex;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySeAtSpecifyBattleSpeed;                       // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyPlaySoundSE">();
	}
	static class UFlipbookNotifyPlaySoundSE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyPlaySoundSE>();
	}
};
static_assert(alignof(UFlipbookNotifyPlaySoundSE) == 0x000008, "Wrong alignment on UFlipbookNotifyPlaySoundSE");
static_assert(sizeof(UFlipbookNotifyPlaySoundSE) == 0x000040, "Wrong size on UFlipbookNotifyPlaySoundSE");
static_assert(offsetof(UFlipbookNotifyPlaySoundSE, GopId) == 0x000030, "Member 'UFlipbookNotifyPlaySoundSE::GopId' has a wrong offset!");
static_assert(offsetof(UFlipbookNotifyPlaySoundSE, SEIndex) == 0x000038, "Member 'UFlipbookNotifyPlaySoundSE::SEIndex' has a wrong offset!");
static_assert(offsetof(UFlipbookNotifyPlaySoundSE, bPlaySeAtSpecifyBattleSpeed) == 0x00003C, "Member 'UFlipbookNotifyPlaySoundSE::bPlaySeAtSpecifyBattleSpeed' has a wrong offset!");

// Class Nicola.NicolaCameraFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaCameraFL final : public UBlueprintFunctionLibrary
{
public:
	static class ANicolaCameraActor* GetCurrentCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraFL">();
	}
	static class UNicolaCameraFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCameraFL>();
	}
};
static_assert(alignof(UNicolaCameraFL) == 0x000008, "Wrong alignment on UNicolaCameraFL");
static_assert(sizeof(UNicolaCameraFL) == 0x000028, "Wrong size on UNicolaCameraFL");

// Class Nicola.FlipbookNotifyPlaySoundSE3D
// 0x0008 (0x0038 - 0x0030)
class UFlipbookNotifyPlaySoundSE3D final : public UNicolaFlipbookNotifyBase
{
public:
	class FName                                   GopIdSoundSe;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyPlaySoundSE3D">();
	}
	static class UFlipbookNotifyPlaySoundSE3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyPlaySoundSE3D>();
	}
};
static_assert(alignof(UFlipbookNotifyPlaySoundSE3D) == 0x000008, "Wrong alignment on UFlipbookNotifyPlaySoundSE3D");
static_assert(sizeof(UFlipbookNotifyPlaySoundSE3D) == 0x000038, "Wrong size on UFlipbookNotifyPlaySoundSE3D");
static_assert(offsetof(UFlipbookNotifyPlaySoundSE3D, GopIdSoundSe) == 0x000030, "Member 'UFlipbookNotifyPlaySoundSE3D::GopIdSoundSe' has a wrong offset!");

// Class Nicola.FlipbookNotifyPlaySoundSEEx
// 0x0008 (0x0038 - 0x0030)
class UFlipbookNotifyPlaySoundSEEx final : public UNicolaFlipbookNotifyBase
{
public:
	class FName                                   GopIdSoundSe;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyPlaySoundSEEx">();
	}
	static class UFlipbookNotifyPlaySoundSEEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyPlaySoundSEEx>();
	}
};
static_assert(alignof(UFlipbookNotifyPlaySoundSEEx) == 0x000008, "Wrong alignment on UFlipbookNotifyPlaySoundSEEx");
static_assert(sizeof(UFlipbookNotifyPlaySoundSEEx) == 0x000038, "Wrong size on UFlipbookNotifyPlaySoundSEEx");
static_assert(offsetof(UFlipbookNotifyPlaySoundSEEx, GopIdSoundSe) == 0x000030, "Member 'UFlipbookNotifyPlaySoundSEEx::GopIdSoundSe' has a wrong offset!");

// Class Nicola.FlipbookNotifyResumeBattleScript
// 0x0000 (0x0030 - 0x0030)
class UFlipbookNotifyResumeBattleScript final : public UNicolaFlipbookNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyResumeBattleScript">();
	}
	static class UFlipbookNotifyResumeBattleScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyResumeBattleScript>();
	}
};
static_assert(alignof(UFlipbookNotifyResumeBattleScript) == 0x000008, "Wrong alignment on UFlipbookNotifyResumeBattleScript");
static_assert(sizeof(UFlipbookNotifyResumeBattleScript) == 0x000030, "Wrong size on UFlipbookNotifyResumeBattleScript");

// Class Nicola.UIListItemIcon
// 0x0008 (0x0060 - 0x0058)
class UUIListItemIcon : public UUIListItem
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemIcon">();
	}
	static class UUIListItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemIcon>();
	}
};
static_assert(alignof(UUIListItemIcon) == 0x000008, "Wrong alignment on UUIListItemIcon");
static_assert(sizeof(UUIListItemIcon) == 0x000060, "Wrong size on UUIListItemIcon");
static_assert(offsetof(UUIListItemIcon, ImageIcon) == 0x000058, "Member 'UUIListItemIcon::ImageIcon' has a wrong offset!");

// Class Nicola.UIListItemIconDouble
// 0x0008 (0x0068 - 0x0060)
class UUIListItemIconDouble : public UUIListItemIcon
{
public:
	class UImage*                                 ImageIcon2;                                        // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemIconDouble">();
	}
	static class UUIListItemIconDouble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemIconDouble>();
	}
};
static_assert(alignof(UUIListItemIconDouble) == 0x000008, "Wrong alignment on UUIListItemIconDouble");
static_assert(sizeof(UUIListItemIconDouble) == 0x000068, "Wrong size on UUIListItemIconDouble");
static_assert(offsetof(UUIListItemIconDouble, ImageIcon2) == 0x000060, "Member 'UUIListItemIconDouble::ImageIcon2' has a wrong offset!");

// Class Nicola.UIListItemSelectItemInventory
// 0x0028 (0x0090 - 0x0068)
class UUIListItemSelectItemInventory final : public UUIListItemIconDouble
{
public:
	class UGopTextBlock*                          TextCount;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSign;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextPrice;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextG;                                             // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextCannotSell;                                    // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemSelectItemInventory">();
	}
	static class UUIListItemSelectItemInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemSelectItemInventory>();
	}
};
static_assert(alignof(UUIListItemSelectItemInventory) == 0x000008, "Wrong alignment on UUIListItemSelectItemInventory");
static_assert(sizeof(UUIListItemSelectItemInventory) == 0x000090, "Wrong size on UUIListItemSelectItemInventory");
static_assert(offsetof(UUIListItemSelectItemInventory, TextCount) == 0x000068, "Member 'UUIListItemSelectItemInventory::TextCount' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectItemInventory, TextSign) == 0x000070, "Member 'UUIListItemSelectItemInventory::TextSign' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectItemInventory, TextPrice) == 0x000078, "Member 'UUIListItemSelectItemInventory::TextPrice' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectItemInventory, TextG) == 0x000080, "Member 'UUIListItemSelectItemInventory::TextG' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectItemInventory, TextCannotSell) == 0x000088, "Member 'UUIListItemSelectItemInventory::TextCannotSell' has a wrong offset!");

// Class Nicola.FlipbookNotifySpriteOffset
// 0x0010 (0x0040 - 0x0030)
class UFlipbookNotifySpriteOffset final : public UNicolaFlipbookNotifyBase
{
public:
	struct FVector                                Offset;                                            // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifySpriteOffset">();
	}
	static class UFlipbookNotifySpriteOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifySpriteOffset>();
	}
};
static_assert(alignof(UFlipbookNotifySpriteOffset) == 0x000008, "Wrong alignment on UFlipbookNotifySpriteOffset");
static_assert(sizeof(UFlipbookNotifySpriteOffset) == 0x000040, "Wrong size on UFlipbookNotifySpriteOffset");
static_assert(offsetof(UFlipbookNotifySpriteOffset, Offset) == 0x000030, "Member 'UFlipbookNotifySpriteOffset::Offset' has a wrong offset!");

// Class Nicola.FlipbookNotifyStartFade
// 0x0008 (0x0038 - 0x0030)
class UFlipbookNotifyStartFade final : public UNicolaFlipbookNotifyBase
{
public:
	bool                                          bFadeIn;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeSec;                                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookNotifyStartFade">();
	}
	static class UFlipbookNotifyStartFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookNotifyStartFade>();
	}
};
static_assert(alignof(UFlipbookNotifyStartFade) == 0x000008, "Wrong alignment on UFlipbookNotifyStartFade");
static_assert(sizeof(UFlipbookNotifyStartFade) == 0x000038, "Wrong size on UFlipbookNotifyStartFade");
static_assert(offsetof(UFlipbookNotifyStartFade, bFadeIn) == 0x000030, "Member 'UFlipbookNotifyStartFade::bFadeIn' has a wrong offset!");
static_assert(offsetof(UFlipbookNotifyStartFade, FadeSec) == 0x000034, "Member 'UFlipbookNotifyStartFade::FadeSec' has a wrong offset!");

// Class Nicola.SearchAnimEvent
// 0x0028 (0x02A0 - 0x0278)
class ASearchAnimEvent : public ASearchEventGimmick
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ObjectMesh;                                        // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        OpenAnimation;                                     // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        CloseAnimation;                                    // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       Sphere;                                            // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAnimEvent">();
	}
	static class ASearchAnimEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchAnimEvent>();
	}
};
static_assert(alignof(ASearchAnimEvent) == 0x000008, "Wrong alignment on ASearchAnimEvent");
static_assert(sizeof(ASearchAnimEvent) == 0x0002A0, "Wrong size on ASearchAnimEvent");
static_assert(offsetof(ASearchAnimEvent, ObjectMesh) == 0x000280, "Member 'ASearchAnimEvent::ObjectMesh' has a wrong offset!");
static_assert(offsetof(ASearchAnimEvent, OpenAnimation) == 0x000288, "Member 'ASearchAnimEvent::OpenAnimation' has a wrong offset!");
static_assert(offsetof(ASearchAnimEvent, CloseAnimation) == 0x000290, "Member 'ASearchAnimEvent::CloseAnimation' has a wrong offset!");
static_assert(offsetof(ASearchAnimEvent, Sphere) == 0x000298, "Member 'ASearchAnimEvent::Sphere' has a wrong offset!");

// Class Nicola.NicolaPlayerController
// 0x0030 (0x05D0 - 0x05A0)
class ANicolaPlayerController : public ANicolaPlayerControllerBase
{
public:
	TArray<struct FNicolaInputReceiverInfo>       InputReceivers;                                    // 0x05A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FNicolaInputReceiverInfo>       InputReceiversAddReserved;                         // 0x05B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FNicolaInputReceiverInfo>       InputReceiversRemoveReserved;                      // 0x05C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlayerController">();
	}
	static class ANicolaPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaPlayerController>();
	}
};
static_assert(alignof(ANicolaPlayerController) == 0x000008, "Wrong alignment on ANicolaPlayerController");
static_assert(sizeof(ANicolaPlayerController) == 0x0005D0, "Wrong size on ANicolaPlayerController");
static_assert(offsetof(ANicolaPlayerController, InputReceivers) == 0x0005A0, "Member 'ANicolaPlayerController::InputReceivers' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerController, InputReceiversAddReserved) == 0x0005B0, "Member 'ANicolaPlayerController::InputReceiversAddReserved' has a wrong offset!");
static_assert(offsetof(ANicolaPlayerController, InputReceiversRemoveReserved) == 0x0005C0, "Member 'ANicolaPlayerController::InputReceiversRemoveReserved' has a wrong offset!");

// Class Nicola.NicolaBattlePlayerController
// 0x0000 (0x05D0 - 0x05D0)
class ANicolaBattlePlayerController final : public ANicolaPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattlePlayerController">();
	}
	static class ANicolaBattlePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaBattlePlayerController>();
	}
};
static_assert(alignof(ANicolaBattlePlayerController) == 0x000008, "Wrong alignment on ANicolaBattlePlayerController");
static_assert(sizeof(ANicolaBattlePlayerController) == 0x0005D0, "Wrong size on ANicolaBattlePlayerController");

// Class Nicola.FlipbookWidget
// 0x00D0 (0x03F8 - 0x0328)
class UFlipbookWidget : public UCommonBaseWidget
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ENicolaFlipbookWidgetLayoutType               NicolaFlipbookWidgetLayoutType;                    // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      MaterialNicolaUnit;                                // 0x0338(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel1;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox;                                           // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image;                                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPaperFlipbook*                         SourceFlipbook;                                    // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           interpOpacity;                                     // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FNicolaFlipbookWidgetKeyFrameData> KeyFrameDatas;                                     // 0x0388(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x60];                                     // 0x0398(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookWidget">();
	}
	static class UFlipbookWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookWidget>();
	}
};
static_assert(alignof(UFlipbookWidget) == 0x000008, "Wrong alignment on UFlipbookWidget");
static_assert(sizeof(UFlipbookWidget) == 0x0003F8, "Wrong size on UFlipbookWidget");
static_assert(offsetof(UFlipbookWidget, NicolaFlipbookWidgetLayoutType) == 0x000330, "Member 'UFlipbookWidget::NicolaFlipbookWidgetLayoutType' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, MaterialNicolaUnit) == 0x000338, "Member 'UFlipbookWidget::MaterialNicolaUnit' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, CanvasPanel1) == 0x000360, "Member 'UFlipbookWidget::CanvasPanel1' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, SizeBox) == 0x000368, "Member 'UFlipbookWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, Image) == 0x000370, "Member 'UFlipbookWidget::Image' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, SourceFlipbook) == 0x000378, "Member 'UFlipbookWidget::SourceFlipbook' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, interpOpacity) == 0x000380, "Member 'UFlipbookWidget::interpOpacity' has a wrong offset!");
static_assert(offsetof(UFlipbookWidget, KeyFrameDatas) == 0x000388, "Member 'UFlipbookWidget::KeyFrameDatas' has a wrong offset!");

// Class Nicola.LuaTriggerInterface
// 0x0000 (0x0028 - 0x0028)
class ILuaTriggerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaTriggerInterface">();
	}
	static class ILuaTriggerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILuaTriggerInterface>();
	}
};
static_assert(alignof(ILuaTriggerInterface) == 0x000008, "Wrong alignment on ILuaTriggerInterface");
static_assert(sizeof(ILuaTriggerInterface) == 0x000028, "Wrong size on ILuaTriggerInterface");

// Class Nicola.FlipbookWidgetBase
// 0x0098 (0x02F8 - 0x0260)
class UFlipbookWidgetBase final : public UUserWidget
{
public:
	struct FCSWFlipbookBrush                      FlipbookBrush;                                     // 0x0260(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USizeBox*                               SizeBox;                                           // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image;                                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x40];                                     // 0x02B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipbookWidgetBase">();
	}
	static class UFlipbookWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipbookWidgetBase>();
	}
};
static_assert(alignof(UFlipbookWidgetBase) == 0x000008, "Wrong alignment on UFlipbookWidgetBase");
static_assert(sizeof(UFlipbookWidgetBase) == 0x0002F8, "Wrong size on UFlipbookWidgetBase");
static_assert(offsetof(UFlipbookWidgetBase, FlipbookBrush) == 0x000260, "Member 'UFlipbookWidgetBase::FlipbookBrush' has a wrong offset!");
static_assert(offsetof(UFlipbookWidgetBase, SizeBox) == 0x0002A8, "Member 'UFlipbookWidgetBase::SizeBox' has a wrong offset!");
static_assert(offsetof(UFlipbookWidgetBase, Image) == 0x0002B0, "Member 'UFlipbookWidgetBase::Image' has a wrong offset!");

// Class Nicola.UIMBRCommonWindowMagicItem
// 0x0010 (0x0050 - 0x0040)
class UUIMBRCommonWindowMagicItem final : public UUIWindowItem
{
public:
	TArray<class UUIWindowItemIcon*>              MagicItems;                                        // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonWindowMagicItem">();
	}
	static class UUIMBRCommonWindowMagicItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonWindowMagicItem>();
	}
};
static_assert(alignof(UUIMBRCommonWindowMagicItem) == 0x000008, "Wrong alignment on UUIMBRCommonWindowMagicItem");
static_assert(sizeof(UUIMBRCommonWindowMagicItem) == 0x000050, "Wrong size on UUIMBRCommonWindowMagicItem");
static_assert(offsetof(UUIMBRCommonWindowMagicItem, MagicItems) == 0x000040, "Member 'UUIMBRCommonWindowMagicItem::MagicItems' has a wrong offset!");

// Class Nicola.ForceFeedbackEffectMan
// 0x0000 (0x0028 - 0x0028)
class UForceFeedbackEffectMan final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackEffectMan">();
	}
	static class UForceFeedbackEffectMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackEffectMan>();
	}
};
static_assert(alignof(UForceFeedbackEffectMan) == 0x000008, "Wrong alignment on UForceFeedbackEffectMan");
static_assert(sizeof(UForceFeedbackEffectMan) == 0x000028, "Wrong size on UForceFeedbackEffectMan");

// Class Nicola.NicolaCharacterFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaCharacterFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugAmbientOcclusion(float Val);
	static void DebugBloom(float Val);
	static void DebugChangeCharaColor(int32 Index_0, float R, float G, float b, float ColorPower, float metallicPower);
	static float DebugGetAperture();
	static bool DebugGetCharaColor(int32 Index_0, float* R, float* G, float* b, float* ColorPower, float* metallicPower);
	static float DebugGetNearDOF();
	static void DebugMotionBlur(float Val);
	static void DebugSceneFringe(float Val);
	static void DebugSetAperture(float Val);
	static void DebugSetNearDOF(float Val);
	static TArray<class ANicolaCharacterBase*> GetCharactersFromParty();
	static class ANicolaCharacterBase* SpawnUnit(const struct FUnitCommonCreateOption& UnitCommonCreateOption, const struct FUnitInstanceCreateOption& UnitInstanceCreateOption, const struct FUnitLooksActorCreateOption& UnitLooksActorCreateOption);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterFL">();
	}
	static class UNicolaCharacterFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCharacterFL>();
	}
};
static_assert(alignof(UNicolaCharacterFL) == 0x000008, "Wrong alignment on UNicolaCharacterFL");
static_assert(sizeof(UNicolaCharacterFL) == 0x000028, "Wrong size on UNicolaCharacterFL");

// Class Nicola.FrameGrabberActor
// 0x0040 (0x0260 - 0x0220)
class AFrameGrabberActor final : public AActor
{
public:
	float                                         viewprotScale;                                     // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 captureFrameData;                                  // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             captureFrameTexture;                               // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x20];                                     // 0x0240(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameGrabberActor">();
	}
	static class AFrameGrabberActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFrameGrabberActor>();
	}
};
static_assert(alignof(AFrameGrabberActor) == 0x000008, "Wrong alignment on AFrameGrabberActor");
static_assert(sizeof(AFrameGrabberActor) == 0x000260, "Wrong size on AFrameGrabberActor");
static_assert(offsetof(AFrameGrabberActor, viewprotScale) == 0x000220, "Member 'AFrameGrabberActor::viewprotScale' has a wrong offset!");
static_assert(offsetof(AFrameGrabberActor, captureFrameData) == 0x000228, "Member 'AFrameGrabberActor::captureFrameData' has a wrong offset!");
static_assert(offsetof(AFrameGrabberActor, captureFrameTexture) == 0x000238, "Member 'AFrameGrabberActor::captureFrameTexture' has a wrong offset!");

// Class Nicola.GameDataCoreFL
// 0x0000 (0x0028 - 0x0028)
class UGameDataCoreFL final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddGameMoney(int32 Value, bool isBank);
	static void AddMiniMedal(int32 addCount);
	static void AddMonsterKillCount(class FName InMonsterId, int32 InAddCount);
	static void BP_DebugDisconnectControllerMessage();
	static bool BP_DebugGetGOPEnumFlag(const EDebugGOPFlagType Type, int32 flagIndex);
	static TArray<class FName> BP_DebugGetGOPEnumFlagNameList(const EDebugGOPFlagType Type);
	static void BP_DebugSetGOPEnumFlag(const EDebugGOPFlagType Type, int32 flagIndex, bool Value);
	static void DebugAddGamePlayTime(int32 addValue);
	static void DebugAllRuraPointUnlock();
	static void GetAllMonsterUnitMasterID(TArray<class FName>* GopIdList);
	static int32 GetGameMoney();
	static int32 ReduceGameMoney(int32 Value);
	static void SetAllMonsterAddLibrary();
	static void SetCanRuraVolume(bool bIsCanRura);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataCoreFL">();
	}
	static class UGameDataCoreFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataCoreFL>();
	}
};
static_assert(alignof(UGameDataCoreFL) == 0x000008, "Wrong alignment on UGameDataCoreFL");
static_assert(sizeof(UGameDataCoreFL) == 0x000028, "Wrong size on UGameDataCoreFL");

// Class Nicola.MangaIconActor
// 0x0010 (0x0230 - 0x0220)
class AMangaIconActor final : public AActor
{
public:
	class UPaperFlipbookComponent*                FlipbookComp;                                      // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        BillboardComp;                                     // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangaIconActor">();
	}
	static class AMangaIconActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMangaIconActor>();
	}
};
static_assert(alignof(AMangaIconActor) == 0x000008, "Wrong alignment on AMangaIconActor");
static_assert(sizeof(AMangaIconActor) == 0x000230, "Wrong size on AMangaIconActor");
static_assert(offsetof(AMangaIconActor, FlipbookComp) == 0x000220, "Member 'AMangaIconActor::FlipbookComp' has a wrong offset!");
static_assert(offsetof(AMangaIconActor, BillboardComp) == 0x000228, "Member 'AMangaIconActor::BillboardComp' has a wrong offset!");

// Class Nicola.GameDataFL
// 0x0000 (0x0028 - 0x0028)
class UGameDataFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugCallSetupAfterLoaded();
	static EGameMode GetGameMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFL">();
	}
	static class UGameDataFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFL>();
	}
};
static_assert(alignof(UGameDataFL) == 0x000008, "Wrong alignment on UGameDataFL");
static_assert(sizeof(UGameDataFL) == 0x000028, "Wrong size on UGameDataFL");

// Class Nicola.UIFieldTacticsStaticsMenuWindowCategory
// 0x0020 (0x0078 - 0x0058)
class UUIFieldTacticsStaticsMenuWindowCategory final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextTitle;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonLeft;                                   // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonRight;                                  // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextCategory;                                      // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsStaticsMenuWindowCategory">();
	}
	static class UUIFieldTacticsStaticsMenuWindowCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsStaticsMenuWindowCategory>();
	}
};
static_assert(alignof(UUIFieldTacticsStaticsMenuWindowCategory) == 0x000008, "Wrong alignment on UUIFieldTacticsStaticsMenuWindowCategory");
static_assert(sizeof(UUIFieldTacticsStaticsMenuWindowCategory) == 0x000078, "Wrong size on UUIFieldTacticsStaticsMenuWindowCategory");
static_assert(offsetof(UUIFieldTacticsStaticsMenuWindowCategory, TextTitle) == 0x000058, "Member 'UUIFieldTacticsStaticsMenuWindowCategory::TextTitle' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStaticsMenuWindowCategory, ImageButtonLeft) == 0x000060, "Member 'UUIFieldTacticsStaticsMenuWindowCategory::ImageButtonLeft' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStaticsMenuWindowCategory, ImageButtonRight) == 0x000068, "Member 'UUIFieldTacticsStaticsMenuWindowCategory::ImageButtonRight' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStaticsMenuWindowCategory, TextCategory) == 0x000070, "Member 'UUIFieldTacticsStaticsMenuWindowCategory::TextCategory' has a wrong offset!");

// Class Nicola.GDKAccountController
// 0x0000 (0x0028 - 0x0028)
class UGDKAccountController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GDKAccountController">();
	}
	static class UGDKAccountController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGDKAccountController>();
	}
};
static_assert(alignof(UGDKAccountController) == 0x000008, "Wrong alignment on UGDKAccountController");
static_assert(sizeof(UGDKAccountController) == 0x000028, "Wrong size on UGDKAccountController");

// Class Nicola.UIMBREntryMenuFlowStartMatch
// 0x0008 (0x0078 - 0x0070)
class UUIMBREntryMenuFlowStartMatch final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuFlowStartMatch">();
	}
	static class UUIMBREntryMenuFlowStartMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuFlowStartMatch>();
	}
};
static_assert(alignof(UUIMBREntryMenuFlowStartMatch) == 0x000008, "Wrong alignment on UUIMBREntryMenuFlowStartMatch");
static_assert(sizeof(UUIMBREntryMenuFlowStartMatch) == 0x000078, "Wrong size on UUIMBREntryMenuFlowStartMatch");

// Class Nicola.GhostShipRecastNavMesh
// 0x0018 (0x04F0 - 0x04D8)
class AGhostShipRecastNavMesh final : public ARecastNavMesh
{
public:
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostShipRecastNavMesh">();
	}
	static class AGhostShipRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGhostShipRecastNavMesh>();
	}
};
static_assert(alignof(AGhostShipRecastNavMesh) == 0x000008, "Wrong alignment on AGhostShipRecastNavMesh");
static_assert(sizeof(AGhostShipRecastNavMesh) == 0x0004F0, "Wrong size on AGhostShipRecastNavMesh");

// Class Nicola.NicolaCheatManager
// 0x0000 (0x0088 - 0x0088)
class UNicolaCheatManager final : public UCheatManager
{
public:
	void DisableEncount();
	void DisableShipStep();
	void EnableEncount();
	void EnableShipStep();
	void FindTextGopId(const class FName& GopId);
	void HelloWorld();
	void ImprintRecollection();
	void LuaDebugExec(const class FString& funcName);
	void ResetEncount();
	void SetNearDOF(const float DOFPower);
	void StartBattle(const class FName& BattleMapID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCheatManager">();
	}
	static class UNicolaCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCheatManager>();
	}
};
static_assert(alignof(UNicolaCheatManager) == 0x000008, "Wrong alignment on UNicolaCheatManager");
static_assert(sizeof(UNicolaCheatManager) == 0x000088, "Wrong size on UNicolaCheatManager");

// Class Nicola.GimmickAnimation
// 0x0000 (0x0028 - 0x0028)
class IGimmickAnimation final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickAnimation">();
	}
	static class IGimmickAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGimmickAnimation>();
	}
};
static_assert(alignof(IGimmickAnimation) == 0x000008, "Wrong alignment on IGimmickAnimation");
static_assert(sizeof(IGimmickAnimation) == 0x000028, "Wrong size on IGimmickAnimation");

// Class Nicola.GimmickReceiver
// 0x0000 (0x0028 - 0x0028)
class IGimmickReceiver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickReceiver">();
	}
	static class IGimmickReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGimmickReceiver>();
	}
};
static_assert(alignof(IGimmickReceiver) == 0x000008, "Wrong alignment on IGimmickReceiver");
static_assert(sizeof(IGimmickReceiver) == 0x000028, "Wrong size on IGimmickReceiver");

// Class Nicola.GopFL
// 0x0000 (0x0028 - 0x0028)
class UGopFL final : public UBlueprintFunctionLibrary
{
public:
	static const class UDataTable* GetDataTableEvent(EEventTableType TableType, EGopEventType GopType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GopFL">();
	}
	static class UGopFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGopFL>();
	}
};
static_assert(alignof(UGopFL) == 0x000008, "Wrong alignment on UGopFL");
static_assert(sizeof(UGopFL) == 0x000028, "Wrong size on UGopFL");

// Class Nicola.UIFieldTacticsSystemSettingWindowVram
// 0x0018 (0x0070 - 0x0058)
class UUIFieldTacticsSystemSettingWindowVram final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextVram;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageGauge;                                        // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsSystemSettingWindowVram">();
	}
	static class UUIFieldTacticsSystemSettingWindowVram* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsSystemSettingWindowVram>();
	}
};
static_assert(alignof(UUIFieldTacticsSystemSettingWindowVram) == 0x000008, "Wrong alignment on UUIFieldTacticsSystemSettingWindowVram");
static_assert(sizeof(UUIFieldTacticsSystemSettingWindowVram) == 0x000070, "Wrong size on UUIFieldTacticsSystemSettingWindowVram");
static_assert(offsetof(UUIFieldTacticsSystemSettingWindowVram, TextItem) == 0x000058, "Member 'UUIFieldTacticsSystemSettingWindowVram::TextItem' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsSystemSettingWindowVram, TextVram) == 0x000060, "Member 'UUIFieldTacticsSystemSettingWindowVram::TextVram' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsSystemSettingWindowVram, ImageGauge) == 0x000068, "Member 'UUIFieldTacticsSystemSettingWindowVram::ImageGauge' has a wrong offset!");

// Class Nicola.GopManager
// 0x00A8 (0x00D0 - 0x0028)
class UGopManager final : public UObject
{
public:
	class FString                                 GopPrefixName;                                     // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     dataDataTableArray;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     textDataTableArray;                                // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     scenarioTextDataTableArray;                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     eventDataTableArray;                               // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     npcTalkDataTableArray;                             // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     searchObjectDataTableArray;                        // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x38];                                      // 0x0098(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GopManager">();
	}
	static class UGopManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGopManager>();
	}
};
static_assert(alignof(UGopManager) == 0x000008, "Wrong alignment on UGopManager");
static_assert(sizeof(UGopManager) == 0x0000D0, "Wrong size on UGopManager");
static_assert(offsetof(UGopManager, GopPrefixName) == 0x000028, "Member 'UGopManager::GopPrefixName' has a wrong offset!");
static_assert(offsetof(UGopManager, dataDataTableArray) == 0x000038, "Member 'UGopManager::dataDataTableArray' has a wrong offset!");
static_assert(offsetof(UGopManager, textDataTableArray) == 0x000048, "Member 'UGopManager::textDataTableArray' has a wrong offset!");
static_assert(offsetof(UGopManager, scenarioTextDataTableArray) == 0x000058, "Member 'UGopManager::scenarioTextDataTableArray' has a wrong offset!");
static_assert(offsetof(UGopManager, eventDataTableArray) == 0x000068, "Member 'UGopManager::eventDataTableArray' has a wrong offset!");
static_assert(offsetof(UGopManager, npcTalkDataTableArray) == 0x000078, "Member 'UGopManager::npcTalkDataTableArray' has a wrong offset!");
static_assert(offsetof(UGopManager, searchObjectDataTableArray) == 0x000088, "Member 'UGopManager::searchObjectDataTableArray' has a wrong offset!");

// Class Nicola.NicolaCharacterMovementComponent
// 0x0060 (0x0B50 - 0x0AF0)
class UNicolaCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	float                                         MovingRate;                                        // 0x0AF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingSpeed;                                      // 0x0AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0AF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSpeed;                                         // 0x0AFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickRateRunThreshold;                             // 0x0B00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B04[0x4];                                      // 0x0B04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveSpeedRateByStick;                             // 0x0B08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurveAnimRateBySpeed;                              // 0x0B10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B18[0x8];                                      // 0x0B18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSlidMoveParam>                 SlideMoveParams;                                   // 0x0B20(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B30[0x20];                                     // 0x0B30(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterMovementComponent">();
	}
	static class UNicolaCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCharacterMovementComponent>();
	}
};
static_assert(alignof(UNicolaCharacterMovementComponent) == 0x000010, "Wrong alignment on UNicolaCharacterMovementComponent");
static_assert(sizeof(UNicolaCharacterMovementComponent) == 0x000B50, "Wrong size on UNicolaCharacterMovementComponent");
static_assert(offsetof(UNicolaCharacterMovementComponent, MovingRate) == 0x000AF0, "Member 'UNicolaCharacterMovementComponent::MovingRate' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, WalkingSpeed) == 0x000AF4, "Member 'UNicolaCharacterMovementComponent::WalkingSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, RunSpeed) == 0x000AF8, "Member 'UNicolaCharacterMovementComponent::RunSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, DashSpeed) == 0x000AFC, "Member 'UNicolaCharacterMovementComponent::DashSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, StickRateRunThreshold) == 0x000B00, "Member 'UNicolaCharacterMovementComponent::StickRateRunThreshold' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, curveSpeedRateByStick) == 0x000B08, "Member 'UNicolaCharacterMovementComponent::curveSpeedRateByStick' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, CurveAnimRateBySpeed) == 0x000B10, "Member 'UNicolaCharacterMovementComponent::CurveAnimRateBySpeed' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterMovementComponent, SlideMoveParams) == 0x000B20, "Member 'UNicolaCharacterMovementComponent::SlideMoveParams' has a wrong offset!");

// Class Nicola.GopTextBlock
// 0x0050 (0x02F8 - 0x02A8)
class UGopTextBlock final : public UTextBlock
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopId;                                             // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGopTextBlockContainMode                      ContainMode;                                       // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x17];                                     // 0x02B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UNicolaSizeBox*                         SizeBox;                                           // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonWindowWidget*                    ParentWidget;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugSetGopID(const class FText& InGop, const class FString& InArg00);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GopTextBlock">();
	}
	static class UGopTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGopTextBlock>();
	}
};
static_assert(alignof(UGopTextBlock) == 0x000008, "Wrong alignment on UGopTextBlock");
static_assert(sizeof(UGopTextBlock) == 0x0002F8, "Wrong size on UGopTextBlock");
static_assert(offsetof(UGopTextBlock, GopId) == 0x0002B0, "Member 'UGopTextBlock::GopId' has a wrong offset!");
static_assert(offsetof(UGopTextBlock, ContainMode) == 0x0002B8, "Member 'UGopTextBlock::ContainMode' has a wrong offset!");
static_assert(offsetof(UGopTextBlock, SizeBox) == 0x0002D0, "Member 'UGopTextBlock::SizeBox' has a wrong offset!");
static_assert(offsetof(UGopTextBlock, ParentWidget) == 0x0002E8, "Member 'UGopTextBlock::ParentWidget' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuPF
// 0x0030 (0x00C8 - 0x0098)
class UUIKeyboardNameMenuPF : public UUIKeyboardNameMenu
{
public:
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIKeyboardNameMenuPFWindow*            PFWindow;                                          // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuPF">();
	}
	static class UUIKeyboardNameMenuPF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuPF>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuPF) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuPF");
static_assert(sizeof(UUIKeyboardNameMenuPF) == 0x0000C8, "Wrong size on UUIKeyboardNameMenuPF");
static_assert(offsetof(UUIKeyboardNameMenuPF, PFWindow) == 0x0000B0, "Member 'UUIKeyboardNameMenuPF::PFWindow' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuRealPF
// 0x0000 (0x00C8 - 0x00C8)
class UUIKeyboardNameMenuRealPF final : public UUIKeyboardNameMenuPF
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuRealPF">();
	}
	static class UUIKeyboardNameMenuRealPF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuRealPF>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuRealPF) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuRealPF");
static_assert(sizeof(UUIKeyboardNameMenuRealPF) == 0x0000C8, "Wrong size on UUIKeyboardNameMenuRealPF");

// Class Nicola.HealGimmick
// 0x0018 (0x0240 - 0x0228)
class AHealGimmick final : public APlayerControllableGimmick
{
public:
	class FName                                   EffectId;                                          // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SEId;                                              // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopTime;                                          // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayHealAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealGimmick">();
	}
	static class AHealGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHealGimmick>();
	}
};
static_assert(alignof(AHealGimmick) == 0x000008, "Wrong alignment on AHealGimmick");
static_assert(sizeof(AHealGimmick) == 0x000240, "Wrong size on AHealGimmick");
static_assert(offsetof(AHealGimmick, EffectId) == 0x000228, "Member 'AHealGimmick::EffectId' has a wrong offset!");
static_assert(offsetof(AHealGimmick, SEId) == 0x000230, "Member 'AHealGimmick::SEId' has a wrong offset!");
static_assert(offsetof(AHealGimmick, StopTime) == 0x000238, "Member 'AHealGimmick::StopTime' has a wrong offset!");

// Class Nicola.NicolaDataAssetGlow
// 0x0050 (0x0080 - 0x0030)
class UNicolaDataAssetGlow final : public UNicolaDataAssetBase
{
public:
	struct FGlowRand                              BaseRandRange;                                     // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BaseRandRangeDiv;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        UpRate_STR;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpRate_ARM;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpRate_AGI;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpRate_VIT;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpRate_INT;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpRate_LUC;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpHPMP_Base;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGlowRand                              UpHPMP_RandRange;                                  // 0x0074(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         UpHPMP_RandRangeDiv;                               // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetGlow">();
	}
	static class UNicolaDataAssetGlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetGlow>();
	}
};
static_assert(alignof(UNicolaDataAssetGlow) == 0x000008, "Wrong alignment on UNicolaDataAssetGlow");
static_assert(sizeof(UNicolaDataAssetGlow) == 0x000080, "Wrong size on UNicolaDataAssetGlow");
static_assert(offsetof(UNicolaDataAssetGlow, BaseRandRange) == 0x000030, "Member 'UNicolaDataAssetGlow::BaseRandRange' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, BaseRandRangeDiv) == 0x000038, "Member 'UNicolaDataAssetGlow::BaseRandRangeDiv' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpRate_STR) == 0x000040, "Member 'UNicolaDataAssetGlow::UpRate_STR' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpRate_ARM) == 0x000048, "Member 'UNicolaDataAssetGlow::UpRate_ARM' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpRate_AGI) == 0x000050, "Member 'UNicolaDataAssetGlow::UpRate_AGI' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpRate_VIT) == 0x000058, "Member 'UNicolaDataAssetGlow::UpRate_VIT' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpRate_INT) == 0x000060, "Member 'UNicolaDataAssetGlow::UpRate_INT' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpRate_LUC) == 0x000068, "Member 'UNicolaDataAssetGlow::UpRate_LUC' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpHPMP_Base) == 0x000070, "Member 'UNicolaDataAssetGlow::UpHPMP_Base' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpHPMP_RandRange) == 0x000074, "Member 'UNicolaDataAssetGlow::UpHPMP_RandRange' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetGlow, UpHPMP_RandRangeDiv) == 0x00007C, "Member 'UNicolaDataAssetGlow::UpHPMP_RandRangeDiv' has a wrong offset!");

// Class Nicola.InitialLoadingManager
// 0x0000 (0x0028 - 0x0028)
class UInitialLoadingManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitialLoadingManager">();
	}
	static class UInitialLoadingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInitialLoadingManager>();
	}
};
static_assert(alignof(UInitialLoadingManager) == 0x000008, "Wrong alignment on UInitialLoadingManager");
static_assert(sizeof(UInitialLoadingManager) == 0x000028, "Wrong size on UInitialLoadingManager");

// Class Nicola.InputFL
// 0x0000 (0x0028 - 0x0028)
class UInputFL final : public UBlueprintFunctionLibrary
{
public:
	static float GetLeftStickTilt(ENicolaInputMode inputMode);
	static bool IsAnyDirectionalKey(ENicolaInputMode inputMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputFL">();
	}
	static class UInputFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputFL>();
	}
};
static_assert(alignof(UInputFL) == 0x000008, "Wrong alignment on UInputFL");
static_assert(sizeof(UInputFL) == 0x000028, "Wrong size on UInputFL");

// Class Nicola.InterfaceBattleEventReceiver
// 0x0000 (0x0028 - 0x0028)
class IInterfaceBattleEventReceiver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterfaceBattleEventReceiver">();
	}
	static class IInterfaceBattleEventReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterfaceBattleEventReceiver>();
	}
};
static_assert(alignof(IInterfaceBattleEventReceiver) == 0x000008, "Wrong alignment on IInterfaceBattleEventReceiver");
static_assert(sizeof(IInterfaceBattleEventReceiver) == 0x000028, "Wrong size on IInterfaceBattleEventReceiver");

// Class Nicola.UIFieldTopMenu
// 0x0040 (0x00B8 - 0x0078)
class UUIFieldTopMenu final : public UUIRootBase
{
public:
	class UUIFieldTopMenuListTop*                 ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTopMenuWindowLongPush*          WindowLongPush;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     ItemMoney;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTopMenuWindowParty*             WindowParty;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapGuideMenuWindowMain*              WindowMapGuide;                                    // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ItemKeyGuide;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemTreasureChest*             ItemTreasureChest;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTopMenu">();
	}
	static class UUIFieldTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTopMenu>();
	}
};
static_assert(alignof(UUIFieldTopMenu) == 0x000008, "Wrong alignment on UUIFieldTopMenu");
static_assert(sizeof(UUIFieldTopMenu) == 0x0000B8, "Wrong size on UUIFieldTopMenu");
static_assert(offsetof(UUIFieldTopMenu, ListTop) == 0x000078, "Member 'UUIFieldTopMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenu, WindowLongPush) == 0x000080, "Member 'UUIFieldTopMenu::WindowLongPush' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenu, ItemMoney) == 0x000088, "Member 'UUIFieldTopMenu::ItemMoney' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenu, WindowParty) == 0x000090, "Member 'UUIFieldTopMenu::WindowParty' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenu, WindowMapGuide) == 0x000098, "Member 'UUIFieldTopMenu::WindowMapGuide' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenu, ItemKeyGuide) == 0x0000A0, "Member 'UUIFieldTopMenu::ItemKeyGuide' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenu, ItemTreasureChest) == 0x0000A8, "Member 'UUIFieldTopMenu::ItemTreasureChest' has a wrong offset!");

// Class Nicola.InterfaceGameDataProgressEventReceiver
// 0x0000 (0x0028 - 0x0028)
class IInterfaceGameDataProgressEventReceiver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterfaceGameDataProgressEventReceiver">();
	}
	static class IInterfaceGameDataProgressEventReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterfaceGameDataProgressEventReceiver>();
	}
};
static_assert(alignof(IInterfaceGameDataProgressEventReceiver) == 0x000008, "Wrong alignment on IInterfaceGameDataProgressEventReceiver");
static_assert(sizeof(IInterfaceGameDataProgressEventReceiver) == 0x000028, "Wrong size on IInterfaceGameDataProgressEventReceiver");

// Class Nicola.InterfaceMapTimeEventReceiver
// 0x0000 (0x0028 - 0x0028)
class IInterfaceMapTimeEventReceiver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterfaceMapTimeEventReceiver">();
	}
	static class IInterfaceMapTimeEventReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterfaceMapTimeEventReceiver>();
	}
};
static_assert(alignof(IInterfaceMapTimeEventReceiver) == 0x000008, "Wrong alignment on IInterfaceMapTimeEventReceiver");
static_assert(sizeof(IInterfaceMapTimeEventReceiver) == 0x000028, "Wrong size on IInterfaceMapTimeEventReceiver");

// Class Nicola.InterfaceSoundAmbientEventReceiver
// 0x0000 (0x0028 - 0x0028)
class IInterfaceSoundAmbientEventReceiver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterfaceSoundAmbientEventReceiver">();
	}
	static class IInterfaceSoundAmbientEventReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterfaceSoundAmbientEventReceiver>();
	}
};
static_assert(alignof(IInterfaceSoundAmbientEventReceiver) == 0x000008, "Wrong alignment on IInterfaceSoundAmbientEventReceiver");
static_assert(sizeof(IInterfaceSoundAmbientEventReceiver) == 0x000028, "Wrong size on IInterfaceSoundAmbientEventReceiver");

// Class Nicola.NicolaDataAssetCommon
// 0x0470 (0x04A0 - 0x0030)
class UNicolaDataAssetCommon final : public UNicolaDataAssetBase
{
public:
	float                                         FlipbookLocationGap;                               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlipbookOffsetPowerToScreenCenterByCameraAngle;    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlipbookOffsetToCenterByCameraAngle;               // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             FlipbookOffsetYByCameraAngleCurveObject;           // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             FlipbookScalingByCameraAngleCurveObject;           // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             FlipbookCircleShadowOpacityByCameraAngleCurveObject; // 0x0090(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EAnimationType>                        FlipbookPreLoadedAnimationTypesCommon;             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EAnimationType>                        FlipbookPreLoadedAnimationTypesForPlayer;          // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BP_SearchObjectItem;                               // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LuidaRegistrationNumMax;                           // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LuidaStandbyNumMax;                                // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PoisonDistanceCount;                               // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ParalysisHealDistanceSeedMax;                      // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ParalysisHealDistanceSeedMin;                      // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RockHoldOnTime;                                    // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RockMovableFloorAngle;                             // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnTileInhaleSpeed;                               // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnTileExhaleSpeed;                               // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlinkCycleSecFieldPoisonDamage;                    // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BlinkColorFieldPoisonDamage;                       // 0x0128(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlinkCycleSecFieldBarrierDamage;                   // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BlinkColorFieldBarrierDamage;                      // 0x0138(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InpasuColorBlue;                                   // 0x0144(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InpasuColorRed;                                    // 0x0150(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InpasuColorYellow;                                 // 0x015C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              UpperWorldBasePosition;                            // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              UpperWorldGridCount;                               // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              UpperWorldOneGridSize;                             // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              UnderWorldBasePosition;                            // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              UnderWorldGridCount;                               // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              UnderWorldOneGridSize;                             // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UnderWorldRadius;                                  // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         seaHeight;                                         // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         lamiaFlyHeightMin;                                 // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         levelStreamingOffsetDist;                          // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperWorldSkySphereRadius;                         // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UnderWorldSkySphereRadius;                         // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperWorldDistFromBorderStartChangeEffectParam;    // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperWorldDistFromBorderEndChangeEffectParam;      // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             ActorFadingCurveObject;                            // 0x01B8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActorFadingTime;                                   // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartActorFadingDistanceFromCamera;                // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActorFadingOffsetDepth;                            // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TryCatchingFadingActorTime;                        // 0x01EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SwayAnimNeedLoopCountMin;                          // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SwayAnimNeedLoopCountMax;                          // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ShadowOffsetDefault;                               // 0x01F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ShadowRotationDefault;                             // 0x0204(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ShadowOffsetEvening;                               // 0x0210(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ShadowRotationEvening;                             // 0x021C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             LanternCurve;                                      // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   LanternLight;                                      // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         decalShadowFadeTime;                               // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         decalShadowFadeDistance;                           // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalStatusEffectAtField;                       // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleStatusEffectAtField;                          // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OffsetPoisonStatusEffectOnShip;                    // 0x0288(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OffsetParalyzeStatusEffectOnShip;                  // 0x0294(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> mapLocalPostProcessMaterials;                      // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BattleSequencerPostProcessVolumeClass;             // 0x02B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EventSequencerPostProcessVolumeClass;              // 0x02D8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      trapZonePostProcessMaterial;                       // 0x0300(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      travelDoorPostProcessMaterial;                     // 0x0328(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      RanarutaPostProcessMaterial_DayToNight;            // 0x0350(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      RanarutaPostProcessMaterial_NightToDay;            // 0x0378(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             ParameterCurve_Cycle_RanarutaPostProcessMaterial_DayToNight; // 0x03A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             ParameterCurve_DarkOut_RanarutaPostProcessMaterial_DayToNight; // 0x03C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             ParameterCurve_Cycle_RanarutaPostProcessMaterial_NightToDay; // 0x03F0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             ParameterCurve_DarkOut_RanarutaPostProcessMaterial_NightToDay; // 0x0418(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      sepiaPostProcessMaterial;                          // 0x0440(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      recollectionPostProcessMaterial;                   // 0x0468(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapTransitionMarginSecBlackout;                    // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelDoorFadeTime;                                // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapTransitionFadeTime;                             // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelDoorEffectTime;                              // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetCommon">();
	}
	static class UNicolaDataAssetCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetCommon>();
	}
};
static_assert(alignof(UNicolaDataAssetCommon) == 0x000008, "Wrong alignment on UNicolaDataAssetCommon");
static_assert(sizeof(UNicolaDataAssetCommon) == 0x0004A0, "Wrong size on UNicolaDataAssetCommon");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookLocationGap) == 0x000030, "Member 'UNicolaDataAssetCommon::FlipbookLocationGap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookOffsetPowerToScreenCenterByCameraAngle) == 0x000034, "Member 'UNicolaDataAssetCommon::FlipbookOffsetPowerToScreenCenterByCameraAngle' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookOffsetToCenterByCameraAngle) == 0x000038, "Member 'UNicolaDataAssetCommon::FlipbookOffsetToCenterByCameraAngle' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookOffsetYByCameraAngleCurveObject) == 0x000040, "Member 'UNicolaDataAssetCommon::FlipbookOffsetYByCameraAngleCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookScalingByCameraAngleCurveObject) == 0x000068, "Member 'UNicolaDataAssetCommon::FlipbookScalingByCameraAngleCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookCircleShadowOpacityByCameraAngleCurveObject) == 0x000090, "Member 'UNicolaDataAssetCommon::FlipbookCircleShadowOpacityByCameraAngleCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookPreLoadedAnimationTypesCommon) == 0x0000B8, "Member 'UNicolaDataAssetCommon::FlipbookPreLoadedAnimationTypesCommon' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, FlipbookPreLoadedAnimationTypesForPlayer) == 0x0000C8, "Member 'UNicolaDataAssetCommon::FlipbookPreLoadedAnimationTypesForPlayer' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, BP_SearchObjectItem) == 0x0000D8, "Member 'UNicolaDataAssetCommon::BP_SearchObjectItem' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, LuidaRegistrationNumMax) == 0x000100, "Member 'UNicolaDataAssetCommon::LuidaRegistrationNumMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, LuidaStandbyNumMax) == 0x000104, "Member 'UNicolaDataAssetCommon::LuidaStandbyNumMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, PoisonDistanceCount) == 0x000108, "Member 'UNicolaDataAssetCommon::PoisonDistanceCount' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ParalysisHealDistanceSeedMax) == 0x00010C, "Member 'UNicolaDataAssetCommon::ParalysisHealDistanceSeedMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ParalysisHealDistanceSeedMin) == 0x000110, "Member 'UNicolaDataAssetCommon::ParalysisHealDistanceSeedMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, RockHoldOnTime) == 0x000114, "Member 'UNicolaDataAssetCommon::RockHoldOnTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, RockMovableFloorAngle) == 0x000118, "Member 'UNicolaDataAssetCommon::RockMovableFloorAngle' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, TurnTileInhaleSpeed) == 0x00011C, "Member 'UNicolaDataAssetCommon::TurnTileInhaleSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, TurnTileExhaleSpeed) == 0x000120, "Member 'UNicolaDataAssetCommon::TurnTileExhaleSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, BlinkCycleSecFieldPoisonDamage) == 0x000124, "Member 'UNicolaDataAssetCommon::BlinkCycleSecFieldPoisonDamage' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, BlinkColorFieldPoisonDamage) == 0x000128, "Member 'UNicolaDataAssetCommon::BlinkColorFieldPoisonDamage' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, BlinkCycleSecFieldBarrierDamage) == 0x000134, "Member 'UNicolaDataAssetCommon::BlinkCycleSecFieldBarrierDamage' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, BlinkColorFieldBarrierDamage) == 0x000138, "Member 'UNicolaDataAssetCommon::BlinkColorFieldBarrierDamage' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, InpasuColorBlue) == 0x000144, "Member 'UNicolaDataAssetCommon::InpasuColorBlue' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, InpasuColorRed) == 0x000150, "Member 'UNicolaDataAssetCommon::InpasuColorRed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, InpasuColorYellow) == 0x00015C, "Member 'UNicolaDataAssetCommon::InpasuColorYellow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UpperWorldBasePosition) == 0x000168, "Member 'UNicolaDataAssetCommon::UpperWorldBasePosition' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UpperWorldGridCount) == 0x000170, "Member 'UNicolaDataAssetCommon::UpperWorldGridCount' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UpperWorldOneGridSize) == 0x000178, "Member 'UNicolaDataAssetCommon::UpperWorldOneGridSize' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UnderWorldBasePosition) == 0x000180, "Member 'UNicolaDataAssetCommon::UnderWorldBasePosition' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UnderWorldGridCount) == 0x000188, "Member 'UNicolaDataAssetCommon::UnderWorldGridCount' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UnderWorldOneGridSize) == 0x000190, "Member 'UNicolaDataAssetCommon::UnderWorldOneGridSize' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UnderWorldRadius) == 0x000198, "Member 'UNicolaDataAssetCommon::UnderWorldRadius' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, seaHeight) == 0x00019C, "Member 'UNicolaDataAssetCommon::seaHeight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, lamiaFlyHeightMin) == 0x0001A0, "Member 'UNicolaDataAssetCommon::lamiaFlyHeightMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, levelStreamingOffsetDist) == 0x0001A4, "Member 'UNicolaDataAssetCommon::levelStreamingOffsetDist' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UpperWorldSkySphereRadius) == 0x0001A8, "Member 'UNicolaDataAssetCommon::UpperWorldSkySphereRadius' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UnderWorldSkySphereRadius) == 0x0001AC, "Member 'UNicolaDataAssetCommon::UnderWorldSkySphereRadius' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UpperWorldDistFromBorderStartChangeEffectParam) == 0x0001B0, "Member 'UNicolaDataAssetCommon::UpperWorldDistFromBorderStartChangeEffectParam' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, UpperWorldDistFromBorderEndChangeEffectParam) == 0x0001B4, "Member 'UNicolaDataAssetCommon::UpperWorldDistFromBorderEndChangeEffectParam' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ActorFadingCurveObject) == 0x0001B8, "Member 'UNicolaDataAssetCommon::ActorFadingCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ActorFadingTime) == 0x0001E0, "Member 'UNicolaDataAssetCommon::ActorFadingTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, StartActorFadingDistanceFromCamera) == 0x0001E4, "Member 'UNicolaDataAssetCommon::StartActorFadingDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ActorFadingOffsetDepth) == 0x0001E8, "Member 'UNicolaDataAssetCommon::ActorFadingOffsetDepth' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, TryCatchingFadingActorTime) == 0x0001EC, "Member 'UNicolaDataAssetCommon::TryCatchingFadingActorTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, SwayAnimNeedLoopCountMin) == 0x0001F0, "Member 'UNicolaDataAssetCommon::SwayAnimNeedLoopCountMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, SwayAnimNeedLoopCountMax) == 0x0001F4, "Member 'UNicolaDataAssetCommon::SwayAnimNeedLoopCountMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ShadowOffsetDefault) == 0x0001F8, "Member 'UNicolaDataAssetCommon::ShadowOffsetDefault' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ShadowRotationDefault) == 0x000204, "Member 'UNicolaDataAssetCommon::ShadowRotationDefault' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ShadowOffsetEvening) == 0x000210, "Member 'UNicolaDataAssetCommon::ShadowOffsetEvening' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ShadowRotationEvening) == 0x00021C, "Member 'UNicolaDataAssetCommon::ShadowRotationEvening' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, LanternCurve) == 0x000228, "Member 'UNicolaDataAssetCommon::LanternCurve' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, LanternLight) == 0x000250, "Member 'UNicolaDataAssetCommon::LanternLight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, decalShadowFadeTime) == 0x000278, "Member 'UNicolaDataAssetCommon::decalShadowFadeTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, decalShadowFadeDistance) == 0x00027C, "Member 'UNicolaDataAssetCommon::decalShadowFadeDistance' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, IntervalStatusEffectAtField) == 0x000280, "Member 'UNicolaDataAssetCommon::IntervalStatusEffectAtField' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ScaleStatusEffectAtField) == 0x000284, "Member 'UNicolaDataAssetCommon::ScaleStatusEffectAtField' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, OffsetPoisonStatusEffectOnShip) == 0x000288, "Member 'UNicolaDataAssetCommon::OffsetPoisonStatusEffectOnShip' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, OffsetParalyzeStatusEffectOnShip) == 0x000294, "Member 'UNicolaDataAssetCommon::OffsetParalyzeStatusEffectOnShip' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, mapLocalPostProcessMaterials) == 0x0002A0, "Member 'UNicolaDataAssetCommon::mapLocalPostProcessMaterials' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, BattleSequencerPostProcessVolumeClass) == 0x0002B0, "Member 'UNicolaDataAssetCommon::BattleSequencerPostProcessVolumeClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, EventSequencerPostProcessVolumeClass) == 0x0002D8, "Member 'UNicolaDataAssetCommon::EventSequencerPostProcessVolumeClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, trapZonePostProcessMaterial) == 0x000300, "Member 'UNicolaDataAssetCommon::trapZonePostProcessMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, travelDoorPostProcessMaterial) == 0x000328, "Member 'UNicolaDataAssetCommon::travelDoorPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, RanarutaPostProcessMaterial_DayToNight) == 0x000350, "Member 'UNicolaDataAssetCommon::RanarutaPostProcessMaterial_DayToNight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, RanarutaPostProcessMaterial_NightToDay) == 0x000378, "Member 'UNicolaDataAssetCommon::RanarutaPostProcessMaterial_NightToDay' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ParameterCurve_Cycle_RanarutaPostProcessMaterial_DayToNight) == 0x0003A0, "Member 'UNicolaDataAssetCommon::ParameterCurve_Cycle_RanarutaPostProcessMaterial_DayToNight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ParameterCurve_DarkOut_RanarutaPostProcessMaterial_DayToNight) == 0x0003C8, "Member 'UNicolaDataAssetCommon::ParameterCurve_DarkOut_RanarutaPostProcessMaterial_DayToNight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ParameterCurve_Cycle_RanarutaPostProcessMaterial_NightToDay) == 0x0003F0, "Member 'UNicolaDataAssetCommon::ParameterCurve_Cycle_RanarutaPostProcessMaterial_NightToDay' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, ParameterCurve_DarkOut_RanarutaPostProcessMaterial_NightToDay) == 0x000418, "Member 'UNicolaDataAssetCommon::ParameterCurve_DarkOut_RanarutaPostProcessMaterial_NightToDay' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, sepiaPostProcessMaterial) == 0x000440, "Member 'UNicolaDataAssetCommon::sepiaPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, recollectionPostProcessMaterial) == 0x000468, "Member 'UNicolaDataAssetCommon::recollectionPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, MapTransitionMarginSecBlackout) == 0x000490, "Member 'UNicolaDataAssetCommon::MapTransitionMarginSecBlackout' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, TravelDoorFadeTime) == 0x000494, "Member 'UNicolaDataAssetCommon::TravelDoorFadeTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, MapTransitionFadeTime) == 0x000498, "Member 'UNicolaDataAssetCommon::MapTransitionFadeTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCommon, TravelDoorEffectTime) == 0x00049C, "Member 'UNicolaDataAssetCommon::TravelDoorEffectTime' has a wrong offset!");

// Class Nicola.InterfaceTickableWidget
// 0x0000 (0x0028 - 0x0028)
class IInterfaceTickableWidget final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterfaceTickableWidget">();
	}
	static class IInterfaceTickableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterfaceTickableWidget>();
	}
};
static_assert(alignof(IInterfaceTickableWidget) == 0x000008, "Wrong alignment on IInterfaceTickableWidget");
static_assert(sizeof(IInterfaceTickableWidget) == 0x000028, "Wrong size on IInterfaceTickableWidget");

// Class Nicola.UIListItemText3
// 0x0010 (0x0068 - 0x0058)
class UUIListItemText3 final : public UUIListItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemText3">();
	}
	static class UUIListItemText3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemText3>();
	}
};
static_assert(alignof(UUIListItemText3) == 0x000008, "Wrong alignment on UUIListItemText3");
static_assert(sizeof(UUIListItemText3) == 0x000068, "Wrong size on UUIListItemText3");
static_assert(offsetof(UUIListItemText3, TextItem2) == 0x000058, "Member 'UUIListItemText3::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIListItemText3, TextItem3) == 0x000060, "Member 'UUIListItemText3::TextItem3' has a wrong offset!");

// Class Nicola.InterpFloat
// 0x0060 (0x0088 - 0x0028)
class UInterpFloat final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelTransition(bool bCallDelegate);
	void Clamp(float NewClampValueMin, float NewClampValueMax);
	void SetCurrentValue(float NewCurrentValue);
	void StartTransition(float NewTargetValue, float NewDurationSec);

	float GetCurrentValue() const;
	bool IsOnTransition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpFloat">();
	}
	static class UInterpFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpFloat>();
	}
};
static_assert(alignof(UInterpFloat) == 0x000008, "Wrong alignment on UInterpFloat");
static_assert(sizeof(UInterpFloat) == 0x000088, "Wrong size on UInterpFloat");

// Class Nicola.NicolaDataAssetSoundFieldAmbient
// 0x00D8 (0x0108 - 0x0030)
class UNicolaDataAssetSoundFieldAmbient final : public UNicolaDataAssetBase
{
public:
	TSoftObjectPtr<class UCurveFloat>             CoastCurveVolumeRateByDinstance;                   // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPhysicalSurface, class FName>           GopIdsSEField;                                     // 0x0058(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ESoundAmbientCoastType, class FName>     GopIdsSEFieldForCoast;                             // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TimeAmbientSoundFadeOutSec;                        // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeWaitSoundPlayableSec;                          // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeAmbientSoundFadeInSec;                         // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetSoundFieldAmbient">();
	}
	static class UNicolaDataAssetSoundFieldAmbient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetSoundFieldAmbient>();
	}
};
static_assert(alignof(UNicolaDataAssetSoundFieldAmbient) == 0x000008, "Wrong alignment on UNicolaDataAssetSoundFieldAmbient");
static_assert(sizeof(UNicolaDataAssetSoundFieldAmbient) == 0x000108, "Wrong size on UNicolaDataAssetSoundFieldAmbient");
static_assert(offsetof(UNicolaDataAssetSoundFieldAmbient, CoastCurveVolumeRateByDinstance) == 0x000030, "Member 'UNicolaDataAssetSoundFieldAmbient::CoastCurveVolumeRateByDinstance' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundFieldAmbient, GopIdsSEField) == 0x000058, "Member 'UNicolaDataAssetSoundFieldAmbient::GopIdsSEField' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundFieldAmbient, GopIdsSEFieldForCoast) == 0x0000A8, "Member 'UNicolaDataAssetSoundFieldAmbient::GopIdsSEFieldForCoast' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundFieldAmbient, TimeAmbientSoundFadeOutSec) == 0x0000F8, "Member 'UNicolaDataAssetSoundFieldAmbient::TimeAmbientSoundFadeOutSec' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundFieldAmbient, TimeWaitSoundPlayableSec) == 0x0000FC, "Member 'UNicolaDataAssetSoundFieldAmbient::TimeWaitSoundPlayableSec' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundFieldAmbient, TimeAmbientSoundFadeInSec) == 0x000100, "Member 'UNicolaDataAssetSoundFieldAmbient::TimeAmbientSoundFadeInSec' has a wrong offset!");

// Class Nicola.LadderGimmick
// 0x0008 (0x0268 - 0x0260)
class ALadderGimmick final : public ALadderGimmickBase
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderGimmick">();
	}
	static class ALadderGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadderGimmick>();
	}
};
static_assert(alignof(ALadderGimmick) == 0x000008, "Wrong alignment on ALadderGimmick");
static_assert(sizeof(ALadderGimmick) == 0x000268, "Wrong size on ALadderGimmick");
static_assert(offsetof(ALadderGimmick, Mesh) == 0x000260, "Member 'ALadderGimmick::Mesh' has a wrong offset!");

// Class Nicola.NicolaDataAssetLevelCommon
// 0x0000 (0x0030 - 0x0030)
class UNicolaDataAssetLevelCommon final : public UNicolaDataAssetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetLevelCommon">();
	}
	static class UNicolaDataAssetLevelCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetLevelCommon>();
	}
};
static_assert(alignof(UNicolaDataAssetLevelCommon) == 0x000008, "Wrong alignment on UNicolaDataAssetLevelCommon");
static_assert(sizeof(UNicolaDataAssetLevelCommon) == 0x000030, "Wrong size on UNicolaDataAssetLevelCommon");

// Class Nicola.UIMBRBattleEncountMenuWindow
// 0x0018 (0x0088 - 0x0070)
class UUIMBRBattleEncountMenuWindow final : public UUICtrlBase
{
public:
	class UImage*                                 ImageFight1;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageFight2;                                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleEncountMenuWindow">();
	}
	static class UUIMBRBattleEncountMenuWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleEncountMenuWindow>();
	}
};
static_assert(alignof(UUIMBRBattleEncountMenuWindow) == 0x000008, "Wrong alignment on UUIMBRBattleEncountMenuWindow");
static_assert(sizeof(UUIMBRBattleEncountMenuWindow) == 0x000088, "Wrong size on UUIMBRBattleEncountMenuWindow");
static_assert(offsetof(UUIMBRBattleEncountMenuWindow, ImageFight1) == 0x000070, "Member 'UUIMBRBattleEncountMenuWindow::ImageFight1' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleEncountMenuWindow, ImageFight2) == 0x000078, "Member 'UUIMBRBattleEncountMenuWindow::ImageFight2' has a wrong offset!");

// Class Nicola.LandingAttributeVolumeForFieldSymbolBox
// 0x0000 (0x0268 - 0x0268)
class ALandingAttributeVolumeForFieldSymbolBox : public ALandingAttributeVolumeForFieldSymbolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingAttributeVolumeForFieldSymbolBox">();
	}
	static class ALandingAttributeVolumeForFieldSymbolBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandingAttributeVolumeForFieldSymbolBox>();
	}
};
static_assert(alignof(ALandingAttributeVolumeForFieldSymbolBox) == 0x000008, "Wrong alignment on ALandingAttributeVolumeForFieldSymbolBox");
static_assert(sizeof(ALandingAttributeVolumeForFieldSymbolBox) == 0x000268, "Wrong size on ALandingAttributeVolumeForFieldSymbolBox");

// Class Nicola.NicolaDataAssetBattle
// 0x0570 (0x05A0 - 0x0030)
class UNicolaDataAssetBattle final : public UNicolaDataAssetBase
{
public:
	TSoftClassPtr<class UClass>                   battlePawn;                                        // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   calcEncountActor;                                  // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBattleCameraSetting> CameraSettings;                                    // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          battleCommonLevels;                                // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          battleRoadCommonLevels;                            // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   testWidget;                                        // 0x00F0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   testWidgetMenu;                                    // 0x0118(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   testWidgetButton;                                  // 0x0140(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         speedSetting_Fast;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         speedSetting_VeryFast;                             // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         bigDamageThresholdMin;                             // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         bigDamageThresholdRate;                            // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MerchantAddGoldRate;                               // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MerchantAddGold;                                   // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShiefStealRate;                                    // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 TurnSleepOff;                                      // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AttackSleepOff;                                    // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackConfuseOff;                                  // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitiativeEnemyActionRate;                         // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitiativeEnemyActionMinNum;                       // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 RunAwayRate;                                       // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         RunAwayFailedEnemyActionRate;                      // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RunAwayFailedEnemyActionMinNum;                    // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RunAwaySuccessLvDiff;                              // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OrderWeights;                                      // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 OrderReverseWeights;                               // 0x01D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         HardModeGetEXPRate;                                // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HardModeGetGoldRate;                               // 0x01EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HardModeWeakRate;                                  // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HardModeBossHPRate;                                // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EWeaponType>                           OrdealWeaponTypes_A;                               // 0x01F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EWeaponType>                           OrdealWeaponTypes_B;                               // 0x0208(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         OrdealAttackDamageRate;                            // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OrdealDefenseDamageRate;                           // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> encounterPostProcessMaterials;                     // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      crossFadePostProcessMaterial;                      // 0x0230(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBattleEffectSetting                   BattleEffectSetting;                               // 0x0258(0x01D0)(Edit, Protected, NativeAccessSpecifierProtected)
	class FName                                   effectAssetTableIdSphereOfLight;                   // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   effectBattleIdDarkAura;                            // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   effectBattleIdOrdealDebuff;                        // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   effectAssetTableIdBlackFog;                        // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   sequenceBattleIdFinishBlow;                        // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   sequenceBattleIdSphereOfLight;                     // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   sequenceBattleIdZomaHadou;                         // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EBattleMoveType, TSoftObjectPtr<class UCurveFloat>> BattleMoveCurveMap;                                // 0x0460(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             MoveEffectEndLocationCurve;                        // 0x04B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         changeCameraEffectSec;                             // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         crossFadeSec;                                      // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   battleSceneCaptureActorClass;                      // 0x04E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SceneCapture;                                      // 0x0508(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      settingThresholdValueArray;                        // 0x0530(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      formationMinimumGuaranteeSizeArray;                // 0x0540(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   coffinActorClass;                                  // 0x0550(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             LightIntensityChangeCurve;                         // 0x0578(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetBattle">();
	}
	static class UNicolaDataAssetBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetBattle>();
	}
};
static_assert(alignof(UNicolaDataAssetBattle) == 0x000008, "Wrong alignment on UNicolaDataAssetBattle");
static_assert(sizeof(UNicolaDataAssetBattle) == 0x0005A0, "Wrong size on UNicolaDataAssetBattle");
static_assert(offsetof(UNicolaDataAssetBattle, battlePawn) == 0x000030, "Member 'UNicolaDataAssetBattle::battlePawn' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, calcEncountActor) == 0x000058, "Member 'UNicolaDataAssetBattle::calcEncountActor' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, CameraSettings) == 0x000080, "Member 'UNicolaDataAssetBattle::CameraSettings' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, battleCommonLevels) == 0x0000D0, "Member 'UNicolaDataAssetBattle::battleCommonLevels' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, battleRoadCommonLevels) == 0x0000E0, "Member 'UNicolaDataAssetBattle::battleRoadCommonLevels' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, testWidget) == 0x0000F0, "Member 'UNicolaDataAssetBattle::testWidget' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, testWidgetMenu) == 0x000118, "Member 'UNicolaDataAssetBattle::testWidgetMenu' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, testWidgetButton) == 0x000140, "Member 'UNicolaDataAssetBattle::testWidgetButton' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, speedSetting_Fast) == 0x000168, "Member 'UNicolaDataAssetBattle::speedSetting_Fast' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, speedSetting_VeryFast) == 0x00016C, "Member 'UNicolaDataAssetBattle::speedSetting_VeryFast' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, bigDamageThresholdMin) == 0x000170, "Member 'UNicolaDataAssetBattle::bigDamageThresholdMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, bigDamageThresholdRate) == 0x000174, "Member 'UNicolaDataAssetBattle::bigDamageThresholdRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, MerchantAddGoldRate) == 0x000178, "Member 'UNicolaDataAssetBattle::MerchantAddGoldRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, MerchantAddGold) == 0x00017C, "Member 'UNicolaDataAssetBattle::MerchantAddGold' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, ShiefStealRate) == 0x000180, "Member 'UNicolaDataAssetBattle::ShiefStealRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, TurnSleepOff) == 0x000188, "Member 'UNicolaDataAssetBattle::TurnSleepOff' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, AttackSleepOff) == 0x000198, "Member 'UNicolaDataAssetBattle::AttackSleepOff' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, AttackConfuseOff) == 0x00019C, "Member 'UNicolaDataAssetBattle::AttackConfuseOff' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, InitiativeEnemyActionRate) == 0x0001A0, "Member 'UNicolaDataAssetBattle::InitiativeEnemyActionRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, InitiativeEnemyActionMinNum) == 0x0001A4, "Member 'UNicolaDataAssetBattle::InitiativeEnemyActionMinNum' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, RunAwayRate) == 0x0001A8, "Member 'UNicolaDataAssetBattle::RunAwayRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, RunAwayFailedEnemyActionRate) == 0x0001B8, "Member 'UNicolaDataAssetBattle::RunAwayFailedEnemyActionRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, RunAwayFailedEnemyActionMinNum) == 0x0001BC, "Member 'UNicolaDataAssetBattle::RunAwayFailedEnemyActionMinNum' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, RunAwaySuccessLvDiff) == 0x0001C0, "Member 'UNicolaDataAssetBattle::RunAwaySuccessLvDiff' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, OrderWeights) == 0x0001C8, "Member 'UNicolaDataAssetBattle::OrderWeights' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, OrderReverseWeights) == 0x0001D8, "Member 'UNicolaDataAssetBattle::OrderReverseWeights' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, HardModeGetEXPRate) == 0x0001E8, "Member 'UNicolaDataAssetBattle::HardModeGetEXPRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, HardModeGetGoldRate) == 0x0001EC, "Member 'UNicolaDataAssetBattle::HardModeGetGoldRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, HardModeWeakRate) == 0x0001F0, "Member 'UNicolaDataAssetBattle::HardModeWeakRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, HardModeBossHPRate) == 0x0001F4, "Member 'UNicolaDataAssetBattle::HardModeBossHPRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, OrdealWeaponTypes_A) == 0x0001F8, "Member 'UNicolaDataAssetBattle::OrdealWeaponTypes_A' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, OrdealWeaponTypes_B) == 0x000208, "Member 'UNicolaDataAssetBattle::OrdealWeaponTypes_B' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, OrdealAttackDamageRate) == 0x000218, "Member 'UNicolaDataAssetBattle::OrdealAttackDamageRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, OrdealDefenseDamageRate) == 0x00021C, "Member 'UNicolaDataAssetBattle::OrdealDefenseDamageRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, encounterPostProcessMaterials) == 0x000220, "Member 'UNicolaDataAssetBattle::encounterPostProcessMaterials' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, crossFadePostProcessMaterial) == 0x000230, "Member 'UNicolaDataAssetBattle::crossFadePostProcessMaterial' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, BattleEffectSetting) == 0x000258, "Member 'UNicolaDataAssetBattle::BattleEffectSetting' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, effectAssetTableIdSphereOfLight) == 0x000428, "Member 'UNicolaDataAssetBattle::effectAssetTableIdSphereOfLight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, effectBattleIdDarkAura) == 0x000430, "Member 'UNicolaDataAssetBattle::effectBattleIdDarkAura' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, effectBattleIdOrdealDebuff) == 0x000438, "Member 'UNicolaDataAssetBattle::effectBattleIdOrdealDebuff' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, effectAssetTableIdBlackFog) == 0x000440, "Member 'UNicolaDataAssetBattle::effectAssetTableIdBlackFog' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, sequenceBattleIdFinishBlow) == 0x000448, "Member 'UNicolaDataAssetBattle::sequenceBattleIdFinishBlow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, sequenceBattleIdSphereOfLight) == 0x000450, "Member 'UNicolaDataAssetBattle::sequenceBattleIdSphereOfLight' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, sequenceBattleIdZomaHadou) == 0x000458, "Member 'UNicolaDataAssetBattle::sequenceBattleIdZomaHadou' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, BattleMoveCurveMap) == 0x000460, "Member 'UNicolaDataAssetBattle::BattleMoveCurveMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, MoveEffectEndLocationCurve) == 0x0004B0, "Member 'UNicolaDataAssetBattle::MoveEffectEndLocationCurve' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, changeCameraEffectSec) == 0x0004D8, "Member 'UNicolaDataAssetBattle::changeCameraEffectSec' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, crossFadeSec) == 0x0004DC, "Member 'UNicolaDataAssetBattle::crossFadeSec' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, battleSceneCaptureActorClass) == 0x0004E0, "Member 'UNicolaDataAssetBattle::battleSceneCaptureActorClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, SceneCapture) == 0x000508, "Member 'UNicolaDataAssetBattle::SceneCapture' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, settingThresholdValueArray) == 0x000530, "Member 'UNicolaDataAssetBattle::settingThresholdValueArray' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, formationMinimumGuaranteeSizeArray) == 0x000540, "Member 'UNicolaDataAssetBattle::formationMinimumGuaranteeSizeArray' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, coffinActorClass) == 0x000550, "Member 'UNicolaDataAssetBattle::coffinActorClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetBattle, LightIntensityChangeCurve) == 0x000578, "Member 'UNicolaDataAssetBattle::LightIntensityChangeCurve' has a wrong offset!");

// Class Nicola.LandingAttributeVolumeForFieldSymbolCapsule
// 0x0000 (0x0268 - 0x0268)
class ALandingAttributeVolumeForFieldSymbolCapsule final : public ALandingAttributeVolumeForFieldSymbolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingAttributeVolumeForFieldSymbolCapsule">();
	}
	static class ALandingAttributeVolumeForFieldSymbolCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandingAttributeVolumeForFieldSymbolCapsule>();
	}
};
static_assert(alignof(ALandingAttributeVolumeForFieldSymbolCapsule) == 0x000008, "Wrong alignment on ALandingAttributeVolumeForFieldSymbolCapsule");
static_assert(sizeof(ALandingAttributeVolumeForFieldSymbolCapsule) == 0x000268, "Wrong size on ALandingAttributeVolumeForFieldSymbolCapsule");

// Class Nicola.LanternManager
// 0x0088 (0x00B0 - 0x0028)
class alignas(0x10) ULanternManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APointLight*                            lightObject;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ANicolaCharacterBase*>           shadowCharacters;                                  // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ANicolaCharacterBase*                   reserveAttachLightCharacter;                       // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            curveAsset;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x58];                                      // 0x0058(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternManager">();
	}
	static class ULanternManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULanternManager>();
	}
};
static_assert(alignof(ULanternManager) == 0x000010, "Wrong alignment on ULanternManager");
static_assert(sizeof(ULanternManager) == 0x0000B0, "Wrong size on ULanternManager");
static_assert(offsetof(ULanternManager, lightObject) == 0x000030, "Member 'ULanternManager::lightObject' has a wrong offset!");
static_assert(offsetof(ULanternManager, shadowCharacters) == 0x000038, "Member 'ULanternManager::shadowCharacters' has a wrong offset!");
static_assert(offsetof(ULanternManager, reserveAttachLightCharacter) == 0x000048, "Member 'ULanternManager::reserveAttachLightCharacter' has a wrong offset!");
static_assert(offsetof(ULanternManager, curveAsset) == 0x000050, "Member 'ULanternManager::curveAsset' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuListTargetPlayerItem
// 0x0030 (0x0088 - 0x0058)
class UUIBattleUnitMenuListTargetPlayerItem final : public UUIListItem
{
public:
	class UImage*                                 ImagePlayer;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageStatus;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextLabel;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextNow;                                           // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextMax;                                           // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListTargetPlayerItem">();
	}
	static class UUIBattleUnitMenuListTargetPlayerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListTargetPlayerItem>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListTargetPlayerItem) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListTargetPlayerItem");
static_assert(sizeof(UUIBattleUnitMenuListTargetPlayerItem) == 0x000088, "Wrong size on UUIBattleUnitMenuListTargetPlayerItem");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayerItem, ImagePlayer) == 0x000058, "Member 'UUIBattleUnitMenuListTargetPlayerItem::ImagePlayer' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayerItem, ImageStatus) == 0x000060, "Member 'UUIBattleUnitMenuListTargetPlayerItem::ImageStatus' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayerItem, TextLabel) == 0x000068, "Member 'UUIBattleUnitMenuListTargetPlayerItem::TextLabel' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayerItem, TextNow) == 0x000070, "Member 'UUIBattleUnitMenuListTargetPlayerItem::TextNow' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayerItem, TextSlash) == 0x000078, "Member 'UUIBattleUnitMenuListTargetPlayerItem::TextSlash' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayerItem, TextMax) == 0x000080, "Member 'UUIBattleUnitMenuListTargetPlayerItem::TextMax' has a wrong offset!");

// Class Nicola.LevelFL
// 0x0000 (0x0028 - 0x0028)
class ULevelFL final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEndMakingMapData();
	static void ReturnTitle(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelFL">();
	}
	static class ULevelFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelFL>();
	}
};
static_assert(alignof(ULevelFL) == 0x000008, "Wrong alignment on ULevelFL");
static_assert(sizeof(ULevelFL) == 0x000028, "Wrong size on ULevelFL");

// Class Nicola.UIBattleStatusIconPanel
// 0x0040 (0x0098 - 0x0058)
class UUIBattleStatusIconPanel final : public UUIWindowBase
{
public:
	TArray<class UUIBattleStatusIconItem*>        WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleStatusIconPanel">();
	}
	static class UUIBattleStatusIconPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleStatusIconPanel>();
	}
};
static_assert(alignof(UUIBattleStatusIconPanel) == 0x000008, "Wrong alignment on UUIBattleStatusIconPanel");
static_assert(sizeof(UUIBattleStatusIconPanel) == 0x000098, "Wrong size on UUIBattleStatusIconPanel");
static_assert(offsetof(UUIBattleStatusIconPanel, WindowItems) == 0x000058, "Member 'UUIBattleStatusIconPanel::WindowItems' has a wrong offset!");

// Class Nicola.LightingFL
// 0x0000 (0x0028 - 0x0028)
class ULightingFL final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateVariation(class FName variationName);
	static void DeactivateVariation(class FName variationName);
	static void DebugCatchDirectionalLight();
	static void DebugCatchLightDirRotator();
	static float GetFieldSymbolLightingRate();
	static bool IsCatchingDirectionalLight();
	static bool IsCatchingLightDirRotator();
	static void ReleaseDirectionalLight();
	static void ReleaseLightDirRotator();
	static void RequestLightDirRotatorUpdating();
	static void SetDirectionalLightInfo(class FName MapId, EMapTimeFrame MapTime, class FName subLevelId);
	static void SetLightDirRotatorInfo(class FName MapId, EMapTimeFrame MapTime, class FName subLevelId);
	static void SetVisibleLightingActors(bool bVisible, bool bSetByRotator);
	static void UpdateFieldSymbolLighting(float lightingRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingFL">();
	}
	static class ULightingFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingFL>();
	}
};
static_assert(alignof(ULightingFL) == 0x000008, "Wrong alignment on ULightingFL");
static_assert(sizeof(ULightingFL) == 0x000028, "Wrong size on ULightingFL");

// Class Nicola.LoadableImage
// 0x0040 (0x0250 - 0x0210)
class ULoadableImage final : public UImage
{
public:
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITextureManager*                      TextureManager;                                    // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                LoadingWidget;                                     // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonWindowWidget*                    ParentWidget;                                      // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadableImage">();
	}
	static class ULoadableImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadableImage>();
	}
};
static_assert(alignof(ULoadableImage) == 0x000008, "Wrong alignment on ULoadableImage");
static_assert(sizeof(ULoadableImage) == 0x000250, "Wrong size on ULoadableImage");
static_assert(offsetof(ULoadableImage, TextureManager) == 0x000218, "Member 'ULoadableImage::TextureManager' has a wrong offset!");
static_assert(offsetof(ULoadableImage, LoadingWidget) == 0x000220, "Member 'ULoadableImage::LoadingWidget' has a wrong offset!");
static_assert(offsetof(ULoadableImage, ParentWidget) == 0x000240, "Member 'ULoadableImage::ParentWidget' has a wrong offset!");

// Class Nicola.UIBattleWindowStatus1
// 0x0020 (0x0078 - 0x0058)
class UUIBattleWindowStatus1 final : public UUIWindowBase
{
public:
	TArray<class UUIBattleWindowStatus1Player*>   Players;                                           // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIBattleStatusIconCtrl*                StatusIconCtrl;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleWindowStatus1">();
	}
	static class UUIBattleWindowStatus1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleWindowStatus1>();
	}
};
static_assert(alignof(UUIBattleWindowStatus1) == 0x000008, "Wrong alignment on UUIBattleWindowStatus1");
static_assert(sizeof(UUIBattleWindowStatus1) == 0x000078, "Wrong size on UUIBattleWindowStatus1");
static_assert(offsetof(UUIBattleWindowStatus1, Players) == 0x000058, "Member 'UUIBattleWindowStatus1::Players' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1, StatusIconCtrl) == 0x000068, "Member 'UUIBattleWindowStatus1::StatusIconCtrl' has a wrong offset!");

// Class Nicola.LuaAsset
// 0x0020 (0x0048 - 0x0028)
class ULuaAsset final : public UObject
{
public:
	class FString                                 Filename;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LuaSourceString;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaAsset">();
	}
	static class ULuaAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaAsset>();
	}
};
static_assert(alignof(ULuaAsset) == 0x000008, "Wrong alignment on ULuaAsset");
static_assert(sizeof(ULuaAsset) == 0x000048, "Wrong size on ULuaAsset");
static_assert(offsetof(ULuaAsset, Filename) == 0x000028, "Member 'ULuaAsset::Filename' has a wrong offset!");
static_assert(offsetof(ULuaAsset, LuaSourceString) == 0x000038, "Member 'ULuaAsset::LuaSourceString' has a wrong offset!");

// Class Nicola.LuaCompileFL
// 0x0000 (0x0028 - 0x0028)
class ULuaCompileFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaCompileFL">();
	}
	static class ULuaCompileFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaCompileFL>();
	}
};
static_assert(alignof(ULuaCompileFL) == 0x000008, "Wrong alignment on ULuaCompileFL");
static_assert(sizeof(ULuaCompileFL) == 0x000028, "Wrong size on ULuaCompileFL");

// Class Nicola.LuaFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULuaFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool BP_GetSystemFlag(int32 flagNo);
	static bool BP_GetSystemFlagByName(class FName FlagName);
	static void BP_SetSystemFlag(int32 flagNo, bool flag);
	static void BP_SetSystemFlagByName(class FName FlagName, bool flag);
	static void DebugAllEventPlay(const class FString& StartTitle);
	static void DebugChangeActorVisibility();
	static class FString FindLuaLevelScript(const class FString& levelName, bool* bExist);
	static ENicolaInputMode GetActionInputMode();
	static int32 GetSystemGlobalVariableByInteger(ELuaSysGlobal sysGlobalInfo);
	static int32 GetSystemVariableByInteger(ELuaSysInfo sysInfo);
	static class UDebugMenuResource* LoadTextResource(const class FString& dir, const class FString& fname, const class FString& outputText);
	static class FString OutputLuaFile(const class FString& dir, const class FString& fname, const class FString& outputText);
	static void ScenarioInitialize();
	static void SetBattleOrderCommandToLua();
	static void SetLuaLevelScript(const class FString& levelName, const class FString& ScriptName);
	static void SetMessageActionCommandToLua(const class FString& TagName, const class FString& Argment);
	static void SetMessageCommandToLua(const class FString& MessageCommand);
	static void SetStandByCommandToLua();
	static void SetSystemGlobalVariableByInteger(ELuaSysGlobal sysGlobalInfo, int32 Value);
	static void SetSystemVariableByInteger(ELuaSysInfo sysInfo, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaFunctionLibrary">();
	}
	static class ULuaFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaFunctionLibrary>();
	}
};
static_assert(alignof(ULuaFunctionLibrary) == 0x000008, "Wrong alignment on ULuaFunctionLibrary");
static_assert(sizeof(ULuaFunctionLibrary) == 0x000028, "Wrong size on ULuaFunctionLibrary");

// Class Nicola.UIFieldEquipMenuWindowAutoEquip
// 0x0018 (0x0070 - 0x0058)
class UUIFieldEquipMenuWindowAutoEquip final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGopTextBlock*                          ItemText;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWindowItemButtonLongPress*           ItemLongPress;                                     // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuWindowAutoEquip">();
	}
	static class UUIFieldEquipMenuWindowAutoEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuWindowAutoEquip>();
	}
};
static_assert(alignof(UUIFieldEquipMenuWindowAutoEquip) == 0x000008, "Wrong alignment on UUIFieldEquipMenuWindowAutoEquip");
static_assert(sizeof(UUIFieldEquipMenuWindowAutoEquip) == 0x000070, "Wrong size on UUIFieldEquipMenuWindowAutoEquip");
static_assert(offsetof(UUIFieldEquipMenuWindowAutoEquip, ItemText) == 0x000060, "Member 'UUIFieldEquipMenuWindowAutoEquip::ItemText' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuWindowAutoEquip, ItemLongPress) == 0x000068, "Member 'UUIFieldEquipMenuWindowAutoEquip::ItemLongPress' has a wrong offset!");

// Class Nicola.DebugMenuFlag
// 0x0020 (0x0048 - 0x0028)
class UDebugMenuFlag final : public UObject
{
public:
	int32                                         LuaIndex;                                          // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Key;                                               // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuFlag">();
	}
	static class UDebugMenuFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuFlag>();
	}
};
static_assert(alignof(UDebugMenuFlag) == 0x000008, "Wrong alignment on UDebugMenuFlag");
static_assert(sizeof(UDebugMenuFlag) == 0x000048, "Wrong size on UDebugMenuFlag");
static_assert(offsetof(UDebugMenuFlag, LuaIndex) == 0x000028, "Member 'UDebugMenuFlag::LuaIndex' has a wrong offset!");
static_assert(offsetof(UDebugMenuFlag, Key) == 0x000030, "Member 'UDebugMenuFlag::Key' has a wrong offset!");
static_assert(offsetof(UDebugMenuFlag, Value) == 0x000040, "Member 'UDebugMenuFlag::Value' has a wrong offset!");

// Class Nicola.UIBattleDamage
// 0x0018 (0x0088 - 0x0070)
class UUIBattleDamage final : public UUICtrlBase
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIBattleDamageViewItem*>        ViewItems;                                         // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleDamage">();
	}
	static class UUIBattleDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleDamage>();
	}
};
static_assert(alignof(UUIBattleDamage) == 0x000008, "Wrong alignment on UUIBattleDamage");
static_assert(sizeof(UUIBattleDamage) == 0x000088, "Wrong size on UUIBattleDamage");
static_assert(offsetof(UUIBattleDamage, CanvasPanel) == 0x000070, "Member 'UUIBattleDamage::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUIBattleDamage, ViewItems) == 0x000078, "Member 'UUIBattleDamage::ViewItems' has a wrong offset!");

// Class Nicola.DebugMenuItem
// 0x0048 (0x0070 - 0x0028)
class UDebugMenuItem final : public UObject
{
public:
	class UDebugMenuResource*                     child;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 levelName;                                         // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 luaFileName;                                       // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 luaEventName;                                      // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UDebugMenuResource* GetChildMenu() const;
	bool IsChildMenu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuItem">();
	}
	static class UDebugMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuItem>();
	}
};
static_assert(alignof(UDebugMenuItem) == 0x000008, "Wrong alignment on UDebugMenuItem");
static_assert(sizeof(UDebugMenuItem) == 0x000070, "Wrong size on UDebugMenuItem");
static_assert(offsetof(UDebugMenuItem, child) == 0x000028, "Member 'UDebugMenuItem::child' has a wrong offset!");
static_assert(offsetof(UDebugMenuItem, Text) == 0x000030, "Member 'UDebugMenuItem::Text' has a wrong offset!");
static_assert(offsetof(UDebugMenuItem, levelName) == 0x000040, "Member 'UDebugMenuItem::levelName' has a wrong offset!");
static_assert(offsetof(UDebugMenuItem, luaFileName) == 0x000050, "Member 'UDebugMenuItem::luaFileName' has a wrong offset!");
static_assert(offsetof(UDebugMenuItem, luaEventName) == 0x000060, "Member 'UDebugMenuItem::luaEventName' has a wrong offset!");

// Class Nicola.UIFieldMagicSkillMenu
// 0x0028 (0x00A0 - 0x0078)
class UUIFieldMagicSkillMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFieldMagicSkillMenuListTop*          ListTop;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldMagicSkillMenuListMagicSkill*   ListMagicSkill;                                    // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldMagicSkillMenuListSelectTarget* ListSelectTarget;                                  // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSub*             WindowSub;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMagicSkillMenu">();
	}
	static class UUIFieldMagicSkillMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMagicSkillMenu>();
	}
};
static_assert(alignof(UUIFieldMagicSkillMenu) == 0x000008, "Wrong alignment on UUIFieldMagicSkillMenu");
static_assert(sizeof(UUIFieldMagicSkillMenu) == 0x0000A0, "Wrong size on UUIFieldMagicSkillMenu");
static_assert(offsetof(UUIFieldMagicSkillMenu, ListTop) == 0x000080, "Member 'UUIFieldMagicSkillMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenu, ListMagicSkill) == 0x000088, "Member 'UUIFieldMagicSkillMenu::ListMagicSkill' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenu, ListSelectTarget) == 0x000090, "Member 'UUIFieldMagicSkillMenu::ListSelectTarget' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenu, WindowSub) == 0x000098, "Member 'UUIFieldMagicSkillMenu::WindowSub' has a wrong offset!");

// Class Nicola.LuaTriggerBox
// 0x0048 (0x0270 - 0x0228)
class ALuaTriggerBox final : public ATriggerBox
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FunctionName;                                      // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Arguments;                                         // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OnTalkOverLapEventCompatible;                      // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x1F];                                     // 0x0251(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaTriggerBox">();
	}
	static class ALuaTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALuaTriggerBox>();
	}
};
static_assert(alignof(ALuaTriggerBox) == 0x000008, "Wrong alignment on ALuaTriggerBox");
static_assert(sizeof(ALuaTriggerBox) == 0x000270, "Wrong size on ALuaTriggerBox");
static_assert(offsetof(ALuaTriggerBox, FunctionName) == 0x000230, "Member 'ALuaTriggerBox::FunctionName' has a wrong offset!");
static_assert(offsetof(ALuaTriggerBox, Arguments) == 0x000240, "Member 'ALuaTriggerBox::Arguments' has a wrong offset!");
static_assert(offsetof(ALuaTriggerBox, OnTalkOverLapEventCompatible) == 0x000250, "Member 'ALuaTriggerBox::OnTalkOverLapEventCompatible' has a wrong offset!");

// Class Nicola.LuaTriggerCapsule
// 0x0030 (0x0258 - 0x0228)
class ALuaTriggerCapsule final : public ATriggerCapsule
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FunctionName;                                      // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Arguments;                                         // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OnTalkOverLapEventCompatible;                      // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaTriggerCapsule">();
	}
	static class ALuaTriggerCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALuaTriggerCapsule>();
	}
};
static_assert(alignof(ALuaTriggerCapsule) == 0x000008, "Wrong alignment on ALuaTriggerCapsule");
static_assert(sizeof(ALuaTriggerCapsule) == 0x000258, "Wrong size on ALuaTriggerCapsule");
static_assert(offsetof(ALuaTriggerCapsule, FunctionName) == 0x000230, "Member 'ALuaTriggerCapsule::FunctionName' has a wrong offset!");
static_assert(offsetof(ALuaTriggerCapsule, Arguments) == 0x000240, "Member 'ALuaTriggerCapsule::Arguments' has a wrong offset!");
static_assert(offsetof(ALuaTriggerCapsule, OnTalkOverLapEventCompatible) == 0x000250, "Member 'ALuaTriggerCapsule::OnTalkOverLapEventCompatible' has a wrong offset!");

// Class Nicola.MakeMapsConfig
// 0x0030 (0x0060 - 0x0030)
class UMakeMapsConfig final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          Levels;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           MapIDs;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           BattleMapIDs;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakeMapsConfig">();
	}
	static class UMakeMapsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMakeMapsConfig>();
	}
};
static_assert(alignof(UMakeMapsConfig) == 0x000008, "Wrong alignment on UMakeMapsConfig");
static_assert(sizeof(UMakeMapsConfig) == 0x000060, "Wrong size on UMakeMapsConfig");
static_assert(offsetof(UMakeMapsConfig, Levels) == 0x000030, "Member 'UMakeMapsConfig::Levels' has a wrong offset!");
static_assert(offsetof(UMakeMapsConfig, MapIDs) == 0x000040, "Member 'UMakeMapsConfig::MapIDs' has a wrong offset!");
static_assert(offsetof(UMakeMapsConfig, BattleMapIDs) == 0x000050, "Member 'UMakeMapsConfig::BattleMapIDs' has a wrong offset!");

// Class Nicola.UIFieldPopup
// 0x0038 (0x00B0 - 0x0078)
class UUIFieldPopup final : public UUIRootBase
{
public:
	class UUIWindowItem*                          MemoryItem;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          GuideItem;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x28];                                      // 0x0088(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BPPlayPopup(int32 InNum);
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldPopup">();
	}
	static class UUIFieldPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldPopup>();
	}
};
static_assert(alignof(UUIFieldPopup) == 0x000008, "Wrong alignment on UUIFieldPopup");
static_assert(sizeof(UUIFieldPopup) == 0x0000B0, "Wrong size on UUIFieldPopup");
static_assert(offsetof(UUIFieldPopup, MemoryItem) == 0x000078, "Member 'UUIFieldPopup::MemoryItem' has a wrong offset!");
static_assert(offsetof(UUIFieldPopup, GuideItem) == 0x000080, "Member 'UUIFieldPopup::GuideItem' has a wrong offset!");

// Class Nicola.MapFL
// 0x0000 (0x0028 - 0x0028)
class UMapFL final : public UBlueprintFunctionLibrary
{
public:
	static void AllPlayerStartOverlapTest_Debug();
	static bool CanLanding(EPhysicalSurface surfaceType);
	static bool CanSwim(EPhysicalSurface surfaceType);
	static bool CanWalk(EPhysicalSurface surfaceType);
	static void DecalTest_Debug();
	static struct FTransform GetActorLevelTransform(const class AActor* TARGET);
	static struct FTransform GetActorLevelTransformFromActorLocation(const class AActor* TARGET);
	static const class FName GetCurrentMapId();
	static class FString GetFloorMapName(const class FString& PrefixId);
	static class FName GetFloorMapNameID(const class FString& PrefixId);
	static void GetLanternTable(bool* outValidTable, struct FGOP_LanternTable* outTable);
	static void GetMapIdsByPrefixId(const class FName& PrefixId, TArray<class FName>* Result);
	static void GetMapPrefixIds(TArray<class FName>* Result);
	static bool SetActorLevelLocation(class AActor* TARGET, const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	static bool SetActorLevelLocationAndRotation(class AActor* TARGET, const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	static bool SetActorLevelRotation(class AActor* TARGET, const struct FRotator& NewRotation, bool bTeleportPhysics);
	static bool SetActorLevelTransform(class AActor* TARGET, const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	static void StartMapTransition(const class FName& MapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapFL">();
	}
	static class UMapFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapFL>();
	}
};
static_assert(alignof(UMapFL) == 0x000008, "Wrong alignment on UMapFL");
static_assert(sizeof(UMapFL) == 0x000028, "Wrong size on UMapFL");

// Class Nicola.MapTimeFL
// 0x0000 (0x0028 - 0x0028)
class UMapTimeFL final : public UBlueprintFunctionLibrary
{
public:
	static void GetEnableTimePassedFlags(bool& outIsInSystemProcessing, bool& outIsInEventProcessing, bool& outIsInBattle, bool& outIsInUIOpening, bool& outIsInUppergroundField);
	static EFieldTimeFrame GetFieldTimeFrame();
	static float GetMapMaterialTime();
	static EMapTimeFrame GetMapTimeFrame();
	static int32 GetMapTimeHour();
	static bool IsEnableTimePassed();
	static void SetFieldTimeFrame(EFieldTimeFrame FieldTimeFrame);
	static void SetMapTimeFrame(EMapTimeFrame MapTimeFrame);
	static void SetMapTimeHour(int32 hour);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTimeFL">();
	}
	static class UMapTimeFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapTimeFL>();
	}
};
static_assert(alignof(UMapTimeFL) == 0x000008, "Wrong alignment on UMapTimeFL");
static_assert(sizeof(UMapTimeFL) == 0x000028, "Wrong size on UMapTimeFL");

// Class Nicola.SwkbdManager
// 0x0028 (0x0058 - 0x0030)
class USwkbdManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USwkbdBase*                             SoftwareKeyboard;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwkbdManager">();
	}
	static class USwkbdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwkbdManager>();
	}
};
static_assert(alignof(USwkbdManager) == 0x000008, "Wrong alignment on USwkbdManager");
static_assert(sizeof(USwkbdManager) == 0x000058, "Wrong size on USwkbdManager");
static_assert(offsetof(USwkbdManager, SoftwareKeyboard) == 0x000050, "Member 'USwkbdManager::SoftwareKeyboard' has a wrong offset!");

// Class Nicola.UIBar2MenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUIBar2MenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TextColors;                                        // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListTop">();
	}
	static class UUIBar2MenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListTop>();
	}
};
static_assert(alignof(UUIBar2MenuListTop) == 0x000008, "Wrong alignment on UUIBar2MenuListTop");
static_assert(sizeof(UUIBar2MenuListTop) == 0x0000E8, "Wrong size on UUIBar2MenuListTop");
static_assert(offsetof(UUIBar2MenuListTop, TextColors) == 0x0000D8, "Member 'UUIBar2MenuListTop::TextColors' has a wrong offset!");

// Class Nicola.UISimpleLoadingMenu
// 0x0010 (0x0088 - 0x0078)
class UUISimpleLoadingMenu final : public UUIRootBase
{
public:
	class UCommonItemWidget*                      ItemWidget;                                        // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISimpleLoadingMenu">();
	}
	static class UUISimpleLoadingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISimpleLoadingMenu>();
	}
};
static_assert(alignof(UUISimpleLoadingMenu) == 0x000008, "Wrong alignment on UUISimpleLoadingMenu");
static_assert(sizeof(UUISimpleLoadingMenu) == 0x000088, "Wrong size on UUISimpleLoadingMenu");
static_assert(offsetof(UUISimpleLoadingMenu, ItemWidget) == 0x000078, "Member 'UUISimpleLoadingMenu::ItemWidget' has a wrong offset!");

// Class Nicola.MBREventTrigger
// 0x0008 (0x0100 - 0x00F8)
class UMBREventTrigger final : public UEventTriggerComponentBase
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBREventTrigger">();
	}
	static class UMBREventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBREventTrigger>();
	}
};
static_assert(alignof(UMBREventTrigger) == 0x000008, "Wrong alignment on UMBREventTrigger");
static_assert(sizeof(UMBREventTrigger) == 0x000100, "Wrong size on UMBREventTrigger");

// Class Nicola.UIChurchMenu
// 0x0448 (0x04C0 - 0x0078)
class UUIChurchMenu final : public UUIRootBase
{
public:
	class UUIChurchMenuListTop*                   ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveLoadList*                        ListSaveLoad;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIChurchMenuListPartyRevive*           ListPartyRevive;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIChurchMenuListPartyHeal*             ListPartyHeal;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     WindowMoney;                                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowBase*                          WindowSaving;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveGameDataFlow*                    FlowSaveGameData;                                  // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x410];                                     // 0x00B0(0x0410)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu(EChurchMenuMenuMode InMenuMode, class FName InGopId, int32 InCallMemberIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChurchMenu">();
	}
	static class UUIChurchMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChurchMenu>();
	}
};
static_assert(alignof(UUIChurchMenu) == 0x000008, "Wrong alignment on UUIChurchMenu");
static_assert(sizeof(UUIChurchMenu) == 0x0004C0, "Wrong size on UUIChurchMenu");
static_assert(offsetof(UUIChurchMenu, ListTop) == 0x000078, "Member 'UUIChurchMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIChurchMenu, ListSaveLoad) == 0x000080, "Member 'UUIChurchMenu::ListSaveLoad' has a wrong offset!");
static_assert(offsetof(UUIChurchMenu, ListPartyRevive) == 0x000088, "Member 'UUIChurchMenu::ListPartyRevive' has a wrong offset!");
static_assert(offsetof(UUIChurchMenu, ListPartyHeal) == 0x000090, "Member 'UUIChurchMenu::ListPartyHeal' has a wrong offset!");
static_assert(offsetof(UUIChurchMenu, WindowMoney) == 0x000098, "Member 'UUIChurchMenu::WindowMoney' has a wrong offset!");
static_assert(offsetof(UUIChurchMenu, WindowSaving) == 0x0000A0, "Member 'UUIChurchMenu::WindowSaving' has a wrong offset!");
static_assert(offsetof(UUIChurchMenu, FlowSaveGameData) == 0x0000A8, "Member 'UUIChurchMenu::FlowSaveGameData' has a wrong offset!");

// Class Nicola.MBRFailBoxComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRFailBoxComponent final : public UMBRBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRFailBoxComponent">();
	}
	static class UMBRFailBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRFailBoxComponent>();
	}
};
static_assert(alignof(UMBRFailBoxComponent) == 0x000010, "Wrong alignment on UMBRFailBoxComponent");
static_assert(sizeof(UMBRFailBoxComponent) == 0x000480, "Wrong size on UMBRFailBoxComponent");

// Class Nicola.MBRFailSphereComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRFailSphereComponent final : public UMBRSphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRFailSphereComponent">();
	}
	static class UMBRFailSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRFailSphereComponent>();
	}
};
static_assert(alignof(UMBRFailSphereComponent) == 0x000010, "Wrong alignment on UMBRFailSphereComponent");
static_assert(sizeof(UMBRFailSphereComponent) == 0x000480, "Wrong size on UMBRFailSphereComponent");

// Class Nicola.TownDungeonMapParameterCollection
// 0x0000 (0x0088 - 0x0088)
class UTownDungeonMapParameterCollection final : public UNicolaParameterCollectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownDungeonMapParameterCollection">();
	}
	static class UTownDungeonMapParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTownDungeonMapParameterCollection>();
	}
};
static_assert(alignof(UTownDungeonMapParameterCollection) == 0x000008, "Wrong alignment on UTownDungeonMapParameterCollection");
static_assert(sizeof(UTownDungeonMapParameterCollection) == 0x000088, "Wrong size on UTownDungeonMapParameterCollection");

// Class Nicola.UIBattleHideController
// 0x0020 (0x0090 - 0x0070)
class UUIBattleHideController final : public UUICtrlBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButton;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleHideController">();
	}
	static class UUIBattleHideController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleHideController>();
	}
};
static_assert(alignof(UUIBattleHideController) == 0x000008, "Wrong alignment on UUIBattleHideController");
static_assert(sizeof(UUIBattleHideController) == 0x000090, "Wrong size on UUIBattleHideController");
static_assert(offsetof(UUIBattleHideController, TextItem) == 0x000070, "Member 'UUIBattleHideController::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBattleHideController, ImageButton) == 0x000078, "Member 'UUIBattleHideController::ImageButton' has a wrong offset!");

// Class Nicola.MBRFailCapsuleComponent
// 0x0000 (0x0480 - 0x0480)
class UMBRFailCapsuleComponent final : public UMBRCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRFailCapsuleComponent">();
	}
	static class UMBRFailCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMBRFailCapsuleComponent>();
	}
};
static_assert(alignof(UMBRFailCapsuleComponent) == 0x000010, "Wrong alignment on UMBRFailCapsuleComponent");
static_assert(sizeof(UMBRFailCapsuleComponent) == 0x000480, "Wrong size on UMBRFailCapsuleComponent");

// Class Nicola.MBRTriggerCharaActor
// 0x0030 (0x0320 - 0x02F0)
class AMBRTriggerCharaActor final : public ATriggerCharaActor
{
public:
	class FName                                   MBRScoutId;                                        // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMBREventTrigger*                       MBREventTriggerComp;                               // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x20];                                     // 0x0300(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MBRTriggerCharaActor">();
	}
	static class AMBRTriggerCharaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMBRTriggerCharaActor>();
	}
};
static_assert(alignof(AMBRTriggerCharaActor) == 0x000008, "Wrong alignment on AMBRTriggerCharaActor");
static_assert(sizeof(AMBRTriggerCharaActor) == 0x000320, "Wrong size on AMBRTriggerCharaActor");
static_assert(offsetof(AMBRTriggerCharaActor, MBRScoutId) == 0x0002F0, "Member 'AMBRTriggerCharaActor::MBRScoutId' has a wrong offset!");
static_assert(offsetof(AMBRTriggerCharaActor, MBREventTriggerComp) == 0x0002F8, "Member 'AMBRTriggerCharaActor::MBREventTriggerComp' has a wrong offset!");

// Class Nicola.UIListItemText2
// 0x0008 (0x0060 - 0x0058)
class UUIListItemText2 : public UUIListItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemText2">();
	}
	static class UUIListItemText2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemText2>();
	}
};
static_assert(alignof(UUIListItemText2) == 0x000008, "Wrong alignment on UUIListItemText2");
static_assert(sizeof(UUIListItemText2) == 0x000060, "Wrong size on UUIListItemText2");
static_assert(offsetof(UUIListItemText2, TextItem2) == 0x000058, "Member 'UUIListItemText2::TextItem2' has a wrong offset!");

// Class Nicola.UIBattleTacticsListUnitItem
// 0x0008 (0x0068 - 0x0060)
class UUIBattleTacticsListUnitItem final : public UUIListItemText2
{
public:
	class UImage*                                 ImagePlayer;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTacticsListUnitItem">();
	}
	static class UUIBattleTacticsListUnitItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTacticsListUnitItem>();
	}
};
static_assert(alignof(UUIBattleTacticsListUnitItem) == 0x000008, "Wrong alignment on UUIBattleTacticsListUnitItem");
static_assert(sizeof(UUIBattleTacticsListUnitItem) == 0x000068, "Wrong size on UUIBattleTacticsListUnitItem");
static_assert(offsetof(UUIBattleTacticsListUnitItem, ImagePlayer) == 0x000060, "Member 'UUIBattleTacticsListUnitItem::ImagePlayer' has a wrong offset!");

// Class Nicola.NicolaAchievementManager
// 0x0038 (0x0060 - 0x0028)
class UNicolaAchievementManager final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UNicolaAchievementManager* GetInstance();

	void CountupAchievementValue(EAchievement AchievementID, int32 addValue);
	void DebugSetCountValue(EAchievement AchievementID, int32 InCount);
	bool IsUnlockedAchievement(EAchievement AchievementID);
	void OnFinishCacheAchievements(bool bSuccess);
	void OnStartCacheAchievements();
	void RequestResetAchievements(bool bResetCount);
	void RequestUnlockAchievement(EAchievement AchievementID);
	bool RequestUnlockAchievementIfAchievedCount(EAchievement AchievementID, int32 InCount);

	EAchievement DebugGetAchievementNameToEnum(const class FName& InName) const;
	int32 DebugGetCountLimit(EAchievement AchievementID) const;
	int32 DebugGetCountValue(EAchievement AchievementID) const;
	bool IsInitializedAchievementSystem() const;
	bool IsValidAchievement(EAchievement AchievementID, bool bValidPlatinum) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaAchievementManager">();
	}
	static class UNicolaAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaAchievementManager>();
	}
};
static_assert(alignof(UNicolaAchievementManager) == 0x000008, "Wrong alignment on UNicolaAchievementManager");
static_assert(sizeof(UNicolaAchievementManager) == 0x000060, "Wrong size on UNicolaAchievementManager");

// Class Nicola.SearchObjEventTrigger
// 0x0010 (0x0108 - 0x00F8)
class USearchObjEventTrigger : public UEventTriggerComponentBase
{
public:
	class FName                                   SearchObjEventGopId;                               // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsLookAtSearchObject;                              // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchObjEventTrigger">();
	}
	static class USearchObjEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchObjEventTrigger>();
	}
};
static_assert(alignof(USearchObjEventTrigger) == 0x000008, "Wrong alignment on USearchObjEventTrigger");
static_assert(sizeof(USearchObjEventTrigger) == 0x000108, "Wrong size on USearchObjEventTrigger");
static_assert(offsetof(USearchObjEventTrigger, SearchObjEventGopId) == 0x0000F8, "Member 'USearchObjEventTrigger::SearchObjEventGopId' has a wrong offset!");
static_assert(offsetof(USearchObjEventTrigger, IsLookAtSearchObject) == 0x000100, "Member 'USearchObjEventTrigger::IsLookAtSearchObject' has a wrong offset!");

// Class Nicola.ShineSearchObjTrigger
// 0x0000 (0x0108 - 0x0108)
class UShineSearchObjTrigger final : public USearchObjEventTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShineSearchObjTrigger">();
	}
	static class UShineSearchObjTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShineSearchObjTrigger>();
	}
};
static_assert(alignof(UShineSearchObjTrigger) == 0x000008, "Wrong alignment on UShineSearchObjTrigger");
static_assert(sizeof(UShineSearchObjTrigger) == 0x000108, "Wrong size on UShineSearchObjTrigger");

// Class Nicola.UITestMouseMenuListPageItem
// 0x0008 (0x0060 - 0x0058)
class UUITestMouseMenuListPageItem final : public UUIListItem
{
public:
	class UImage*                                 ImageClick;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListPageItem">();
	}
	static class UUITestMouseMenuListPageItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListPageItem>();
	}
};
static_assert(alignof(UUITestMouseMenuListPageItem) == 0x000008, "Wrong alignment on UUITestMouseMenuListPageItem");
static_assert(sizeof(UUITestMouseMenuListPageItem) == 0x000060, "Wrong size on UUITestMouseMenuListPageItem");
static_assert(offsetof(UUITestMouseMenuListPageItem, ImageClick) == 0x000058, "Member 'UUITestMouseMenuListPageItem::ImageClick' has a wrong offset!");

// Class Nicola.NicolaActionComponent
// 0x0028 (0x00E0 - 0x00B8)
class UNicolaActionComponent final : public UNicolaCharacterComponentBase
{
public:
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityZeroThreshold;                             // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRunThreshold;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityZeroTimeThreshold;                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySequencerAnimation(EAnimationType animationType, bool IsLoop, float PlayRate);
	void StopSequencerAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaActionComponent">();
	}
	static class UNicolaActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaActionComponent>();
	}
};
static_assert(alignof(UNicolaActionComponent) == 0x000008, "Wrong alignment on UNicolaActionComponent");
static_assert(sizeof(UNicolaActionComponent) == 0x0000E0, "Wrong size on UNicolaActionComponent");
static_assert(offsetof(UNicolaActionComponent, VelocityZeroThreshold) == 0x0000BC, "Member 'UNicolaActionComponent::VelocityZeroThreshold' has a wrong offset!");
static_assert(offsetof(UNicolaActionComponent, VelocityRunThreshold) == 0x0000C0, "Member 'UNicolaActionComponent::VelocityRunThreshold' has a wrong offset!");
static_assert(offsetof(UNicolaActionComponent, VelocityZeroTimeThreshold) == 0x0000C4, "Member 'UNicolaActionComponent::VelocityZeroTimeThreshold' has a wrong offset!");

// Class Nicola.UIBattleResultMenuWindowMessage
// 0x00C8 (0x0138 - 0x0070)
class UUIBattleResultMenuWindowMessage final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0xC8];                                      // 0x0070(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenuWindowMessage">();
	}
	static class UUIBattleResultMenuWindowMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenuWindowMessage>();
	}
};
static_assert(alignof(UUIBattleResultMenuWindowMessage) == 0x000008, "Wrong alignment on UUIBattleResultMenuWindowMessage");
static_assert(sizeof(UUIBattleResultMenuWindowMessage) == 0x000138, "Wrong size on UUIBattleResultMenuWindowMessage");

// Class Nicola.NicolaActionInputModeInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaActionInputModeInterface final : public IInterface
{
public:
	void OnChangeActionInputMode(ENicolaInputMode prevInputMode, ENicolaInputMode newInputMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaActionInputModeInterface">();
	}
	static class INicolaActionInputModeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaActionInputModeInterface>();
	}
};
static_assert(alignof(INicolaActionInputModeInterface) == 0x000008, "Wrong alignment on INicolaActionInputModeInterface");
static_assert(sizeof(INicolaActionInputModeInterface) == 0x000028, "Wrong size on INicolaActionInputModeInterface");

// Class Nicola.UIBattleRetryMenuWindowItemMoney
// 0x0028 (0x0068 - 0x0040)
class UUIBattleRetryMenuWindowItemMoney final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem4;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem5;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleRetryMenuWindowItemMoney">();
	}
	static class UUIBattleRetryMenuWindowItemMoney* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleRetryMenuWindowItemMoney>();
	}
};
static_assert(alignof(UUIBattleRetryMenuWindowItemMoney) == 0x000008, "Wrong alignment on UUIBattleRetryMenuWindowItemMoney");
static_assert(sizeof(UUIBattleRetryMenuWindowItemMoney) == 0x000068, "Wrong size on UUIBattleRetryMenuWindowItemMoney");
static_assert(offsetof(UUIBattleRetryMenuWindowItemMoney, TextItem2) == 0x000040, "Member 'UUIBattleRetryMenuWindowItemMoney::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowItemMoney, TextItem4) == 0x000048, "Member 'UUIBattleRetryMenuWindowItemMoney::TextItem4' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowItemMoney, TextItem3) == 0x000050, "Member 'UUIBattleRetryMenuWindowItemMoney::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowItemMoney, TextItem5) == 0x000058, "Member 'UUIBattleRetryMenuWindowItemMoney::TextItem5' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowItemMoney, ItemIcon) == 0x000060, "Member 'UUIBattleRetryMenuWindowItemMoney::ItemIcon' has a wrong offset!");

// Class Nicola.NicolaBattleCameraActor
// 0x0000 (0x0820 - 0x0820)
class ANicolaBattleCameraActor : public ANicolaCameraActor
{
public:
	struct FVector SetFocusRelativeOffset(const struct FVector& Offset);

	struct FVector GetFocusRelativeOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattleCameraActor">();
	}
	static class ANicolaBattleCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaBattleCameraActor>();
	}
};
static_assert(alignof(ANicolaBattleCameraActor) == 0x000010, "Wrong alignment on ANicolaBattleCameraActor");
static_assert(sizeof(ANicolaBattleCameraActor) == 0x000820, "Wrong size on ANicolaBattleCameraActor");

// Class Nicola.UIFieldMagicSkillMenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUIFieldMagicSkillMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMagicSkillMenuListTop">();
	}
	static class UUIFieldMagicSkillMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMagicSkillMenuListTop>();
	}
};
static_assert(alignof(UUIFieldMagicSkillMenuListTop) == 0x000008, "Wrong alignment on UUIFieldMagicSkillMenuListTop");
static_assert(sizeof(UUIFieldMagicSkillMenuListTop) == 0x0000E8, "Wrong size on UUIFieldMagicSkillMenuListTop");

// Class Nicola.NicolaBattleGameMode
// 0x0000 (0x02C0 - 0x02C0)
class ANicolaBattleGameMode final : public ANicolaGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattleGameMode">();
	}
	static class ANicolaBattleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaBattleGameMode>();
	}
};
static_assert(alignof(ANicolaBattleGameMode) == 0x000008, "Wrong alignment on ANicolaBattleGameMode");
static_assert(sizeof(ANicolaBattleGameMode) == 0x0002C0, "Wrong size on ANicolaBattleGameMode");

// Class Nicola.UIFieldEfxMenuWindowVehicleGuide
// 0x0030 (0x0058 - 0x0028)
class UUIFieldEfxMenuWindowVehicleGuide final : public UObject
{
public:
	TArray<class UUIFieldEfxMenuWindowItemVehicleGuide*> ListItems;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            DispGuideText;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonItemWidget*                      View;                                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       Slot;                                              // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowVehicleGuide">();
	}
	static class UUIFieldEfxMenuWindowVehicleGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowVehicleGuide>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowVehicleGuide) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowVehicleGuide");
static_assert(sizeof(UUIFieldEfxMenuWindowVehicleGuide) == 0x000058, "Wrong size on UUIFieldEfxMenuWindowVehicleGuide");
static_assert(offsetof(UUIFieldEfxMenuWindowVehicleGuide, ListItems) == 0x000028, "Member 'UUIFieldEfxMenuWindowVehicleGuide::ListItems' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowVehicleGuide, DispGuideText) == 0x000038, "Member 'UUIFieldEfxMenuWindowVehicleGuide::DispGuideText' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowVehicleGuide, View) == 0x000040, "Member 'UUIFieldEfxMenuWindowVehicleGuide::View' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowVehicleGuide, Slot) == 0x000050, "Member 'UUIFieldEfxMenuWindowVehicleGuide::Slot' has a wrong offset!");

// Class Nicola.NicolaBattleLevel
// 0x0008 (0x0268 - 0x0260)
class ANicolaBattleLevel final : public ANicolaTownDungeonLevel
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattleLevel">();
	}
	static class ANicolaBattleLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaBattleLevel>();
	}
};
static_assert(alignof(ANicolaBattleLevel) == 0x000008, "Wrong alignment on ANicolaBattleLevel");
static_assert(sizeof(ANicolaBattleLevel) == 0x000268, "Wrong size on ANicolaBattleLevel");

// Class Nicola.UIFieldTacticsGotoTitleMenu
// 0x0018 (0x0090 - 0x0078)
class UUIFieldTacticsGotoTitleMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISaveLoadList*                        ListAutoSave;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsGotoTitleMenu">();
	}
	static class UUIFieldTacticsGotoTitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsGotoTitleMenu>();
	}
};
static_assert(alignof(UUIFieldTacticsGotoTitleMenu) == 0x000008, "Wrong alignment on UUIFieldTacticsGotoTitleMenu");
static_assert(sizeof(UUIFieldTacticsGotoTitleMenu) == 0x000090, "Wrong size on UUIFieldTacticsGotoTitleMenu");
static_assert(offsetof(UUIFieldTacticsGotoTitleMenu, ListAutoSave) == 0x000080, "Member 'UUIFieldTacticsGotoTitleMenu::ListAutoSave' has a wrong offset!");

// Class Nicola.NicolaBattlePlayerCameraManager
// 0x0040 (0x2940 - 0x2900)
class ANicolaBattlePlayerCameraManager final : public ANicolaPlayerCameraManager
{
public:
	uint8                                         Pad_2900[0x18];                                    // 0x2900(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   FocusActorClass;                                   // 0x2918(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattlePlayerCameraManager">();
	}
	static class ANicolaBattlePlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaBattlePlayerCameraManager>();
	}
};
static_assert(alignof(ANicolaBattlePlayerCameraManager) == 0x000010, "Wrong alignment on ANicolaBattlePlayerCameraManager");
static_assert(sizeof(ANicolaBattlePlayerCameraManager) == 0x002940, "Wrong size on ANicolaBattlePlayerCameraManager");
static_assert(offsetof(ANicolaBattlePlayerCameraManager, FocusActorClass) == 0x002918, "Member 'ANicolaBattlePlayerCameraManager::FocusActorClass' has a wrong offset!");

// Class Nicola.VolumeEventTrigger
// 0x0000 (0x00F8 - 0x00F8)
class UVolumeEventTrigger : public UEventTriggerComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeEventTrigger">();
	}
	static class UVolumeEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVolumeEventTrigger>();
	}
};
static_assert(alignof(UVolumeEventTrigger) == 0x000008, "Wrong alignment on UVolumeEventTrigger");
static_assert(sizeof(UVolumeEventTrigger) == 0x0000F8, "Wrong size on UVolumeEventTrigger");

// Class Nicola.VolumeEventTriggerByOneFrame
// 0x0000 (0x00F8 - 0x00F8)
class UVolumeEventTriggerByOneFrame final : public UVolumeEventTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeEventTriggerByOneFrame">();
	}
	static class UVolumeEventTriggerByOneFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVolumeEventTriggerByOneFrame>();
	}
};
static_assert(alignof(UVolumeEventTriggerByOneFrame) == 0x000008, "Wrong alignment on UVolumeEventTriggerByOneFrame");
static_assert(sizeof(UVolumeEventTriggerByOneFrame) == 0x0000F8, "Wrong size on UVolumeEventTriggerByOneFrame");

// Class Nicola.NicolaBattleRoadDebugFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaBattleRoadDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static void AddScoutMonster(class FName InSpecyId, int32 InAddCount);
	static void AddScoutMonsterSpecies(int32 InAddCount);
	static void GetBattleRoadMonsterNameSpeciesIdMap(TMap<class FString, class FName>* outMap);
	static void GetGopMonsterSpeciesIdList(TArray<class FName>* OutGopIdList);
	static void GetMBRClearRankIdList(TArray<class FName>* OutList);
	static class FName GetMBRRankName(class FName InName);
	static class FName GetMonsterName(const class FName& InSpecyId, bool bBattleMonster);
	static int32 GetMonsterScoutNum(const class FName& InSpecyId);
	static int32 GetMonsterScoutNumMax(const class FName& InSpecyId);
	static class FName GetMonsterSpecyName(const class FName& InSpecyId);
	static void ResetScoutMonsters();
	static void ScoutAllMonster();
	static void SetMBRAllRankNotCleared();
	static void SetMBRRankCleared(bool InAll);
	static void SetScoutMonsterNum(class FName InSpecyId, int32 InCount);
	static void SubScoutMonster(class FName InSpecyId, int32 InSubCount);
	static void SubScoutMonsterSpecies(int32 InSubCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBattleRoadDebugFL">();
	}
	static class UNicolaBattleRoadDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaBattleRoadDebugFL>();
	}
};
static_assert(alignof(UNicolaBattleRoadDebugFL) == 0x000008, "Wrong alignment on UNicolaBattleRoadDebugFL");
static_assert(sizeof(UNicolaBattleRoadDebugFL) == 0x000028, "Wrong size on UNicolaBattleRoadDebugFL");

// Class Nicola.UIChurchMenuListPartyRevive
// 0x0008 (0x00D8 - 0x00D0)
class UUIChurchMenuListPartyRevive final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChurchMenuListPartyRevive">();
	}
	static class UUIChurchMenuListPartyRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChurchMenuListPartyRevive>();
	}
};
static_assert(alignof(UUIChurchMenuListPartyRevive) == 0x000008, "Wrong alignment on UUIChurchMenuListPartyRevive");
static_assert(sizeof(UUIChurchMenuListPartyRevive) == 0x0000D8, "Wrong size on UUIChurchMenuListPartyRevive");

// Class Nicola.NicolaBillboardComponent
// 0x00C0 (0x02C0 - 0x0200)
class UNicolaBillboardComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BillboardPitchCurve;                               // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveScalingByCameraAngle;                         // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveFloatOffsetPowerToScreenCenterByCameraAngle;  // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         forwardAngle;                                      // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         backAngle;                                         // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         lookAtDegreePitchMax;                              // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         lookAtDegreeYawMax;                                // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x68];                                     // 0x0230(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LookAtTarget;                                      // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ASceneCapture2D*                        sceneCaptureActor;                                 // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaBillboardComponent">();
	}
	static class UNicolaBillboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaBillboardComponent>();
	}
};
static_assert(alignof(UNicolaBillboardComponent) == 0x000010, "Wrong alignment on UNicolaBillboardComponent");
static_assert(sizeof(UNicolaBillboardComponent) == 0x0002C0, "Wrong size on UNicolaBillboardComponent");
static_assert(offsetof(UNicolaBillboardComponent, BillboardPitchCurve) == 0x000208, "Member 'UNicolaBillboardComponent::BillboardPitchCurve' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, CurveScalingByCameraAngle) == 0x000210, "Member 'UNicolaBillboardComponent::CurveScalingByCameraAngle' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, CurveFloatOffsetPowerToScreenCenterByCameraAngle) == 0x000218, "Member 'UNicolaBillboardComponent::CurveFloatOffsetPowerToScreenCenterByCameraAngle' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, forwardAngle) == 0x000220, "Member 'UNicolaBillboardComponent::forwardAngle' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, backAngle) == 0x000224, "Member 'UNicolaBillboardComponent::backAngle' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, lookAtDegreePitchMax) == 0x000228, "Member 'UNicolaBillboardComponent::lookAtDegreePitchMax' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, lookAtDegreeYawMax) == 0x00022C, "Member 'UNicolaBillboardComponent::lookAtDegreeYawMax' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, LookAtTarget) == 0x000298, "Member 'UNicolaBillboardComponent::LookAtTarget' has a wrong offset!");
static_assert(offsetof(UNicolaBillboardComponent, sceneCaptureActor) == 0x0002B0, "Member 'UNicolaBillboardComponent::sceneCaptureActor' has a wrong offset!");

// Class Nicola.VisualizeEventObjectActor
// 0x0018 (0x0238 - 0x0220)
class AVisualizeEventObjectActor final : public AActor
{
public:
	TArray<struct FObjectFlagVisibleInfo>         ObjectVisibleInfoList;                             // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorList;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetVisibleActors(const class FName Tag, bool IsVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualizeEventObjectActor">();
	}
	static class AVisualizeEventObjectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVisualizeEventObjectActor>();
	}
};
static_assert(alignof(AVisualizeEventObjectActor) == 0x000008, "Wrong alignment on AVisualizeEventObjectActor");
static_assert(sizeof(AVisualizeEventObjectActor) == 0x000238, "Wrong size on AVisualizeEventObjectActor");
static_assert(offsetof(AVisualizeEventObjectActor, ObjectVisibleInfoList) == 0x000220, "Member 'AVisualizeEventObjectActor::ObjectVisibleInfoList' has a wrong offset!");
static_assert(offsetof(AVisualizeEventObjectActor, ActorList) == 0x000230, "Member 'AVisualizeEventObjectActor::ActorList' has a wrong offset!");

// Class Nicola.NicolaCameraEffectActor
// 0x0020 (0x0240 - 0x0220)
class ANicolaCameraEffectActor final : public AActor
{
public:
	TArray<class UNiagaraComponent*>              effectComps;                                       // 0x0220(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraEffectActor">();
	}
	static class ANicolaCameraEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCameraEffectActor>();
	}
};
static_assert(alignof(ANicolaCameraEffectActor) == 0x000008, "Wrong alignment on ANicolaCameraEffectActor");
static_assert(sizeof(ANicolaCameraEffectActor) == 0x000240, "Wrong size on ANicolaCameraEffectActor");
static_assert(offsetof(ANicolaCameraEffectActor, effectComps) == 0x000220, "Member 'ANicolaCameraEffectActor::effectComps' has a wrong offset!");

// Class Nicola.NicolaStageCameraFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaStageCameraFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaStageCameraFL">();
	}
	static class UNicolaStageCameraFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaStageCameraFL>();
	}
};
static_assert(alignof(UNicolaStageCameraFL) == 0x000008, "Wrong alignment on UNicolaStageCameraFL");
static_assert(sizeof(UNicolaStageCameraFL) == 0x000028, "Wrong size on UNicolaStageCameraFL");

// Class Nicola.NicolaFieldTriggerBase
// 0x00B0 (0x02D0 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) ANicolaFieldTriggerBase : public AActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        currentOuterComponent;                             // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShapeComponent*                        currentInnerComponent;                             // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x4];                                      // 0x0238(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 debugDrawColorInnerBounds;                         // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 debugDrawColorOuterBounds;                         // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 debugDrawColorArrowForInner;                       // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 debugDrawColorArrowForOuter;                       // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseMinimumBlendRate;                            // 0x024C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoBlendByOverlap;                                 // 0x024D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoBlendByDistance;                                // 0x024E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoBlendByDistanceFromOuter;                       // 0x024F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoBlendByTime;                                    // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeTriggeredByWalk;                                // 0x0251(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeTriggeredByShip;                                // 0x0252(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeTriggeredByLamia;                               // 0x0253(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0xC];                                      // 0x0254(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InnerShapeRelativeTransform;                       // 0x0260(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDoOverwriteInnerShapeRelativePositionByNotScaledValue; // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                overwriteInnerShapeRelativePosition;               // 0x0294(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAutomaticCalcBlendDistanceMode;                 // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendDistanceStart;                                // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendDistanceEnd;                                  // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoCalcBlendDistanceByInnerShape;                  // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendDistanceStartFromOuter;                       // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendDistanceEndFromOuter;                         // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTimeFadeIn;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTimeFadeOut;                                  // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlendTimePassedByMoving;                        // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldTriggerBase">();
	}
	static class ANicolaFieldTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldTriggerBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANicolaFieldTriggerBase) == 0x000010, "Wrong alignment on ANicolaFieldTriggerBase");
static_assert(sizeof(ANicolaFieldTriggerBase) == 0x0002D0, "Wrong size on ANicolaFieldTriggerBase");
static_assert(offsetof(ANicolaFieldTriggerBase, ActorListComponent) == 0x000220, "Member 'ANicolaFieldTriggerBase::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, currentOuterComponent) == 0x000228, "Member 'ANicolaFieldTriggerBase::currentOuterComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, currentInnerComponent) == 0x000230, "Member 'ANicolaFieldTriggerBase::currentInnerComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, debugDrawColorInnerBounds) == 0x00023C, "Member 'ANicolaFieldTriggerBase::debugDrawColorInnerBounds' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, debugDrawColorOuterBounds) == 0x000240, "Member 'ANicolaFieldTriggerBase::debugDrawColorOuterBounds' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, debugDrawColorArrowForInner) == 0x000244, "Member 'ANicolaFieldTriggerBase::debugDrawColorArrowForInner' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, debugDrawColorArrowForOuter) == 0x000248, "Member 'ANicolaFieldTriggerBase::debugDrawColorArrowForOuter' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoUseMinimumBlendRate) == 0x00024C, "Member 'ANicolaFieldTriggerBase::bDoUseMinimumBlendRate' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoBlendByOverlap) == 0x00024D, "Member 'ANicolaFieldTriggerBase::bDoBlendByOverlap' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoBlendByDistance) == 0x00024E, "Member 'ANicolaFieldTriggerBase::bDoBlendByDistance' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoBlendByDistanceFromOuter) == 0x00024F, "Member 'ANicolaFieldTriggerBase::bDoBlendByDistanceFromOuter' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoBlendByTime) == 0x000250, "Member 'ANicolaFieldTriggerBase::bDoBlendByTime' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bBeTriggeredByWalk) == 0x000251, "Member 'ANicolaFieldTriggerBase::bBeTriggeredByWalk' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bBeTriggeredByShip) == 0x000252, "Member 'ANicolaFieldTriggerBase::bBeTriggeredByShip' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bBeTriggeredByLamia) == 0x000253, "Member 'ANicolaFieldTriggerBase::bBeTriggeredByLamia' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, InnerShapeRelativeTransform) == 0x000260, "Member 'ANicolaFieldTriggerBase::InnerShapeRelativeTransform' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoOverwriteInnerShapeRelativePositionByNotScaledValue) == 0x000290, "Member 'ANicolaFieldTriggerBase::bDoOverwriteInnerShapeRelativePositionByNotScaledValue' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, overwriteInnerShapeRelativePosition) == 0x000294, "Member 'ANicolaFieldTriggerBase::overwriteInnerShapeRelativePosition' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bIsAutomaticCalcBlendDistanceMode) == 0x0002A0, "Member 'ANicolaFieldTriggerBase::bIsAutomaticCalcBlendDistanceMode' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, BlendDistanceStart) == 0x0002A4, "Member 'ANicolaFieldTriggerBase::BlendDistanceStart' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, BlendDistanceEnd) == 0x0002A8, "Member 'ANicolaFieldTriggerBase::BlendDistanceEnd' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bDoCalcBlendDistanceByInnerShape) == 0x0002AC, "Member 'ANicolaFieldTriggerBase::bDoCalcBlendDistanceByInnerShape' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, BlendDistanceStartFromOuter) == 0x0002B0, "Member 'ANicolaFieldTriggerBase::BlendDistanceStartFromOuter' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, BlendDistanceEndFromOuter) == 0x0002B4, "Member 'ANicolaFieldTriggerBase::BlendDistanceEndFromOuter' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, BlendTimeFadeIn) == 0x0002B8, "Member 'ANicolaFieldTriggerBase::BlendTimeFadeIn' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, BlendTimeFadeOut) == 0x0002BC, "Member 'ANicolaFieldTriggerBase::BlendTimeFadeOut' has a wrong offset!");
static_assert(offsetof(ANicolaFieldTriggerBase, bIsBlendTimePassedByMoving) == 0x0002C0, "Member 'ANicolaFieldTriggerBase::bIsBlendTimePassedByMoving' has a wrong offset!");

// Class Nicola.NicolaCameraEffectTriggerBase
// 0x0020 (0x02F0 - 0x02D0)
class ANicolaCameraEffectTriggerBase final : public ANicolaFieldTriggerBase
{
public:
	class FName                                   CameraEffectAssetName;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AdditionalParameterNames;                          // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ENicolaFieldTriggerActorTypeFlag              triggerActorType;                                  // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0xF];                                      // 0x02E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraEffectTriggerBase">();
	}
	static class ANicolaCameraEffectTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCameraEffectTriggerBase>();
	}
};
static_assert(alignof(ANicolaCameraEffectTriggerBase) == 0x000010, "Wrong alignment on ANicolaCameraEffectTriggerBase");
static_assert(sizeof(ANicolaCameraEffectTriggerBase) == 0x0002F0, "Wrong size on ANicolaCameraEffectTriggerBase");
static_assert(offsetof(ANicolaCameraEffectTriggerBase, CameraEffectAssetName) == 0x0002C8, "Member 'ANicolaCameraEffectTriggerBase::CameraEffectAssetName' has a wrong offset!");
static_assert(offsetof(ANicolaCameraEffectTriggerBase, AdditionalParameterNames) == 0x0002D0, "Member 'ANicolaCameraEffectTriggerBase::AdditionalParameterNames' has a wrong offset!");
static_assert(offsetof(ANicolaCameraEffectTriggerBase, triggerActorType) == 0x0002E0, "Member 'ANicolaCameraEffectTriggerBase::triggerActorType' has a wrong offset!");

// Class Nicola.UIWindowItemText3
// 0x0010 (0x0050 - 0x0040)
class UUIWindowItemText3 : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemText3">();
	}
	static class UUIWindowItemText3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemText3>();
	}
};
static_assert(alignof(UUIWindowItemText3) == 0x000008, "Wrong alignment on UUIWindowItemText3");
static_assert(sizeof(UUIWindowItemText3) == 0x000050, "Wrong size on UUIWindowItemText3");
static_assert(offsetof(UUIWindowItemText3, TextItem2) == 0x000040, "Member 'UUIWindowItemText3::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIWindowItemText3, TextItem3) == 0x000048, "Member 'UUIWindowItemText3::TextItem3' has a wrong offset!");

// Class Nicola.UIDLCMenuWindowInfoItem
// 0x0008 (0x0058 - 0x0050)
class UUIDLCMenuWindowInfoItem final : public UUIWindowItemText3
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDLCMenuWindowInfoItem">();
	}
	static class UUIDLCMenuWindowInfoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDLCMenuWindowInfoItem>();
	}
};
static_assert(alignof(UUIDLCMenuWindowInfoItem) == 0x000008, "Wrong alignment on UUIDLCMenuWindowInfoItem");
static_assert(sizeof(UUIDLCMenuWindowInfoItem) == 0x000058, "Wrong size on UUIDLCMenuWindowInfoItem");
static_assert(offsetof(UUIDLCMenuWindowInfoItem, ImageIcon) == 0x000050, "Member 'UUIDLCMenuWindowInfoItem::ImageIcon' has a wrong offset!");

// Class Nicola.NicolaCameraFadeActor
// 0x0018 (0x0248 - 0x0230)
class ANicolaCameraFadeActor : public AStaticMeshActor
{
public:
	class UMaterialInstanceDynamic*               materialInstanceDyanmic;                           // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraFadeActor">();
	}
	static class ANicolaCameraFadeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCameraFadeActor>();
	}
};
static_assert(alignof(ANicolaCameraFadeActor) == 0x000008, "Wrong alignment on ANicolaCameraFadeActor");
static_assert(sizeof(ANicolaCameraFadeActor) == 0x000248, "Wrong size on ANicolaCameraFadeActor");
static_assert(offsetof(ANicolaCameraFadeActor, materialInstanceDyanmic) == 0x000230, "Member 'ANicolaCameraFadeActor::materialInstanceDyanmic' has a wrong offset!");

// Class Nicola.NicolaCameraModeReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaCameraModeReceiverInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraModeReceiverInterface">();
	}
	static class INicolaCameraModeReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaCameraModeReceiverInterface>();
	}
};
static_assert(alignof(INicolaCameraModeReceiverInterface) == 0x000008, "Wrong alignment on INicolaCameraModeReceiverInterface");
static_assert(sizeof(INicolaCameraModeReceiverInterface) == 0x000028, "Wrong size on INicolaCameraModeReceiverInterface");

// Class Nicola.NicolaCameraShake
// 0x0000 (0x01B0 - 0x01B0)
class UNicolaCameraShake final : public UMatineeCameraShake
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraShake">();
	}
	static class UNicolaCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCameraShake>();
	}
};
static_assert(alignof(UNicolaCameraShake) == 0x000010, "Wrong alignment on UNicolaCameraShake");
static_assert(sizeof(UNicolaCameraShake) == 0x0001B0, "Wrong size on UNicolaCameraShake");

// Class Nicola.NicolaCameraTriggerBase
// 0x0040 (0x0310 - 0x02D0)
class ANicolaCameraTriggerBase final : public ANicolaFieldTriggerBase
{
public:
	bool                                          bDoOverwriteAngleElevation;                        // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverwriteAngleYaw;                              // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverwriteTargetLength;                          // 0x02CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverwriteFieldOfView;                           // 0x02CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverwriteTargetOffset;                          // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleElevation;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleYaw;                                          // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetLength;                                      // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FieldOfView;                                       // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetOffset;                                      // 0x02E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseInitialAngleElevation;                       // 0x02EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseInitialAngleYaw;                             // 0x02ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseInitialTargetLength;                         // 0x02EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseInitialFieldOfView;                          // 0x02EF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseInitialTargetOffset;                         // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoClearPrevValAngleElevation;                     // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoClearPrevValAngleYaw;                           // 0x02F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoClearPrevValTargetLength;                       // 0x02F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoClearPrevValFieldOfView;                        // 0x02F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoClearPrevValTargetOffset;                       // 0x02F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseSettingForNearCamera_TargetLength;           // 0x02F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F7[0x1];                                      // 0x02F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetLengthForN;                                  // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseInitialTargetLengthForN;                     // 0x02FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoClearPrevValTargetLengthForN;                   // 0x02FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FE[0x2];                                      // 0x02FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENicolaCameraTriggerCurveType                 BlendCurveType;                                    // 0x0304(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305[0xB];                                      // 0x0305(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraTriggerBase">();
	}
	static class ANicolaCameraTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCameraTriggerBase>();
	}
};
static_assert(alignof(ANicolaCameraTriggerBase) == 0x000010, "Wrong alignment on ANicolaCameraTriggerBase");
static_assert(sizeof(ANicolaCameraTriggerBase) == 0x000310, "Wrong size on ANicolaCameraTriggerBase");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoOverwriteAngleElevation) == 0x0002C8, "Member 'ANicolaCameraTriggerBase::bDoOverwriteAngleElevation' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoOverwriteAngleYaw) == 0x0002C9, "Member 'ANicolaCameraTriggerBase::bDoOverwriteAngleYaw' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoOverwriteTargetLength) == 0x0002CA, "Member 'ANicolaCameraTriggerBase::bDoOverwriteTargetLength' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoOverwriteFieldOfView) == 0x0002CB, "Member 'ANicolaCameraTriggerBase::bDoOverwriteFieldOfView' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoOverwriteTargetOffset) == 0x0002CC, "Member 'ANicolaCameraTriggerBase::bDoOverwriteTargetOffset' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, AngleElevation) == 0x0002D0, "Member 'ANicolaCameraTriggerBase::AngleElevation' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, AngleYaw) == 0x0002D4, "Member 'ANicolaCameraTriggerBase::AngleYaw' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, TargetLength) == 0x0002D8, "Member 'ANicolaCameraTriggerBase::TargetLength' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, FieldOfView) == 0x0002DC, "Member 'ANicolaCameraTriggerBase::FieldOfView' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, TargetOffset) == 0x0002E0, "Member 'ANicolaCameraTriggerBase::TargetOffset' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseInitialAngleElevation) == 0x0002EC, "Member 'ANicolaCameraTriggerBase::bDoUseInitialAngleElevation' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseInitialAngleYaw) == 0x0002ED, "Member 'ANicolaCameraTriggerBase::bDoUseInitialAngleYaw' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseInitialTargetLength) == 0x0002EE, "Member 'ANicolaCameraTriggerBase::bDoUseInitialTargetLength' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseInitialFieldOfView) == 0x0002EF, "Member 'ANicolaCameraTriggerBase::bDoUseInitialFieldOfView' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseInitialTargetOffset) == 0x0002F0, "Member 'ANicolaCameraTriggerBase::bDoUseInitialTargetOffset' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoClearPrevValAngleElevation) == 0x0002F1, "Member 'ANicolaCameraTriggerBase::bDoClearPrevValAngleElevation' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoClearPrevValAngleYaw) == 0x0002F2, "Member 'ANicolaCameraTriggerBase::bDoClearPrevValAngleYaw' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoClearPrevValTargetLength) == 0x0002F3, "Member 'ANicolaCameraTriggerBase::bDoClearPrevValTargetLength' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoClearPrevValFieldOfView) == 0x0002F4, "Member 'ANicolaCameraTriggerBase::bDoClearPrevValFieldOfView' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoClearPrevValTargetOffset) == 0x0002F5, "Member 'ANicolaCameraTriggerBase::bDoClearPrevValTargetOffset' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseSettingForNearCamera_TargetLength) == 0x0002F6, "Member 'ANicolaCameraTriggerBase::bDoUseSettingForNearCamera_TargetLength' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, TargetLengthForN) == 0x0002F8, "Member 'ANicolaCameraTriggerBase::TargetLengthForN' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoUseInitialTargetLengthForN) == 0x0002FC, "Member 'ANicolaCameraTriggerBase::bDoUseInitialTargetLengthForN' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, bDoClearPrevValTargetLengthForN) == 0x0002FD, "Member 'ANicolaCameraTriggerBase::bDoClearPrevValTargetLengthForN' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, Priority) == 0x000300, "Member 'ANicolaCameraTriggerBase::Priority' has a wrong offset!");
static_assert(offsetof(ANicolaCameraTriggerBase, BlendCurveType) == 0x000304, "Member 'ANicolaCameraTriggerBase::BlendCurveType' has a wrong offset!");

// Class Nicola.NicolaCameraTriggerManager
// 0x0100 (0x0130 - 0x0030)
class UNicolaCameraTriggerManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENicolaCameraTriggerCurveType, class UCurveFloat*> cameraTriggerCurveMap;                             // 0x0040(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ANicolaCameraTriggerBase*, uint8>  activeTriggers;                                    // 0x0090(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ANicolaCameraTriggerBase*, float>  cameraTriggerTimers;                               // 0x00E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCameraTriggerManager">();
	}
	static class UNicolaCameraTriggerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCameraTriggerManager>();
	}
};
static_assert(alignof(UNicolaCameraTriggerManager) == 0x000008, "Wrong alignment on UNicolaCameraTriggerManager");
static_assert(sizeof(UNicolaCameraTriggerManager) == 0x000130, "Wrong size on UNicolaCameraTriggerManager");
static_assert(offsetof(UNicolaCameraTriggerManager, cameraTriggerCurveMap) == 0x000040, "Member 'UNicolaCameraTriggerManager::cameraTriggerCurveMap' has a wrong offset!");
static_assert(offsetof(UNicolaCameraTriggerManager, activeTriggers) == 0x000090, "Member 'UNicolaCameraTriggerManager::activeTriggers' has a wrong offset!");
static_assert(offsetof(UNicolaCameraTriggerManager, cameraTriggerTimers) == 0x0000E0, "Member 'UNicolaCameraTriggerManager::cameraTriggerTimers' has a wrong offset!");

// Class Nicola.NicolaCharacterBase
// 0x0260 (0x0720 - 0x04C0)
class ANicolaCharacterBase : public APaperCharacter
{
public:
	uint8                                         Pad_4C0[0x18];                                     // 0x04C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNicolaActionComponent*                 actionComponent;                                   // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorListComponent*                    ActorListComponent;                                // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaFlipbookNotifyComponent*         flipbookNotifyComponent;                           // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSwayAnimComponent*               swayAnimComponent;                                 // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaBillboardComponent*              BillboardComponent;                                // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSpriteManagerComponent*          spriteManagerComponent;                            // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaCharacterModifierComponent*      characterModifierComponent;                        // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        secondRotationScene;                               // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        CircleShadowPositionComponent;                     // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DecalComponentCircleShadow;                        // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DecalComponentCharacterShadow;                     // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FEffectSocketDatas>  EffectBaseOffsetsEx;                               // 0x0558(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FVector>             effectForwardVectors;                              // 0x05A8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	bool                                          UseBPDummyShadow;                                  // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseDecalCharacterShadow;                           // 0x05F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsNpc;                                             // 0x05FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5FB[0x1];                                      // 0x05FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalCharacterShadowPitch;                         // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowYawU;                          // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowYawB;                          // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowYawL;                          // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowYawR;                          // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowLocalZ;                        // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowWorldZ;                        // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DecalCharacterShadowRayOffset;                     // 0x0618(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecalCharacterShadowSpeed;                         // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LampIntensity;                                     // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LampAttenuationRadius;                             // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LampSourceRadius;                                  // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LampSoftSourceRadius;                              // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LampSourceLength;                                  // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntPoint                              PixelSize;                                         // 0x063C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               circleShadowMaterialInstanceDynamic;               // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            circleShadowOpacityByCameraAngleCurve;             // 0x0650(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x30];                                     // 0x0658(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     fxCompStatusEffect;                                // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0x20];                                     // 0x0690(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpFloat*                           interpOpacity;                                     // 0x06B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpFloat*                           interpEventEmissive;                               // 0x06C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           interpEventMaterialParam;                          // 0x06C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           interpDarkArmor;                                   // 0x06D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           interpDecalShadow;                                 // 0x06D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           InterpRotationT;                                   // 0x06E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E8[0x38];                                     // 0x06E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeVisibility(bool Enable);
	void OnBeginFieldPlayer();
	void OnBeginTownDungeonPlayer();
	void StartRotationYawBP(const struct FRotator& TargetRotator, float DurationSec);

	class UNicolaActionComponent* GetActionComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterBase">();
	}
	static class ANicolaCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCharacterBase>();
	}
};
static_assert(alignof(ANicolaCharacterBase) == 0x000010, "Wrong alignment on ANicolaCharacterBase");
static_assert(sizeof(ANicolaCharacterBase) == 0x000720, "Wrong size on ANicolaCharacterBase");
static_assert(offsetof(ANicolaCharacterBase, actionComponent) == 0x0004D8, "Member 'ANicolaCharacterBase::actionComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, ActorListComponent) == 0x0004E0, "Member 'ANicolaCharacterBase::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, flipbookNotifyComponent) == 0x0004E8, "Member 'ANicolaCharacterBase::flipbookNotifyComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, swayAnimComponent) == 0x0004F0, "Member 'ANicolaCharacterBase::swayAnimComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, BillboardComponent) == 0x0004F8, "Member 'ANicolaCharacterBase::BillboardComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, spriteManagerComponent) == 0x000500, "Member 'ANicolaCharacterBase::spriteManagerComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, characterModifierComponent) == 0x000508, "Member 'ANicolaCharacterBase::characterModifierComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, secondRotationScene) == 0x000510, "Member 'ANicolaCharacterBase::secondRotationScene' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, CircleShadowPositionComponent) == 0x000518, "Member 'ANicolaCharacterBase::CircleShadowPositionComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalComponentCircleShadow) == 0x000530, "Member 'ANicolaCharacterBase::DecalComponentCircleShadow' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalComponentCharacterShadow) == 0x000548, "Member 'ANicolaCharacterBase::DecalComponentCharacterShadow' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, EffectBaseOffsetsEx) == 0x000558, "Member 'ANicolaCharacterBase::EffectBaseOffsetsEx' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, effectForwardVectors) == 0x0005A8, "Member 'ANicolaCharacterBase::effectForwardVectors' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, UseBPDummyShadow) == 0x0005F8, "Member 'ANicolaCharacterBase::UseBPDummyShadow' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, UseDecalCharacterShadow) == 0x0005F9, "Member 'ANicolaCharacterBase::UseDecalCharacterShadow' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, IsNpc) == 0x0005FA, "Member 'ANicolaCharacterBase::IsNpc' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowPitch) == 0x0005FC, "Member 'ANicolaCharacterBase::DecalCharacterShadowPitch' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowYawU) == 0x000600, "Member 'ANicolaCharacterBase::DecalCharacterShadowYawU' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowYawB) == 0x000604, "Member 'ANicolaCharacterBase::DecalCharacterShadowYawB' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowYawL) == 0x000608, "Member 'ANicolaCharacterBase::DecalCharacterShadowYawL' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowYawR) == 0x00060C, "Member 'ANicolaCharacterBase::DecalCharacterShadowYawR' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowLocalZ) == 0x000610, "Member 'ANicolaCharacterBase::DecalCharacterShadowLocalZ' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowWorldZ) == 0x000614, "Member 'ANicolaCharacterBase::DecalCharacterShadowWorldZ' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowRayOffset) == 0x000618, "Member 'ANicolaCharacterBase::DecalCharacterShadowRayOffset' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, DecalCharacterShadowSpeed) == 0x000624, "Member 'ANicolaCharacterBase::DecalCharacterShadowSpeed' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, LampIntensity) == 0x000628, "Member 'ANicolaCharacterBase::LampIntensity' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, LampAttenuationRadius) == 0x00062C, "Member 'ANicolaCharacterBase::LampAttenuationRadius' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, LampSourceRadius) == 0x000630, "Member 'ANicolaCharacterBase::LampSourceRadius' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, LampSoftSourceRadius) == 0x000634, "Member 'ANicolaCharacterBase::LampSoftSourceRadius' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, LampSourceLength) == 0x000638, "Member 'ANicolaCharacterBase::LampSourceLength' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, PixelSize) == 0x00063C, "Member 'ANicolaCharacterBase::PixelSize' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, circleShadowMaterialInstanceDynamic) == 0x000648, "Member 'ANicolaCharacterBase::circleShadowMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, circleShadowOpacityByCameraAngleCurve) == 0x000650, "Member 'ANicolaCharacterBase::circleShadowOpacityByCameraAngleCurve' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, fxCompStatusEffect) == 0x000688, "Member 'ANicolaCharacterBase::fxCompStatusEffect' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, interpOpacity) == 0x0006B0, "Member 'ANicolaCharacterBase::interpOpacity' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, interpEventEmissive) == 0x0006C0, "Member 'ANicolaCharacterBase::interpEventEmissive' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, interpEventMaterialParam) == 0x0006C8, "Member 'ANicolaCharacterBase::interpEventMaterialParam' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, interpDarkArmor) == 0x0006D0, "Member 'ANicolaCharacterBase::interpDarkArmor' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, interpDecalShadow) == 0x0006D8, "Member 'ANicolaCharacterBase::interpDecalShadow' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterBase, InterpRotationT) == 0x0006E0, "Member 'ANicolaCharacterBase::InterpRotationT' has a wrong offset!");

// Class Nicola.NicolaCharacterDebugFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaCharacterDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugSpawnAndAlignCharacter(EUnitClassType ClassType, int32 looksNo, float spaceWidth, float spaceDepth, bool bBattle);
	static void DebugSpawnAndAlignCoffin(EUnitClassType ClassType, int32 looksNo, float spaceWidth, float spaceDepth, bool bBattle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterDebugFL">();
	}
	static class UNicolaCharacterDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCharacterDebugFL>();
	}
};
static_assert(alignof(UNicolaCharacterDebugFL) == 0x000008, "Wrong alignment on UNicolaCharacterDebugFL");
static_assert(sizeof(UNicolaCharacterDebugFL) == 0x000028, "Wrong size on UNicolaCharacterDebugFL");

// Class Nicola.UIBattleRetryMenu
// 0x0028 (0x00A0 - 0x0078)
class UUIBattleRetryMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBattleRetryMenuListTop*              ListTop;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemIcon*                      WindowRetry;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleRetryMenuWindowLoad*           WindowLoad;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleRetryMenuWindowResume*         WindowResume;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsExecMenu();
	static void OpenMenu(class FName InDummyEventId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleRetryMenu">();
	}
	static class UUIBattleRetryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleRetryMenu>();
	}
};
static_assert(alignof(UUIBattleRetryMenu) == 0x000008, "Wrong alignment on UUIBattleRetryMenu");
static_assert(sizeof(UUIBattleRetryMenu) == 0x0000A0, "Wrong size on UUIBattleRetryMenu");
static_assert(offsetof(UUIBattleRetryMenu, ListTop) == 0x000080, "Member 'UUIBattleRetryMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenu, WindowRetry) == 0x000088, "Member 'UUIBattleRetryMenu::WindowRetry' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenu, WindowLoad) == 0x000090, "Member 'UUIBattleRetryMenu::WindowLoad' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenu, WindowResume) == 0x000098, "Member 'UUIBattleRetryMenu::WindowResume' has a wrong offset!");

// Class Nicola.NicolaCharacterDriverShipGhost
// 0x00B0 (0x02D0 - 0x0220)
class alignas(0x10) ANicolaCharacterDriverShipGhost : public AActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           InterpFloatFlowManegementTimer;                    // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           InterpFloatRotationManegementT;                    // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShipGhost*                             ShipGhostActor;                                    // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABuildingWithJumpPoint*                 BuildingWithJumpPoint;                             // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelLoaderActor*                      LevelLoaderActor;                                  // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveFloatMove;                                    // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveFloatRotation;                                // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x70];                                     // 0x0260(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterDriverShipGhost">();
	}
	static class ANicolaCharacterDriverShipGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaCharacterDriverShipGhost>();
	}
};
static_assert(alignof(ANicolaCharacterDriverShipGhost) == 0x000010, "Wrong alignment on ANicolaCharacterDriverShipGhost");
static_assert(sizeof(ANicolaCharacterDriverShipGhost) == 0x0002D0, "Wrong size on ANicolaCharacterDriverShipGhost");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, ActorListComponent) == 0x000220, "Member 'ANicolaCharacterDriverShipGhost::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, InterpFloatFlowManegementTimer) == 0x000228, "Member 'ANicolaCharacterDriverShipGhost::InterpFloatFlowManegementTimer' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, InterpFloatRotationManegementT) == 0x000230, "Member 'ANicolaCharacterDriverShipGhost::InterpFloatRotationManegementT' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, ShipGhostActor) == 0x000238, "Member 'ANicolaCharacterDriverShipGhost::ShipGhostActor' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, BuildingWithJumpPoint) == 0x000240, "Member 'ANicolaCharacterDriverShipGhost::BuildingWithJumpPoint' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, LevelLoaderActor) == 0x000248, "Member 'ANicolaCharacterDriverShipGhost::LevelLoaderActor' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, CurveFloatMove) == 0x000250, "Member 'ANicolaCharacterDriverShipGhost::CurveFloatMove' has a wrong offset!");
static_assert(offsetof(ANicolaCharacterDriverShipGhost, CurveFloatRotation) == 0x000258, "Member 'ANicolaCharacterDriverShipGhost::CurveFloatRotation' has a wrong offset!");

// Class Nicola.NicolaCharacterModifierComponent
// 0x0050 (0x0250 - 0x0200)
class UNicolaCharacterModifierComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatineeCameraShake*                    Shake;                                             // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            moveCurve;                                         // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x28];                                     // 0x0228(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaCharacterModifierComponent">();
	}
	static class UNicolaCharacterModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaCharacterModifierComponent>();
	}
};
static_assert(alignof(UNicolaCharacterModifierComponent) == 0x000010, "Wrong alignment on UNicolaCharacterModifierComponent");
static_assert(sizeof(UNicolaCharacterModifierComponent) == 0x000250, "Wrong size on UNicolaCharacterModifierComponent");
static_assert(offsetof(UNicolaCharacterModifierComponent, Shake) == 0x000200, "Member 'UNicolaCharacterModifierComponent::Shake' has a wrong offset!");
static_assert(offsetof(UNicolaCharacterModifierComponent, moveCurve) == 0x000220, "Member 'UNicolaCharacterModifierComponent::moveCurve' has a wrong offset!");

// Class Nicola.NicolaControllInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaControllInterface final : public IInterface
{
public:
	void OnControllerUpdate(const class ANicolaPlayerControllerBase* PlayerController, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaControllInterface">();
	}
	static class INicolaControllInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaControllInterface>();
	}
};
static_assert(alignof(INicolaControllInterface) == 0x000008, "Wrong alignment on INicolaControllInterface");
static_assert(sizeof(INicolaControllInterface) == 0x000028, "Wrong size on INicolaControllInterface");

// Class Nicola.UIDLCMenu
// 0x0028 (0x00A0 - 0x0078)
class UUIDLCMenu final : public UUIRootBase
{
public:
	class UUIDLCMenuListTop*                      ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIDLCMenuWindowInfo*                   WindowInfo;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FUIDLCInfo>                     Infos;                                             // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DEBUG_Prepare();
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDLCMenu">();
	}
	static class UUIDLCMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDLCMenu>();
	}
};
static_assert(alignof(UUIDLCMenu) == 0x000008, "Wrong alignment on UUIDLCMenu");
static_assert(sizeof(UUIDLCMenu) == 0x0000A0, "Wrong size on UUIDLCMenu");
static_assert(offsetof(UUIDLCMenu, ListTop) == 0x000078, "Member 'UUIDLCMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIDLCMenu, WindowInfo) == 0x000080, "Member 'UUIDLCMenu::WindowInfo' has a wrong offset!");
static_assert(offsetof(UUIDLCMenu, Infos) == 0x000088, "Member 'UUIDLCMenu::Infos' has a wrong offset!");

// Class Nicola.NicolaDataAssetAchievement
// 0x0050 (0x0080 - 0x0030)
class UNicolaDataAssetAchievement final : public UNicolaDataAssetBase
{
public:
	TMap<EAchievement, int32>                     AchievementTargetCount;                            // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetAchievement">();
	}
	static class UNicolaDataAssetAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetAchievement>();
	}
};
static_assert(alignof(UNicolaDataAssetAchievement) == 0x000008, "Wrong alignment on UNicolaDataAssetAchievement");
static_assert(sizeof(UNicolaDataAssetAchievement) == 0x000080, "Wrong size on UNicolaDataAssetAchievement");
static_assert(offsetof(UNicolaDataAssetAchievement, AchievementTargetCount) == 0x000030, "Member 'UNicolaDataAssetAchievement::AchievementTargetCount' has a wrong offset!");

// Class Nicola.NicolaDataAssetCameraCommon
// 0x02A0 (0x02D0 - 0x0030)
class UNicolaDataAssetCameraCommon final : public UNicolaDataAssetBase
{
public:
	bool                                          bDoUseNicolaCameraAngleLag;                        // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               nicolaCameraAngleLagSpeed;                         // 0x0034(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDoUseNicolaCameraTargetOffsetLag;                 // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                nicolaCameraTargetOffsetLagSpeed;                  // 0x0044(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseNicolaCameraTargetDistanceLag;               // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         nicolaCameraTargetDistanceLagSpeed;                // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseNicolaCameraThresholdPlayerMove;             // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                nicolaCameraThresholdPlayerMove;                   // 0x005C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         nicolaRuraOffsetCorrectionSpeed;                   // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         nicolaRuraOffsetCorrectionSpeedRateFactor;         // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerCameraNorthSouthBlendingTime;                // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerCameraNorthSouthBlendingDeadZone;            // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_WalkToShip;                    // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_WalkToShip;                        // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_WalkToShip;                 // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_WalkToBeginningLamia;          // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_WalkToBeginningLamia;              // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_WalkToBeginningLamia;       // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_BeginningLamiaToPlayableLamia; // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_BeginningLamiaToPlayableLamia;     // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_BeginningLamiaToPlayableLamia; // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_ShipToWalk;                    // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_ShipToWalk;                        // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_ShipToWalk;                 // 0x0110(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_PlayableLamiaToEndingLamia;    // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_PlayableLamiaToEndingLamia;        // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_PlayableLamiaToEndingLamia; // 0x0140(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_PlayableLamiaToEndingLamiaHigh; // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_PlayableLamiaToEndingLamiaHigh;    // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_PlayableLamiaToEndingLamiaHigh; // 0x0170(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_PlayableLamiaToEndingLamiaLow; // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_PlayableLamiaToEndingLamiaLow;     // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_PlayableLamiaToEndingLamiaLow; // 0x01A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitInterpolateTime_EndingLamiaToWalk;             // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolateTime_EndingLamiaToWalk;                 // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             CurveObjectInterpolate_EndingLamiaToWalk;          // 0x01D0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraCollisionChangingTime;                       // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             CameraCollisionChangingCurveObject;                // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENicolaCameraCollisionInterpolationType       CameraCollisionInterpolationTypeForNoCollision;    // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENicolaCameraTriggerCurveType, TSoftObjectPtr<class UCurveFloat>> CameraTriggerCurveObjectMap;                       // 0x0230(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<ENicolaStageCameraParamCopyType, class FName> StageCameraParamIdMap;                             // 0x0280(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetCameraCommon">();
	}
	static class UNicolaDataAssetCameraCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetCameraCommon>();
	}
};
static_assert(alignof(UNicolaDataAssetCameraCommon) == 0x000008, "Wrong alignment on UNicolaDataAssetCameraCommon");
static_assert(sizeof(UNicolaDataAssetCameraCommon) == 0x0002D0, "Wrong size on UNicolaDataAssetCameraCommon");
static_assert(offsetof(UNicolaDataAssetCameraCommon, bDoUseNicolaCameraAngleLag) == 0x000030, "Member 'UNicolaDataAssetCameraCommon::bDoUseNicolaCameraAngleLag' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, nicolaCameraAngleLagSpeed) == 0x000034, "Member 'UNicolaDataAssetCameraCommon::nicolaCameraAngleLagSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, bDoUseNicolaCameraTargetOffsetLag) == 0x000040, "Member 'UNicolaDataAssetCameraCommon::bDoUseNicolaCameraTargetOffsetLag' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, nicolaCameraTargetOffsetLagSpeed) == 0x000044, "Member 'UNicolaDataAssetCameraCommon::nicolaCameraTargetOffsetLagSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, bDoUseNicolaCameraTargetDistanceLag) == 0x000050, "Member 'UNicolaDataAssetCameraCommon::bDoUseNicolaCameraTargetDistanceLag' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, nicolaCameraTargetDistanceLagSpeed) == 0x000054, "Member 'UNicolaDataAssetCameraCommon::nicolaCameraTargetDistanceLagSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, bDoUseNicolaCameraThresholdPlayerMove) == 0x000058, "Member 'UNicolaDataAssetCameraCommon::bDoUseNicolaCameraThresholdPlayerMove' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, nicolaCameraThresholdPlayerMove) == 0x00005C, "Member 'UNicolaDataAssetCameraCommon::nicolaCameraThresholdPlayerMove' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, nicolaRuraOffsetCorrectionSpeed) == 0x000068, "Member 'UNicolaDataAssetCameraCommon::nicolaRuraOffsetCorrectionSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, nicolaRuraOffsetCorrectionSpeedRateFactor) == 0x00006C, "Member 'UNicolaDataAssetCameraCommon::nicolaRuraOffsetCorrectionSpeedRateFactor' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, PlayerCameraNorthSouthBlendingTime) == 0x000070, "Member 'UNicolaDataAssetCameraCommon::PlayerCameraNorthSouthBlendingTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, PlayerCameraNorthSouthBlendingDeadZone) == 0x000074, "Member 'UNicolaDataAssetCameraCommon::PlayerCameraNorthSouthBlendingDeadZone' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_WalkToShip) == 0x000078, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_WalkToShip' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_WalkToShip) == 0x00007C, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_WalkToShip' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_WalkToShip) == 0x000080, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_WalkToShip' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_WalkToBeginningLamia) == 0x0000A8, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_WalkToBeginningLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_WalkToBeginningLamia) == 0x0000AC, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_WalkToBeginningLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_WalkToBeginningLamia) == 0x0000B0, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_WalkToBeginningLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_BeginningLamiaToPlayableLamia) == 0x0000D8, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_BeginningLamiaToPlayableLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_BeginningLamiaToPlayableLamia) == 0x0000DC, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_BeginningLamiaToPlayableLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_BeginningLamiaToPlayableLamia) == 0x0000E0, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_BeginningLamiaToPlayableLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_ShipToWalk) == 0x000108, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_ShipToWalk' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_ShipToWalk) == 0x00010C, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_ShipToWalk' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_ShipToWalk) == 0x000110, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_ShipToWalk' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_PlayableLamiaToEndingLamia) == 0x000138, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_PlayableLamiaToEndingLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_PlayableLamiaToEndingLamia) == 0x00013C, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_PlayableLamiaToEndingLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_PlayableLamiaToEndingLamia) == 0x000140, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_PlayableLamiaToEndingLamia' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_PlayableLamiaToEndingLamiaHigh) == 0x000168, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_PlayableLamiaToEndingLamiaHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_PlayableLamiaToEndingLamiaHigh) == 0x00016C, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_PlayableLamiaToEndingLamiaHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_PlayableLamiaToEndingLamiaHigh) == 0x000170, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_PlayableLamiaToEndingLamiaHigh' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_PlayableLamiaToEndingLamiaLow) == 0x000198, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_PlayableLamiaToEndingLamiaLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_PlayableLamiaToEndingLamiaLow) == 0x00019C, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_PlayableLamiaToEndingLamiaLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_PlayableLamiaToEndingLamiaLow) == 0x0001A0, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_PlayableLamiaToEndingLamiaLow' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, WaitInterpolateTime_EndingLamiaToWalk) == 0x0001C8, "Member 'UNicolaDataAssetCameraCommon::WaitInterpolateTime_EndingLamiaToWalk' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, InterpolateTime_EndingLamiaToWalk) == 0x0001CC, "Member 'UNicolaDataAssetCameraCommon::InterpolateTime_EndingLamiaToWalk' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CurveObjectInterpolate_EndingLamiaToWalk) == 0x0001D0, "Member 'UNicolaDataAssetCameraCommon::CurveObjectInterpolate_EndingLamiaToWalk' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CameraCollisionChangingTime) == 0x0001F8, "Member 'UNicolaDataAssetCameraCommon::CameraCollisionChangingTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CameraCollisionChangingCurveObject) == 0x000200, "Member 'UNicolaDataAssetCameraCommon::CameraCollisionChangingCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CameraCollisionInterpolationTypeForNoCollision) == 0x000228, "Member 'UNicolaDataAssetCameraCommon::CameraCollisionInterpolationTypeForNoCollision' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, CameraTriggerCurveObjectMap) == 0x000230, "Member 'UNicolaDataAssetCameraCommon::CameraTriggerCurveObjectMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetCameraCommon, StageCameraParamIdMap) == 0x000280, "Member 'UNicolaDataAssetCameraCommon::StageCameraParamIdMap' has a wrong offset!");

// Class Nicola.NicolaDataAssetEvent
// 0x01A0 (0x01D0 - 0x0030)
class UNicolaDataAssetEvent final : public UNicolaDataAssetBase
{
public:
	TSoftObjectPtr<class UCurveFloat>             NpcJumpCurve;                                      // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ENpcMoveSpeed, float>                    MoveSpeedMap;                                      // 0x0058(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ENpcMoveWaitTime, float>                 MoveWaitSecondMap;                                 // 0x00A8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         NpcMoveAnimationRate;                              // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NpcRunMoveAnimationRate;                           // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NpcMoveSpeedThreshold;                             // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESearchObjectType, class FString>        SearchObjectScriptMap;                             // 0x0108(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MangaIconDefaultOffset;                            // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconSleepFloorCharacterOffset;                // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconSleepBedCharacterOffset;                  // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconSitCharacterOffset;                       // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconMinScaleRate;                             // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconMaxScaleRate;                             // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MangaIconDefaultScale;                             // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EventSkipFadeOutSeconds;                           // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EventSkipFadeOutWaitSeconds;                       // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EventFastForwardTimeRate;                          // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurseGoldenClawsCameraEffectId;                    // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurseGoldenClawsCoffinEffectId;                    // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 DispelCurseGoldenClawsScriptName;                  // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LancelReturnTrialChurchId;                         // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClonePCFadeTime;                                   // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RestartChurchScriptFunctionName;                   // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 DLCScriptFunctionName;                             // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool GetDebugEnableEventFastForwardTimeRate();
	static float GetDebugEventFastForwardTimeRate();
	static void SetDebugEnableEventFastForwardTimeRate(bool InEnable);
	static void SetDebugEventFastForwardTimeRate(float InRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetEvent">();
	}
	static class UNicolaDataAssetEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetEvent>();
	}
};
static_assert(alignof(UNicolaDataAssetEvent) == 0x000008, "Wrong alignment on UNicolaDataAssetEvent");
static_assert(sizeof(UNicolaDataAssetEvent) == 0x0001D0, "Wrong size on UNicolaDataAssetEvent");
static_assert(offsetof(UNicolaDataAssetEvent, NpcJumpCurve) == 0x000030, "Member 'UNicolaDataAssetEvent::NpcJumpCurve' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MoveSpeedMap) == 0x000058, "Member 'UNicolaDataAssetEvent::MoveSpeedMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MoveWaitSecondMap) == 0x0000A8, "Member 'UNicolaDataAssetEvent::MoveWaitSecondMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, NpcMoveAnimationRate) == 0x0000F8, "Member 'UNicolaDataAssetEvent::NpcMoveAnimationRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, NpcRunMoveAnimationRate) == 0x0000FC, "Member 'UNicolaDataAssetEvent::NpcRunMoveAnimationRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, NpcMoveSpeedThreshold) == 0x000100, "Member 'UNicolaDataAssetEvent::NpcMoveSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, SearchObjectScriptMap) == 0x000108, "Member 'UNicolaDataAssetEvent::SearchObjectScriptMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconDefaultOffset) == 0x000158, "Member 'UNicolaDataAssetEvent::MangaIconDefaultOffset' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconSleepFloorCharacterOffset) == 0x00015C, "Member 'UNicolaDataAssetEvent::MangaIconSleepFloorCharacterOffset' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconSleepBedCharacterOffset) == 0x000160, "Member 'UNicolaDataAssetEvent::MangaIconSleepBedCharacterOffset' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconSitCharacterOffset) == 0x000164, "Member 'UNicolaDataAssetEvent::MangaIconSitCharacterOffset' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconMinScaleRate) == 0x000168, "Member 'UNicolaDataAssetEvent::MangaIconMinScaleRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconMaxScaleRate) == 0x00016C, "Member 'UNicolaDataAssetEvent::MangaIconMaxScaleRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, MangaIconDefaultScale) == 0x000170, "Member 'UNicolaDataAssetEvent::MangaIconDefaultScale' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, EventSkipFadeOutSeconds) == 0x000174, "Member 'UNicolaDataAssetEvent::EventSkipFadeOutSeconds' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, EventSkipFadeOutWaitSeconds) == 0x000178, "Member 'UNicolaDataAssetEvent::EventSkipFadeOutWaitSeconds' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, EventFastForwardTimeRate) == 0x00017C, "Member 'UNicolaDataAssetEvent::EventFastForwardTimeRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, CurseGoldenClawsCameraEffectId) == 0x000180, "Member 'UNicolaDataAssetEvent::CurseGoldenClawsCameraEffectId' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, CurseGoldenClawsCoffinEffectId) == 0x000188, "Member 'UNicolaDataAssetEvent::CurseGoldenClawsCoffinEffectId' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, DispelCurseGoldenClawsScriptName) == 0x000190, "Member 'UNicolaDataAssetEvent::DispelCurseGoldenClawsScriptName' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, LancelReturnTrialChurchId) == 0x0001A0, "Member 'UNicolaDataAssetEvent::LancelReturnTrialChurchId' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, ClonePCFadeTime) == 0x0001A8, "Member 'UNicolaDataAssetEvent::ClonePCFadeTime' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, RestartChurchScriptFunctionName) == 0x0001B0, "Member 'UNicolaDataAssetEvent::RestartChurchScriptFunctionName' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetEvent, DLCScriptFunctionName) == 0x0001C0, "Member 'UNicolaDataAssetEvent::DLCScriptFunctionName' has a wrong offset!");

// Class Nicola.NicolaDataAssetGOPUnitLooks
// 0x0050 (0x0080 - 0x0030)
class UNicolaDataAssetGOPUnitLooks final : public UDataAsset
{
public:
	TMap<class FName, TSoftClassPtr<class UClass>> LooksActorClasses;                                 // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetGOPUnitLooks">();
	}
	static class UNicolaDataAssetGOPUnitLooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetGOPUnitLooks>();
	}
};
static_assert(alignof(UNicolaDataAssetGOPUnitLooks) == 0x000008, "Wrong alignment on UNicolaDataAssetGOPUnitLooks");
static_assert(sizeof(UNicolaDataAssetGOPUnitLooks) == 0x000080, "Wrong size on UNicolaDataAssetGOPUnitLooks");
static_assert(offsetof(UNicolaDataAssetGOPUnitLooks, LooksActorClasses) == 0x000030, "Member 'UNicolaDataAssetGOPUnitLooks::LooksActorClasses' has a wrong offset!");

// Class Nicola.UISaveLoadList
// 0x0020 (0x00F0 - 0x00D0)
class UUISaveLoadList : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadList">();
	}
	static class UUISaveLoadList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadList>();
	}
};
static_assert(alignof(UUISaveLoadList) == 0x000008, "Wrong alignment on UUISaveLoadList");
static_assert(sizeof(UUISaveLoadList) == 0x0000F0, "Wrong size on UUISaveLoadList");

// Class Nicola.UIEndingSaveMenuListSave
// 0x0000 (0x00F0 - 0x00F0)
class UUIEndingSaveMenuListSave final : public UUISaveLoadList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingSaveMenuListSave">();
	}
	static class UUIEndingSaveMenuListSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingSaveMenuListSave>();
	}
};
static_assert(alignof(UUIEndingSaveMenuListSave) == 0x000008, "Wrong alignment on UUIEndingSaveMenuListSave");
static_assert(sizeof(UUIEndingSaveMenuListSave) == 0x0000F0, "Wrong size on UUIEndingSaveMenuListSave");

// Class Nicola.NicolaDataAssetMapCommon
// 0x01E0 (0x0210 - 0x0030)
class UNicolaDataAssetMapCommon final : public UNicolaDataAssetBase
{
public:
	float                                         GhostShipMoveSpeedMin;                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipMoveSpeedMax;                             // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipMoveLengthMin;                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipMoveLengthMax;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipMoveIntervalSecMin;                       // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipMoveIntervalSecMax;                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipRotationPowerMin;                         // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipRotationPowerMax;                         // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipRotationIntervalSecMin;                   // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostShipRotationIntervalSecMax;                   // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GhostShipClass;                                    // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GhostShipBuildingWithJumpPointClass;               // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GhostShipLevelLoaderActorClass;                    // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             GhostShipMoveCurveObject;                          // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             GhostShipRotationCurveObject;                      // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   HeroShipUpperClass;                                // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   HeroShipUnderClass;                                // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TownHeroShipUpperClass;                            // 0x0170(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TownHeroShipUnderClass;                            // 0x0198(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TownShipTrapClass;                                 // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TownShipBoatClass;                                 // 0x01E8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetMapCommon">();
	}
	static class UNicolaDataAssetMapCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetMapCommon>();
	}
};
static_assert(alignof(UNicolaDataAssetMapCommon) == 0x000008, "Wrong alignment on UNicolaDataAssetMapCommon");
static_assert(sizeof(UNicolaDataAssetMapCommon) == 0x000210, "Wrong size on UNicolaDataAssetMapCommon");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveSpeedMin) == 0x000030, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveSpeedMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveSpeedMax) == 0x000034, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveSpeedMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveLengthMin) == 0x000038, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveLengthMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveLengthMax) == 0x00003C, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveLengthMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveIntervalSecMin) == 0x000040, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveIntervalSecMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveIntervalSecMax) == 0x000044, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveIntervalSecMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipRotationPowerMin) == 0x000048, "Member 'UNicolaDataAssetMapCommon::GhostShipRotationPowerMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipRotationPowerMax) == 0x00004C, "Member 'UNicolaDataAssetMapCommon::GhostShipRotationPowerMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipRotationIntervalSecMin) == 0x000050, "Member 'UNicolaDataAssetMapCommon::GhostShipRotationIntervalSecMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipRotationIntervalSecMax) == 0x000054, "Member 'UNicolaDataAssetMapCommon::GhostShipRotationIntervalSecMax' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipClass) == 0x000058, "Member 'UNicolaDataAssetMapCommon::GhostShipClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipBuildingWithJumpPointClass) == 0x000080, "Member 'UNicolaDataAssetMapCommon::GhostShipBuildingWithJumpPointClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipLevelLoaderActorClass) == 0x0000A8, "Member 'UNicolaDataAssetMapCommon::GhostShipLevelLoaderActorClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipMoveCurveObject) == 0x0000D0, "Member 'UNicolaDataAssetMapCommon::GhostShipMoveCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, GhostShipRotationCurveObject) == 0x0000F8, "Member 'UNicolaDataAssetMapCommon::GhostShipRotationCurveObject' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, HeroShipUpperClass) == 0x000120, "Member 'UNicolaDataAssetMapCommon::HeroShipUpperClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, HeroShipUnderClass) == 0x000148, "Member 'UNicolaDataAssetMapCommon::HeroShipUnderClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, TownHeroShipUpperClass) == 0x000170, "Member 'UNicolaDataAssetMapCommon::TownHeroShipUpperClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, TownHeroShipUnderClass) == 0x000198, "Member 'UNicolaDataAssetMapCommon::TownHeroShipUnderClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, TownShipTrapClass) == 0x0001C0, "Member 'UNicolaDataAssetMapCommon::TownShipTrapClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetMapCommon, TownShipBoatClass) == 0x0001E8, "Member 'UNicolaDataAssetMapCommon::TownShipBoatClass' has a wrong offset!");

// Class Nicola.NicolaDataAssetParameterCollection
// 0x0190 (0x01C0 - 0x0030)
class UNicolaDataAssetParameterCollection final : public UNicolaDataAssetBase
{
public:
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParameterCollection_Debug;                 // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraParameterCollection> NiagaraParameterCollection_Debug;                  // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParameterCollection_Effect;                // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraParameterCollection> NiagaraParameterCollection_Effect;                 // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParameterCollection_FieldMap;              // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraParameterCollection> NiagaraParameterCollection_FieldMap;               // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParameterCollection_TownDungeonMap;        // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraParameterCollection> NiagaraParameterCollection_TownDungeonMap;         // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParameterCollection_BattleMap;             // 0x0170(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraParameterCollection> NiagaraParameterCollection_BattleMap;              // 0x0198(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetParameterCollection">();
	}
	static class UNicolaDataAssetParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetParameterCollection>();
	}
};
static_assert(alignof(UNicolaDataAssetParameterCollection) == 0x000008, "Wrong alignment on UNicolaDataAssetParameterCollection");
static_assert(sizeof(UNicolaDataAssetParameterCollection) == 0x0001C0, "Wrong size on UNicolaDataAssetParameterCollection");
static_assert(offsetof(UNicolaDataAssetParameterCollection, MaterialParameterCollection_Debug) == 0x000030, "Member 'UNicolaDataAssetParameterCollection::MaterialParameterCollection_Debug' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, NiagaraParameterCollection_Debug) == 0x000058, "Member 'UNicolaDataAssetParameterCollection::NiagaraParameterCollection_Debug' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, MaterialParameterCollection_Effect) == 0x000080, "Member 'UNicolaDataAssetParameterCollection::MaterialParameterCollection_Effect' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, NiagaraParameterCollection_Effect) == 0x0000A8, "Member 'UNicolaDataAssetParameterCollection::NiagaraParameterCollection_Effect' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, MaterialParameterCollection_FieldMap) == 0x0000D0, "Member 'UNicolaDataAssetParameterCollection::MaterialParameterCollection_FieldMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, NiagaraParameterCollection_FieldMap) == 0x0000F8, "Member 'UNicolaDataAssetParameterCollection::NiagaraParameterCollection_FieldMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, MaterialParameterCollection_TownDungeonMap) == 0x000120, "Member 'UNicolaDataAssetParameterCollection::MaterialParameterCollection_TownDungeonMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, NiagaraParameterCollection_TownDungeonMap) == 0x000148, "Member 'UNicolaDataAssetParameterCollection::NiagaraParameterCollection_TownDungeonMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, MaterialParameterCollection_BattleMap) == 0x000170, "Member 'UNicolaDataAssetParameterCollection::MaterialParameterCollection_BattleMap' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetParameterCollection, NiagaraParameterCollection_BattleMap) == 0x000198, "Member 'UNicolaDataAssetParameterCollection::NiagaraParameterCollection_BattleMap' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuWindowSub
// 0x0018 (0x0070 - 0x0058)
class UUIFieldEquipMenuWindowSub final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          ItemText;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIFieldEquipMenuItemSub*>       ItemStatus;                                        // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuWindowSub">();
	}
	static class UUIFieldEquipMenuWindowSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuWindowSub>();
	}
};
static_assert(alignof(UUIFieldEquipMenuWindowSub) == 0x000008, "Wrong alignment on UUIFieldEquipMenuWindowSub");
static_assert(sizeof(UUIFieldEquipMenuWindowSub) == 0x000070, "Wrong size on UUIFieldEquipMenuWindowSub");
static_assert(offsetof(UUIFieldEquipMenuWindowSub, ItemText) == 0x000058, "Member 'UUIFieldEquipMenuWindowSub::ItemText' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuWindowSub, ItemStatus) == 0x000060, "Member 'UUIFieldEquipMenuWindowSub::ItemStatus' has a wrong offset!");

// Class Nicola.NicolaDataAssetSoundCommon
// 0x00E0 (0x0110 - 0x0030)
class UNicolaDataAssetSoundCommon final : public UNicolaDataAssetBase
{
public:
	float                                         BattleAdditionalMarginSecPostFadeOutPreBgm;        // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventSequenceDuckingVolumeRate;                    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ENicolaSoundCategory>                  EventSequenceDuckingSoundCategories;               // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaSoundCueSheetTypeVoice, struct FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage> LocalizeCueSheetsVoice;                            // 0x0048(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MapTransitionSoundFadeOutSec;                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapTransitionSoundFadeOutSecBgm;                   // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ENicolaSoundCategory>                  MEDuckingSoundCategoriesOnPlaying;                 // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SoundTransitionFadeOutSecMin;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundTransitionFadeInSecMin;                       // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundTransitionMarginSecPostFadeOut;               // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SoundSuperVisionWidgetClass;                       // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SoundSuperVisionWidgetContentClass;                // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetSoundCommon">();
	}
	static class UNicolaDataAssetSoundCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetSoundCommon>();
	}
};
static_assert(alignof(UNicolaDataAssetSoundCommon) == 0x000008, "Wrong alignment on UNicolaDataAssetSoundCommon");
static_assert(sizeof(UNicolaDataAssetSoundCommon) == 0x000110, "Wrong size on UNicolaDataAssetSoundCommon");
static_assert(offsetof(UNicolaDataAssetSoundCommon, BattleAdditionalMarginSecPostFadeOutPreBgm) == 0x000030, "Member 'UNicolaDataAssetSoundCommon::BattleAdditionalMarginSecPostFadeOutPreBgm' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, EventSequenceDuckingVolumeRate) == 0x000034, "Member 'UNicolaDataAssetSoundCommon::EventSequenceDuckingVolumeRate' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, EventSequenceDuckingSoundCategories) == 0x000038, "Member 'UNicolaDataAssetSoundCommon::EventSequenceDuckingSoundCategories' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, LocalizeCueSheetsVoice) == 0x000048, "Member 'UNicolaDataAssetSoundCommon::LocalizeCueSheetsVoice' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, MapTransitionSoundFadeOutSec) == 0x000098, "Member 'UNicolaDataAssetSoundCommon::MapTransitionSoundFadeOutSec' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, MapTransitionSoundFadeOutSecBgm) == 0x00009C, "Member 'UNicolaDataAssetSoundCommon::MapTransitionSoundFadeOutSecBgm' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, MEDuckingSoundCategoriesOnPlaying) == 0x0000A0, "Member 'UNicolaDataAssetSoundCommon::MEDuckingSoundCategoriesOnPlaying' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, SoundTransitionFadeOutSecMin) == 0x0000B0, "Member 'UNicolaDataAssetSoundCommon::SoundTransitionFadeOutSecMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, SoundTransitionFadeInSecMin) == 0x0000B4, "Member 'UNicolaDataAssetSoundCommon::SoundTransitionFadeInSecMin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, SoundTransitionMarginSecPostFadeOut) == 0x0000B8, "Member 'UNicolaDataAssetSoundCommon::SoundTransitionMarginSecPostFadeOut' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, SoundSuperVisionWidgetClass) == 0x0000C0, "Member 'UNicolaDataAssetSoundCommon::SoundSuperVisionWidgetClass' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetSoundCommon, SoundSuperVisionWidgetContentClass) == 0x0000E8, "Member 'UNicolaDataAssetSoundCommon::SoundSuperVisionWidgetContentClass' has a wrong offset!");

// Class Nicola.NicolaDataAssetStaffRoll
// 0x0188 (0x01B8 - 0x0030)
class UNicolaDataAssetStaffRoll final : public UNicolaDataAssetBase
{
public:
	float                                         ScrollSpeed;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMargin;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           StartPos;                                          // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              EndPos;                                            // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DisplaySize;                                       // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_LayoutHeader;                                   // 0x0098(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_LayoutHeader2;                                  // 0x00C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_LayoutBodySingle;                               // 0x00E8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_LayoutBodyDouble;                               // 0x0110(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_LayoutBodyTriple;                               // 0x0138(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_LayoutImage;                                    // 0x0160(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WB_DebugInfo;                                      // 0x0188(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugInfoPos;                                      // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDataAssetStaffRoll">();
	}
	static class UNicolaDataAssetStaffRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDataAssetStaffRoll>();
	}
};
static_assert(alignof(UNicolaDataAssetStaffRoll) == 0x000008, "Wrong alignment on UNicolaDataAssetStaffRoll");
static_assert(sizeof(UNicolaDataAssetStaffRoll) == 0x0001B8, "Wrong size on UNicolaDataAssetStaffRoll");
static_assert(offsetof(UNicolaDataAssetStaffRoll, ScrollSpeed) == 0x000030, "Member 'UNicolaDataAssetStaffRoll::ScrollSpeed' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, EndMargin) == 0x000034, "Member 'UNicolaDataAssetStaffRoll::EndMargin' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, StartPos) == 0x000038, "Member 'UNicolaDataAssetStaffRoll::StartPos' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, EndPos) == 0x000088, "Member 'UNicolaDataAssetStaffRoll::EndPos' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, DisplaySize) == 0x000090, "Member 'UNicolaDataAssetStaffRoll::DisplaySize' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_LayoutHeader) == 0x000098, "Member 'UNicolaDataAssetStaffRoll::WB_LayoutHeader' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_LayoutHeader2) == 0x0000C0, "Member 'UNicolaDataAssetStaffRoll::WB_LayoutHeader2' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_LayoutBodySingle) == 0x0000E8, "Member 'UNicolaDataAssetStaffRoll::WB_LayoutBodySingle' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_LayoutBodyDouble) == 0x000110, "Member 'UNicolaDataAssetStaffRoll::WB_LayoutBodyDouble' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_LayoutBodyTriple) == 0x000138, "Member 'UNicolaDataAssetStaffRoll::WB_LayoutBodyTriple' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_LayoutImage) == 0x000160, "Member 'UNicolaDataAssetStaffRoll::WB_LayoutImage' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, WB_DebugInfo) == 0x000188, "Member 'UNicolaDataAssetStaffRoll::WB_DebugInfo' has a wrong offset!");
static_assert(offsetof(UNicolaDataAssetStaffRoll, DebugInfoPos) == 0x0001B0, "Member 'UNicolaDataAssetStaffRoll::DebugInfoPos' has a wrong offset!");

// Class Nicola.NicolaDebugSetting
// 0x0128 (0x0150 - 0x0028)
class UNicolaDebugSetting final : public USaveGame
{
public:
	uint64                                        debugActionFlags;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        debugDrawFlags;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        debugSoundFlags;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        debugWorldMapFlags;                                // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         mapTimeProgressSecondsPerHour;                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         mapTimeStart;                                      // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         mapTimeProgressRate;                               // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        elapsedTimeBattleType;                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        GameTypeVersion;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         gameClearCount;                                    // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         elapsedTimeBattle;                                 // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         saveLoadErrorCode;                                 // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        debugEtcFlags;                                     // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDebugForcePersuade                           forcePersuade;                                     // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDebugVoteResult                              voteResult;                                        // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         battleAttackAlwaysDeadType;                        // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         battleAttackDamageZeroType;                        // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         battleDorpItemRarity;                              // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        debugBattleFlags;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         debugBattleActionPattern;                          // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   debugBattleActionId;                               // 0x0084(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         debugBattleRandomAction;                           // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   debugBattlePlayAction;                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         debugSkillTransformTarget;                         // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, uint8>                      debugLogLevels;                                    // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      debugSoundSuperVisionVolumePercentSettings;        // 0x00F0(0x0050)(NativeAccessSpecifierPrivate)
	uint32                                        debugSkillFlags;                                   // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   debugUnitPersonality;                              // 0x0144(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ClearDebugActionFlags();
	static void ClearDebugBattleActionId();
	static void ClearDebugBattleActionPattern();
	static void ClearDebugBattleFlags();
	static void ClearDebugBattlePlayAction();
	static void ClearDebugBattleRandomAction();
	static void ClearDebugDrawFlags();
	static void ClearDebugEtcFlags();
	static void ClearDebugForcePersuade();
	static void ClearDebugLogLevels();
	static void ClearDebugMapTimeProgressRate();
	static void ClearDebugMapTimeProgressSecondsPerHour();
	static void ClearDebugMapTimeStart();
	static void ClearDebugSkillFlags();
	static void ClearDebugSkillTransformTarget();
	static void ClearDebugSoundFlags();
	static void ClearDebugUnitPersonality();
	static void ClearDebugVoteResult();
	static void ClearDebugWorldMapFlags();
	static void ClearElapsedTimeBattle();
	static void ClearElapsedTimeBattleType();
	static void ClearEtcData();
	static void ClearGameClearCount();
	static void ClearGameTypeVersion();
	static void ClearSaveLoadErrorCode();
	static int32 GetBattleAttackAlwaysDeadType();
	static int32 GetBattleAttackDamageZeroType();
	static int32 GetBattleDropItemRarity();
	static float GetBgmVolumeRate();
	static float GetCameraSpeedRateH();
	static float GetCameraSpeedRateV();
	static float GetCursorBaseRotateByStickAxisDotMin();
	static float GetCursorBaseRotateByStickAxisSizeMin();
	static class FName GetDebugBattleActionId();
	static int32 GetDebugBattleActionPattern();
	static class FName GetDebugBattlePlayAction();
	static int32 GetDebugBattleRandomAction();
	static EDebugForcePersuade GetDebugForcePersuade();
	static uint8 GetDebugLogLevel(class FName logCategory);
	static float GetDebugMapTimeProgressRate();
	static float GetDebugMapTimeProgressSecondsPerHour();
	static float GetDebugMapTimeStart();
	static int32 GetDebugSkillTransformTarget();
	static class FName GetDebugUnitPersonality();
	static EDebugVoteResult GetDebugVoteResult();
	static float GetElapsedTimeBattle();
	static int32 GetElapsedTimeBattleType();
	static bool GetEnableCursorBaseRotateByStickCheck();
	static bool GetEnableForceFeedback();
	static int32 GetGameClearCount();
	static int32 GetGameTypeVersion();
	static float GetPostProcessGainRate();
	static bool GetQuickCameraRotation();
	static bool GetReverseCameraH();
	static bool GetReverseCameraV();
	static int32 GetSaveLoadErrorCode();
	static float GetSeVolumeRate();
	static float GetVoiceVolumeRate();
	static bool IsDebugActionFlagOn(EDebugActionFlags flag);
	static bool IsDebugBattleFlagOn(EDebugBattleFlags flag);
	static bool IsDebugDrawFlagOn(EDebugDrawFlags flag);
	static bool IsDebugEtcFlagOn(EDebugEtcFlags flag);
	static bool IsDebugSkillFlagOn(EDebugSkillFlags flag);
	static bool IsDebugSoundFlagOn(EDebugSoundFlags flag);
	static bool IsDebugWorldMapFlagOn(EDebugWorldMapFlags flag);
	static class UNicolaDebugSetting* Reset();
	static void SetBattleAttackAlwaysDeadType(int32 Type);
	static void SetBattleAttackDamageZeroType(int32 Type);
	static void SetBattleDropItemRarity(int32 rarity);
	static void SetBgmVolumeRate(float Rate);
	static void SetCameraSpeedRateH(float Rate);
	static void SetCameraSpeedRateV(float Rate);
	static void SetCursorBaseRotateByStickAxisDotMin(const class UObject* WorldContextObject, float Val);
	static void SetCursorBaseRotateByStickAxisSizeMin(const class UObject* WorldContextObject, float Val);
	static void SetDebugActionFlag(EDebugActionFlags flag, bool Value);
	static void SetDebugBattleActionId(const class FName& actionId);
	static void SetDebugBattleActionPattern(int32 pattern);
	static void SetDebugBattleFlag(EDebugBattleFlags flag, bool Value);
	static void SetDebugBattlePlayAction(const class FName& actionId);
	static void SetDebugBattleRandomAction(int32 action);
	static void SetDebugDrawFlag(EDebugDrawFlags flag, bool Value);
	static void SetDebugEtcFlag(EDebugEtcFlags flag, bool Value);
	static void SetDebugForcePersuade(EDebugForcePersuade Value);
	static void SetDebugLogLevel(class FName logCategory, uint8 logVerbosity);
	static void SetDebugMapTimeProgressRate(float Rate);
	static void SetDebugMapTimeProgressSecondsPerHour(float secondsPerHour);
	static void SetDebugMapTimeStart(float MapTime);
	static void SetDebugSkillFlag(EDebugSkillFlags flag, bool Value);
	static void SetDebugSkillTransformTarget(int32 TARGET);
	static void SetDebugSoundFlag(EDebugSoundFlags flag, bool Value);
	static void SetDebugUnitPersonality(const class FName& TARGET);
	static void SetDebugVoteResult(EDebugVoteResult Value);
	static void SetDebugWorldMapFlag(EDebugWorldMapFlags flag, bool Value);
	static void SetElapsedTimeBattle(float elapsedTimeBattle_0);
	static void SetElapsedTimeBattleType(int32 elapsedTimeBattleType_0);
	static void SetEnableCursorBaseRotateByStickCheck(const class UObject* WorldContextObject, bool bEnable);
	static void SetEnableForceFeedback(bool Enable);
	static void SetGameClearCount(int32 gameClearCount_0);
	static void SetGameTypeVersion(int32 GameTypeVersion_0);
	static void SetPostProcessGainRate(float Rate);
	static void SetPostProcessGammaRate(float Rate);
	static void SetQuickCameraRotation(bool Enable);
	static void SetReverseCameraH(bool Reverse);
	static void SetReverseCameraV(bool Reverse);
	static void SetSaveLoadErrorCode(int32 saveLoadErrorCode_0);
	static void SetSeVolumeRate(float Rate);
	static void SetVoiceVolumeRate(float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDebugSetting">();
	}
	static class UNicolaDebugSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDebugSetting>();
	}
};
static_assert(alignof(UNicolaDebugSetting) == 0x000008, "Wrong alignment on UNicolaDebugSetting");
static_assert(sizeof(UNicolaDebugSetting) == 0x000150, "Wrong size on UNicolaDebugSetting");
static_assert(offsetof(UNicolaDebugSetting, debugActionFlags) == 0x000028, "Member 'UNicolaDebugSetting::debugActionFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugDrawFlags) == 0x000030, "Member 'UNicolaDebugSetting::debugDrawFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugSoundFlags) == 0x000038, "Member 'UNicolaDebugSetting::debugSoundFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugWorldMapFlags) == 0x00003C, "Member 'UNicolaDebugSetting::debugWorldMapFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, mapTimeProgressSecondsPerHour) == 0x000040, "Member 'UNicolaDebugSetting::mapTimeProgressSecondsPerHour' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, mapTimeStart) == 0x000044, "Member 'UNicolaDebugSetting::mapTimeStart' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, mapTimeProgressRate) == 0x000048, "Member 'UNicolaDebugSetting::mapTimeProgressRate' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, elapsedTimeBattleType) == 0x00004C, "Member 'UNicolaDebugSetting::elapsedTimeBattleType' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, GameTypeVersion) == 0x000050, "Member 'UNicolaDebugSetting::GameTypeVersion' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, gameClearCount) == 0x000054, "Member 'UNicolaDebugSetting::gameClearCount' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, elapsedTimeBattle) == 0x000058, "Member 'UNicolaDebugSetting::elapsedTimeBattle' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, saveLoadErrorCode) == 0x00005C, "Member 'UNicolaDebugSetting::saveLoadErrorCode' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugEtcFlags) == 0x000060, "Member 'UNicolaDebugSetting::debugEtcFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, forcePersuade) == 0x000064, "Member 'UNicolaDebugSetting::forcePersuade' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, voteResult) == 0x000065, "Member 'UNicolaDebugSetting::voteResult' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, battleAttackAlwaysDeadType) == 0x000068, "Member 'UNicolaDebugSetting::battleAttackAlwaysDeadType' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, battleAttackDamageZeroType) == 0x00006C, "Member 'UNicolaDebugSetting::battleAttackDamageZeroType' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, battleDorpItemRarity) == 0x000070, "Member 'UNicolaDebugSetting::battleDorpItemRarity' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugBattleFlags) == 0x000078, "Member 'UNicolaDebugSetting::debugBattleFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugBattleActionPattern) == 0x000080, "Member 'UNicolaDebugSetting::debugBattleActionPattern' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugBattleActionId) == 0x000084, "Member 'UNicolaDebugSetting::debugBattleActionId' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugBattleRandomAction) == 0x00008C, "Member 'UNicolaDebugSetting::debugBattleRandomAction' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugBattlePlayAction) == 0x000090, "Member 'UNicolaDebugSetting::debugBattlePlayAction' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugSkillTransformTarget) == 0x000098, "Member 'UNicolaDebugSetting::debugSkillTransformTarget' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugLogLevels) == 0x0000A0, "Member 'UNicolaDebugSetting::debugLogLevels' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugSoundSuperVisionVolumePercentSettings) == 0x0000F0, "Member 'UNicolaDebugSetting::debugSoundSuperVisionVolumePercentSettings' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugSkillFlags) == 0x000140, "Member 'UNicolaDebugSetting::debugSkillFlags' has a wrong offset!");
static_assert(offsetof(UNicolaDebugSetting, debugUnitPersonality) == 0x000144, "Member 'UNicolaDebugSetting::debugUnitPersonality' has a wrong offset!");

// Class Nicola.NicolaDPICustomScalingRule
// 0x0000 (0x0028 - 0x0028)
class UNicolaDPICustomScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDPICustomScalingRule">();
	}
	static class UNicolaDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDPICustomScalingRule>();
	}
};
static_assert(alignof(UNicolaDPICustomScalingRule) == 0x000008, "Wrong alignment on UNicolaDPICustomScalingRule");
static_assert(sizeof(UNicolaDPICustomScalingRule) == 0x000028, "Wrong size on UNicolaDPICustomScalingRule");

// Class Nicola.NpcAIController
// 0x00F8 (0x0420 - 0x0328)
class ANpcAIController final : public AAIController
{
public:
	uint8                                         Pad_328[0x38];                                     // 0x0328(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpFloat*                           JumpInterp;                                        // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            JumpCurve;                                         // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpFloat*                           MoveUpOrDownInterp;                                // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x98];                                     // 0x0388(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FRotator GetNpcRotatorForDirectionType(ENpcDirectionType Type);

	void ChangeMovePattern(ENpcMovePattern NextState, int32 nextSpeedIdx, int32 nextWaitIdx);
	void InitializeScriptOnly();
	void InterruptScriptAnimationBP(EAnimationType AnimType, bool IsLoop, bool IsAutoIdle, float AnimRate, bool IsOverride);
	void InterruptScriptCommandAllAbort();
	void InterruptScriptEnd();
	void InterruptScriptJump(float InJumpHeight, float InJumpSeconds, bool InNoWaitJump);
	void InterruptScriptMove(const struct FVector& targetLocation, float MoveSpeed, bool IsRelative, ENpcDirectionType DirectionType, EAnimationType AnimType, float AnimRate, int32 PlayType);
	void InterruptScriptMovePhysicsJump(const struct FVector& InLocation, float InMoveSpeed, float InJumpZVelocity, EAnimationType InAnimationType);
	void InterruptScriptMoveUpOrDownInterpolate(float Height, bool IsMoveUp, float Seconds, EEasingFunc EaseFunc, float EaseExp);
	void InterruptScriptStart();
	void InterruptScriptTurn(ENpcDirectionType Type);
	void InterruptScriptTurnFromRotation(const struct FRotator& Rotation, bool InIsRelative);
	void InterruptScriptWait(float InWaitTime);
	void OnCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ResetOverrideAnimation();

	bool IsMoveState() const;
	bool IsScriptAnimation() const;
	bool IsScriptControl() const;
	bool IsScriptJump() const;
	bool IsScriptMove() const;
	bool IsScriptMovePhysicsJump() const;
	bool IsScriptTurn() const;
	bool IsTurnState() const;
	bool IsWaitCommand() const;
	bool IsWaitMoveUpOrDownInterpolate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcAIController">();
	}
	static class ANpcAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcAIController>();
	}
};
static_assert(alignof(ANpcAIController) == 0x000008, "Wrong alignment on ANpcAIController");
static_assert(sizeof(ANpcAIController) == 0x000420, "Wrong size on ANpcAIController");
static_assert(offsetof(ANpcAIController, JumpInterp) == 0x000360, "Member 'ANpcAIController::JumpInterp' has a wrong offset!");
static_assert(offsetof(ANpcAIController, JumpCurve) == 0x000368, "Member 'ANpcAIController::JumpCurve' has a wrong offset!");
static_assert(offsetof(ANpcAIController, MoveUpOrDownInterp) == 0x000380, "Member 'ANpcAIController::MoveUpOrDownInterp' has a wrong offset!");

// Class Nicola.WidgetSoundSuperVisionTop
// 0x0128 (0x0388 - 0x0260)
class UWidgetSoundSuperVisionTop final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSoundSuperVisionContent*         ReferenceTopic;                                    // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSoundSuperVisionContent*         ReferenceCurrent;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSoundSuperVisionContent*         ReferenceHold;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSoundSuperVisionContent*         DebugMenuSoundSuperVisionContentTopic;             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcherArrowUp;                             // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcherArrowDown;                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBoxContentRoot;                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextCurrentStartPosition;                          // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextCurrentEndPosition;                            // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EWidgetSoundSuperVisionState, struct FLinearColor> LinearColorsBackground;                            // 0x02B0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidgetSoundSuperVisionContent*> WidgetSoundSuperVisionContents;                    // 0x0300(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x78];                                     // 0x0310(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetSoundSuperVisionTop">();
	}
	static class UWidgetSoundSuperVisionTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetSoundSuperVisionTop>();
	}
};
static_assert(alignof(UWidgetSoundSuperVisionTop) == 0x000008, "Wrong alignment on UWidgetSoundSuperVisionTop");
static_assert(sizeof(UWidgetSoundSuperVisionTop) == 0x000388, "Wrong size on UWidgetSoundSuperVisionTop");
static_assert(offsetof(UWidgetSoundSuperVisionTop, ReferenceTopic) == 0x000268, "Member 'UWidgetSoundSuperVisionTop::ReferenceTopic' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, ReferenceCurrent) == 0x000270, "Member 'UWidgetSoundSuperVisionTop::ReferenceCurrent' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, ReferenceHold) == 0x000278, "Member 'UWidgetSoundSuperVisionTop::ReferenceHold' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, DebugMenuSoundSuperVisionContentTopic) == 0x000280, "Member 'UWidgetSoundSuperVisionTop::DebugMenuSoundSuperVisionContentTopic' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, WidgetSwitcherArrowUp) == 0x000288, "Member 'UWidgetSoundSuperVisionTop::WidgetSwitcherArrowUp' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, WidgetSwitcherArrowDown) == 0x000290, "Member 'UWidgetSoundSuperVisionTop::WidgetSwitcherArrowDown' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, VerticalBoxContentRoot) == 0x000298, "Member 'UWidgetSoundSuperVisionTop::VerticalBoxContentRoot' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, TextCurrentStartPosition) == 0x0002A0, "Member 'UWidgetSoundSuperVisionTop::TextCurrentStartPosition' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, TextCurrentEndPosition) == 0x0002A8, "Member 'UWidgetSoundSuperVisionTop::TextCurrentEndPosition' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, LinearColorsBackground) == 0x0002B0, "Member 'UWidgetSoundSuperVisionTop::LinearColorsBackground' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionTop, WidgetSoundSuperVisionContents) == 0x000300, "Member 'UWidgetSoundSuperVisionTop::WidgetSoundSuperVisionContents' has a wrong offset!");

// Class Nicola.NicolaDynamicFlipbookFactory
// 0x0000 (0x0028 - 0x0028)
class UNicolaDynamicFlipbookFactory final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaDynamicFlipbookFactory">();
	}
	static class UNicolaDynamicFlipbookFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaDynamicFlipbookFactory>();
	}
};
static_assert(alignof(UNicolaDynamicFlipbookFactory) == 0x000008, "Wrong alignment on UNicolaDynamicFlipbookFactory");
static_assert(sizeof(UNicolaDynamicFlipbookFactory) == 0x000028, "Wrong size on UNicolaDynamicFlipbookFactory");

// Class Nicola.RockPuzzleGimmickActor
// 0x0050 (0x0270 - 0x0220)
class ARockPuzzleGimmickActor final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorListComponent*                    ActorList;                                         // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RockPuzzleId;                                      // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARockGimmick*>                   RockGimmickActors;                                 // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ARockPuzzleGoalFloor*>           RockPuzzleGoalActors;                              // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class ARockPuzzleAreaVolume*                  RockPuzzleArea;                                    // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RetryPlayerStartTag;                               // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveRockOneSquare(class ARockGimmick* RockGimmick);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockPuzzleGimmickActor">();
	}
	static class ARockPuzzleGimmickActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockPuzzleGimmickActor>();
	}
};
static_assert(alignof(ARockPuzzleGimmickActor) == 0x000008, "Wrong alignment on ARockPuzzleGimmickActor");
static_assert(sizeof(ARockPuzzleGimmickActor) == 0x000270, "Wrong size on ARockPuzzleGimmickActor");
static_assert(offsetof(ARockPuzzleGimmickActor, ActorList) == 0x000228, "Member 'ARockPuzzleGimmickActor::ActorList' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGimmickActor, RockPuzzleId) == 0x000230, "Member 'ARockPuzzleGimmickActor::RockPuzzleId' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGimmickActor, RockGimmickActors) == 0x000238, "Member 'ARockPuzzleGimmickActor::RockGimmickActors' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGimmickActor, RockPuzzleGoalActors) == 0x000248, "Member 'ARockPuzzleGimmickActor::RockPuzzleGoalActors' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGimmickActor, RockPuzzleArea) == 0x000258, "Member 'ARockPuzzleGimmickActor::RockPuzzleArea' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGimmickActor, RetryPlayerStartTag) == 0x000260, "Member 'ARockPuzzleGimmickActor::RetryPlayerStartTag' has a wrong offset!");

// Class Nicola.NicolaEffectManager
// 0x0020 (0x0048 - 0x0028)
class UNicolaEffectManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEffectParameterCollection*             EffectParameterCollection;                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFadeEffectInfo>                fadeEffectInfoArray;                               // 0x0038(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UNicolaEffectManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEffectManager">();
	}
	static class UNicolaEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaEffectManager>();
	}
};
static_assert(alignof(UNicolaEffectManager) == 0x000008, "Wrong alignment on UNicolaEffectManager");
static_assert(sizeof(UNicolaEffectManager) == 0x000048, "Wrong size on UNicolaEffectManager");
static_assert(offsetof(UNicolaEffectManager, EffectParameterCollection) == 0x000030, "Member 'UNicolaEffectManager::EffectParameterCollection' has a wrong offset!");
static_assert(offsetof(UNicolaEffectManager, fadeEffectInfoArray) == 0x000038, "Member 'UNicolaEffectManager::fadeEffectInfoArray' has a wrong offset!");

// Class Nicola.UnitPassiveDataFL
// 0x0000 (0x0028 - 0x0028)
class UUnitPassiveDataFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnitPassiveDataFL">();
	}
	static class UUnitPassiveDataFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnitPassiveDataFL>();
	}
};
static_assert(alignof(UUnitPassiveDataFL) == 0x000008, "Wrong alignment on UUnitPassiveDataFL");
static_assert(sizeof(UUnitPassiveDataFL) == 0x000028, "Wrong size on UUnitPassiveDataFL");

// Class Nicola.NicolaEncountCalcActor
// 0x0000 (0x0220 - 0x0220)
class ANicolaEncountCalcActor final : public AActor
{
public:
	float CalcEncountSec(float min_time, float max_time, float offset_time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEncountCalcActor">();
	}
	static class ANicolaEncountCalcActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaEncountCalcActor>();
	}
};
static_assert(alignof(ANicolaEncountCalcActor) == 0x000008, "Wrong alignment on ANicolaEncountCalcActor");
static_assert(sizeof(ANicolaEncountCalcActor) == 0x000220, "Wrong size on ANicolaEncountCalcActor");

// Class Nicola.NicolaEndingManager
// 0x0010 (0x0038 - 0x0028)
class UNicolaEndingManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UNicolaEndingManager* GetInstance();

	void Begin();
	void StartDebugEndingEvent();
	void StartDebugEndingSave();
	void StartDebugEndingStaffroll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEndingManager">();
	}
	static class UNicolaEndingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaEndingManager>();
	}
};
static_assert(alignof(UNicolaEndingManager) == 0x000008, "Wrong alignment on UNicolaEndingManager");
static_assert(sizeof(UNicolaEndingManager) == 0x000038, "Wrong size on UNicolaEndingManager");

// Class Nicola.ResearchSequenceCamera
// 0x0230 (0x0580 - 0x0350)
class alignas(0x10) AResearchSequenceCamera final : public ASequenceCameraManager
{
public:
	class ACameraActor*                           SequenceCamera;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class ULevelSequence>>  levelSequences;                                    // 0x0360(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FString, TSoftObjectPtr<class AActor>> ObjectBindMap;                                     // 0x0370(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class USequencerPostUpdateComponent*          PostUpdateComponent;                               // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEventCutSceneBindData>         EventCutBindDataList;                              // 0x03C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEventCutSceneBindData>         DummyBindData;                                     // 0x03D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FMovieSceneObjectBindingID, struct FMovieSceneObjectBindingIDs> BindParentChildMap;                                // 0x03E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x78];                                     // 0x0438(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AProduceSequencerBase*>            ProduceSequencerSet;                               // 0x04B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class USkipSequenceEventTriggerProcessBase*> EventTriggerProcessSet;                            // 0x0510(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            ChangeComponentsByRenderCharacterForegroundPrePass; // 0x0570(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void DebugPlaySequence(int32 Index_0);
	void OnPlaySequenceAfterFirstFrame();
	void PlaySequence(int32 Index_0, bool bIsInvisibleNpc, bool bJumpToEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResearchSequenceCamera">();
	}
	static class AResearchSequenceCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResearchSequenceCamera>();
	}
};
static_assert(alignof(AResearchSequenceCamera) == 0x000010, "Wrong alignment on AResearchSequenceCamera");
static_assert(sizeof(AResearchSequenceCamera) == 0x000580, "Wrong size on AResearchSequenceCamera");
static_assert(offsetof(AResearchSequenceCamera, SequenceCamera) == 0x000350, "Member 'AResearchSequenceCamera::SequenceCamera' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, TargetActor) == 0x000358, "Member 'AResearchSequenceCamera::TargetActor' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, levelSequences) == 0x000360, "Member 'AResearchSequenceCamera::levelSequences' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, ObjectBindMap) == 0x000370, "Member 'AResearchSequenceCamera::ObjectBindMap' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, PostUpdateComponent) == 0x0003C0, "Member 'AResearchSequenceCamera::PostUpdateComponent' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, EventCutBindDataList) == 0x0003C8, "Member 'AResearchSequenceCamera::EventCutBindDataList' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, DummyBindData) == 0x0003D8, "Member 'AResearchSequenceCamera::DummyBindData' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, BindParentChildMap) == 0x0003E8, "Member 'AResearchSequenceCamera::BindParentChildMap' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, ProduceSequencerSet) == 0x0004B0, "Member 'AResearchSequenceCamera::ProduceSequencerSet' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, EventTriggerProcessSet) == 0x000510, "Member 'AResearchSequenceCamera::EventTriggerProcessSet' has a wrong offset!");
static_assert(offsetof(AResearchSequenceCamera, ChangeComponentsByRenderCharacterForegroundPrePass) == 0x000570, "Member 'AResearchSequenceCamera::ChangeComponentsByRenderCharacterForegroundPrePass' has a wrong offset!");

// Class Nicola.UIWindowItemMovie
// 0x0050 (0x0090 - 0x0040)
class UUIWindowItemMovie : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ANicolaManaMovieActor*                  ManaActor;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UManaTexture>            LoadingTexture;                                    // 0x0058(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UManaTexture*                           ManaTexture;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageMovie;                                        // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnLoadedMovie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemMovie">();
	}
	static class UUIWindowItemMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemMovie>();
	}
};
static_assert(alignof(UUIWindowItemMovie) == 0x000008, "Wrong alignment on UUIWindowItemMovie");
static_assert(sizeof(UUIWindowItemMovie) == 0x000090, "Wrong size on UUIWindowItemMovie");
static_assert(offsetof(UUIWindowItemMovie, ManaActor) == 0x000048, "Member 'UUIWindowItemMovie::ManaActor' has a wrong offset!");
static_assert(offsetof(UUIWindowItemMovie, LoadingTexture) == 0x000058, "Member 'UUIWindowItemMovie::LoadingTexture' has a wrong offset!");
static_assert(offsetof(UUIWindowItemMovie, ManaTexture) == 0x000080, "Member 'UUIWindowItemMovie::ManaTexture' has a wrong offset!");
static_assert(offsetof(UUIWindowItemMovie, ImageMovie) == 0x000088, "Member 'UUIWindowItemMovie::ImageMovie' has a wrong offset!");

// Class Nicola.UIWindowItemMovieImage
// 0x0038 (0x00C8 - 0x0090)
class UUIWindowItemMovieImage final : public UUIWindowItemMovie
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              LoadingImageTexture;                               // 0x0098(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnLoadedImage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemMovieImage">();
	}
	static class UUIWindowItemMovieImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemMovieImage>();
	}
};
static_assert(alignof(UUIWindowItemMovieImage) == 0x000008, "Wrong alignment on UUIWindowItemMovieImage");
static_assert(sizeof(UUIWindowItemMovieImage) == 0x0000C8, "Wrong size on UUIWindowItemMovieImage");
static_assert(offsetof(UUIWindowItemMovieImage, LoadingImageTexture) == 0x000098, "Member 'UUIWindowItemMovieImage::LoadingImageTexture' has a wrong offset!");
static_assert(offsetof(UUIWindowItemMovieImage, ItemImage) == 0x0000C0, "Member 'UUIWindowItemMovieImage::ItemImage' has a wrong offset!");

// Class Nicola.NicolaEventFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaEventFL final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyEventDebug(const class FName& EventDebugId, const class UDataTable* DebugTable, bool ChangeMap);
	static bool CheckEnableEchoFlute();
	static bool CheckEnableRemirama();
	static void CloseEventScreenShot();
	static bool DebugPlayEventScript(const EEventTriggerType Type, const class FName& TriggerID, const class FString& EventID);
	static void DispelCurseGoldenClaws(bool IsPyramidUnderGround);
	static bool ExistEventForTriggerType(const EEventTriggerType Type);
	static class FName GetEventDebugDescription(const class FName& EventDebugId, const class UDataTable* DebugTable);
	static TArray<class FString> GetEventIdList(const EEventTriggerType Type, const class FName TriggerID);
	static void GetFlagIndexStartEnd(EEventFlagType FlagType, int32* Start, int32* End);
	static int32 GetNumOfSearchObjContainItems(bool IsCheckOnlyScreen);
	static class FString GetSaveFlagStr(const int32 Index_0);
	static TArray<class FName> GetTriggerIdList(const EEventTriggerType Type);
	static TArray<class FName> GetUIManpuIDList();
	static bool IsPlayEventScript();
	static EInpasuType JudgeInpasuType();
	static struct FEventConditionInfo MakeEventConditionInfo(const class FString& InEventId, int32 InPriority, int32 InProgLower, int32 InProgUpper, class FName InFlagName1, bool InIsTrueCondition1, class FName InFlagName2, bool InIsTrueCondition2, bool IsAndOperator, class FName InGopId);
	static struct FEventConditionInfo MakeEventConditionInfoForGOPEventCommon(const struct FGOP_Event_CommonTable& EventTable);
	static TArray<class FName> MakeScriptCommandTag(const class FString& EventID, const class FName& TriggerID, const class FName& GopId, const class FName& NpcTypeId, const bool IsLookAtPlayerToTarget, const class FName& CollisionTag);
	static void PlayEffectEchoFlute(const class FName& EffectId, float PlayEffectTime);
	static void PlayEffectInpasu();
	static void PlayEffectRemirama(const class FName& EffectId, float PlayEffectTime);
	static bool PlayEventScript(const EEventTriggerType TriggerType, const class FName TriggerID);
	static bool PlayEventScriptCommand(const class FString& EventScriptId, const TArray<class FName>& Tags, const TArray<class FName>& Args);
	static void ReloadEventData(const class FString& ScriptPath, const class FName& MapName, class UDataTable* EventTable, class UDataTable* TalkTable, class UDataTable* SearchTable);
	static void RequestEventScreenShotTexture(const class FName& InScreenShotGopId);
	static void ResetEffectAndFlagsCurseGoldenClaws();
	static void ResetFlag(EEventFlagType FlagType);
	static void ResetTempSaveFlag(bool IsResetDungeon, bool IsResetSuspend);
	static void RetryRockPuzzleGimmick();
	static void SaveTemporaryEventDataInfo();
	static void ShowEventScreenShot(const class FName& InScreenShotGopId);
	static void StartEventScreenShotUI();
	static void StopEffectInpasu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEventFL">();
	}
	static class UNicolaEventFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaEventFL>();
	}
};
static_assert(alignof(UNicolaEventFL) == 0x000008, "Wrong alignment on UNicolaEventFL");
static_assert(sizeof(UNicolaEventFL) == 0x000028, "Wrong size on UNicolaEventFL");

// Class Nicola.UIBar2MenuListParty2
// 0x0028 (0x00F8 - 0x00D0)
class UUIBar2MenuListParty2 final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListParty2">();
	}
	static class UUIBar2MenuListParty2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListParty2>();
	}
};
static_assert(alignof(UUIBar2MenuListParty2) == 0x000008, "Wrong alignment on UUIBar2MenuListParty2");
static_assert(sizeof(UUIBar2MenuListParty2) == 0x0000F8, "Wrong size on UUIBar2MenuListParty2");

// Class Nicola.NicolaEventManager
// 0x0130 (0x0158 - 0x0028)
class UNicolaEventManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentScriptPath;                                 // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentMapName;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CurrentEventTable;                                 // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CurrentTalkTable;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CurrentSearchTable;                                // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CommonEventTable;                                  // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CommonTalkTable;                                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CommonSearchTable;                                 // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EEventTriggerType, struct FEventInfo>    EventInfoMap;                                      // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EEventTriggerType, struct FEventInfo>    CommonEventInfoMap;                                // 0x00D8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRestoreDataAfterEvent>         RestoreDataSet;                                    // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEventManager">();
	}
	static class UNicolaEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaEventManager>();
	}
};
static_assert(alignof(UNicolaEventManager) == 0x000008, "Wrong alignment on UNicolaEventManager");
static_assert(sizeof(UNicolaEventManager) == 0x000158, "Wrong size on UNicolaEventManager");
static_assert(offsetof(UNicolaEventManager, CurrentScriptPath) == 0x000040, "Member 'UNicolaEventManager::CurrentScriptPath' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CurrentMapName) == 0x000050, "Member 'UNicolaEventManager::CurrentMapName' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CurrentEventTable) == 0x000058, "Member 'UNicolaEventManager::CurrentEventTable' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CurrentTalkTable) == 0x000060, "Member 'UNicolaEventManager::CurrentTalkTable' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CurrentSearchTable) == 0x000068, "Member 'UNicolaEventManager::CurrentSearchTable' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CommonEventTable) == 0x000070, "Member 'UNicolaEventManager::CommonEventTable' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CommonTalkTable) == 0x000078, "Member 'UNicolaEventManager::CommonTalkTable' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CommonSearchTable) == 0x000080, "Member 'UNicolaEventManager::CommonSearchTable' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, EventInfoMap) == 0x000088, "Member 'UNicolaEventManager::EventInfoMap' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, CommonEventInfoMap) == 0x0000D8, "Member 'UNicolaEventManager::CommonEventInfoMap' has a wrong offset!");
static_assert(offsetof(UNicolaEventManager, RestoreDataSet) == 0x000138, "Member 'UNicolaEventManager::RestoreDataSet' has a wrong offset!");

// Class Nicola.NicolaEventSequenceCameraActor
// 0x0000 (0x0820 - 0x0820)
class ANicolaEventSequenceCameraActor final : public ASequenceCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEventSequenceCameraActor">();
	}
	static class ANicolaEventSequenceCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaEventSequenceCameraActor>();
	}
};
static_assert(alignof(ANicolaEventSequenceCameraActor) == 0x000010, "Wrong alignment on ANicolaEventSequenceCameraActor");
static_assert(sizeof(ANicolaEventSequenceCameraActor) == 0x000820, "Wrong size on ANicolaEventSequenceCameraActor");

// Class Nicola.NicolaEventSequencerPostProcessVolume
// 0x0000 (0x07D0 - 0x07D0)
class ANicolaEventSequencerPostProcessVolume final : public ANicolaSequencerPostProcessVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaEventSequencerPostProcessVolume">();
	}
	static class ANicolaEventSequencerPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaEventSequencerPostProcessVolume>();
	}
};
static_assert(alignof(ANicolaEventSequencerPostProcessVolume) == 0x000010, "Wrong alignment on ANicolaEventSequencerPostProcessVolume");
static_assert(sizeof(ANicolaEventSequencerPostProcessVolume) == 0x0007D0, "Wrong size on ANicolaEventSequencerPostProcessVolume");

// Class Nicola.NicolaFadingActor
// 0x00D0 (0x02F0 - 0x0220)
class ANicolaFadingActor : public AActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoFadeByTrigger;                                  // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoFadeByCameraPos;                                // 0x0229(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PositionOffset;                                    // 0x022C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoNotRenderInMainPassAfterEndingFadeOut;          // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverrideFadingTime;                             // 0x0239(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A[0x2];                                      // 0x023A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideFadingTime;                                // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverrideStartFadingDistanceFromCamera;          // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideStartFadingDistanceFromCamera;             // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverrideFadingOffsetDepth;                      // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideFadingOffsetDepth;                         // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoInvertStaticMeshFading;                         // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoInvertNiagaraFading;                            // 0x0251(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252[0x16];                                     // 0x0252(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            fadeCurveFloat;                                    // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         requestedTriggerArray;                             // 0x0270(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       staticMeshMIDArray;                                // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInstanceDynamic*, float>  staticMeshDefaultDepthMap;                         // 0x0290(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              niagaraComponentArray;                             // 0x02E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFadingActor">();
	}
	static class ANicolaFadingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFadingActor>();
	}
};
static_assert(alignof(ANicolaFadingActor) == 0x000008, "Wrong alignment on ANicolaFadingActor");
static_assert(sizeof(ANicolaFadingActor) == 0x0002F0, "Wrong size on ANicolaFadingActor");
static_assert(offsetof(ANicolaFadingActor, ActorListComponent) == 0x000220, "Member 'ANicolaFadingActor::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoFadeByTrigger) == 0x000228, "Member 'ANicolaFadingActor::bDoFadeByTrigger' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoFadeByCameraPos) == 0x000229, "Member 'ANicolaFadingActor::bDoFadeByCameraPos' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, PositionOffset) == 0x00022C, "Member 'ANicolaFadingActor::PositionOffset' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoNotRenderInMainPassAfterEndingFadeOut) == 0x000238, "Member 'ANicolaFadingActor::bDoNotRenderInMainPassAfterEndingFadeOut' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoOverrideFadingTime) == 0x000239, "Member 'ANicolaFadingActor::bDoOverrideFadingTime' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, OverrideFadingTime) == 0x00023C, "Member 'ANicolaFadingActor::OverrideFadingTime' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoOverrideStartFadingDistanceFromCamera) == 0x000240, "Member 'ANicolaFadingActor::bDoOverrideStartFadingDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, OverrideStartFadingDistanceFromCamera) == 0x000244, "Member 'ANicolaFadingActor::OverrideStartFadingDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoOverrideFadingOffsetDepth) == 0x000248, "Member 'ANicolaFadingActor::bDoOverrideFadingOffsetDepth' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, OverrideFadingOffsetDepth) == 0x00024C, "Member 'ANicolaFadingActor::OverrideFadingOffsetDepth' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoInvertStaticMeshFading) == 0x000250, "Member 'ANicolaFadingActor::bDoInvertStaticMeshFading' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, bDoInvertNiagaraFading) == 0x000251, "Member 'ANicolaFadingActor::bDoInvertNiagaraFading' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, fadeCurveFloat) == 0x000268, "Member 'ANicolaFadingActor::fadeCurveFloat' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, requestedTriggerArray) == 0x000270, "Member 'ANicolaFadingActor::requestedTriggerArray' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, staticMeshMIDArray) == 0x000280, "Member 'ANicolaFadingActor::staticMeshMIDArray' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, staticMeshDefaultDepthMap) == 0x000290, "Member 'ANicolaFadingActor::staticMeshDefaultDepthMap' has a wrong offset!");
static_assert(offsetof(ANicolaFadingActor, niagaraComponentArray) == 0x0002E0, "Member 'ANicolaFadingActor::niagaraComponentArray' has a wrong offset!");

// Class Nicola.NicolaFadingStaticMeshActor
// 0x00C0 (0x02F0 - 0x0230)
class ANicolaFadingStaticMeshActor final : public AStaticMeshActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoFadeByTrigger;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoFadeByCameraPos;                                // 0x0239(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A[0x2];                                      // 0x023A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PositionOffset;                                    // 0x023C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoNotRenderInMainPassAfterEndingFadeOut;          // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverrideFadingTime;                             // 0x0249(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x2];                                      // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideFadingTime;                                // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverrideStartFadingDistanceFromCamera;          // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideStartFadingDistanceFromCamera;             // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoOverrideFadingOffsetDepth;                      // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideFadingOffsetDepth;                         // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoInvertFading;                                   // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x17];                                     // 0x0261(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            fadeCurveFloat;                                    // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         requestedTriggerArray;                             // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       staticMeshMIDArray;                                // 0x0290(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInstanceDynamic*, float>  staticMeshDefaultDepthMap;                         // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFadingStaticMeshActor">();
	}
	static class ANicolaFadingStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFadingStaticMeshActor>();
	}
};
static_assert(alignof(ANicolaFadingStaticMeshActor) == 0x000008, "Wrong alignment on ANicolaFadingStaticMeshActor");
static_assert(sizeof(ANicolaFadingStaticMeshActor) == 0x0002F0, "Wrong size on ANicolaFadingStaticMeshActor");
static_assert(offsetof(ANicolaFadingStaticMeshActor, ActorListComponent) == 0x000230, "Member 'ANicolaFadingStaticMeshActor::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoFadeByTrigger) == 0x000238, "Member 'ANicolaFadingStaticMeshActor::bDoFadeByTrigger' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoFadeByCameraPos) == 0x000239, "Member 'ANicolaFadingStaticMeshActor::bDoFadeByCameraPos' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, PositionOffset) == 0x00023C, "Member 'ANicolaFadingStaticMeshActor::PositionOffset' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoNotRenderInMainPassAfterEndingFadeOut) == 0x000248, "Member 'ANicolaFadingStaticMeshActor::bDoNotRenderInMainPassAfterEndingFadeOut' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoOverrideFadingTime) == 0x000249, "Member 'ANicolaFadingStaticMeshActor::bDoOverrideFadingTime' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, OverrideFadingTime) == 0x00024C, "Member 'ANicolaFadingStaticMeshActor::OverrideFadingTime' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoOverrideStartFadingDistanceFromCamera) == 0x000250, "Member 'ANicolaFadingStaticMeshActor::bDoOverrideStartFadingDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, OverrideStartFadingDistanceFromCamera) == 0x000254, "Member 'ANicolaFadingStaticMeshActor::OverrideStartFadingDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoOverrideFadingOffsetDepth) == 0x000258, "Member 'ANicolaFadingStaticMeshActor::bDoOverrideFadingOffsetDepth' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, OverrideFadingOffsetDepth) == 0x00025C, "Member 'ANicolaFadingStaticMeshActor::OverrideFadingOffsetDepth' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, bDoInvertFading) == 0x000260, "Member 'ANicolaFadingStaticMeshActor::bDoInvertFading' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, fadeCurveFloat) == 0x000278, "Member 'ANicolaFadingStaticMeshActor::fadeCurveFloat' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, requestedTriggerArray) == 0x000280, "Member 'ANicolaFadingStaticMeshActor::requestedTriggerArray' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, staticMeshMIDArray) == 0x000290, "Member 'ANicolaFadingStaticMeshActor::staticMeshMIDArray' has a wrong offset!");
static_assert(offsetof(ANicolaFadingStaticMeshActor, staticMeshDefaultDepthMap) == 0x0002A0, "Member 'ANicolaFadingStaticMeshActor::staticMeshDefaultDepthMap' has a wrong offset!");

// Class Nicola.RockGimmickPersonality
// 0x0020 (0x02E8 - 0x02C8)
class ARockGimmickPersonality final : public ARockGimmick
{
public:
	class UMaterialInstanceDynamic*               MaterialInstanceFadeOut;                           // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           FadeInterp;                                        // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockGimmickPersonality">();
	}
	static class ARockGimmickPersonality* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockGimmickPersonality>();
	}
};
static_assert(alignof(ARockGimmickPersonality) == 0x000008, "Wrong alignment on ARockGimmickPersonality");
static_assert(sizeof(ARockGimmickPersonality) == 0x0002E8, "Wrong size on ARockGimmickPersonality");
static_assert(offsetof(ARockGimmickPersonality, MaterialInstanceFadeOut) == 0x0002C8, "Member 'ARockGimmickPersonality::MaterialInstanceFadeOut' has a wrong offset!");
static_assert(offsetof(ARockGimmickPersonality, FadeInterp) == 0x0002D0, "Member 'ARockGimmickPersonality::FadeInterp' has a wrong offset!");

// Class Nicola.UIWindowItemTownName
// 0x0020 (0x0060 - 0x0040)
class UUIWindowItemTownName final : public UUIWindowItem
{
public:
	class UImage*                                 ImageBg;                                           // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemTownName">();
	}
	static class UUIWindowItemTownName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemTownName>();
	}
};
static_assert(alignof(UUIWindowItemTownName) == 0x000008, "Wrong alignment on UUIWindowItemTownName");
static_assert(sizeof(UUIWindowItemTownName) == 0x000060, "Wrong size on UUIWindowItemTownName");
static_assert(offsetof(UUIWindowItemTownName, ImageBg) == 0x000040, "Member 'UUIWindowItemTownName::ImageBg' has a wrong offset!");

// Class Nicola.NicolaFadingTriggerBase
// 0x0058 (0x0278 - 0x0220)
class ANicolaFadingTriggerBase : public AActor
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShapeComponent*                        collisionComponent;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           TargetActorTags;                                   // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDoGetMultiActorsByOneTag;                         // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x27];                                     // 0x0241(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         targetActorArray;                                  // 0x0268(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFadingTriggerBase">();
	}
	static class ANicolaFadingTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFadingTriggerBase>();
	}
};
static_assert(alignof(ANicolaFadingTriggerBase) == 0x000008, "Wrong alignment on ANicolaFadingTriggerBase");
static_assert(sizeof(ANicolaFadingTriggerBase) == 0x000278, "Wrong size on ANicolaFadingTriggerBase");
static_assert(offsetof(ANicolaFadingTriggerBase, ActorListComponent) == 0x000220, "Member 'ANicolaFadingTriggerBase::ActorListComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFadingTriggerBase, collisionComponent) == 0x000228, "Member 'ANicolaFadingTriggerBase::collisionComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFadingTriggerBase, TargetActorTags) == 0x000230, "Member 'ANicolaFadingTriggerBase::TargetActorTags' has a wrong offset!");
static_assert(offsetof(ANicolaFadingTriggerBase, bDoGetMultiActorsByOneTag) == 0x000240, "Member 'ANicolaFadingTriggerBase::bDoGetMultiActorsByOneTag' has a wrong offset!");
static_assert(offsetof(ANicolaFadingTriggerBase, targetActorArray) == 0x000268, "Member 'ANicolaFadingTriggerBase::targetActorArray' has a wrong offset!");

// Class Nicola.UIBarMenuListMember
// 0x0010 (0x00E0 - 0x00D0)
class UUIBarMenuListMember final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenuListMember">();
	}
	static class UUIBarMenuListMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenuListMember>();
	}
};
static_assert(alignof(UUIBarMenuListMember) == 0x000008, "Wrong alignment on UUIBarMenuListMember");
static_assert(sizeof(UUIBarMenuListMember) == 0x0000E0, "Wrong size on UUIBarMenuListMember");

// Class Nicola.NicolaFadingTriggerBox
// 0x0000 (0x0278 - 0x0278)
class ANicolaFadingTriggerBox : public ANicolaFadingTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFadingTriggerBox">();
	}
	static class ANicolaFadingTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFadingTriggerBox>();
	}
};
static_assert(alignof(ANicolaFadingTriggerBox) == 0x000008, "Wrong alignment on ANicolaFadingTriggerBox");
static_assert(sizeof(ANicolaFadingTriggerBox) == 0x000278, "Wrong size on ANicolaFadingTriggerBox");

// Class Nicola.NicolaFadingTriggerCapsule
// 0x0000 (0x0278 - 0x0278)
class ANicolaFadingTriggerCapsule final : public ANicolaFadingTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFadingTriggerCapsule">();
	}
	static class ANicolaFadingTriggerCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFadingTriggerCapsule>();
	}
};
static_assert(alignof(ANicolaFadingTriggerCapsule) == 0x000008, "Wrong alignment on ANicolaFadingTriggerCapsule");
static_assert(sizeof(ANicolaFadingTriggerCapsule) == 0x000278, "Wrong size on ANicolaFadingTriggerCapsule");

// Class Nicola.NicolaFadingTriggerSphere
// 0x0000 (0x0278 - 0x0278)
class ANicolaFadingTriggerSphere final : public ANicolaFadingTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFadingTriggerSphere">();
	}
	static class ANicolaFadingTriggerSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFadingTriggerSphere>();
	}
};
static_assert(alignof(ANicolaFadingTriggerSphere) == 0x000008, "Wrong alignment on ANicolaFadingTriggerSphere");
static_assert(sizeof(ANicolaFadingTriggerSphere) == 0x000278, "Wrong size on ANicolaFadingTriggerSphere");

// Class Nicola.NicolaFieldActorBase
// 0x0018 (0x0238 - 0x0220)
class ANicolaFieldActorBase : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          rootBoxComponent;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorListComponent;                                // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldActorBase">();
	}
	static class ANicolaFieldActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldActorBase>();
	}
};
static_assert(alignof(ANicolaFieldActorBase) == 0x000008, "Wrong alignment on ANicolaFieldActorBase");
static_assert(sizeof(ANicolaFieldActorBase) == 0x000238, "Wrong size on ANicolaFieldActorBase");
static_assert(offsetof(ANicolaFieldActorBase, rootBoxComponent) == 0x000228, "Member 'ANicolaFieldActorBase::rootBoxComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldActorBase, ActorListComponent) == 0x000230, "Member 'ANicolaFieldActorBase::ActorListComponent' has a wrong offset!");

// Class Nicola.NicolaTransitionLevel
// 0x0008 (0x0230 - 0x0228)
class ANicolaTransitionLevel final : public ALevelScriptActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaTransitionLevel">();
	}
	static class ANicolaTransitionLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaTransitionLevel>();
	}
};
static_assert(alignof(ANicolaTransitionLevel) == 0x000008, "Wrong alignment on ANicolaTransitionLevel");
static_assert(sizeof(ANicolaTransitionLevel) == 0x000230, "Wrong size on ANicolaTransitionLevel");

// Class Nicola.NicolaFieldActorInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaFieldActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldActorInterface">();
	}
	static class INicolaFieldActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaFieldActorInterface>();
	}
};
static_assert(alignof(INicolaFieldActorInterface) == 0x000008, "Wrong alignment on INicolaFieldActorInterface");
static_assert(sizeof(INicolaFieldActorInterface) == 0x000028, "Wrong size on INicolaFieldActorInterface");

// Class Nicola.NicolaFieldCameraActor
// 0x0000 (0x0AC0 - 0x0AC0)
class ANicolaFieldCameraActor : public ANicolaResearchCameraBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldCameraActor">();
	}
	static class ANicolaFieldCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldCameraActor>();
	}
};
static_assert(alignof(ANicolaFieldCameraActor) == 0x000010, "Wrong alignment on ANicolaFieldCameraActor");
static_assert(sizeof(ANicolaFieldCameraActor) == 0x000AC0, "Wrong size on ANicolaFieldCameraActor");

// Class Nicola.SearchObjectItem
// 0x0068 (0x0288 - 0x0220)
class ASearchObjectItem final : public AActor
{
public:
	class USceneComponent*                        BillboardComponent;                                // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPaperFlipbookComponent*                FlipbookComponent;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTimelineComponent*                     TimelineComponent;                                 // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndTime;                                           // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4C];                                     // 0x023C(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveToPlayer(const struct FVector& Offset);
	void PlayItemGet(EItemGetType Type);
	void PlaySearchObjectGet(ESearchObjectType Type);
	void SetLocationOffset(const struct FVector& Offset);
	void SetVisibilityItem(bool Visibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchObjectItem">();
	}
	static class ASearchObjectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchObjectItem>();
	}
};
static_assert(alignof(ASearchObjectItem) == 0x000008, "Wrong alignment on ASearchObjectItem");
static_assert(sizeof(ASearchObjectItem) == 0x000288, "Wrong size on ASearchObjectItem");
static_assert(offsetof(ASearchObjectItem, BillboardComponent) == 0x000220, "Member 'ASearchObjectItem::BillboardComponent' has a wrong offset!");
static_assert(offsetof(ASearchObjectItem, FlipbookComponent) == 0x000228, "Member 'ASearchObjectItem::FlipbookComponent' has a wrong offset!");
static_assert(offsetof(ASearchObjectItem, TimelineComponent) == 0x000230, "Member 'ASearchObjectItem::TimelineComponent' has a wrong offset!");
static_assert(offsetof(ASearchObjectItem, EndTime) == 0x000238, "Member 'ASearchObjectItem::EndTime' has a wrong offset!");

// Class Nicola.NicolaFieldEffectActor
// 0x0020 (0x0258 - 0x0238)
class ANicolaFieldEffectActor final : public ANicolaFieldActorBase
{
public:
	class UBoxComponent*                          triggerControlledEffectRootBoxComponent;           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoSetRandomSeedOffsetAutomatically;               // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              triggerControlledEffectComps;                      // 0x0248(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldEffectActor">();
	}
	static class ANicolaFieldEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldEffectActor>();
	}
};
static_assert(alignof(ANicolaFieldEffectActor) == 0x000008, "Wrong alignment on ANicolaFieldEffectActor");
static_assert(sizeof(ANicolaFieldEffectActor) == 0x000258, "Wrong size on ANicolaFieldEffectActor");
static_assert(offsetof(ANicolaFieldEffectActor, triggerControlledEffectRootBoxComponent) == 0x000238, "Member 'ANicolaFieldEffectActor::triggerControlledEffectRootBoxComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldEffectActor, bDoSetRandomSeedOffsetAutomatically) == 0x000240, "Member 'ANicolaFieldEffectActor::bDoSetRandomSeedOffsetAutomatically' has a wrong offset!");
static_assert(offsetof(ANicolaFieldEffectActor, triggerControlledEffectComps) == 0x000248, "Member 'ANicolaFieldEffectActor::triggerControlledEffectComps' has a wrong offset!");

// Class Nicola.ShineSearchEvent
// 0x0020 (0x02A0 - 0x0280)
class AShineSearchEvent : public ASearchEvent
{
public:
	class UChildActorComponent*                   DirectionChildActorComponent;                      // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeleteFadeOutSec;                                  // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpFloat*                           InterpFadeOut;                                     // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialInstanceFadeOut;                           // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnStartShineSearchEventEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShineSearchEvent">();
	}
	static class AShineSearchEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShineSearchEvent>();
	}
};
static_assert(alignof(AShineSearchEvent) == 0x000008, "Wrong alignment on AShineSearchEvent");
static_assert(sizeof(AShineSearchEvent) == 0x0002A0, "Wrong size on AShineSearchEvent");
static_assert(offsetof(AShineSearchEvent, DirectionChildActorComponent) == 0x000280, "Member 'AShineSearchEvent::DirectionChildActorComponent' has a wrong offset!");
static_assert(offsetof(AShineSearchEvent, DeleteFadeOutSec) == 0x000288, "Member 'AShineSearchEvent::DeleteFadeOutSec' has a wrong offset!");
static_assert(offsetof(AShineSearchEvent, InterpFadeOut) == 0x000290, "Member 'AShineSearchEvent::InterpFadeOut' has a wrong offset!");
static_assert(offsetof(AShineSearchEvent, MaterialInstanceFadeOut) == 0x000298, "Member 'AShineSearchEvent::MaterialInstanceFadeOut' has a wrong offset!");

// Class Nicola.NicolaFieldEffectTriggerBase
// 0x0010 (0x02E0 - 0x02D0)
class ANicolaFieldEffectTriggerBase final : public ANicolaFieldTriggerBase
{
public:
	TArray<TSoftObjectPtr<class ANicolaFieldEffectActor>> fieldEffectObjectPtrs;                             // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	ENicolaFieldTriggerActorTypeFlag              triggerActorType;                                  // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldEffectTriggerBase">();
	}
	static class ANicolaFieldEffectTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldEffectTriggerBase>();
	}
};
static_assert(alignof(ANicolaFieldEffectTriggerBase) == 0x000010, "Wrong alignment on ANicolaFieldEffectTriggerBase");
static_assert(sizeof(ANicolaFieldEffectTriggerBase) == 0x0002E0, "Wrong size on ANicolaFieldEffectTriggerBase");
static_assert(offsetof(ANicolaFieldEffectTriggerBase, fieldEffectObjectPtrs) == 0x0002C8, "Member 'ANicolaFieldEffectTriggerBase::fieldEffectObjectPtrs' has a wrong offset!");
static_assert(offsetof(ANicolaFieldEffectTriggerBase, triggerActorType) == 0x0002D8, "Member 'ANicolaFieldEffectTriggerBase::triggerActorType' has a wrong offset!");

// Class Nicola.NicolaFieldGameMode
// 0x0000 (0x02C0 - 0x02C0)
class ANicolaFieldGameMode : public ANicolaGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldGameMode">();
	}
	static class ANicolaFieldGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldGameMode>();
	}
};
static_assert(alignof(ANicolaFieldGameMode) == 0x000008, "Wrong alignment on ANicolaFieldGameMode");
static_assert(sizeof(ANicolaFieldGameMode) == 0x0002C0, "Wrong size on ANicolaFieldGameMode");

// Class Nicola.NicolaFieldLevel
// 0x0040 (0x02A0 - 0x0260)
class ANicolaFieldLevel : public ANicolaLevelBase
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ANicolaFieldLevelManager*               fieldLevelMan;                                     // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaParameterCollectionUpdatingActor* NPCUpdatingActor;                                  // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULanternManager*                        LanternManager;                                    // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                preLoadingEffectAssets;                            // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FNicolaFieldLevelStreamingInfo> NotStreamingLeveInfos;                             // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnVisibleLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldLevel">();
	}
	static class ANicolaFieldLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldLevel>();
	}
};
static_assert(alignof(ANicolaFieldLevel) == 0x000008, "Wrong alignment on ANicolaFieldLevel");
static_assert(sizeof(ANicolaFieldLevel) == 0x0002A0, "Wrong size on ANicolaFieldLevel");
static_assert(offsetof(ANicolaFieldLevel, fieldLevelMan) == 0x000268, "Member 'ANicolaFieldLevel::fieldLevelMan' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevel, NPCUpdatingActor) == 0x000270, "Member 'ANicolaFieldLevel::NPCUpdatingActor' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevel, LanternManager) == 0x000278, "Member 'ANicolaFieldLevel::LanternManager' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevel, preLoadingEffectAssets) == 0x000280, "Member 'ANicolaFieldLevel::preLoadingEffectAssets' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevel, NotStreamingLeveInfos) == 0x000290, "Member 'ANicolaFieldLevel::NotStreamingLeveInfos' has a wrong offset!");

// Class Nicola.UIBankTopMenu
// 0x0038 (0x00B0 - 0x0078)
class UUIBankTopMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBankTopMenuListTop*                  ListTop;                                           // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBankMoneyMenuListTop*                ListMoney;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoneyBank*                 ItemMoney;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoneyBank*                 ItemDepositMoney;                                  // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBankMenuWindowAll*                   AllButton;                                         // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBankTopMenu">();
	}
	static class UUIBankTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBankTopMenu>();
	}
};
static_assert(alignof(UUIBankTopMenu) == 0x000008, "Wrong alignment on UUIBankTopMenu");
static_assert(sizeof(UUIBankTopMenu) == 0x0000B0, "Wrong size on UUIBankTopMenu");
static_assert(offsetof(UUIBankTopMenu, ListTop) == 0x000088, "Member 'UUIBankTopMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIBankTopMenu, ListMoney) == 0x000090, "Member 'UUIBankTopMenu::ListMoney' has a wrong offset!");
static_assert(offsetof(UUIBankTopMenu, ItemMoney) == 0x000098, "Member 'UUIBankTopMenu::ItemMoney' has a wrong offset!");
static_assert(offsetof(UUIBankTopMenu, ItemDepositMoney) == 0x0000A0, "Member 'UUIBankTopMenu::ItemDepositMoney' has a wrong offset!");
static_assert(offsetof(UUIBankTopMenu, AllButton) == 0x0000A8, "Member 'UUIBankTopMenu::AllButton' has a wrong offset!");

// Class Nicola.UITitleMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUITitleMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenuListTop">();
	}
	static class UUITitleMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenuListTop>();
	}
};
static_assert(alignof(UUITitleMenuListTop) == 0x000008, "Wrong alignment on UUITitleMenuListTop");
static_assert(sizeof(UUITitleMenuListTop) == 0x0000D8, "Wrong size on UUITitleMenuListTop");

// Class Nicola.NicolaFieldLevelManager
// 0x0210 (0x0430 - 0x0220)
class ANicolaFieldLevelManager final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFieldGridData>                 gridDatas;                                         // 0x0228(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSet<int32>                                   shiftGridDataIds;                                  // 0x0238(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<int32>                                   visibleGridDataIds;                                // 0x0288(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         movableObjects;                                    // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         pendingObjects;                                    // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         loadingObjects;                                    // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ANicolaFieldEffectTriggerBase*, uint8> overlappedFieldEffectTriggers;                     // 0x0318(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ANicolaFieldEffectTriggerBase*, float> fieldEffectTriggerTimers;                          // 0x0368(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ANicolaFieldEffectActor*>          fieldEffectsRequestedToHide;                       // 0x03B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFieldLevelManagerRequestParam> fieldLevelManagerRequestParams;                    // 0x0418(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldLevelManager">();
	}
	static class ANicolaFieldLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldLevelManager>();
	}
};
static_assert(alignof(ANicolaFieldLevelManager) == 0x000008, "Wrong alignment on ANicolaFieldLevelManager");
static_assert(sizeof(ANicolaFieldLevelManager) == 0x000430, "Wrong size on ANicolaFieldLevelManager");
static_assert(offsetof(ANicolaFieldLevelManager, gridDatas) == 0x000228, "Member 'ANicolaFieldLevelManager::gridDatas' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, shiftGridDataIds) == 0x000238, "Member 'ANicolaFieldLevelManager::shiftGridDataIds' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, visibleGridDataIds) == 0x000288, "Member 'ANicolaFieldLevelManager::visibleGridDataIds' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, movableObjects) == 0x0002E0, "Member 'ANicolaFieldLevelManager::movableObjects' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, pendingObjects) == 0x0002F0, "Member 'ANicolaFieldLevelManager::pendingObjects' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, loadingObjects) == 0x000300, "Member 'ANicolaFieldLevelManager::loadingObjects' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, overlappedFieldEffectTriggers) == 0x000318, "Member 'ANicolaFieldLevelManager::overlappedFieldEffectTriggers' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, fieldEffectTriggerTimers) == 0x000368, "Member 'ANicolaFieldLevelManager::fieldEffectTriggerTimers' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, fieldEffectsRequestedToHide) == 0x0003B8, "Member 'ANicolaFieldLevelManager::fieldEffectsRequestedToHide' has a wrong offset!");
static_assert(offsetof(ANicolaFieldLevelManager, fieldLevelManagerRequestParams) == 0x000418, "Member 'ANicolaFieldLevelManager::fieldLevelManagerRequestParams' has a wrong offset!");

// Class Nicola.NicolaFieldMarkerComponent
// 0x0060 (0x0290 - 0x0230)
class UNicolaFieldMarkerComponent final : public UChildActorComponent
{
public:
	bool                                          doUseCameraRotationForDecal;                       // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         fadeInTime;                                        // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         fadeOutTime;                                       // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          doUsePlayerSpeedRange;                             // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         playerSpeedRangeMin;                               // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         playerSpeedRangeMax;                               // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         markerStaticMeshMoveSpeedXPos;                     // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         markerStaticMeshMoveSpeedXNeg;                     // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         markerStaticMeshMoveSpeedYPos;                     // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         markerStaticMeshMoveSpeedYNeg;                     // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         markerStaticMeshMoveSpeedZPos;                     // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         markerStaticMeshMoveSpeedZNeg;                     // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x2C];                                     // 0x0264(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldMarkerComponent">();
	}
	static class UNicolaFieldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaFieldMarkerComponent>();
	}
};
static_assert(alignof(UNicolaFieldMarkerComponent) == 0x000010, "Wrong alignment on UNicolaFieldMarkerComponent");
static_assert(sizeof(UNicolaFieldMarkerComponent) == 0x000290, "Wrong size on UNicolaFieldMarkerComponent");
static_assert(offsetof(UNicolaFieldMarkerComponent, doUseCameraRotationForDecal) == 0x000230, "Member 'UNicolaFieldMarkerComponent::doUseCameraRotationForDecal' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, FadeTime) == 0x000234, "Member 'UNicolaFieldMarkerComponent::FadeTime' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, fadeInTime) == 0x000238, "Member 'UNicolaFieldMarkerComponent::fadeInTime' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, fadeOutTime) == 0x00023C, "Member 'UNicolaFieldMarkerComponent::fadeOutTime' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, doUsePlayerSpeedRange) == 0x000240, "Member 'UNicolaFieldMarkerComponent::doUsePlayerSpeedRange' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, playerSpeedRangeMin) == 0x000244, "Member 'UNicolaFieldMarkerComponent::playerSpeedRangeMin' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, playerSpeedRangeMax) == 0x000248, "Member 'UNicolaFieldMarkerComponent::playerSpeedRangeMax' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, markerStaticMeshMoveSpeedXPos) == 0x00024C, "Member 'UNicolaFieldMarkerComponent::markerStaticMeshMoveSpeedXPos' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, markerStaticMeshMoveSpeedXNeg) == 0x000250, "Member 'UNicolaFieldMarkerComponent::markerStaticMeshMoveSpeedXNeg' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, markerStaticMeshMoveSpeedYPos) == 0x000254, "Member 'UNicolaFieldMarkerComponent::markerStaticMeshMoveSpeedYPos' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, markerStaticMeshMoveSpeedYNeg) == 0x000258, "Member 'UNicolaFieldMarkerComponent::markerStaticMeshMoveSpeedYNeg' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, markerStaticMeshMoveSpeedZPos) == 0x00025C, "Member 'UNicolaFieldMarkerComponent::markerStaticMeshMoveSpeedZPos' has a wrong offset!");
static_assert(offsetof(UNicolaFieldMarkerComponent, markerStaticMeshMoveSpeedZNeg) == 0x000260, "Member 'UNicolaFieldMarkerComponent::markerStaticMeshMoveSpeedZNeg' has a wrong offset!");

// Class Nicola.NicolaResearchPlayerCameraManagerBase
// 0x04B0 (0x2DB0 - 0x2900)
class ANicolaResearchPlayerCameraManagerBase : public ANicolaPlayerCameraManager
{
public:
	TArray<struct FCameraCollisionInfo>           m_collisions;                                      // 0x2900(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FCameraKeepOutInfo>             m_keepOuts;                                        // 0x2910(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2920[0x2C8];                                   // 0x2920(0x02C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_WalkToShip;                       // 0x2BE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BF0[0x8];                                     // 0x2BF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_WalkToBeginningLamia;             // 0x2BF8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C00[0x8];                                     // 0x2C00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_BeginningLamiaToPlayableLamia;    // 0x2C08(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C10[0x8];                                     // 0x2C10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_ShipToWalk;                       // 0x2C18(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C20[0x8];                                     // 0x2C20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_PlayableLamiaToEndingLamiaHigh;   // 0x2C28(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C30[0x8];                                     // 0x2C30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_PlayableLamiaToEndingLamiaLow;    // 0x2C38(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C40[0x8];                                     // 0x2C40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveInterpolate_EndingLamiaToWalk;                // 0x2C48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C50[0x10];                                    // 0x2C50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            currentCurveInterpolateCameraState;                // 0x2C60(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaCameraEffectActor*               cameraEffect;                                      // 0x2C68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANicolaCameraEffectActor*               battleCameraEffect;                                // 0x2C70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraEffectOffset;                                // 0x2C78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7C[0x4];                                     // 0x2C7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANicolaCameraFadeActor*                 cameraFade;                                        // 0x2C80(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CameraFadeActorClass;                              // 0x2C88(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ANicolaCameraEffectTriggerBase*, uint8> overlappedCameraEffectTriggers;                    // 0x2CB0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ANicolaCameraEffectTriggerBase*, float> cameraEffectTriggerTimers;                         // 0x2D00(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D50[0x60];                                    // 0x2D50(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestCameraFadeIn(float FadeTime);
	void RequestCameraFadeOut(float targetAlpha, float FadeTime);
	void RequestHideBattleCameraEffect(class FName AssetName, float FadeTime);
	void RequestHideCameraEffect(class FName AssetName, float FadeTime);
	void RequestShowBattleCameraEffect(class FName AssetName, float FadeTime);
	void RequestShowCameraEffect(class FName AssetName, float FadeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchPlayerCameraManagerBase">();
	}
	static class ANicolaResearchPlayerCameraManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchPlayerCameraManagerBase>();
	}
};
static_assert(alignof(ANicolaResearchPlayerCameraManagerBase) == 0x000010, "Wrong alignment on ANicolaResearchPlayerCameraManagerBase");
static_assert(sizeof(ANicolaResearchPlayerCameraManagerBase) == 0x002DB0, "Wrong size on ANicolaResearchPlayerCameraManagerBase");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, m_collisions) == 0x002900, "Member 'ANicolaResearchPlayerCameraManagerBase::m_collisions' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, m_keepOuts) == 0x002910, "Member 'ANicolaResearchPlayerCameraManagerBase::m_keepOuts' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_WalkToShip) == 0x002BE8, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_WalkToShip' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_WalkToBeginningLamia) == 0x002BF8, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_WalkToBeginningLamia' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_BeginningLamiaToPlayableLamia) == 0x002C08, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_BeginningLamiaToPlayableLamia' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_ShipToWalk) == 0x002C18, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_ShipToWalk' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_PlayableLamiaToEndingLamiaHigh) == 0x002C28, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_PlayableLamiaToEndingLamiaHigh' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_PlayableLamiaToEndingLamiaLow) == 0x002C38, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_PlayableLamiaToEndingLamiaLow' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, curveInterpolate_EndingLamiaToWalk) == 0x002C48, "Member 'ANicolaResearchPlayerCameraManagerBase::curveInterpolate_EndingLamiaToWalk' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, currentCurveInterpolateCameraState) == 0x002C60, "Member 'ANicolaResearchPlayerCameraManagerBase::currentCurveInterpolateCameraState' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, cameraEffect) == 0x002C68, "Member 'ANicolaResearchPlayerCameraManagerBase::cameraEffect' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, battleCameraEffect) == 0x002C70, "Member 'ANicolaResearchPlayerCameraManagerBase::battleCameraEffect' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, CameraEffectOffset) == 0x002C78, "Member 'ANicolaResearchPlayerCameraManagerBase::CameraEffectOffset' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, cameraFade) == 0x002C80, "Member 'ANicolaResearchPlayerCameraManagerBase::cameraFade' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, CameraFadeActorClass) == 0x002C88, "Member 'ANicolaResearchPlayerCameraManagerBase::CameraFadeActorClass' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, overlappedCameraEffectTriggers) == 0x002CB0, "Member 'ANicolaResearchPlayerCameraManagerBase::overlappedCameraEffectTriggers' has a wrong offset!");
static_assert(offsetof(ANicolaResearchPlayerCameraManagerBase, cameraEffectTriggerTimers) == 0x002D00, "Member 'ANicolaResearchPlayerCameraManagerBase::cameraEffectTriggerTimers' has a wrong offset!");

// Class Nicola.NicolaTitleGameMode
// 0x0000 (0x02C0 - 0x02C0)
class ANicolaTitleGameMode final : public ANicolaGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaTitleGameMode">();
	}
	static class ANicolaTitleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaTitleGameMode>();
	}
};
static_assert(alignof(ANicolaTitleGameMode) == 0x000008, "Wrong alignment on ANicolaTitleGameMode");
static_assert(sizeof(ANicolaTitleGameMode) == 0x0002C0, "Wrong size on ANicolaTitleGameMode");

// Class Nicola.NicolaFieldPlayerCameraManager
// 0x0000 (0x2DB0 - 0x2DB0)
class ANicolaFieldPlayerCameraManager final : public ANicolaResearchPlayerCameraManagerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldPlayerCameraManager">();
	}
	static class ANicolaFieldPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldPlayerCameraManager>();
	}
};
static_assert(alignof(ANicolaFieldPlayerCameraManager) == 0x000010, "Wrong alignment on ANicolaFieldPlayerCameraManager");
static_assert(sizeof(ANicolaFieldPlayerCameraManager) == 0x002DB0, "Wrong size on ANicolaFieldPlayerCameraManager");

// Class Nicola.NicolaVolumetricLightMapManager
// 0x0010 (0x0040 - 0x0030)
class UNicolaVolumetricLightMapManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaVolumetricLightMapManager">();
	}
	static class UNicolaVolumetricLightMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaVolumetricLightMapManager>();
	}
};
static_assert(alignof(UNicolaVolumetricLightMapManager) == 0x000008, "Wrong alignment on UNicolaVolumetricLightMapManager");
static_assert(sizeof(UNicolaVolumetricLightMapManager) == 0x000040, "Wrong size on UNicolaVolumetricLightMapManager");

// Class Nicola.NicolaFieldPlayerController
// 0x0000 (0x05D0 - 0x05D0)
class ANicolaFieldPlayerController : public ANicolaPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldPlayerController">();
	}
	static class ANicolaFieldPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldPlayerController>();
	}
};
static_assert(alignof(ANicolaFieldPlayerController) == 0x000008, "Wrong alignment on ANicolaFieldPlayerController");
static_assert(sizeof(ANicolaFieldPlayerController) == 0x0005D0, "Wrong size on ANicolaFieldPlayerController");

// Class Nicola.NicolaFieldSpotInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaFieldSpotInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldSpotInterface">();
	}
	static class INicolaFieldSpotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaFieldSpotInterface>();
	}
};
static_assert(alignof(INicolaFieldSpotInterface) == 0x000008, "Wrong alignment on INicolaFieldSpotInterface");
static_assert(sizeof(INicolaFieldSpotInterface) == 0x000028, "Wrong size on INicolaFieldSpotInterface");

// Class Nicola.NicolaFieldStaticMeshActorBase
// 0x0010 (0x0240 - 0x0230)
class ANicolaFieldStaticMeshActorBase final : public AStaticMeshActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorListComponent*                    ActorListComponent;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldStaticMeshActorBase">();
	}
	static class ANicolaFieldStaticMeshActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldStaticMeshActorBase>();
	}
};
static_assert(alignof(ANicolaFieldStaticMeshActorBase) == 0x000008, "Wrong alignment on ANicolaFieldStaticMeshActorBase");
static_assert(sizeof(ANicolaFieldStaticMeshActorBase) == 0x000240, "Wrong size on ANicolaFieldStaticMeshActorBase");
static_assert(offsetof(ANicolaFieldStaticMeshActorBase, ActorListComponent) == 0x000238, "Member 'ANicolaFieldStaticMeshActorBase::ActorListComponent' has a wrong offset!");

// Class Nicola.RichTextBlockMaterialDecorator
// 0x00E8 (0x0110 - 0x0028)
class URichTextBlockMaterialDecorator : public URichTextBlockDecorator
{
public:
	struct FSlateBrush                            MaterialIcon;                                      // 0x0028(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   TagName;                                           // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TagId;                                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      AdditionalMaterialParam;                           // 0x00C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockMaterialDecorator">();
	}
	static class URichTextBlockMaterialDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockMaterialDecorator>();
	}
};
static_assert(alignof(URichTextBlockMaterialDecorator) == 0x000008, "Wrong alignment on URichTextBlockMaterialDecorator");
static_assert(sizeof(URichTextBlockMaterialDecorator) == 0x000110, "Wrong size on URichTextBlockMaterialDecorator");
static_assert(offsetof(URichTextBlockMaterialDecorator, MaterialIcon) == 0x000028, "Member 'URichTextBlockMaterialDecorator::MaterialIcon' has a wrong offset!");
static_assert(offsetof(URichTextBlockMaterialDecorator, TagName) == 0x0000B0, "Member 'URichTextBlockMaterialDecorator::TagName' has a wrong offset!");
static_assert(offsetof(URichTextBlockMaterialDecorator, TagId) == 0x0000B8, "Member 'URichTextBlockMaterialDecorator::TagId' has a wrong offset!");
static_assert(offsetof(URichTextBlockMaterialDecorator, AdditionalMaterialParam) == 0x0000C0, "Member 'URichTextBlockMaterialDecorator::AdditionalMaterialParam' has a wrong offset!");

// Class Nicola.UIEndingStaffRollMenuItemScroll
// 0x0038 (0x0078 - 0x0040)
class UUIEndingStaffRollMenuItemScroll final : public UUIWindowItem
{
public:
	class UCanvasPanelSlot*                       Slot;                                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNicolaRichTextBlock*                   RichText;                                          // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNicolaRichTextBlock*                   RichText2;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNicolaRichTextBlock*                   RichText3;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon2;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon3;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingStaffRollMenuItemScroll">();
	}
	static class UUIEndingStaffRollMenuItemScroll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingStaffRollMenuItemScroll>();
	}
};
static_assert(alignof(UUIEndingStaffRollMenuItemScroll) == 0x000008, "Wrong alignment on UUIEndingStaffRollMenuItemScroll");
static_assert(sizeof(UUIEndingStaffRollMenuItemScroll) == 0x000078, "Wrong size on UUIEndingStaffRollMenuItemScroll");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, Slot) == 0x000040, "Member 'UUIEndingStaffRollMenuItemScroll::Slot' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, RichText) == 0x000048, "Member 'UUIEndingStaffRollMenuItemScroll::RichText' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, RichText2) == 0x000050, "Member 'UUIEndingStaffRollMenuItemScroll::RichText2' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, RichText3) == 0x000058, "Member 'UUIEndingStaffRollMenuItemScroll::RichText3' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, ItemIcon) == 0x000060, "Member 'UUIEndingStaffRollMenuItemScroll::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, ItemIcon2) == 0x000068, "Member 'UUIEndingStaffRollMenuItemScroll::ItemIcon2' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemScroll, ItemIcon3) == 0x000070, "Member 'UUIEndingStaffRollMenuItemScroll::ItemIcon3' has a wrong offset!");

// Class Nicola.NicolaFieldSymbolActor
// 0x0078 (0x02B0 - 0x0238)
class ANicolaFieldSymbolActor : public ANicolaFieldActorBase
{
public:
	class UBoxComponent*                          staticMeshRootComponent;                           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          niagaraRootComponent;                              // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          lightRootComponent;                                // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          collisionComponent;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   landingVolumeComponent;                            // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ULightComponent*, float>           lightCompInitialIntensity;                         // 0x0260(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFieldSymbolActor">();
	}
	static class ANicolaFieldSymbolActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFieldSymbolActor>();
	}
};
static_assert(alignof(ANicolaFieldSymbolActor) == 0x000008, "Wrong alignment on ANicolaFieldSymbolActor");
static_assert(sizeof(ANicolaFieldSymbolActor) == 0x0002B0, "Wrong size on ANicolaFieldSymbolActor");
static_assert(offsetof(ANicolaFieldSymbolActor, staticMeshRootComponent) == 0x000238, "Member 'ANicolaFieldSymbolActor::staticMeshRootComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldSymbolActor, niagaraRootComponent) == 0x000240, "Member 'ANicolaFieldSymbolActor::niagaraRootComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldSymbolActor, lightRootComponent) == 0x000248, "Member 'ANicolaFieldSymbolActor::lightRootComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldSymbolActor, collisionComponent) == 0x000250, "Member 'ANicolaFieldSymbolActor::collisionComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldSymbolActor, landingVolumeComponent) == 0x000258, "Member 'ANicolaFieldSymbolActor::landingVolumeComponent' has a wrong offset!");
static_assert(offsetof(ANicolaFieldSymbolActor, lightCompInitialIntensity) == 0x000260, "Member 'ANicolaFieldSymbolActor::lightCompInitialIntensity' has a wrong offset!");

// Class Nicola.NicolaFiledPlayerLoopTestMgr
// 0x0008 (0x0228 - 0x0220)
class ANicolaFiledPlayerLoopTestMgr final : public AActor
{
public:
	bool                                          bEnableLoop;                                       // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFiledPlayerLoopTestMgr">();
	}
	static class ANicolaFiledPlayerLoopTestMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaFiledPlayerLoopTestMgr>();
	}
};
static_assert(alignof(ANicolaFiledPlayerLoopTestMgr) == 0x000008, "Wrong alignment on ANicolaFiledPlayerLoopTestMgr");
static_assert(sizeof(ANicolaFiledPlayerLoopTestMgr) == 0x000228, "Wrong size on ANicolaFiledPlayerLoopTestMgr");
static_assert(offsetof(ANicolaFiledPlayerLoopTestMgr, bEnableLoop) == 0x000220, "Member 'ANicolaFiledPlayerLoopTestMgr::bEnableLoop' has a wrong offset!");

// Class Nicola.NicolaFlipbookNotifyComponent
// 0x0008 (0x00C0 - 0x00B8)
class UNicolaFlipbookNotifyComponent final : public UNicolaCharacterComponentBase
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaFlipbookNotifyComponent">();
	}
	static class UNicolaFlipbookNotifyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaFlipbookNotifyComponent>();
	}
};
static_assert(alignof(UNicolaFlipbookNotifyComponent) == 0x000008, "Wrong alignment on UNicolaFlipbookNotifyComponent");
static_assert(sizeof(UNicolaFlipbookNotifyComponent) == 0x0000C0, "Wrong size on UNicolaFlipbookNotifyComponent");

// Class Nicola.NicolaGameInstance
// 0x03C0 (0x0568 - 0x01A8)
class UNicolaGameInstance : public UGameInstance
{
public:
	class ULuaScriptMgr*                          LuaScriptMgr;                                      // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNicolaDataAssetGOPUnitLooks> DataAssetGOPUnitLooksObject;                       // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetCommon>  StaticDataCommonAsset;                             // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetBattle>  StaticDataBattleAsset;                             // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetParameterCollection> StaticDataParameterCollectionAsset;                // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetPlayerActor> StaticDataPlayerAsset;                             // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetSoundCommon> NicolaDataAssetSoundCommonObject;                  // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetSoundFieldAmbient> NicolaDataAssetSoundFieldAmbientObject;            // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetEvent>   NicolaDataAssetEventObject;                        // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetLevelCommon> NicolaDataAssetLevelCommonObject;                  // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetMapCommon> NicolaDataAssetMapCommonObject;                    // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetCameraCommon> NicolaDataAssetCameraCommonObject;                 // 0x0340(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetStaffRoll> NicolaDataAssetStaffRollObject;                    // 0x0368(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetAchievement> NicolaDataAssetAchievementObject;                  // 0x0390(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetGlow>    StaticDataGlowAsset;                               // 0x03B8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNicolaDataAssetMaterial> StaticDataMaterialAsset;                           // 0x03E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNicolaUIManager>           BP_NicolaUIManager;                                // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaInGameManager*                   InGameManager;                                     // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaUIManager*                       NicolaUIManager;                                   // 0x0418(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSoundManager*                    SoundManager;                                      // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSkillManager*                    SkillManager;                                      // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSaveGameManager*                 saveGameManager;                                   // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDebugSetting*                    debugSetting;                                      // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugParameterCollection*              DebugParameterCollection;                          // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorListMan*                          ActorListMan;                                      // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEffectAssetMan*                        EffectAssetMan;                                    // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInitialLoadingManager*                 InitialLoadingManager;                             // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaEventManager*                    EventMgr;                                          // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaEffectManager*                   EffectManager;                                     // 0x0468(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaEndingManager*                   EndingManager;                                     // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapParameterCollectionManager*         MapParameterCollectionManager;                     // 0x0478(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaMapGuideManager*                 MapGuideManager;                                   // 0x0480(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaGuideIconManager*                GuideIconManager;                                  // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaAchievementManager*              AchievementManager;                                // 0x0490(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPS5ActivityManager*                    PS5ActivityManager;                                // 0x0498(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaMapTransitionFlowTimeCounter*    NicolaMapTransitionFlowTimeCounter;                // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGDKAccountController*                  GDKAccountController;                              // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetGOPUnitLooks*           DataAssetGOPUnitLooks;                             // 0x04B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetCommon*                 StaticDataCommon;                                  // 0x04B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetBattle*                 StaticDataBattle;                                  // 0x04C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetParameterCollection*    StaticDataParameterCollection;                     // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetPlayerActor*            StaticDataPlayer;                                  // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetSoundCommon*            NicolaDataAssetSoundCommon;                        // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetSoundFieldAmbient*      NicolaDataAssetSoundFieldAmbient;                  // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetEvent*                  NicolaDataAssetEvent;                              // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetLevelCommon*            NicolaDataAssetLevelCommon;                        // 0x04F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetMapCommon*              NicolaDataAssetMapCommon;                          // 0x04F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetCameraCommon*           NicolaDataAssetCameraCommon;                       // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetStaffRoll*              NicolaDataAssetStaffRoll;                          // 0x0508(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetAchievement*            NicolaDataAssetAchievement;                        // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetGlow*                   StaticDataGlow;                                    // 0x0518(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaDataAssetMaterial*               DataAssetMaterial;                                 // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x40];                                     // 0x0528(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName DemoEnding();
	class FName Ending();
	class FName NewGame(bool titleSelectNewGame);
	void onApplicationHasEnteredForeground();
	void onApplicationWillEnterBackground();
	void ProcessRequestReturnTitle();
	void RequestEnding();
	void ResetDebugSettings();
	class FName ReturnTitle();
	void SendRequestReturnTitle();
	class FName StartFromDevelopmentLauncher();

	class UNicolaAchievementManager* GetAchievementManager() const;
	class FText GetCompileVersion() const;
	class UNicolaEffectManager* GetEffectManager() const;
	class UNicolaEndingManager* GetEndingManager() const;
	class UNicolaEventManager* GetEventManager() const;
	class UNicolaGuideIconManager* GetGuideIconManager() const;
	class UNicolaInGameManager* GetInGameManager() const;
	class ULuaScriptMgr* GetLuaScriptManager() const;
	class UNicolaMapGuideManager* GetMapGuideManager() const;
	class UMapParameterCollectionManager* GetMapParameterCollectionManager() const;
	class UPS5ActivityManager* GetPS5ActivityManager() const;
	class UNicolaSaveGameManager* GetSaveGameManager() const;
	class UNicolaSkillManager* GetSkillManager() const;
	class UNicolaSoundManager* GetSoundManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameInstance">();
	}
	static class UNicolaGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaGameInstance>();
	}
};
static_assert(alignof(UNicolaGameInstance) == 0x000008, "Wrong alignment on UNicolaGameInstance");
static_assert(sizeof(UNicolaGameInstance) == 0x000568, "Wrong size on UNicolaGameInstance");
static_assert(offsetof(UNicolaGameInstance, LuaScriptMgr) == 0x0001A8, "Member 'UNicolaGameInstance::LuaScriptMgr' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, DataAssetGOPUnitLooksObject) == 0x0001B0, "Member 'UNicolaGameInstance::DataAssetGOPUnitLooksObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataCommonAsset) == 0x0001D8, "Member 'UNicolaGameInstance::StaticDataCommonAsset' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataBattleAsset) == 0x000200, "Member 'UNicolaGameInstance::StaticDataBattleAsset' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataParameterCollectionAsset) == 0x000228, "Member 'UNicolaGameInstance::StaticDataParameterCollectionAsset' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataPlayerAsset) == 0x000250, "Member 'UNicolaGameInstance::StaticDataPlayerAsset' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetSoundCommonObject) == 0x000278, "Member 'UNicolaGameInstance::NicolaDataAssetSoundCommonObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetSoundFieldAmbientObject) == 0x0002A0, "Member 'UNicolaGameInstance::NicolaDataAssetSoundFieldAmbientObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetEventObject) == 0x0002C8, "Member 'UNicolaGameInstance::NicolaDataAssetEventObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetLevelCommonObject) == 0x0002F0, "Member 'UNicolaGameInstance::NicolaDataAssetLevelCommonObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetMapCommonObject) == 0x000318, "Member 'UNicolaGameInstance::NicolaDataAssetMapCommonObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetCameraCommonObject) == 0x000340, "Member 'UNicolaGameInstance::NicolaDataAssetCameraCommonObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetStaffRollObject) == 0x000368, "Member 'UNicolaGameInstance::NicolaDataAssetStaffRollObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetAchievementObject) == 0x000390, "Member 'UNicolaGameInstance::NicolaDataAssetAchievementObject' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataGlowAsset) == 0x0003B8, "Member 'UNicolaGameInstance::StaticDataGlowAsset' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataMaterialAsset) == 0x0003E0, "Member 'UNicolaGameInstance::StaticDataMaterialAsset' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, BP_NicolaUIManager) == 0x000408, "Member 'UNicolaGameInstance::BP_NicolaUIManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, InGameManager) == 0x000410, "Member 'UNicolaGameInstance::InGameManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaUIManager) == 0x000418, "Member 'UNicolaGameInstance::NicolaUIManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, SoundManager) == 0x000420, "Member 'UNicolaGameInstance::SoundManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, SkillManager) == 0x000428, "Member 'UNicolaGameInstance::SkillManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, saveGameManager) == 0x000430, "Member 'UNicolaGameInstance::saveGameManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, debugSetting) == 0x000438, "Member 'UNicolaGameInstance::debugSetting' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, DebugParameterCollection) == 0x000440, "Member 'UNicolaGameInstance::DebugParameterCollection' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, ActorListMan) == 0x000448, "Member 'UNicolaGameInstance::ActorListMan' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, EffectAssetMan) == 0x000450, "Member 'UNicolaGameInstance::EffectAssetMan' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, InitialLoadingManager) == 0x000458, "Member 'UNicolaGameInstance::InitialLoadingManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, EventMgr) == 0x000460, "Member 'UNicolaGameInstance::EventMgr' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, EffectManager) == 0x000468, "Member 'UNicolaGameInstance::EffectManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, EndingManager) == 0x000470, "Member 'UNicolaGameInstance::EndingManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, MapParameterCollectionManager) == 0x000478, "Member 'UNicolaGameInstance::MapParameterCollectionManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, MapGuideManager) == 0x000480, "Member 'UNicolaGameInstance::MapGuideManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, GuideIconManager) == 0x000488, "Member 'UNicolaGameInstance::GuideIconManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, AchievementManager) == 0x000490, "Member 'UNicolaGameInstance::AchievementManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, PS5ActivityManager) == 0x000498, "Member 'UNicolaGameInstance::PS5ActivityManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaMapTransitionFlowTimeCounter) == 0x0004A0, "Member 'UNicolaGameInstance::NicolaMapTransitionFlowTimeCounter' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, GDKAccountController) == 0x0004A8, "Member 'UNicolaGameInstance::GDKAccountController' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, DataAssetGOPUnitLooks) == 0x0004B0, "Member 'UNicolaGameInstance::DataAssetGOPUnitLooks' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataCommon) == 0x0004B8, "Member 'UNicolaGameInstance::StaticDataCommon' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataBattle) == 0x0004C0, "Member 'UNicolaGameInstance::StaticDataBattle' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataParameterCollection) == 0x0004C8, "Member 'UNicolaGameInstance::StaticDataParameterCollection' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataPlayer) == 0x0004D0, "Member 'UNicolaGameInstance::StaticDataPlayer' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetSoundCommon) == 0x0004D8, "Member 'UNicolaGameInstance::NicolaDataAssetSoundCommon' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetSoundFieldAmbient) == 0x0004E0, "Member 'UNicolaGameInstance::NicolaDataAssetSoundFieldAmbient' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetEvent) == 0x0004E8, "Member 'UNicolaGameInstance::NicolaDataAssetEvent' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetLevelCommon) == 0x0004F0, "Member 'UNicolaGameInstance::NicolaDataAssetLevelCommon' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetMapCommon) == 0x0004F8, "Member 'UNicolaGameInstance::NicolaDataAssetMapCommon' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetCameraCommon) == 0x000500, "Member 'UNicolaGameInstance::NicolaDataAssetCameraCommon' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetStaffRoll) == 0x000508, "Member 'UNicolaGameInstance::NicolaDataAssetStaffRoll' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, NicolaDataAssetAchievement) == 0x000510, "Member 'UNicolaGameInstance::NicolaDataAssetAchievement' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, StaticDataGlow) == 0x000518, "Member 'UNicolaGameInstance::StaticDataGlow' has a wrong offset!");
static_assert(offsetof(UNicolaGameInstance, DataAssetMaterial) == 0x000520, "Member 'UNicolaGameInstance::DataAssetMaterial' has a wrong offset!");

// Class Nicola.NicolaGameSingleton
// 0x0030 (0x0058 - 0x0028)
class UNicolaGameSingleton : public UObject
{
public:
	class UGopManager*                            GopManager;                                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNicolaConst>                   NicolaConst;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameSingleton">();
	}
	static class UNicolaGameSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaGameSingleton>();
	}
};
static_assert(alignof(UNicolaGameSingleton) == 0x000008, "Wrong alignment on UNicolaGameSingleton");
static_assert(sizeof(UNicolaGameSingleton) == 0x000058, "Wrong size on UNicolaGameSingleton");
static_assert(offsetof(UNicolaGameSingleton, GopManager) == 0x000028, "Member 'UNicolaGameSingleton::GopManager' has a wrong offset!");
static_assert(offsetof(UNicolaGameSingleton, NicolaConst) == 0x000040, "Member 'UNicolaGameSingleton::NicolaConst' has a wrong offset!");

// Class Nicola.NicolaGameStateBase
// 0x0028 (0x0298 - 0x0270)
class ANicolaGameStateBase : public AGameStateBase
{
public:
	TSubclassOf<class AFrameGrabberActor>         FrameGrabberActor;                                 // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AEffectBaseActor>           EffectBaseActor;                                   // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffectMan*                ForceFeedbackEffectMan;                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ANicolaPlayerControllerBase* GetPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameStateBase">();
	}
	static class ANicolaGameStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaGameStateBase>();
	}
};
static_assert(alignof(ANicolaGameStateBase) == 0x000008, "Wrong alignment on ANicolaGameStateBase");
static_assert(sizeof(ANicolaGameStateBase) == 0x000298, "Wrong size on ANicolaGameStateBase");
static_assert(offsetof(ANicolaGameStateBase, FrameGrabberActor) == 0x000270, "Member 'ANicolaGameStateBase::FrameGrabberActor' has a wrong offset!");
static_assert(offsetof(ANicolaGameStateBase, EffectBaseActor) == 0x000278, "Member 'ANicolaGameStateBase::EffectBaseActor' has a wrong offset!");
static_assert(offsetof(ANicolaGameStateBase, ForceFeedbackEffectMan) == 0x000290, "Member 'ANicolaGameStateBase::ForceFeedbackEffectMan' has a wrong offset!");

// Class Nicola.NicolaGameStateBattle
// 0x0000 (0x0298 - 0x0298)
class ANicolaGameStateBattle final : public ANicolaGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameStateBattle">();
	}
	static class ANicolaGameStateBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaGameStateBattle>();
	}
};
static_assert(alignof(ANicolaGameStateBattle) == 0x000008, "Wrong alignment on ANicolaGameStateBattle");
static_assert(sizeof(ANicolaGameStateBattle) == 0x000298, "Wrong size on ANicolaGameStateBattle");

// Class Nicola.UIFieldEfxMenuWindowItemVehicleGuide
// 0x0010 (0x0050 - 0x0040)
class UUIFieldEfxMenuWindowItemVehicleGuide final : public UUIWindowItem
{
public:
	TArray<class UUIWindowItemButtonIcon*>        ItemIcons;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowItemVehicleGuide">();
	}
	static class UUIFieldEfxMenuWindowItemVehicleGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowItemVehicleGuide>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowItemVehicleGuide) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowItemVehicleGuide");
static_assert(sizeof(UUIFieldEfxMenuWindowItemVehicleGuide) == 0x000050, "Wrong size on UUIFieldEfxMenuWindowItemVehicleGuide");
static_assert(offsetof(UUIFieldEfxMenuWindowItemVehicleGuide, ItemIcons) == 0x000040, "Member 'UUIFieldEfxMenuWindowItemVehicleGuide::ItemIcons' has a wrong offset!");

// Class Nicola.NicolaGameStateField
// 0x0000 (0x0298 - 0x0298)
class ANicolaGameStateField : public ANicolaGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameStateField">();
	}
	static class ANicolaGameStateField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaGameStateField>();
	}
};
static_assert(alignof(ANicolaGameStateField) == 0x000008, "Wrong alignment on ANicolaGameStateField");
static_assert(sizeof(ANicolaGameStateField) == 0x000298, "Wrong size on ANicolaGameStateField");

// Class Nicola.ProduceSequencerAchievement
// 0x0000 (0x0220 - 0x0220)
class AProduceSequencerAchievement final : public AProduceSequencerBase
{
public:
	void RequestUnlockAchievementByDefeatBaramos();
	void RequestUnlockAchievementByDefeatBossTroll();
	void RequestUnlockAchievementByDefeatDemonOfNile();
	void RequestUnlockAchievementByDefeatGuardianOfHell();
	void RequestUnlockAchievementByDefeatOrochi();
	void RequestUnlockAchievementByDefeatRevnant();
	void RequestUnlockAchievementByDefeatWarlock();
	void RequestUnlockAchievementByDispelRubiss();
	void RequestUnlockAchievementByUseRainbowDrop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerAchievement">();
	}
	static class AProduceSequencerAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerAchievement>();
	}
};
static_assert(alignof(AProduceSequencerAchievement) == 0x000008, "Wrong alignment on AProduceSequencerAchievement");
static_assert(sizeof(AProduceSequencerAchievement) == 0x000220, "Wrong size on AProduceSequencerAchievement");

// Class Nicola.NicolaGameStateResearch
// 0x0000 (0x0298 - 0x0298)
class ANicolaGameStateResearch final : public ANicolaGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGameStateResearch">();
	}
	static class ANicolaGameStateResearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaGameStateResearch>();
	}
};
static_assert(alignof(ANicolaGameStateResearch) == 0x000008, "Wrong alignment on ANicolaGameStateResearch");
static_assert(sizeof(ANicolaGameStateResearch) == 0x000298, "Wrong size on ANicolaGameStateResearch");

// Class Nicola.NicolaGraphicSettingFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaGraphicSettingFL final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyPostProcessSetting_DOF();
	static void ApplyPostProcessSetting_Gamma();
	static void ApplyPostProcessSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGraphicSettingFL">();
	}
	static class UNicolaGraphicSettingFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaGraphicSettingFL>();
	}
};
static_assert(alignof(UNicolaGraphicSettingFL) == 0x000008, "Wrong alignment on UNicolaGraphicSettingFL");
static_assert(sizeof(UNicolaGraphicSettingFL) == 0x000028, "Wrong size on UNicolaGraphicSettingFL");

// Class Nicola.NicolaGuideIconManager
// 0x0020 (0x0048 - 0x0028)
class UNicolaGuideIconManager final : public UObject
{
public:
	TArray<struct FGuideIconData>                 dataListMain;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGuideIconData>                 dataListSub;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaGuideIconManager">();
	}
	static class UNicolaGuideIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaGuideIconManager>();
	}
};
static_assert(alignof(UNicolaGuideIconManager) == 0x000008, "Wrong alignment on UNicolaGuideIconManager");
static_assert(sizeof(UNicolaGuideIconManager) == 0x000048, "Wrong size on UNicolaGuideIconManager");
static_assert(offsetof(UNicolaGuideIconManager, dataListMain) == 0x000028, "Member 'UNicolaGuideIconManager::dataListMain' has a wrong offset!");
static_assert(offsetof(UNicolaGuideIconManager, dataListSub) == 0x000038, "Member 'UNicolaGuideIconManager::dataListSub' has a wrong offset!");

// Class Nicola.NicolaHighlightReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class INicolaHighlightReceiverInterface final : public IInterface
{
public:
	void OnBeginHighlighting();
	void OnEndHighlighting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaHighlightReceiverInterface">();
	}
	static class INicolaHighlightReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaHighlightReceiverInterface>();
	}
};
static_assert(alignof(INicolaHighlightReceiverInterface) == 0x000008, "Wrong alignment on INicolaHighlightReceiverInterface");
static_assert(sizeof(INicolaHighlightReceiverInterface) == 0x000028, "Wrong size on INicolaHighlightReceiverInterface");

// Class Nicola.UIVisualChangeMenuListTop
// 0x0020 (0x00F0 - 0x00D0)
class UUIVisualChangeMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVisualChangeMenuListTop">();
	}
	static class UUIVisualChangeMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVisualChangeMenuListTop>();
	}
};
static_assert(alignof(UUIVisualChangeMenuListTop) == 0x000008, "Wrong alignment on UUIVisualChangeMenuListTop");
static_assert(sizeof(UUIVisualChangeMenuListTop) == 0x0000F0, "Wrong size on UUIVisualChangeMenuListTop");

// Class Nicola.NicolaHUDBase
// 0x0008 (0x0318 - 0x0310)
class ANicolaHUDBase : public AHUD
{
public:
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaHUDBase">();
	}
	static class ANicolaHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaHUDBase>();
	}
};
static_assert(alignof(ANicolaHUDBase) == 0x000008, "Wrong alignment on ANicolaHUDBase");
static_assert(sizeof(ANicolaHUDBase) == 0x000318, "Wrong size on ANicolaHUDBase");

// Class Nicola.NicolaHUD
// 0x0000 (0x0318 - 0x0318)
class ANicolaHUD final : public ANicolaHUDBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaHUD">();
	}
	static class ANicolaHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaHUD>();
	}
};
static_assert(alignof(ANicolaHUD) == 0x000008, "Wrong alignment on ANicolaHUD");
static_assert(sizeof(ANicolaHUD) == 0x000318, "Wrong size on ANicolaHUD");

// Class Nicola.NicolaSpriteManagerComponent
// 0x02C0 (0x0378 - 0x00B8)
class UNicolaSpriteManagerComponent final : public UNicolaCharacterComponentBase
{
public:
	class FString                                 SpriteReplaceDestString;                           // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SpriteWeaponReplaceDestString;                     // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAnimationType, TSoftObjectPtr<class UNicolaAnimationData>> DefaultAnimationDatas;                             // 0x00D8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<ENicolaFlipbookOverrideType, struct FNicolaFlipbookOverrideData> FlipbookOverrideDatas;                             // 0x0128(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EFlipbookUseType, struct FFlipbookComponentArray> RelativeComponents;                                // 0x0178(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UNicolaPaperFlipbookComponent*          SpriteRootComponent;                               // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           InterpRotT;                                        // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           InterpInvisibleState;                              // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveFloatOffsetYByCameraAngle;                    // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNicolaSpriteManagerComponentMimicData NicolaSpriteManagerComponentMimicData;             // 0x01E8(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EAnimationType, class UNicolaAnimationData*> DefaultAnimationDataCaches;                        // 0x0200(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UNicolaAnimationData*> AnimationAssetAnimationDataCaches;                 // 0x0250(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FFlipbookCacheKey, class UPaperFlipbook*> FlipbookCaches;                                    // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x58];                                     // 0x02F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNicolaPaperFlipbookComponent*>  dummyShadows;                                      // 0x0348(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDecalComponent*                        decalCharacterShadow;                              // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               characterShadowMaterialInstance;                   // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void onFinishedPlaying();
	void SequencerRotationRoll(float Degree);
	void SequencerSetEnableCharacterPrePass(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSpriteManagerComponent">();
	}
	static class UNicolaSpriteManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSpriteManagerComponent>();
	}
};
static_assert(alignof(UNicolaSpriteManagerComponent) == 0x000008, "Wrong alignment on UNicolaSpriteManagerComponent");
static_assert(sizeof(UNicolaSpriteManagerComponent) == 0x000378, "Wrong size on UNicolaSpriteManagerComponent");
static_assert(offsetof(UNicolaSpriteManagerComponent, SpriteReplaceDestString) == 0x0000B8, "Member 'UNicolaSpriteManagerComponent::SpriteReplaceDestString' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, SpriteWeaponReplaceDestString) == 0x0000C8, "Member 'UNicolaSpriteManagerComponent::SpriteWeaponReplaceDestString' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, DefaultAnimationDatas) == 0x0000D8, "Member 'UNicolaSpriteManagerComponent::DefaultAnimationDatas' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, FlipbookOverrideDatas) == 0x000128, "Member 'UNicolaSpriteManagerComponent::FlipbookOverrideDatas' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, RelativeComponents) == 0x000178, "Member 'UNicolaSpriteManagerComponent::RelativeComponents' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, SpriteRootComponent) == 0x0001C8, "Member 'UNicolaSpriteManagerComponent::SpriteRootComponent' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, InterpRotT) == 0x0001D0, "Member 'UNicolaSpriteManagerComponent::InterpRotT' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, InterpInvisibleState) == 0x0001D8, "Member 'UNicolaSpriteManagerComponent::InterpInvisibleState' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, CurveFloatOffsetYByCameraAngle) == 0x0001E0, "Member 'UNicolaSpriteManagerComponent::CurveFloatOffsetYByCameraAngle' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, NicolaSpriteManagerComponentMimicData) == 0x0001E8, "Member 'UNicolaSpriteManagerComponent::NicolaSpriteManagerComponentMimicData' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, DefaultAnimationDataCaches) == 0x000200, "Member 'UNicolaSpriteManagerComponent::DefaultAnimationDataCaches' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, AnimationAssetAnimationDataCaches) == 0x000250, "Member 'UNicolaSpriteManagerComponent::AnimationAssetAnimationDataCaches' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, FlipbookCaches) == 0x0002A0, "Member 'UNicolaSpriteManagerComponent::FlipbookCaches' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, dummyShadows) == 0x000348, "Member 'UNicolaSpriteManagerComponent::dummyShadows' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, decalCharacterShadow) == 0x000358, "Member 'UNicolaSpriteManagerComponent::decalCharacterShadow' has a wrong offset!");
static_assert(offsetof(UNicolaSpriteManagerComponent, characterShadowMaterialInstance) == 0x000360, "Member 'UNicolaSpriteManagerComponent::characterShadowMaterialInstance' has a wrong offset!");

// Class Nicola.NicolaInGameManager
// 0x0010 (0x0038 - 0x0028)
class UNicolaInGameManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaInGameManager">();
	}
	static class UNicolaInGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaInGameManager>();
	}
};
static_assert(alignof(UNicolaInGameManager) == 0x000008, "Wrong alignment on UNicolaInGameManager");
static_assert(sizeof(UNicolaInGameManager) == 0x000038, "Wrong size on UNicolaInGameManager");

// Class Nicola.ProduceSequencerTownNameUI
// 0x0008 (0x0228 - 0x0220)
class AProduceSequencerTownNameUI final : public AProduceSequencerBase
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseTownNameWindow();
	void PlayTownNameWindow(class FName textID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerTownNameUI">();
	}
	static class AProduceSequencerTownNameUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerTownNameUI>();
	}
};
static_assert(alignof(AProduceSequencerTownNameUI) == 0x000008, "Wrong alignment on AProduceSequencerTownNameUI");
static_assert(sizeof(AProduceSequencerTownNameUI) == 0x000228, "Wrong size on AProduceSequencerTownNameUI");

// Class Nicola.NicolaInterfaceUnitDataAccessor
// 0x0000 (0x0028 - 0x0028)
class INicolaInterfaceUnitDataAccessor final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaInterfaceUnitDataAccessor">();
	}
	static class INicolaInterfaceUnitDataAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<INicolaInterfaceUnitDataAccessor>();
	}
};
static_assert(alignof(INicolaInterfaceUnitDataAccessor) == 0x000008, "Wrong alignment on INicolaInterfaceUnitDataAccessor");
static_assert(sizeof(INicolaInterfaceUnitDataAccessor) == 0x000028, "Wrong size on INicolaInterfaceUnitDataAccessor");

// Class Nicola.NicolaItemDataFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaItemDataFL final : public UBlueprintFunctionLibrary
{
public:
	static bool AddItem(const class FName& ItemId, int32 Count, int32 partyMemberNo, bool bForce);
	static int32 AddItemNobody(const class FName& ItemId);
	static bool AdjustBag(const int32 partyUnitIndex, bool checkTidy);
	static bool CanAddItem(int32 partyMemberNo, int32 cnt);
	static void DebugAddItem();
	static void DebugAddItemAll(int32 Count);
	static void DebugAllItemDisplay();
	static void DebugEquipItem();
	static int32 DebugGetItemBagNum(const class FName& InGopId);
	static class FName DebugGetItemNameID(const class FName& InGopId);
	static void DebugSetItemBagNum(const class FName& InGopId, int32 InCount);
	static void DebugTest();
	static void DebugUseItem(class FName ItemId, int32 targetNo, bool bBattle, bool bEnemy, class FName RuraID);
	static bool EquipItem(int32 partyIndex, const class FName& ItemId);
	static int32 GetHaveItemNum(const class FName& ItemId, bool excludeRentalEquip, bool excludeUnitDataFromBelongStatusTemporary);
	static void GetItemGopList(TArray<class FName>* GopIdList);
	static void GetItemGopListByCategory(EItemType InType, TArray<class FName>* OutGopIdList);
	static bool IsHaveItem(const class FName& ItemId, bool excludeRentalEquip, bool excludeUnitDataFromBelongStatusTemporary);
	static bool IsHaveItemEffectType(EItemEffectType EffectType, bool excludeUnitDataFromBelongStatusTemporary);
	static bool RemoveItem(const class FName& ItemId, bool isAllUnitData, bool excludeUnitDataFromBelongStatusTemporary);
	static bool UseItem(bool isBag, int32 DataIndex, int32 ItemIndex, int32 targetNo, EItemUsableType usedTyming, class FName RuraID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaItemDataFL">();
	}
	static class UNicolaItemDataFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaItemDataFL>();
	}
};
static_assert(alignof(UNicolaItemDataFL) == 0x000008, "Wrong alignment on UNicolaItemDataFL");
static_assert(sizeof(UNicolaItemDataFL) == 0x000028, "Wrong size on UNicolaItemDataFL");

// Class Nicola.UITutorialWindowMain
// 0x0028 (0x0080 - 0x0058)
class UUITutorialWindowMain final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItem*                          ItemLabel;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMain;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaRichTextBlock*                   TextInformation;                                   // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           PanelImage;                                        // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialWindowMain">();
	}
	static class UUITutorialWindowMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorialWindowMain>();
	}
};
static_assert(alignof(UUITutorialWindowMain) == 0x000008, "Wrong alignment on UUITutorialWindowMain");
static_assert(sizeof(UUITutorialWindowMain) == 0x000080, "Wrong size on UUITutorialWindowMain");
static_assert(offsetof(UUITutorialWindowMain, ItemLabel) == 0x000060, "Member 'UUITutorialWindowMain::ItemLabel' has a wrong offset!");
static_assert(offsetof(UUITutorialWindowMain, ImageMain) == 0x000068, "Member 'UUITutorialWindowMain::ImageMain' has a wrong offset!");
static_assert(offsetof(UUITutorialWindowMain, TextInformation) == 0x000070, "Member 'UUITutorialWindowMain::TextInformation' has a wrong offset!");
static_assert(offsetof(UUITutorialWindowMain, PanelImage) == 0x000078, "Member 'UUITutorialWindowMain::PanelImage' has a wrong offset!");

// Class Nicola.NicolaLightActor
// 0x0030 (0x0268 - 0x0238)
class ANicolaLightActor : public ANicolaMapTimeDependingActor
{
public:
	uint8                                         Pad_238[0x20];                                     // 0x0238(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            curveLightIntensity;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaParticleActor*                   targetParticleActor;                               // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLightActor">();
	}
	static class ANicolaLightActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaLightActor>();
	}
};
static_assert(alignof(ANicolaLightActor) == 0x000008, "Wrong alignment on ANicolaLightActor");
static_assert(sizeof(ANicolaLightActor) == 0x000268, "Wrong size on ANicolaLightActor");
static_assert(offsetof(ANicolaLightActor, curveLightIntensity) == 0x000258, "Member 'ANicolaLightActor::curveLightIntensity' has a wrong offset!");
static_assert(offsetof(ANicolaLightActor, targetParticleActor) == 0x000260, "Member 'ANicolaLightActor::targetParticleActor' has a wrong offset!");

// Class Nicola.NicolaLightDirRotator
// 0x00A8 (0x02C8 - 0x0220)
class ANicolaLightDirRotator final : public AActor
{
public:
	uint8                                         Pad_220[0x34];                                     // 0x0220(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActivated;                                      // 0x0254(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnvVariation;                                   // 0x0255(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256[0x2];                                      // 0x0256(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraParameterCollection*            TargetNPC_Effect;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPC_Effect_ParamName_LightDir;                     // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPC_Effect_ParamName_LightColor;                   // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class ANicolaLightDirRotator*> VariationNameMap;                                  // 0x0270(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorListComponent;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	uint8 GetCorrectionFlag();
	struct FLinearColor GetCorrectionLightColor();
	float GetCorrectionLightIntensity();
	struct FLinearColor GetCorrectionSkySphereOverallColor();
	void SetVisibleActors(bool bVisible);

	float GetCorrectionBlendRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLightDirRotator">();
	}
	static class ANicolaLightDirRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaLightDirRotator>();
	}
};
static_assert(alignof(ANicolaLightDirRotator) == 0x000008, "Wrong alignment on ANicolaLightDirRotator");
static_assert(sizeof(ANicolaLightDirRotator) == 0x0002C8, "Wrong size on ANicolaLightDirRotator");
static_assert(offsetof(ANicolaLightDirRotator, bIsActivated) == 0x000254, "Member 'ANicolaLightDirRotator::bIsActivated' has a wrong offset!");
static_assert(offsetof(ANicolaLightDirRotator, bIsEnvVariation) == 0x000255, "Member 'ANicolaLightDirRotator::bIsEnvVariation' has a wrong offset!");
static_assert(offsetof(ANicolaLightDirRotator, TargetNPC_Effect) == 0x000258, "Member 'ANicolaLightDirRotator::TargetNPC_Effect' has a wrong offset!");
static_assert(offsetof(ANicolaLightDirRotator, NPC_Effect_ParamName_LightDir) == 0x000260, "Member 'ANicolaLightDirRotator::NPC_Effect_ParamName_LightDir' has a wrong offset!");
static_assert(offsetof(ANicolaLightDirRotator, NPC_Effect_ParamName_LightColor) == 0x000268, "Member 'ANicolaLightDirRotator::NPC_Effect_ParamName_LightColor' has a wrong offset!");
static_assert(offsetof(ANicolaLightDirRotator, VariationNameMap) == 0x000270, "Member 'ANicolaLightDirRotator::VariationNameMap' has a wrong offset!");
static_assert(offsetof(ANicolaLightDirRotator, ActorListComponent) == 0x0002C0, "Member 'ANicolaLightDirRotator::ActorListComponent' has a wrong offset!");

// Class Nicola.UIWindowItemIcon2
// 0x0010 (0x0050 - 0x0040)
class UUIWindowItemIcon2 final : public UUIWindowItem
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon2;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemIcon2">();
	}
	static class UUIWindowItemIcon2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemIcon2>();
	}
};
static_assert(alignof(UUIWindowItemIcon2) == 0x000008, "Wrong alignment on UUIWindowItemIcon2");
static_assert(sizeof(UUIWindowItemIcon2) == 0x000050, "Wrong size on UUIWindowItemIcon2");
static_assert(offsetof(UUIWindowItemIcon2, ItemIcon) == 0x000040, "Member 'UUIWindowItemIcon2::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIWindowItemIcon2, ItemIcon2) == 0x000048, "Member 'UUIWindowItemIcon2::ItemIcon2' has a wrong offset!");

// Class Nicola.NicolaLightingEnvMgrActor
// 0x00A8 (0x02C8 - 0x0220)
class ANicolaLightingEnvMgrActor final : public AActor
{
public:
	uint8                                         Pad_220[0x34];                                     // 0x0220(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActivated;                                      // 0x0254(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRequestedUpdating;                              // 0x0255(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256[0x2];                                      // 0x0256(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class ANicolaLightingEnvPresetActor*> PresetActorNameMap;                                // 0x0258(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNiagaraParameterCollection*            TargetNPC_Effect;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPC_Effect_ParamName_LightDir;                     // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPC_Effect_ParamName_LightColor;                   // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorListComponent*                    ActorListComponent;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckProgressFlagFromString(const class FString& inString);
	uint8 GetCorrectionFlag();
	struct FLinearColor GetCorrectionLightColor();
	float GetCorrectionLightIntensity();
	struct FLinearColor GetCorrectionSkySphereOverallColor();
	void OnReleaseActors();
	void SetVisibleActors(bool bVisible);

	float GetCorrectionBlendRate() const;
	void UpdateSkyLightComponentSourceTypeByCubeMap(const class USkyLightComponent* comp, const class UTextureCube* cubeMap) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLightingEnvMgrActor">();
	}
	static class ANicolaLightingEnvMgrActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaLightingEnvMgrActor>();
	}
};
static_assert(alignof(ANicolaLightingEnvMgrActor) == 0x000008, "Wrong alignment on ANicolaLightingEnvMgrActor");
static_assert(sizeof(ANicolaLightingEnvMgrActor) == 0x0002C8, "Wrong size on ANicolaLightingEnvMgrActor");
static_assert(offsetof(ANicolaLightingEnvMgrActor, bIsActivated) == 0x000254, "Member 'ANicolaLightingEnvMgrActor::bIsActivated' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvMgrActor, bIsRequestedUpdating) == 0x000255, "Member 'ANicolaLightingEnvMgrActor::bIsRequestedUpdating' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvMgrActor, PresetActorNameMap) == 0x000258, "Member 'ANicolaLightingEnvMgrActor::PresetActorNameMap' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvMgrActor, TargetNPC_Effect) == 0x0002A8, "Member 'ANicolaLightingEnvMgrActor::TargetNPC_Effect' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvMgrActor, NPC_Effect_ParamName_LightDir) == 0x0002B0, "Member 'ANicolaLightingEnvMgrActor::NPC_Effect_ParamName_LightDir' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvMgrActor, NPC_Effect_ParamName_LightColor) == 0x0002B8, "Member 'ANicolaLightingEnvMgrActor::NPC_Effect_ParamName_LightColor' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvMgrActor, ActorListComponent) == 0x0002C0, "Member 'ANicolaLightingEnvMgrActor::ActorListComponent' has a wrong offset!");

// Class Nicola.NicolaLightingEnvPresetActor
// 0x0B60 (0x0D80 - 0x0220)
class ANicolaLightingEnvPresetActor final : public AActor
{
public:
	class FName                                   PresetName;                                        // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivated;                                      // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProcessOrder;                                      // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRate;                                         // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENicolaNicolaLightingEnvParam_DirectionalLight, class UCurveFloat*> paramCurves_DirectionalLight_Sun_Float;            // 0x0238(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_DirectionalLight, class UCurveLinearColor*> paramCurves_DirectionalLight_Sun_Color;            // 0x0288(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_DirectionalLight, class UCurveVector*> paramCurves_DirectionalLight_Sun_Vector;           // 0x02D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_DirectionalLight, class UCurveFloat*> paramCurves_DirectionalLight_Moon_Float;           // 0x0328(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_DirectionalLight, class UCurveLinearColor*> paramCurves_DirectionalLight_Moon_Color;           // 0x0378(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_DirectionalLight, class UCurveVector*> paramCurves_DirectionalLight_Moon_Vector;          // 0x03C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_SkyLight, class UCurveFloat*> paramCurves_SkyLight_Float;                        // 0x0418(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_SkyLight, class UCurveLinearColor*> paramCurves_SkyLight_Color;                        // 0x0468(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_SkyLight, class UCurveVector*> paramCurves_SkyLight_Vector;                       // 0x04B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_ExponentialHeightFog, class UCurveFloat*> paramCurves_ExponentialHeightFog_Float;            // 0x0508(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_ExponentialHeightFog, class UCurveLinearColor*> paramCurves_ExponentialHeightFog_Color;            // 0x0558(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_ExponentialHeightFog, class UCurveVector*> paramCurves_ExponentialHeightFog_Vector;           // 0x05A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_PostProcessVolume, class UCurveFloat*> paramCurves_PostProcessVolume_Float;               // 0x05F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_PostProcessVolume, class UCurveLinearColor*> paramCurves_PostProcessVolume_Color;               // 0x0648(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_PostProcessVolume, class UCurveVector*> paramCurves_PostProcessVolume_Vector;              // 0x0698(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Emissive, class UCurveFloat*> paramCurves_MPC_Emissive_Float;                    // 0x06E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Emissive, class UCurveLinearColor*> paramCurves_MPC_Emissive_Color;                    // 0x0738(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Emissive, class UCurveVector*> paramCurves_MPC_Emissive_Vector;                   // 0x0788(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_SkySphere, class UCurveFloat*> paramCurves_MPC_SkySphere_Float;                   // 0x07D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_SkySphere, class UCurveLinearColor*> paramCurves_MPC_SkySphere_Color;                   // 0x0828(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_SkySphere, class UCurveVector*> paramCurves_MPC_SkySphere_Vector;                  // 0x0878(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Cloud, class UCurveFloat*> paramCurves_MPC_Cloud_Float;                       // 0x08C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Cloud, class UCurveLinearColor*> paramCurves_MPC_Cloud_Color;                       // 0x0918(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Cloud, class UCurveVector*> paramCurves_MPC_Cloud_Vector;                      // 0x0968(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Water, class UCurveFloat*> paramCurves_MPC_Water_Float;                       // 0x09B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Water, class UCurveLinearColor*> paramCurves_MPC_Water_Color;                       // 0x0A08(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Water, class UCurveVector*> paramCurves_MPC_Water_Vector;                      // 0x0A58(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Foliage, class UCurveFloat*> paramCurves_MPC_Foliage_Float;                     // 0x0AA8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Foliage, class UCurveLinearColor*> paramCurves_MPC_Foliage_Color;                     // 0x0AF8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_Foliage, class UCurveVector*> paramCurves_MPC_Foliage_Vector;                    // 0x0B48(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_HeatHaze, class UCurveFloat*> paramCurves_MPC_HeatHaze_Float;                    // 0x0B98(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_HeatHaze, class UCurveLinearColor*> paramCurves_MPC_HeatHaze_Color;                    // 0x0BE8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_MPC_HeatHaze, class UCurveVector*> paramCurves_MPC_HeatHaze_Vector;                   // 0x0C38(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_FieldSymbol, class UCurveFloat*> paramCurves_FieldSymbol_Float;                     // 0x0C88(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_FieldSymbol, class UCurveLinearColor*> paramCurves_FieldSymbol_Color;                     // 0x0CD8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ENicolaNicolaLightingEnvParam_FieldSymbol, class UCurveVector*> paramCurves_FieldSymbol_Vector;                    // 0x0D28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorListComponent;                                // 0x0D78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLightingEnvPresetActor">();
	}
	static class ANicolaLightingEnvPresetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaLightingEnvPresetActor>();
	}
};
static_assert(alignof(ANicolaLightingEnvPresetActor) == 0x000008, "Wrong alignment on ANicolaLightingEnvPresetActor");
static_assert(sizeof(ANicolaLightingEnvPresetActor) == 0x000D80, "Wrong size on ANicolaLightingEnvPresetActor");
static_assert(offsetof(ANicolaLightingEnvPresetActor, PresetName) == 0x000220, "Member 'ANicolaLightingEnvPresetActor::PresetName' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, bIsActivated) == 0x000228, "Member 'ANicolaLightingEnvPresetActor::bIsActivated' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, ProcessOrder) == 0x00022C, "Member 'ANicolaLightingEnvPresetActor::ProcessOrder' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, BlendRate) == 0x000230, "Member 'ANicolaLightingEnvPresetActor::BlendRate' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_DirectionalLight_Sun_Float) == 0x000238, "Member 'ANicolaLightingEnvPresetActor::paramCurves_DirectionalLight_Sun_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_DirectionalLight_Sun_Color) == 0x000288, "Member 'ANicolaLightingEnvPresetActor::paramCurves_DirectionalLight_Sun_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_DirectionalLight_Sun_Vector) == 0x0002D8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_DirectionalLight_Sun_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_DirectionalLight_Moon_Float) == 0x000328, "Member 'ANicolaLightingEnvPresetActor::paramCurves_DirectionalLight_Moon_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_DirectionalLight_Moon_Color) == 0x000378, "Member 'ANicolaLightingEnvPresetActor::paramCurves_DirectionalLight_Moon_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_DirectionalLight_Moon_Vector) == 0x0003C8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_DirectionalLight_Moon_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_SkyLight_Float) == 0x000418, "Member 'ANicolaLightingEnvPresetActor::paramCurves_SkyLight_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_SkyLight_Color) == 0x000468, "Member 'ANicolaLightingEnvPresetActor::paramCurves_SkyLight_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_SkyLight_Vector) == 0x0004B8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_SkyLight_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_ExponentialHeightFog_Float) == 0x000508, "Member 'ANicolaLightingEnvPresetActor::paramCurves_ExponentialHeightFog_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_ExponentialHeightFog_Color) == 0x000558, "Member 'ANicolaLightingEnvPresetActor::paramCurves_ExponentialHeightFog_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_ExponentialHeightFog_Vector) == 0x0005A8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_ExponentialHeightFog_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_PostProcessVolume_Float) == 0x0005F8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_PostProcessVolume_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_PostProcessVolume_Color) == 0x000648, "Member 'ANicolaLightingEnvPresetActor::paramCurves_PostProcessVolume_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_PostProcessVolume_Vector) == 0x000698, "Member 'ANicolaLightingEnvPresetActor::paramCurves_PostProcessVolume_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Emissive_Float) == 0x0006E8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Emissive_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Emissive_Color) == 0x000738, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Emissive_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Emissive_Vector) == 0x000788, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Emissive_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_SkySphere_Float) == 0x0007D8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_SkySphere_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_SkySphere_Color) == 0x000828, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_SkySphere_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_SkySphere_Vector) == 0x000878, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_SkySphere_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Cloud_Float) == 0x0008C8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Cloud_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Cloud_Color) == 0x000918, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Cloud_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Cloud_Vector) == 0x000968, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Cloud_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Water_Float) == 0x0009B8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Water_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Water_Color) == 0x000A08, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Water_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Water_Vector) == 0x000A58, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Water_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Foliage_Float) == 0x000AA8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Foliage_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Foliage_Color) == 0x000AF8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Foliage_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_Foliage_Vector) == 0x000B48, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_Foliage_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_HeatHaze_Float) == 0x000B98, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_HeatHaze_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_HeatHaze_Color) == 0x000BE8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_HeatHaze_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_MPC_HeatHaze_Vector) == 0x000C38, "Member 'ANicolaLightingEnvPresetActor::paramCurves_MPC_HeatHaze_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_FieldSymbol_Float) == 0x000C88, "Member 'ANicolaLightingEnvPresetActor::paramCurves_FieldSymbol_Float' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_FieldSymbol_Color) == 0x000CD8, "Member 'ANicolaLightingEnvPresetActor::paramCurves_FieldSymbol_Color' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, paramCurves_FieldSymbol_Vector) == 0x000D28, "Member 'ANicolaLightingEnvPresetActor::paramCurves_FieldSymbol_Vector' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvPresetActor, ActorListComponent) == 0x000D78, "Member 'ANicolaLightingEnvPresetActor::ActorListComponent' has a wrong offset!");

// Class Nicola.NicolaUnitDataFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaUnitDataFL final : public UBlueprintFunctionLibrary
{
public:
	static bool ApplyHeroInitStatus();
	static bool AutoHPMax(bool bAlmost);
	static void ChangePartyUnitParsonality(int32 partyNo, class FName PersonalityId);
	static void DebugAddExp(int32 partyNo, int32 Exp);
	static void DebugAddExpBeforeLevelUp(int32 partyNo);
	static void DebugAddExpTargetLevel(int32 partyNo, int32 targetLv);
	static void DebugCharaMake(class FName Name_0, EUnitClassType ClassType, EUnitGenderType GenderType, EUnitVoicePattern VoicePattern, int32 looksPattern, int32 hairColorPattern, EStatusType Seed1, EStatusType Seed2, EStatusType Seed3, EStatusType seed4, EStatusType seed5, EStatusType seed6);
	static void DebugCharaMakeForDebugMenu(EUnitClassType ClassType, EUnitGenderType GenderType, int32 seedMode);
	static void DebugCreateAlphaParty();
	static void DebugCreateBattleParty(const struct FCharaMakeInfo& Party1, const struct FCharaMakeInfo& Party2, const struct FCharaMakeInfo& Party3, const struct FCharaMakeInfo& Party4, int32 minLv);
	static struct FCharaMakeInfo DebugCreateCharaMakeInfo(EUnitClassType ClassType, EUnitGenderType GenderType, EUnitVoicePattern VoicePattern, int32 looksPattern, int32 hairColorPattern, EDebugCharaMakeOption Option);
	static void DebugDisplayAllMember(bool partyOnly);
	static void DebugGetAllSkill(int32 partyNo);
	static void DebugMaxDoping(int32 partyNo, int32 sub);
	static void DebugModifyHp(int32 partyIndex, int32 modifyValue, bool bAccepDead);
	static void DebugModifyMp(int32 partyNo, int32 modifyValue, bool bAcceptEmpty);
	static void DebugSetPartyUnitStatusEffectBP(int32 statusEffectFlag, bool bAdd, int32 partyMemberIndex, float healRatio);
	static bool DeleteUnitDataFromStandby(int32 standbyIndex);
	static int32 GetHairColorMax();
	static int32 GetPartyMemberNum();
	static TMap<int32, class FString> GetUnitDatasByBelongStatus(EUnitResidentBelongStatus belongStatus);
	static void HealAllPartyMember(bool bHealStatusEffect);
	static void HealPartyUnitHP(int32 partyNo, int32 Value);
	static void HealPartyUnitMP(int32 partyNo, int32 Value);
	static bool MoveUnitDataToParty(int32 standbyIndex);
	static bool MoveUnitDataToPartyFromTemporary();
	static bool MoveUnitDataToStandby(int32 partyIndex);
	static bool MoveUnitDataToTemporary(int32 partyIndex);
	static void ReducePartyUnitHP(int32 partyNo, int32 Value);
	static void ReducePartyUnitMP(int32 partyNo, int32 Value);
	static bool SetUnitVoicePattern(int32 partyUnitIndex, EUnitVoicePattern VoicePattern);
	static void SortItemAll(bool bSortABC);
	static bool SwapUnitDataPosition(int32 partyIndex1, int32 partyIndex2);
	static bool UseSkillBattle(bool bEnemy, int32 UserIndex, int32 targetIndex, class FName SkillId);
	static bool UseSkillNoBattle(int32 UserIndex, int32 targetIndex, class FName SkillId, class FName RuraID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaUnitDataFL">();
	}
	static class UNicolaUnitDataFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaUnitDataFL>();
	}
};
static_assert(alignof(UNicolaUnitDataFL) == 0x000008, "Wrong alignment on UNicolaUnitDataFL");
static_assert(sizeof(UNicolaUnitDataFL) == 0x000028, "Wrong size on UNicolaUnitDataFL");

// Class Nicola.UIXenlonWish
// 0x0008 (0x0080 - 0x0078)
class UUIXenlonWish final : public UUIRootBase
{
public:
	class UUIXenlonWishListTop*                   ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIXenlonWish">();
	}
	static class UUIXenlonWish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIXenlonWish>();
	}
};
static_assert(alignof(UUIXenlonWish) == 0x000008, "Wrong alignment on UUIXenlonWish");
static_assert(sizeof(UUIXenlonWish) == 0x000080, "Wrong size on UUIXenlonWish");
static_assert(offsetof(UUIXenlonWish, ListTop) == 0x000078, "Member 'UUIXenlonWish::ListTop' has a wrong offset!");

// Class Nicola.NicolaLightingEnvVariationTriggerBase
// 0x0010 (0x02E0 - 0x02D0)
class ANicolaLightingEnvVariationTriggerBase final : public ANicolaFieldTriggerBase
{
public:
	class FName                                   EnvPresetName;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENicolaFieldTriggerActorTypeFlag              triggerActorType;                                  // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0xF];                                      // 0x02D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLightingEnvVariationTriggerBase">();
	}
	static class ANicolaLightingEnvVariationTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaLightingEnvVariationTriggerBase>();
	}
};
static_assert(alignof(ANicolaLightingEnvVariationTriggerBase) == 0x000010, "Wrong alignment on ANicolaLightingEnvVariationTriggerBase");
static_assert(sizeof(ANicolaLightingEnvVariationTriggerBase) == 0x0002E0, "Wrong size on ANicolaLightingEnvVariationTriggerBase");
static_assert(offsetof(ANicolaLightingEnvVariationTriggerBase, EnvPresetName) == 0x0002C8, "Member 'ANicolaLightingEnvVariationTriggerBase::EnvPresetName' has a wrong offset!");
static_assert(offsetof(ANicolaLightingEnvVariationTriggerBase, triggerActorType) == 0x0002D0, "Member 'ANicolaLightingEnvVariationTriggerBase::triggerActorType' has a wrong offset!");

// Class Nicola.SkipSequenceEventTriggerProcessBase
// 0x0010 (0x0038 - 0x0028)
class USkipSequenceEventTriggerProcessBase : public UObject
{
public:
	TArray<struct FSequenceEventTriggerFunctionData> FuncDataList;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkipSequenceEventTriggerProcessBase">();
	}
	static class USkipSequenceEventTriggerProcessBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkipSequenceEventTriggerProcessBase>();
	}
};
static_assert(alignof(USkipSequenceEventTriggerProcessBase) == 0x000008, "Wrong alignment on USkipSequenceEventTriggerProcessBase");
static_assert(sizeof(USkipSequenceEventTriggerProcessBase) == 0x000038, "Wrong size on USkipSequenceEventTriggerProcessBase");
static_assert(offsetof(USkipSequenceEventTriggerProcessBase, FuncDataList) == 0x000028, "Member 'USkipSequenceEventTriggerProcessBase::FuncDataList' has a wrong offset!");

// Class Nicola.SkipSequenceEventTriggerProcessAchievement
// 0x0000 (0x0038 - 0x0038)
class USkipSequenceEventTriggerProcessAchievement final : public USkipSequenceEventTriggerProcessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkipSequenceEventTriggerProcessAchievement">();
	}
	static class USkipSequenceEventTriggerProcessAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkipSequenceEventTriggerProcessAchievement>();
	}
};
static_assert(alignof(USkipSequenceEventTriggerProcessAchievement) == 0x000008, "Wrong alignment on USkipSequenceEventTriggerProcessAchievement");
static_assert(sizeof(USkipSequenceEventTriggerProcessAchievement) == 0x000038, "Wrong size on USkipSequenceEventTriggerProcessAchievement");

// Class Nicola.NicolaLightingMgr
// 0x0378 (0x03A8 - 0x0030)
class UNicolaLightingMgr final : public UGameInstanceSubsystem
{
public:
	class ANicolaLightingEnvMgrActor*             lightDirRotator;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ADirectionalLight*                      DirectionalLight;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AExponentialHeightFog*                  ExponentialHeightFog;                              // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x120];                                     // 0x0088(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            directionalLightChangeCurve;                       // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ANicolaLightingEnvVariationTriggerBase*, uint8> overlappedTriggers;                                // 0x01B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ANicolaLightingEnvVariationTriggerBase*, float> triggerTimers;                                     // 0x0200(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x158];                                    // 0x0250(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDebugCascadeDistributionExponent(float Value);
	void SetDebugCascadeTransitionFraction(float Value);
	void SetDebugDynamicShadowCascades(int32 Value);
	void SetDebugDynamicShadowDistance(float Value);
	void SetDebugLightFunctionFadeDistance(float Value);
	void SetDebugShadowBias(float Value);
	void SetDebugShadowDistanceFadeoutFraction(float Value);
	void SetLightDirRotatorActivated(bool isActivated);
	void SetUseDebugDirectionalLightParameterFlag(bool Value);

	float GetDebugCascadeDistributionExponent() const;
	float GetDebugCascadeTransitionFraction() const;
	int32 GetDebugDynamicShadowCascades() const;
	float GetDebugDynamicShadowDistance() const;
	float GetDebugLightFunctionFadeDistance() const;
	float GetDebugShadowBias() const;
	float GetDebugShadowDistanceFadeoutFraction() const;
	bool IsEnvironmentDirectionalLightEnable() const;
	bool IsEnvironmentSkyLightEnable() const;
	bool IsEnvironmentSkySphereEnable() const;
	bool IsLightDirRotatorActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLightingMgr">();
	}
	static class UNicolaLightingMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaLightingMgr>();
	}
};
static_assert(alignof(UNicolaLightingMgr) == 0x000008, "Wrong alignment on UNicolaLightingMgr");
static_assert(sizeof(UNicolaLightingMgr) == 0x0003A8, "Wrong size on UNicolaLightingMgr");
static_assert(offsetof(UNicolaLightingMgr, lightDirRotator) == 0x000030, "Member 'UNicolaLightingMgr::lightDirRotator' has a wrong offset!");
static_assert(offsetof(UNicolaLightingMgr, DirectionalLight) == 0x000058, "Member 'UNicolaLightingMgr::DirectionalLight' has a wrong offset!");
static_assert(offsetof(UNicolaLightingMgr, ExponentialHeightFog) == 0x000080, "Member 'UNicolaLightingMgr::ExponentialHeightFog' has a wrong offset!");
static_assert(offsetof(UNicolaLightingMgr, directionalLightChangeCurve) == 0x0001A8, "Member 'UNicolaLightingMgr::directionalLightChangeCurve' has a wrong offset!");
static_assert(offsetof(UNicolaLightingMgr, overlappedTriggers) == 0x0001B0, "Member 'UNicolaLightingMgr::overlappedTriggers' has a wrong offset!");
static_assert(offsetof(UNicolaLightingMgr, triggerTimers) == 0x000200, "Member 'UNicolaLightingMgr::triggerTimers' has a wrong offset!");

// Class Nicola.UIInitialMenuFlowXbox
// 0x0008 (0x0078 - 0x0070)
class UUIInitialMenuFlowXbox final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInitialMenuFlowXbox">();
	}
	static class UUIInitialMenuFlowXbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInitialMenuFlowXbox>();
	}
};
static_assert(alignof(UUIInitialMenuFlowXbox) == 0x000008, "Wrong alignment on UUIInitialMenuFlowXbox");
static_assert(sizeof(UUIInitialMenuFlowXbox) == 0x000078, "Wrong size on UUIInitialMenuFlowXbox");

// Class Nicola.NicolaListenerController
// 0x0000 (0x0088 - 0x0088)
class UNicolaListenerController final : public UADSoundListenerControllerCRIWare
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaListenerController">();
	}
	static class UNicolaListenerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaListenerController>();
	}
};
static_assert(alignof(UNicolaListenerController) == 0x000008, "Wrong alignment on UNicolaListenerController");
static_assert(sizeof(UNicolaListenerController) == 0x000088, "Wrong size on UNicolaListenerController");

// Class Nicola.UIBar2MenuWindowEquip
// 0x0010 (0x0068 - 0x0058)
class UUIBar2MenuWindowEquip final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemIcon2*>             WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuWindowEquip">();
	}
	static class UUIBar2MenuWindowEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuWindowEquip>();
	}
};
static_assert(alignof(UUIBar2MenuWindowEquip) == 0x000008, "Wrong alignment on UUIBar2MenuWindowEquip");
static_assert(sizeof(UUIBar2MenuWindowEquip) == 0x000068, "Wrong size on UUIBar2MenuWindowEquip");
static_assert(offsetof(UUIBar2MenuWindowEquip, WindowItems) == 0x000058, "Member 'UUIBar2MenuWindowEquip::WindowItems' has a wrong offset!");

// Class Nicola.NicolaListenerSe
// 0x0010 (0x00B0 - 0x00A0)
class UNicolaListenerSe final : public UADSoundListenerCRIWare
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaListenerSe">();
	}
	static class UNicolaListenerSe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaListenerSe>();
	}
};
static_assert(alignof(UNicolaListenerSe) == 0x000008, "Wrong alignment on UNicolaListenerSe");
static_assert(sizeof(UNicolaListenerSe) == 0x0000B0, "Wrong size on UNicolaListenerSe");

// Class Nicola.NicolaLuaDebugFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaLuaDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaLuaDebugFL">();
	}
	static class UNicolaLuaDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaLuaDebugFL>();
	}
};
static_assert(alignof(UNicolaLuaDebugFL) == 0x000008, "Wrong alignment on UNicolaLuaDebugFL");
static_assert(sizeof(UNicolaLuaDebugFL) == 0x000028, "Wrong size on UNicolaLuaDebugFL");

// Class Nicola.UIBar2Menu
// 0x00D0 (0x0148 - 0x0078)
class UUIBar2Menu final : public UUIRootBase
{
public:
	class UUIBar2MenuListTop*                     ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuListBar*                     ListBar;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuListLend*                    ListLend;                                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuListBorrow*                  ListBorrow;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuListParty*                   ListParty;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuListParty2*                  ListParty2;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuListRental*                  ListRental;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuWindowEquip*                 WindowEquip;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuWindowStatus*                WindowStatus;                                      // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveGameDataFlow*                    FlowSaveGameData;                                  // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x80];                                      // 0x00C8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DEBUG_PrepareForStart();
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2Menu">();
	}
	static class UUIBar2Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2Menu>();
	}
};
static_assert(alignof(UUIBar2Menu) == 0x000008, "Wrong alignment on UUIBar2Menu");
static_assert(sizeof(UUIBar2Menu) == 0x000148, "Wrong size on UUIBar2Menu");
static_assert(offsetof(UUIBar2Menu, ListTop) == 0x000078, "Member 'UUIBar2Menu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, ListBar) == 0x000080, "Member 'UUIBar2Menu::ListBar' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, ListLend) == 0x000088, "Member 'UUIBar2Menu::ListLend' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, ListBorrow) == 0x000090, "Member 'UUIBar2Menu::ListBorrow' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, ListParty) == 0x000098, "Member 'UUIBar2Menu::ListParty' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, ListParty2) == 0x0000A0, "Member 'UUIBar2Menu::ListParty2' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, ListRental) == 0x0000A8, "Member 'UUIBar2Menu::ListRental' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, WindowEquip) == 0x0000B0, "Member 'UUIBar2Menu::WindowEquip' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, WindowStatus) == 0x0000B8, "Member 'UUIBar2Menu::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIBar2Menu, FlowSaveGameData) == 0x0000C0, "Member 'UUIBar2Menu::FlowSaveGameData' has a wrong offset!");

// Class Nicola.UIJobChangeMenuListJob
// 0x0020 (0x0110 - 0x00F0)
class UUIJobChangeMenuListJob final : public UUIMemberCreateMenuListJob
{
public:
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIJobChangeMenuListJob">();
	}
	static class UUIJobChangeMenuListJob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIJobChangeMenuListJob>();
	}
};
static_assert(alignof(UUIJobChangeMenuListJob) == 0x000008, "Wrong alignment on UUIJobChangeMenuListJob");
static_assert(sizeof(UUIJobChangeMenuListJob) == 0x000110, "Wrong size on UUIJobChangeMenuListJob");

// Class Nicola.NicolaMapGuideManager
// 0x0038 (0x0060 - 0x0028)
class UNicolaMapGuideManager final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaMapGuideManager">();
	}
	static class UNicolaMapGuideManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaMapGuideManager>();
	}
};
static_assert(alignof(UNicolaMapGuideManager) == 0x000008, "Wrong alignment on UNicolaMapGuideManager");
static_assert(sizeof(UNicolaMapGuideManager) == 0x000060, "Wrong size on UNicolaMapGuideManager");

// Class Nicola.NicolaMaterialParameterActor
// 0x0030 (0x0268 - 0x0238)
class ANicolaMaterialParameterActor final : public ANicolaMapTimeDependingActor
{
public:
	TArray<class FName>                           ParameterNames;                                    // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UCurveBase*>                     curveParameterChanging;                            // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           Collection;                                        // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaMaterialParameterActor">();
	}
	static class ANicolaMaterialParameterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaMaterialParameterActor>();
	}
};
static_assert(alignof(ANicolaMaterialParameterActor) == 0x000008, "Wrong alignment on ANicolaMaterialParameterActor");
static_assert(sizeof(ANicolaMaterialParameterActor) == 0x000268, "Wrong size on ANicolaMaterialParameterActor");
static_assert(offsetof(ANicolaMaterialParameterActor, ParameterNames) == 0x000238, "Member 'ANicolaMaterialParameterActor::ParameterNames' has a wrong offset!");
static_assert(offsetof(ANicolaMaterialParameterActor, curveParameterChanging) == 0x000248, "Member 'ANicolaMaterialParameterActor::curveParameterChanging' has a wrong offset!");
static_assert(offsetof(ANicolaMaterialParameterActor, Collection) == 0x000258, "Member 'ANicolaMaterialParameterActor::Collection' has a wrong offset!");

// Class Nicola.TownPlayerActor
// 0x0030 (0x0660 - 0x0630)
class ATownPlayerActor : public ABreadcrumbman
{
public:
	uint8                                         Pad_630[0x30];                                     // 0x0630(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownPlayerActor">();
	}
	static class ATownPlayerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATownPlayerActor>();
	}
};
static_assert(alignof(ATownPlayerActor) == 0x000010, "Wrong alignment on ATownPlayerActor");
static_assert(sizeof(ATownPlayerActor) == 0x000660, "Wrong size on ATownPlayerActor");

// Class Nicola.ShipTrapSearchObjEventTrigger
// 0x0008 (0x0110 - 0x0108)
class UShipTrapSearchObjEventTrigger final : public USearchObjEventTrigger
{
public:
	bool                                          IsButtonGuideTypeMove;                             // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShipTrapSearchObjEventTrigger">();
	}
	static class UShipTrapSearchObjEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShipTrapSearchObjEventTrigger>();
	}
};
static_assert(alignof(UShipTrapSearchObjEventTrigger) == 0x000008, "Wrong alignment on UShipTrapSearchObjEventTrigger");
static_assert(sizeof(UShipTrapSearchObjEventTrigger) == 0x000110, "Wrong size on UShipTrapSearchObjEventTrigger");
static_assert(offsetof(UShipTrapSearchObjEventTrigger, IsButtonGuideTypeMove) == 0x000108, "Member 'UShipTrapSearchObjEventTrigger::IsButtonGuideTypeMove' has a wrong offset!");

// Class Nicola.NicolaNotifySoundPlay
// 0x0008 (0x0040 - 0x0038)
class UNicolaNotifySoundPlay final : public UAnimNotify
{
public:
	class FName                                   GopId;                                             // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaNotifySoundPlay">();
	}
	static class UNicolaNotifySoundPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaNotifySoundPlay>();
	}
};
static_assert(alignof(UNicolaNotifySoundPlay) == 0x000008, "Wrong alignment on UNicolaNotifySoundPlay");
static_assert(sizeof(UNicolaNotifySoundPlay) == 0x000040, "Wrong size on UNicolaNotifySoundPlay");
static_assert(offsetof(UNicolaNotifySoundPlay, GopId) == 0x000038, "Member 'UNicolaNotifySoundPlay::GopId' has a wrong offset!");

// Class Nicola.NicolaParameterCollectionUpdatingActor
// 0x0000 (0x0220 - 0x0220)
class ANicolaParameterCollectionUpdatingActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaParameterCollectionUpdatingActor">();
	}
	static class ANicolaParameterCollectionUpdatingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaParameterCollectionUpdatingActor>();
	}
};
static_assert(alignof(ANicolaParameterCollectionUpdatingActor) == 0x000008, "Wrong alignment on ANicolaParameterCollectionUpdatingActor");
static_assert(sizeof(ANicolaParameterCollectionUpdatingActor) == 0x000220, "Wrong size on ANicolaParameterCollectionUpdatingActor");

// Class Nicola.UIBar2MenuListRental
// 0x0020 (0x00F0 - 0x00D0)
class UUIBar2MenuListRental final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TextColors;                                        // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListRental">();
	}
	static class UUIBar2MenuListRental* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListRental>();
	}
};
static_assert(alignof(UUIBar2MenuListRental) == 0x000008, "Wrong alignment on UUIBar2MenuListRental");
static_assert(sizeof(UUIBar2MenuListRental) == 0x0000F0, "Wrong size on UUIBar2MenuListRental");
static_assert(offsetof(UUIBar2MenuListRental, TextColors) == 0x0000D8, "Member 'UUIBar2MenuListRental::TextColors' has a wrong offset!");

// Class Nicola.NicolaPerformanceSettingFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaPerformanceSettingFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPerformanceSettingFL">();
	}
	static class UNicolaPerformanceSettingFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaPerformanceSettingFL>();
	}
};
static_assert(alignof(UNicolaPerformanceSettingFL) == 0x000008, "Wrong alignment on UNicolaPerformanceSettingFL");
static_assert(sizeof(UNicolaPerformanceSettingFL) == 0x000028, "Wrong size on UNicolaPerformanceSettingFL");

// Class Nicola.UIBattleTacticsWindowTactics
// 0x0008 (0x0060 - 0x0058)
class UUIBattleTacticsWindowTactics final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTacticsWindowTactics">();
	}
	static class UUIBattleTacticsWindowTactics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTacticsWindowTactics>();
	}
};
static_assert(alignof(UUIBattleTacticsWindowTactics) == 0x000008, "Wrong alignment on UUIBattleTacticsWindowTactics");
static_assert(sizeof(UUIBattleTacticsWindowTactics) == 0x000060, "Wrong size on UUIBattleTacticsWindowTactics");
static_assert(offsetof(UUIBattleTacticsWindowTactics, TextInfo) == 0x000058, "Member 'UUIBattleTacticsWindowTactics::TextInfo' has a wrong offset!");

// Class Nicola.NicolaPlatformFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaPlatformFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPlatformFL">();
	}
	static class UNicolaPlatformFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaPlatformFL>();
	}
};
static_assert(alignof(UNicolaPlatformFL) == 0x000008, "Wrong alignment on UNicolaPlatformFL");
static_assert(sizeof(UNicolaPlatformFL) == 0x000028, "Wrong size on UNicolaPlatformFL");

// Class Nicola.UIBarMenuWindowMemberEquipment
// 0x0010 (0x0068 - 0x0058)
class UUIBarMenuWindowMemberEquipment final : public UUIWindowBase
{
public:
	TArray<class UUIListItemIconDouble*>          WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenuWindowMemberEquipment">();
	}
	static class UUIBarMenuWindowMemberEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenuWindowMemberEquipment>();
	}
};
static_assert(alignof(UUIBarMenuWindowMemberEquipment) == 0x000008, "Wrong alignment on UUIBarMenuWindowMemberEquipment");
static_assert(sizeof(UUIBarMenuWindowMemberEquipment) == 0x000068, "Wrong size on UUIBarMenuWindowMemberEquipment");
static_assert(offsetof(UUIBarMenuWindowMemberEquipment, WindowItems) == 0x000058, "Member 'UUIBarMenuWindowMemberEquipment::WindowItems' has a wrong offset!");

// Class Nicola.NicolaPointLightActor
// 0x0008 (0x0270 - 0x0268)
class ANicolaPointLightActor final : public ANicolaLightActor
{
public:
	class UPointLightComponent*                   PointLightComponent;                               // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPointLightActor">();
	}
	static class ANicolaPointLightActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaPointLightActor>();
	}
};
static_assert(alignof(ANicolaPointLightActor) == 0x000008, "Wrong alignment on ANicolaPointLightActor");
static_assert(sizeof(ANicolaPointLightActor) == 0x000270, "Wrong size on ANicolaPointLightActor");
static_assert(offsetof(ANicolaPointLightActor, PointLightComponent) == 0x000268, "Member 'ANicolaPointLightActor::PointLightComponent' has a wrong offset!");

// Class Nicola.UIKeyboardDayMenu
// 0x0008 (0x0080 - 0x0078)
class UUIKeyboardDayMenu : public UUIRootBase
{
public:
	class UUIKeyboardDateMenuListTop*             ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardDayMenu">();
	}
	static class UUIKeyboardDayMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardDayMenu>();
	}
};
static_assert(alignof(UUIKeyboardDayMenu) == 0x000008, "Wrong alignment on UUIKeyboardDayMenu");
static_assert(sizeof(UUIKeyboardDayMenu) == 0x000080, "Wrong size on UUIKeyboardDayMenu");
static_assert(offsetof(UUIKeyboardDayMenu, ListTop) == 0x000078, "Member 'UUIKeyboardDayMenu::ListTop' has a wrong offset!");

// Class Nicola.UIKeyboardDayMenuEN
// 0x0000 (0x0080 - 0x0080)
class UUIKeyboardDayMenuEN final : public UUIKeyboardDayMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardDayMenuEN">();
	}
	static class UUIKeyboardDayMenuEN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardDayMenuEN>();
	}
};
static_assert(alignof(UUIKeyboardDayMenuEN) == 0x000008, "Wrong alignment on UUIKeyboardDayMenuEN");
static_assert(sizeof(UUIKeyboardDayMenuEN) == 0x000080, "Wrong size on UUIKeyboardDayMenuEN");

// Class Nicola.PostProcessMgrBase
// 0x0290 (0x02C0 - 0x0030)
class alignas(0x10) UPostProcessMgrBase : public UGameInstanceSubsystem
{
public:
	class APostProcessVolume*                     globalPostProcessVolume;                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APostProcessVolume*                     localPostProcessVolume;                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APostProcessVolume*                     eventSequencerPostProcessVolume;                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APostProcessVolume*                     battleSequencerPostProcessVolume;                  // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UMaterialInstanceDynamic*> mapLocalPostProcessMatInsts;                       // 0x0070(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UMaterialInstanceDynamic*> eventSequencerPostProcessMatInsts;                 // 0x00C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UMaterialInstanceDynamic*> battleSequencerPostProcessMatInsts;                // 0x0110(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UMaterialInstanceDynamic*, float>  currentFrameBasePostProcessMatWeights;             // 0x0160(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0xC0];                                     // 0x01B0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENicolaCameraParamType, class AActor*>   focusActors;                                       // 0x0270(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void SetApertureRate(float Rate, float BlendTime);
	void SetFocalLength(ENicolaCameraParamType ParamType, float FocalLength);

	float GetAperture(ENicolaCameraParamType ParamType) const;
	float GetApertureRate() const;
	int32 GetDiaphragmBladeCount(ENicolaCameraParamType ParamType) const;
	float GetDofDepthBlurAmount(ENicolaCameraParamType ParamType) const;
	float GetDofDepthBlurRadius(ENicolaCameraParamType ParamType) const;
	float GetFocalLength(ENicolaCameraParamType ParamType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessMgrBase">();
	}
	static class UPostProcessMgrBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessMgrBase>();
	}
};
static_assert(alignof(UPostProcessMgrBase) == 0x000010, "Wrong alignment on UPostProcessMgrBase");
static_assert(sizeof(UPostProcessMgrBase) == 0x0002C0, "Wrong size on UPostProcessMgrBase");
static_assert(offsetof(UPostProcessMgrBase, globalPostProcessVolume) == 0x000030, "Member 'UPostProcessMgrBase::globalPostProcessVolume' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, localPostProcessVolume) == 0x000038, "Member 'UPostProcessMgrBase::localPostProcessVolume' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, eventSequencerPostProcessVolume) == 0x000040, "Member 'UPostProcessMgrBase::eventSequencerPostProcessVolume' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, battleSequencerPostProcessVolume) == 0x000048, "Member 'UPostProcessMgrBase::battleSequencerPostProcessVolume' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, mapLocalPostProcessMatInsts) == 0x000070, "Member 'UPostProcessMgrBase::mapLocalPostProcessMatInsts' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, eventSequencerPostProcessMatInsts) == 0x0000C0, "Member 'UPostProcessMgrBase::eventSequencerPostProcessMatInsts' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, battleSequencerPostProcessMatInsts) == 0x000110, "Member 'UPostProcessMgrBase::battleSequencerPostProcessMatInsts' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, currentFrameBasePostProcessMatWeights) == 0x000160, "Member 'UPostProcessMgrBase::currentFrameBasePostProcessMatWeights' has a wrong offset!");
static_assert(offsetof(UPostProcessMgrBase, focusActors) == 0x000270, "Member 'UPostProcessMgrBase::focusActors' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuListInput
// 0x0050 (0x0138 - 0x00E8)
class UUIKeyboardNameMenuListInput final : public UUIListFlexibleH
{
public:
	uint8                                         Pad_E8[0x50];                                      // 0x00E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuListInput">();
	}
	static class UUIKeyboardNameMenuListInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuListInput>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuListInput) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuListInput");
static_assert(sizeof(UUIKeyboardNameMenuListInput) == 0x000138, "Wrong size on UUIKeyboardNameMenuListInput");

// Class Nicola.NicolaPostProcessMgr
// 0x0130 (0x03F0 - 0x02C0)
class UNicolaPostProcessMgr final : public UPostProcessMgrBase
{
public:
	TMap<class UMaterialInstanceDynamic*, float>  currentPostProcessMatWeights;                      // 0x02C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       encountPostProcessMatInsts;                        // 0x0310(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               trapZonePostProcessMatInst;                        // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               travelDoorPostProcessMatInst;                      // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ranarutaDayToNightPostProcessMatInst;              // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ranarutaNightToDayPostProcessMatInst;              // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ranarutaDayToNightParamCurve_Cycle;                // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ranarutaDayToNightParamCurve_DarkOut;              // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ranarutaNightToDayParamCurve_Cycle;                // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ranarutaNightToDayParamCurve_DarkOut;              // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               sepiaPostProcessMatInst;                           // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               recollectionPostProcessMatInst;                    // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               battleCrossFadeMatInst;                            // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaPostProcessMgr">();
	}
	static class UNicolaPostProcessMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaPostProcessMgr>();
	}
};
static_assert(alignof(UNicolaPostProcessMgr) == 0x000010, "Wrong alignment on UNicolaPostProcessMgr");
static_assert(sizeof(UNicolaPostProcessMgr) == 0x0003F0, "Wrong size on UNicolaPostProcessMgr");
static_assert(offsetof(UNicolaPostProcessMgr, currentPostProcessMatWeights) == 0x0002C0, "Member 'UNicolaPostProcessMgr::currentPostProcessMatWeights' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, encountPostProcessMatInsts) == 0x000310, "Member 'UNicolaPostProcessMgr::encountPostProcessMatInsts' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, trapZonePostProcessMatInst) == 0x000330, "Member 'UNicolaPostProcessMgr::trapZonePostProcessMatInst' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, travelDoorPostProcessMatInst) == 0x000350, "Member 'UNicolaPostProcessMgr::travelDoorPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, ranarutaDayToNightPostProcessMatInst) == 0x000368, "Member 'UNicolaPostProcessMgr::ranarutaDayToNightPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, ranarutaNightToDayPostProcessMatInst) == 0x000370, "Member 'UNicolaPostProcessMgr::ranarutaNightToDayPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, ranarutaDayToNightParamCurve_Cycle) == 0x000378, "Member 'UNicolaPostProcessMgr::ranarutaDayToNightParamCurve_Cycle' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, ranarutaDayToNightParamCurve_DarkOut) == 0x000380, "Member 'UNicolaPostProcessMgr::ranarutaDayToNightParamCurve_DarkOut' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, ranarutaNightToDayParamCurve_Cycle) == 0x000388, "Member 'UNicolaPostProcessMgr::ranarutaNightToDayParamCurve_Cycle' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, ranarutaNightToDayParamCurve_DarkOut) == 0x000390, "Member 'UNicolaPostProcessMgr::ranarutaNightToDayParamCurve_DarkOut' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, sepiaPostProcessMatInst) == 0x0003A8, "Member 'UNicolaPostProcessMgr::sepiaPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, recollectionPostProcessMatInst) == 0x0003C0, "Member 'UNicolaPostProcessMgr::recollectionPostProcessMatInst' has a wrong offset!");
static_assert(offsetof(UNicolaPostProcessMgr, battleCrossFadeMatInst) == 0x0003D8, "Member 'UNicolaPostProcessMgr::battleCrossFadeMatInst' has a wrong offset!");

// Class Nicola.UIListCrossV
// 0x0040 (0x00E8 - 0x00A8)
class UUIListCrossV : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListCrossV">();
	}
	static class UUIListCrossV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListCrossV>();
	}
};
static_assert(alignof(UUIListCrossV) == 0x000008, "Wrong alignment on UUIListCrossV");
static_assert(sizeof(UUIListCrossV) == 0x0000E8, "Wrong size on UUIListCrossV");

// Class Nicola.UIBattleUnitMenuListItem
// 0x0018 (0x0100 - 0x00E8)
class UUIBattleUnitMenuListItem final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListItem">();
	}
	static class UUIBattleUnitMenuListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListItem>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListItem) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListItem");
static_assert(sizeof(UUIBattleUnitMenuListItem) == 0x000100, "Wrong size on UUIBattleUnitMenuListItem");

// Class Nicola.NicolaRecastNavMesh
// 0x0018 (0x04F0 - 0x04D8)
class ANicolaRecastNavMesh final : public ARecastNavMesh
{
public:
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaRecastNavMesh">();
	}
	static class ANicolaRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaRecastNavMesh>();
	}
};
static_assert(alignof(ANicolaRecastNavMesh) == 0x000008, "Wrong alignment on ANicolaRecastNavMesh");
static_assert(sizeof(ANicolaRecastNavMesh) == 0x0004F0, "Wrong size on ANicolaRecastNavMesh");

// Class Nicola.SwkbdBase
// 0x0000 (0x0028 - 0x0028)
class USwkbdBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwkbdBase">();
	}
	static class USwkbdBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwkbdBase>();
	}
};
static_assert(alignof(USwkbdBase) == 0x000008, "Wrong alignment on USwkbdBase");
static_assert(sizeof(USwkbdBase) == 0x000028, "Wrong size on USwkbdBase");

// Class Nicola.NicolaResearchCommandComponent
// 0x00A8 (0x0158 - 0x00B0)
class UNicolaResearchCommandComponent final : public UActorComponent
{
public:
	TMap<class FName, struct FNotifyEventOverlap> MapNotifyOverlap;                                  // 0x00B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FNotifyEventOverlap                    CurrentTargetCollision;                            // 0x0100(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UButtonGuideComponent*                  ButtonGuideComponent;                              // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATreasureBoxEvent*                      InpasuTargetActor;                                 // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEventOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchCommandComponent">();
	}
	static class UNicolaResearchCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaResearchCommandComponent>();
	}
};
static_assert(alignof(UNicolaResearchCommandComponent) == 0x000008, "Wrong alignment on UNicolaResearchCommandComponent");
static_assert(sizeof(UNicolaResearchCommandComponent) == 0x000158, "Wrong size on UNicolaResearchCommandComponent");
static_assert(offsetof(UNicolaResearchCommandComponent, MapNotifyOverlap) == 0x0000B0, "Member 'UNicolaResearchCommandComponent::MapNotifyOverlap' has a wrong offset!");
static_assert(offsetof(UNicolaResearchCommandComponent, CurrentTargetCollision) == 0x000100, "Member 'UNicolaResearchCommandComponent::CurrentTargetCollision' has a wrong offset!");
static_assert(offsetof(UNicolaResearchCommandComponent, ButtonGuideComponent) == 0x000140, "Member 'UNicolaResearchCommandComponent::ButtonGuideComponent' has a wrong offset!");
static_assert(offsetof(UNicolaResearchCommandComponent, InpasuTargetActor) == 0x000148, "Member 'UNicolaResearchCommandComponent::InpasuTargetActor' has a wrong offset!");

// Class Nicola.NicolaResearchGameMode
// 0x0000 (0x02C0 - 0x02C0)
class ANicolaResearchGameMode final : public ANicolaGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchGameMode">();
	}
	static class ANicolaResearchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchGameMode>();
	}
};
static_assert(alignof(ANicolaResearchGameMode) == 0x000008, "Wrong alignment on ANicolaResearchGameMode");
static_assert(sizeof(ANicolaResearchGameMode) == 0x0002C0, "Wrong size on ANicolaResearchGameMode");

// Class Nicola.ShineSearchEventForField
// 0x0030 (0x02D0 - 0x02A0)
class AShineSearchEventForField final : public AShineSearchEvent
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       overlapFadeCollisionComponent;                     // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpFloat*                           InterpOverlapFading;                               // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoOverlapFade;                                    // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverlapFadeInSec;                                  // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapFadeOutSec;                                 // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnFadeCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShineSearchEventForField">();
	}
	static class AShineSearchEventForField* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShineSearchEventForField>();
	}
};
static_assert(alignof(AShineSearchEventForField) == 0x000008, "Wrong alignment on AShineSearchEventForField");
static_assert(sizeof(AShineSearchEventForField) == 0x0002D0, "Wrong size on AShineSearchEventForField");
static_assert(offsetof(AShineSearchEventForField, overlapFadeCollisionComponent) == 0x0002B0, "Member 'AShineSearchEventForField::overlapFadeCollisionComponent' has a wrong offset!");
static_assert(offsetof(AShineSearchEventForField, InterpOverlapFading) == 0x0002B8, "Member 'AShineSearchEventForField::InterpOverlapFading' has a wrong offset!");
static_assert(offsetof(AShineSearchEventForField, bDoOverlapFade) == 0x0002C0, "Member 'AShineSearchEventForField::bDoOverlapFade' has a wrong offset!");
static_assert(offsetof(AShineSearchEventForField, OverlapFadeInSec) == 0x0002C4, "Member 'AShineSearchEventForField::OverlapFadeInSec' has a wrong offset!");
static_assert(offsetof(AShineSearchEventForField, OverlapFadeOutSec) == 0x0002C8, "Member 'AShineSearchEventForField::OverlapFadeOutSec' has a wrong offset!");

// Class Nicola.SpawnManagementActor
// 0x0040 (0x0260 - 0x0220)
class ASpawnManagementActor : public AActor
{
public:
	class UActorListComponent*                    ActorList;                                         // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   SpawnedChildActorComp;                             // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DefaultSpawnActorClass;                            // 0x0230(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsNeedSpawnForBeginPlay;                          // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DebugSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnManagementActor">();
	}
	static class ASpawnManagementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnManagementActor>();
	}
};
static_assert(alignof(ASpawnManagementActor) == 0x000008, "Wrong alignment on ASpawnManagementActor");
static_assert(sizeof(ASpawnManagementActor) == 0x000260, "Wrong size on ASpawnManagementActor");
static_assert(offsetof(ASpawnManagementActor, ActorList) == 0x000220, "Member 'ASpawnManagementActor::ActorList' has a wrong offset!");
static_assert(offsetof(ASpawnManagementActor, SpawnedChildActorComp) == 0x000228, "Member 'ASpawnManagementActor::SpawnedChildActorComp' has a wrong offset!");
static_assert(offsetof(ASpawnManagementActor, DefaultSpawnActorClass) == 0x000230, "Member 'ASpawnManagementActor::DefaultSpawnActorClass' has a wrong offset!");
static_assert(offsetof(ASpawnManagementActor, bIsNeedSpawnForBeginPlay) == 0x000258, "Member 'ASpawnManagementActor::bIsNeedSpawnForBeginPlay' has a wrong offset!");

// Class Nicola.ProgressSpawnManagementActor
// 0x0018 (0x0278 - 0x0260)
class AProgressSpawnManagementActor : public ASpawnManagementActor
{
public:
	TArray<struct FProgressSpawnInfo>             ProgressSpawnList;                                 // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressSpawnManagementActor">();
	}
	static class AProgressSpawnManagementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProgressSpawnManagementActor>();
	}
};
static_assert(alignof(AProgressSpawnManagementActor) == 0x000008, "Wrong alignment on AProgressSpawnManagementActor");
static_assert(sizeof(AProgressSpawnManagementActor) == 0x000278, "Wrong size on AProgressSpawnManagementActor");
static_assert(offsetof(AProgressSpawnManagementActor, ProgressSpawnList) == 0x000260, "Member 'AProgressSpawnManagementActor::ProgressSpawnList' has a wrong offset!");

// Class Nicola.NicolaResearchPlayerCameraManager
// 0x0000 (0x2DB0 - 0x2DB0)
class ANicolaResearchPlayerCameraManager : public ANicolaResearchPlayerCameraManagerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchPlayerCameraManager">();
	}
	static class ANicolaResearchPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchPlayerCameraManager>();
	}
};
static_assert(alignof(ANicolaResearchPlayerCameraManager) == 0x000010, "Wrong alignment on ANicolaResearchPlayerCameraManager");
static_assert(sizeof(ANicolaResearchPlayerCameraManager) == 0x002DB0, "Wrong size on ANicolaResearchPlayerCameraManager");

// Class Nicola.NicolaResearchPlayerController
// 0x0000 (0x05D0 - 0x05D0)
class ANicolaResearchPlayerController final : public ANicolaPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaResearchPlayerController">();
	}
	static class ANicolaResearchPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaResearchPlayerController>();
	}
};
static_assert(alignof(ANicolaResearchPlayerController) == 0x000008, "Wrong alignment on ANicolaResearchPlayerController");
static_assert(sizeof(ANicolaResearchPlayerController) == 0x0005D0, "Wrong size on ANicolaResearchPlayerController");

// Class Nicola.PlayerFollowNpcCharacter
// 0x0010 (0x04D0 - 0x04C0)
class APlayerFollowNpcCharacter final : public ACharacter
{
public:
	class UActorListComponent*                    ActorListComponent;                                // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerFollowNpcCharacter">();
	}
	static class APlayerFollowNpcCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerFollowNpcCharacter>();
	}
};
static_assert(alignof(APlayerFollowNpcCharacter) == 0x000010, "Wrong alignment on APlayerFollowNpcCharacter");
static_assert(sizeof(APlayerFollowNpcCharacter) == 0x0004D0, "Wrong size on APlayerFollowNpcCharacter");
static_assert(offsetof(APlayerFollowNpcCharacter, ActorListComponent) == 0x0004B8, "Member 'APlayerFollowNpcCharacter::ActorListComponent' has a wrong offset!");

// Class Nicola.SaveSystemDataBase
// 0x0040 (0x0068 - 0x0028)
class USaveSystemDataBase : public USaveGame
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSystemDataBase">();
	}
	static class USaveSystemDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSystemDataBase>();
	}
};
static_assert(alignof(USaveSystemDataBase) == 0x000008, "Wrong alignment on USaveSystemDataBase");
static_assert(sizeof(USaveSystemDataBase) == 0x000068, "Wrong size on USaveSystemDataBase");

// Class Nicola.UITutorial
// 0x0018 (0x0090 - 0x0078)
class UUITutorial final : public UUIRootBase
{
public:
	class UUITutorialCtrlTop*                     Controller;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITutorialWindowMain*                  WindowMain;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ItemButtonHelp;                                    // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsExecMenu();
	static void OpenMenu(class FName InGopId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorial">();
	}
	static class UUITutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorial>();
	}
};
static_assert(alignof(UUITutorial) == 0x000008, "Wrong alignment on UUITutorial");
static_assert(sizeof(UUITutorial) == 0x000090, "Wrong size on UUITutorial");
static_assert(offsetof(UUITutorial, Controller) == 0x000078, "Member 'UUITutorial::Controller' has a wrong offset!");
static_assert(offsetof(UUITutorial, WindowMain) == 0x000080, "Member 'UUITutorial::WindowMain' has a wrong offset!");
static_assert(offsetof(UUITutorial, ItemButtonHelp) == 0x000088, "Member 'UUITutorial::ItemButtonHelp' has a wrong offset!");

// Class Nicola.SaveSystemData
// 0x0D88 (0x0DF0 - 0x0068)
class USaveSystemData final : public USaveSystemDataBase
{
public:
	uint8                                         Pad_68[0xD78];                                     // 0x0068(0x0D78)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 bulkData;                                          // 0x0DE0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSystemData">();
	}
	static class USaveSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSystemData>();
	}
};
static_assert(alignof(USaveSystemData) == 0x000008, "Wrong alignment on USaveSystemData");
static_assert(sizeof(USaveSystemData) == 0x000DF0, "Wrong size on USaveSystemData");
static_assert(offsetof(USaveSystemData, bulkData) == 0x000DE0, "Member 'USaveSystemData::bulkData' has a wrong offset!");

// Class Nicola.SaveSystemDataWithoutCloud
// 0x0040 (0x00A8 - 0x0068)
class USaveSystemDataWithoutCloud final : public USaveSystemDataBase
{
public:
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 bulkData;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSystemDataWithoutCloud">();
	}
	static class USaveSystemDataWithoutCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSystemDataWithoutCloud>();
	}
};
static_assert(alignof(USaveSystemDataWithoutCloud) == 0x000008, "Wrong alignment on USaveSystemDataWithoutCloud");
static_assert(sizeof(USaveSystemDataWithoutCloud) == 0x0000A8, "Wrong size on USaveSystemDataWithoutCloud");
static_assert(offsetof(USaveSystemDataWithoutCloud, bulkData) == 0x000098, "Member 'USaveSystemDataWithoutCloud::bulkData' has a wrong offset!");

// Class Nicola.NicolaWorldSettings
// 0x0020 (0x03C0 - 0x03A0)
class ANicolaWorldSettings final : public AWorldSettings
{
public:
	float                                         MapChipSize;                                       // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapChipHeight;                                     // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CannotDownHeightLevel;                             // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CannotUpHeightLevel;                               // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveBlokingGapRateX;                               // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveBlokingGapRateY;                               // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialBattleCameraYaw;                            // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaWorldSettings">();
	}
	static class ANicolaWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaWorldSettings>();
	}
};
static_assert(alignof(ANicolaWorldSettings) == 0x000008, "Wrong alignment on ANicolaWorldSettings");
static_assert(sizeof(ANicolaWorldSettings) == 0x0003C0, "Wrong size on ANicolaWorldSettings");
static_assert(offsetof(ANicolaWorldSettings, MapChipSize) == 0x0003A0, "Member 'ANicolaWorldSettings::MapChipSize' has a wrong offset!");
static_assert(offsetof(ANicolaWorldSettings, MapChipHeight) == 0x0003A4, "Member 'ANicolaWorldSettings::MapChipHeight' has a wrong offset!");
static_assert(offsetof(ANicolaWorldSettings, CannotDownHeightLevel) == 0x0003A8, "Member 'ANicolaWorldSettings::CannotDownHeightLevel' has a wrong offset!");
static_assert(offsetof(ANicolaWorldSettings, CannotUpHeightLevel) == 0x0003AC, "Member 'ANicolaWorldSettings::CannotUpHeightLevel' has a wrong offset!");
static_assert(offsetof(ANicolaWorldSettings, MoveBlokingGapRateX) == 0x0003B0, "Member 'ANicolaWorldSettings::MoveBlokingGapRateX' has a wrong offset!");
static_assert(offsetof(ANicolaWorldSettings, MoveBlokingGapRateY) == 0x0003B4, "Member 'ANicolaWorldSettings::MoveBlokingGapRateY' has a wrong offset!");
static_assert(offsetof(ANicolaWorldSettings, InitialBattleCameraYaw) == 0x0003B8, "Member 'ANicolaWorldSettings::InitialBattleCameraYaw' has a wrong offset!");

// Class Nicola.SaveGameData
// 0x0090 (0x00B8 - 0x0028)
class USaveGameData final : public USaveGame
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 bulkData;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameData">();
	}
	static class USaveGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameData>();
	}
};
static_assert(alignof(USaveGameData) == 0x000008, "Wrong alignment on USaveGameData");
static_assert(sizeof(USaveGameData) == 0x0000B8, "Wrong size on USaveGameData");
static_assert(offsetof(USaveGameData, bulkData) == 0x000098, "Member 'USaveGameData::bulkData' has a wrong offset!");

// Class Nicola.SwkbdSwitch
// 0x0000 (0x0028 - 0x0028)
class USwkbdSwitch final : public USwkbdBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwkbdSwitch">();
	}
	static class USwkbdSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwkbdSwitch>();
	}
};
static_assert(alignof(USwkbdSwitch) == 0x000008, "Wrong alignment on USwkbdSwitch");
static_assert(sizeof(USwkbdSwitch) == 0x000028, "Wrong size on USwkbdSwitch");

// Class Nicola.NicolaSaveGameFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaSaveGameFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSaveGameFL">();
	}
	static class UNicolaSaveGameFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSaveGameFL>();
	}
};
static_assert(alignof(UNicolaSaveGameFL) == 0x000008, "Wrong alignment on UNicolaSaveGameFL");
static_assert(sizeof(UNicolaSaveGameFL) == 0x000028, "Wrong size on UNicolaSaveGameFL");

// Class Nicola.NicolaSaveGameManager
// 0x00E0 (0x0108 - 0x0028)
class UNicolaSaveGameManager final : public UObject
{
public:
	class USaveSystemData*                        SaveSystemData;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveSystemDataWithoutCloud*            SaveSystemDataWithoutCloud;                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveGameData*                          SaveGame;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveGameData*                          memorySaveGame;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveSystemData*                        swappedSaveSystemData;                             // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xB8];                                      // 0x0050(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AsyncLoadGameData(int32 DataIndex, bool loadForConfig);
	void AsyncSaveGameData(const class UObject* WorldContext, int32 DataIndex, bool gameClear, const class FName saveChurchID);
	bool DEBUG_ResetSystemData(int32 DataIndex);
	void DebugMakeClearData(const class UObject* WorldContext);
	bool DeleteSaveGameData(int32 DataIndex);
	bool DoesSaveGameExist(int32 DataIndex);
	bool LoadGameData(int32 DataIndex);
	void MakeBrokenGameData(int32 DataIndex, int32 randSeed);
	void MakeCrackedGameData(int32 DataIndex, int32 randSeed);
	void MakeDifferentVersionGameData(int32 DataIndex, int32 Version);
	void MakeDifferentVersionSystemData(int32 DataIndex, int32 Version);
	void MakeInvertedGameData(int32 DataIndex);
	void MakeInvertedSystemData(int32 DataIndex);
	bool SaveGameData(const class UObject* WorldContext, int32 DataIndex, bool gameClear, const class FName saveChurchID);

	bool IsExistingAutoSaveData() const;
	bool IsExistingContinueSaveData() const;
	bool IsExistingNormalSaveData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSaveGameManager">();
	}
	static class UNicolaSaveGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSaveGameManager>();
	}
};
static_assert(alignof(UNicolaSaveGameManager) == 0x000008, "Wrong alignment on UNicolaSaveGameManager");
static_assert(sizeof(UNicolaSaveGameManager) == 0x000108, "Wrong size on UNicolaSaveGameManager");
static_assert(offsetof(UNicolaSaveGameManager, SaveSystemData) == 0x000028, "Member 'UNicolaSaveGameManager::SaveSystemData' has a wrong offset!");
static_assert(offsetof(UNicolaSaveGameManager, SaveSystemDataWithoutCloud) == 0x000030, "Member 'UNicolaSaveGameManager::SaveSystemDataWithoutCloud' has a wrong offset!");
static_assert(offsetof(UNicolaSaveGameManager, SaveGame) == 0x000038, "Member 'UNicolaSaveGameManager::SaveGame' has a wrong offset!");
static_assert(offsetof(UNicolaSaveGameManager, memorySaveGame) == 0x000040, "Member 'UNicolaSaveGameManager::memorySaveGame' has a wrong offset!");
static_assert(offsetof(UNicolaSaveGameManager, swappedSaveSystemData) == 0x000048, "Member 'UNicolaSaveGameManager::swappedSaveSystemData' has a wrong offset!");

// Class Nicola.NicolaSkillFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaSkillFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugUseSkill(class FName gopMagicId, int32 targetNo, bool bBattle, bool bEnemy, class FName RuraID);
	static void GetRuraList(TArray<class FName>* GopIdList);
	static const TMap<class FString, class FString> GetScriptArgs(int32 scriptId);
	static void GetSkillGopList(TArray<class FName>* GopIdList);
	static void OnChangeAreaSkill();
	static bool OnWalkStep(bool isInTown, bool isField, float FastWalkRate, float subRate);
	static void RemoveScriptArgs(int32 scriptId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSkillFL">();
	}
	static class UNicolaSkillFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSkillFL>();
	}
};
static_assert(alignof(UNicolaSkillFL) == 0x000008, "Wrong alignment on UNicolaSkillFL");
static_assert(sizeof(UNicolaSkillFL) == 0x000028, "Wrong size on UNicolaSkillFL");

// Class Nicola.OutputFontSizeSubsytem
// 0x0040 (0x0070 - 0x0030)
class UOutputFontSizeSubsytem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OutputFontSize();
	void SetFontPath(const class FString& InFontPath);
	void SetFontSize(int32 InFontSize);

	int32 GetFontSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutputFontSizeSubsytem">();
	}
	static class UOutputFontSizeSubsytem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutputFontSizeSubsytem>();
	}
};
static_assert(alignof(UOutputFontSizeSubsytem) == 0x000008, "Wrong alignment on UOutputFontSizeSubsytem");
static_assert(sizeof(UOutputFontSizeSubsytem) == 0x000070, "Wrong size on UOutputFontSizeSubsytem");

// Class Nicola.TreasureBoxEvent
// 0x0018 (0x02B8 - 0x02A0)
class ATreasureBoxEvent final : public ASearchAnimEvent
{
public:
	class UInterpFloat*                           interpEffectInpasu;                                // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               inpasuMaterialInstance;                            // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureBoxEvent">();
	}
	static class ATreasureBoxEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureBoxEvent>();
	}
};
static_assert(alignof(ATreasureBoxEvent) == 0x000008, "Wrong alignment on ATreasureBoxEvent");
static_assert(sizeof(ATreasureBoxEvent) == 0x0002B8, "Wrong size on ATreasureBoxEvent");
static_assert(offsetof(ATreasureBoxEvent, interpEffectInpasu) == 0x0002A0, "Member 'ATreasureBoxEvent::interpEffectInpasu' has a wrong offset!");
static_assert(offsetof(ATreasureBoxEvent, inpasuMaterialInstance) == 0x0002A8, "Member 'ATreasureBoxEvent::inpasuMaterialInstance' has a wrong offset!");

// Class Nicola.NicolaSkySphereActor
// 0x0020 (0x0250 - 0x0230)
class ANicolaSkySphereActor final : public AStaticMeshActor
{
public:
	uint8                                         Pad_230[0xC];                                      // 0x0230(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoFollowPlayerCamera;                             // 0x023C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUpperFieldSkySphere;                            // 0x023D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUnderFieldSkySphere;                            // 0x023E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23F[0x1];                                      // 0x023F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      niagaraComponentCloud;                             // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      niagaraComponentHorizon;                           // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSkySphereActor">();
	}
	static class ANicolaSkySphereActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaSkySphereActor>();
	}
};
static_assert(alignof(ANicolaSkySphereActor) == 0x000008, "Wrong alignment on ANicolaSkySphereActor");
static_assert(sizeof(ANicolaSkySphereActor) == 0x000250, "Wrong size on ANicolaSkySphereActor");
static_assert(offsetof(ANicolaSkySphereActor, bDoFollowPlayerCamera) == 0x00023C, "Member 'ANicolaSkySphereActor::bDoFollowPlayerCamera' has a wrong offset!");
static_assert(offsetof(ANicolaSkySphereActor, bIsUpperFieldSkySphere) == 0x00023D, "Member 'ANicolaSkySphereActor::bIsUpperFieldSkySphere' has a wrong offset!");
static_assert(offsetof(ANicolaSkySphereActor, bIsUnderFieldSkySphere) == 0x00023E, "Member 'ANicolaSkySphereActor::bIsUnderFieldSkySphere' has a wrong offset!");
static_assert(offsetof(ANicolaSkySphereActor, niagaraComponentCloud) == 0x000240, "Member 'ANicolaSkySphereActor::niagaraComponentCloud' has a wrong offset!");
static_assert(offsetof(ANicolaSkySphereActor, niagaraComponentHorizon) == 0x000248, "Member 'ANicolaSkySphereActor::niagaraComponentHorizon' has a wrong offset!");

// Class Nicola.SequenceCameraFL
// 0x0000 (0x0028 - 0x0028)
class USequenceCameraFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugPlayEventSequence(int32 Index_0);
	static void SequencerSetEnableCharacterForegroundPrePass(class UPrimitiveComponent* TARGET, bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceCameraFL">();
	}
	static class USequenceCameraFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequenceCameraFL>();
	}
};
static_assert(alignof(USequenceCameraFL) == 0x000008, "Wrong alignment on USequenceCameraFL");
static_assert(sizeof(USequenceCameraFL) == 0x000028, "Wrong size on USequenceCameraFL");

// Class Nicola.DebugMenuBGM
// 0x0018 (0x0040 - 0x0028)
class UDebugMenuBGM final : public UObject
{
public:
	int32                                         Index_0;                                           // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Key;                                               // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuBGM">();
	}
	static class UDebugMenuBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuBGM>();
	}
};
static_assert(alignof(UDebugMenuBGM) == 0x000008, "Wrong alignment on UDebugMenuBGM");
static_assert(sizeof(UDebugMenuBGM) == 0x000040, "Wrong size on UDebugMenuBGM");
static_assert(offsetof(UDebugMenuBGM, Index_0) == 0x000028, "Member 'UDebugMenuBGM::Index_0' has a wrong offset!");
static_assert(offsetof(UDebugMenuBGM, Key) == 0x000030, "Member 'UDebugMenuBGM::Key' has a wrong offset!");

// Class Nicola.PostProcessFL
// 0x0000 (0x0028 - 0x0028)
class UPostProcessFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugCatchPostProcessVolume();
	static void EndPostProcessRecollection(float Time);
	static void EndPostProcessSepia(float Time);
	static void EndSettingPostProcessColorByEventScript(float BlendTime);
	static void EndSettingPostProcessGainByEventScript(float BlendTime);
	static void EndSettingPostProcessVignetteByEventScript(float BlendTime);
	static bool IsCatchingPostProcessVolume();
	static bool IsPlayingPostProcessRecollection();
	static bool IsPlayingPostProcessSepia();
	static void ReleasePostProcessVolume();
	static void SetPostProcessVolumeInfo(class FName MapId, EMapTimeFrame MapTime, class FName subLevelId);
	static void StartPostProcessRecollection(float Time);
	static void StartPostProcessSepia(float Time);
	static void StartSettingPostProcessColorByEventScript(const struct FVector& rgbVec, float BlendTime);
	static void StartSettingPostProcessGainByEventScript(float gainRate, float BlendTime);
	static void StartSettingPostProcessVignetteByEventScript(float Intensity, float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessFL">();
	}
	static class UPostProcessFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessFL>();
	}
};
static_assert(alignof(UPostProcessFL) == 0x000008, "Wrong alignment on UPostProcessFL");
static_assert(sizeof(UPostProcessFL) == 0x000028, "Wrong size on UPostProcessFL");

// Class Nicola.NicolaSoundManager
// 0x00C8 (0x0368 - 0x02A0)
class UNicolaSoundManager final : public UADSoundManagerCRIWare
{
public:
	TMap<ENicolaSoundDataTableType, class UDataTable*> GopDataTables;                                     // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<ENicolaSoundCueSheetTypeVoice, class USoundAtomCueSheet*> CurrentVoiceCueSheets;                             // 0x02F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UBgmPlayerManager*                      BgmPlayerMgr;                                      // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoopSoundManager*                      LoopSoundManager;                                  // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSoundManagerFieldAmbient*        NicolaSoundManagerFieldAmbient;                    // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec);
	void FadeOutCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec, bool bAutoStop);
	struct FADSoundPlaybackId PlaySE(const class FName& GopId, const struct FVector& Location, const class UObject* Owner, const TArray<ENicolaSoundCategory>& AdditionalSoundCategory, ENicolaSoundPlayOptionFlags NicolaSoundPlayOptionFlags);
	void SetBgmVolumeRate(float Value);
	void SetSeVolumeRate(float Value);
	void SetVoiceVolumeRate(float Value);
	void StopByCategory(const ENicolaSoundCategory SoundCategory);
	void TransitionCategoryVolumeRate(ENicolaSoundCategory Category, float Rate, float DurationSec);

	bool IsLoopByGopId(const ENicolaSoundDataTableType DataTableType, const class FName& GopId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundManager">();
	}
	static class UNicolaSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundManager>();
	}
};
static_assert(alignof(UNicolaSoundManager) == 0x000008, "Wrong alignment on UNicolaSoundManager");
static_assert(sizeof(UNicolaSoundManager) == 0x000368, "Wrong size on UNicolaSoundManager");
static_assert(offsetof(UNicolaSoundManager, GopDataTables) == 0x0002A0, "Member 'UNicolaSoundManager::GopDataTables' has a wrong offset!");
static_assert(offsetof(UNicolaSoundManager, CurrentVoiceCueSheets) == 0x0002F0, "Member 'UNicolaSoundManager::CurrentVoiceCueSheets' has a wrong offset!");
static_assert(offsetof(UNicolaSoundManager, BgmPlayerMgr) == 0x000340, "Member 'UNicolaSoundManager::BgmPlayerMgr' has a wrong offset!");
static_assert(offsetof(UNicolaSoundManager, LoopSoundManager) == 0x000348, "Member 'UNicolaSoundManager::LoopSoundManager' has a wrong offset!");
static_assert(offsetof(UNicolaSoundManager, NicolaSoundManagerFieldAmbient) == 0x000350, "Member 'UNicolaSoundManager::NicolaSoundManagerFieldAmbient' has a wrong offset!");

// Class Nicola.ShipBase
// 0x0008 (0x0228 - 0x0220)
class AShipBase : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShipBase">();
	}
	static class AShipBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShipBase>();
	}
};
static_assert(alignof(AShipBase) == 0x000008, "Wrong alignment on AShipBase");
static_assert(sizeof(AShipBase) == 0x000228, "Wrong size on AShipBase");
static_assert(offsetof(AShipBase, StaticMeshComponent) == 0x000220, "Member 'AShipBase::StaticMeshComponent' has a wrong offset!");

// Class Nicola.ShipGhost
// 0x0018 (0x0240 - 0x0228)
class AShipGhost final : public AShipBase
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     EffectComp;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EffectId;                                          // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShipGhost">();
	}
	static class AShipGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShipGhost>();
	}
};
static_assert(alignof(AShipGhost) == 0x000008, "Wrong alignment on AShipGhost");
static_assert(sizeof(AShipGhost) == 0x000240, "Wrong size on AShipGhost");
static_assert(offsetof(AShipGhost, BoxComponent) == 0x000228, "Member 'AShipGhost::BoxComponent' has a wrong offset!");
static_assert(offsetof(AShipGhost, EffectComp) == 0x000230, "Member 'AShipGhost::EffectComp' has a wrong offset!");
static_assert(offsetof(AShipGhost, EffectId) == 0x000238, "Member 'AShipGhost::EffectId' has a wrong offset!");

// Class Nicola.UIBar2MenuListBarItem
// 0x0040 (0x0098 - 0x0058)
class UUIBar2MenuListBarItem final : public UUIListItem
{
public:
	class UFlipbookWidget*                        flipbook;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageRental;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLvLabel;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLvValue;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextClassLabel;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextClassText;                                     // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextPsnLabel;                                      // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextPsnText;                                       // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListBarItem">();
	}
	static class UUIBar2MenuListBarItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListBarItem>();
	}
};
static_assert(alignof(UUIBar2MenuListBarItem) == 0x000008, "Wrong alignment on UUIBar2MenuListBarItem");
static_assert(sizeof(UUIBar2MenuListBarItem) == 0x000098, "Wrong size on UUIBar2MenuListBarItem");
static_assert(offsetof(UUIBar2MenuListBarItem, flipbook) == 0x000058, "Member 'UUIBar2MenuListBarItem::flipbook' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, ImageRental) == 0x000060, "Member 'UUIBar2MenuListBarItem::ImageRental' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, TextLvLabel) == 0x000068, "Member 'UUIBar2MenuListBarItem::TextLvLabel' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, TextLvValue) == 0x000070, "Member 'UUIBar2MenuListBarItem::TextLvValue' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, TextClassLabel) == 0x000078, "Member 'UUIBar2MenuListBarItem::TextClassLabel' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, TextClassText) == 0x000080, "Member 'UUIBar2MenuListBarItem::TextClassText' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, TextPsnLabel) == 0x000088, "Member 'UUIBar2MenuListBarItem::TextPsnLabel' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListBarItem, TextPsnText) == 0x000090, "Member 'UUIBar2MenuListBarItem::TextPsnText' has a wrong offset!");

// Class Nicola.NicolaSoundManagerComponentFieldAmbientCoast
// 0x0018 (0x0068 - 0x0050)
class UNicolaSoundManagerComponentFieldAmbientCoast final : public UNicolaSoundManagerComponentFieldAmbientBase
{
public:
	TArray<TWeakObjectPtr<class ANicolaSoundAmbientCoastAreaActor>> OverlappedNicolaSoundAmbientCoastAreaActors;       // 0x0050(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveCoastVolumeRateByDinstance;                   // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundManagerComponentFieldAmbientCoast">();
	}
	static class UNicolaSoundManagerComponentFieldAmbientCoast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundManagerComponentFieldAmbientCoast>();
	}
};
static_assert(alignof(UNicolaSoundManagerComponentFieldAmbientCoast) == 0x000008, "Wrong alignment on UNicolaSoundManagerComponentFieldAmbientCoast");
static_assert(sizeof(UNicolaSoundManagerComponentFieldAmbientCoast) == 0x000068, "Wrong size on UNicolaSoundManagerComponentFieldAmbientCoast");
static_assert(offsetof(UNicolaSoundManagerComponentFieldAmbientCoast, OverlappedNicolaSoundAmbientCoastAreaActors) == 0x000050, "Member 'UNicolaSoundManagerComponentFieldAmbientCoast::OverlappedNicolaSoundAmbientCoastAreaActors' has a wrong offset!");
static_assert(offsetof(UNicolaSoundManagerComponentFieldAmbientCoast, CurveCoastVolumeRateByDinstance) == 0x000060, "Member 'UNicolaSoundManagerComponentFieldAmbientCoast::CurveCoastVolumeRateByDinstance' has a wrong offset!");

// Class Nicola.NicolaSoundManagerFieldAmbient
// 0x0040 (0x0068 - 0x0028)
class UNicolaSoundManagerFieldAmbient final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNicolaSoundManagerComponentFieldAmbientLand* NicolaSoundManagerComponentFieldAmbientLand;       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSoundManagerComponentFieldAmbientCoast* NicolaSoundManagerComponentFieldAmbientCoast;      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSoundManagerFieldAmbient">();
	}
	static class UNicolaSoundManagerFieldAmbient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSoundManagerFieldAmbient>();
	}
};
static_assert(alignof(UNicolaSoundManagerFieldAmbient) == 0x000008, "Wrong alignment on UNicolaSoundManagerFieldAmbient");
static_assert(sizeof(UNicolaSoundManagerFieldAmbient) == 0x000068, "Wrong size on UNicolaSoundManagerFieldAmbient");
static_assert(offsetof(UNicolaSoundManagerFieldAmbient, NicolaSoundManagerComponentFieldAmbientLand) == 0x000030, "Member 'UNicolaSoundManagerFieldAmbient::NicolaSoundManagerComponentFieldAmbientLand' has a wrong offset!");
static_assert(offsetof(UNicolaSoundManagerFieldAmbient, NicolaSoundManagerComponentFieldAmbientCoast) == 0x000038, "Member 'UNicolaSoundManagerFieldAmbient::NicolaSoundManagerComponentFieldAmbientCoast' has a wrong offset!");

// Class Nicola.UIBankMenuWindowAll
// 0x0010 (0x0068 - 0x0058)
class UUIBankMenuWindowAll final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWindowItemButtonIcon*                ItemIcon;                                          // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBankMenuWindowAll">();
	}
	static class UUIBankMenuWindowAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBankMenuWindowAll>();
	}
};
static_assert(alignof(UUIBankMenuWindowAll) == 0x000008, "Wrong alignment on UUIBankMenuWindowAll");
static_assert(sizeof(UUIBankMenuWindowAll) == 0x000068, "Wrong size on UUIBankMenuWindowAll");
static_assert(offsetof(UUIBankMenuWindowAll, TextItem) == 0x000058, "Member 'UUIBankMenuWindowAll::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBankMenuWindowAll, ItemIcon) == 0x000060, "Member 'UUIBankMenuWindowAll::ItemIcon' has a wrong offset!");

// Class Nicola.NicolaSpotLightActor
// 0x0008 (0x0270 - 0x0268)
class ANicolaSpotLightActor final : public ANicolaLightActor
{
public:
	class USpotLightComponent*                    SpotLightComponent;                                // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSpotLightActor">();
	}
	static class ANicolaSpotLightActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaSpotLightActor>();
	}
};
static_assert(alignof(ANicolaSpotLightActor) == 0x000008, "Wrong alignment on ANicolaSpotLightActor");
static_assert(sizeof(ANicolaSpotLightActor) == 0x000270, "Wrong size on ANicolaSpotLightActor");
static_assert(offsetof(ANicolaSpotLightActor, SpotLightComponent) == 0x000268, "Member 'ANicolaSpotLightActor::SpotLightComponent' has a wrong offset!");

// Class Nicola.NicolaSpringArmComponent
// 0x0000 (0x0280 - 0x0280)
class UNicolaSpringArmComponent final : public USpringArmComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSpringArmComponent">();
	}
	static class UNicolaSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSpringArmComponent>();
	}
};
static_assert(alignof(UNicolaSpringArmComponent) == 0x000010, "Wrong alignment on UNicolaSpringArmComponent");
static_assert(sizeof(UNicolaSpringArmComponent) == 0x000280, "Wrong size on UNicolaSpringArmComponent");

// Class Nicola.NicolaStageCameraActor
// 0x0000 (0x0820 - 0x0820)
class ANicolaStageCameraActor : public ANicolaCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaStageCameraActor">();
	}
	static class ANicolaStageCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaStageCameraActor>();
	}
};
static_assert(alignof(ANicolaStageCameraActor) == 0x000010, "Wrong alignment on ANicolaStageCameraActor");
static_assert(sizeof(ANicolaStageCameraActor) == 0x000820, "Wrong size on ANicolaStageCameraActor");

// Class Nicola.NicolaSwayAnimComponent
// 0x0068 (0x0120 - 0x00B8)
class UNicolaSwayAnimComponent final : public UNicolaCharacterComponentBase
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAnimationType, EAnimationType>          swayAnimTable;                                     // 0x00C8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UNicolaSpriteManagerComponent*          spriteManagerComponent;                            // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaSwayAnimComponent">();
	}
	static class UNicolaSwayAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaSwayAnimComponent>();
	}
};
static_assert(alignof(UNicolaSwayAnimComponent) == 0x000008, "Wrong alignment on UNicolaSwayAnimComponent");
static_assert(sizeof(UNicolaSwayAnimComponent) == 0x000120, "Wrong size on UNicolaSwayAnimComponent");
static_assert(offsetof(UNicolaSwayAnimComponent, swayAnimTable) == 0x0000C8, "Member 'UNicolaSwayAnimComponent::swayAnimTable' has a wrong offset!");
static_assert(offsetof(UNicolaSwayAnimComponent, spriteManagerComponent) == 0x000118, "Member 'UNicolaSwayAnimComponent::spriteManagerComponent' has a wrong offset!");

// Class Nicola.NicolaTitleManager
// 0x0068 (0x0288 - 0x0220)
class ANicolaTitleManager final : public AActor
{
public:
	TSubclassOf<class AActor>                     ManaActorClass;                                    // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class AActor*>              ManaActors;                                        // 0x0228(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     AchieveActorClass;                                 // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 AchievementActor;                                  // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class ANicolaTitleManager* GetInstance();

	void OpenTitleDemo();
	void OpenTitleMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaTitleManager">();
	}
	static class ANicolaTitleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANicolaTitleManager>();
	}
};
static_assert(alignof(ANicolaTitleManager) == 0x000008, "Wrong alignment on ANicolaTitleManager");
static_assert(sizeof(ANicolaTitleManager) == 0x000288, "Wrong size on ANicolaTitleManager");
static_assert(offsetof(ANicolaTitleManager, ManaActorClass) == 0x000220, "Member 'ANicolaTitleManager::ManaActorClass' has a wrong offset!");
static_assert(offsetof(ANicolaTitleManager, ManaActors) == 0x000228, "Member 'ANicolaTitleManager::ManaActors' has a wrong offset!");
static_assert(offsetof(ANicolaTitleManager, AchieveActorClass) == 0x000278, "Member 'ANicolaTitleManager::AchieveActorClass' has a wrong offset!");
static_assert(offsetof(ANicolaTitleManager, AchievementActor) == 0x000280, "Member 'ANicolaTitleManager::AchievementActor' has a wrong offset!");

// Class Nicola.NicolaUIManager
// 0x07B0 (0x07D8 - 0x0028)
class UNicolaUIManager : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNicolaGameInstance*                    NGI;                                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaPlayerController*                NPC;                                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUIStorage                             UIStorage;                                         // 0x0040(0x0678)(NativeAccessSpecifierPrivate)
	TSubclassOf<class UUITextureManager>          BP_TextureManager;                                 // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITextureManager*                      TextureManager;                                    // 0x06C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0xE8];                                     // 0x06C8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIInput*                               UIInput;                                           // 0x07B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIWidgetManager>           BP_WidgetManager;                                  // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWidgetManager*                       WidgetManager;                                     // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleManager*                       BattleManager;                                     // 0x07C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D0[0x8];                                      // 0x07D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UNicolaUIManager* GetInstance(const class UObject* InWCO);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaUIManager">();
	}
	static class UNicolaUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaUIManager>();
	}
};
static_assert(alignof(UNicolaUIManager) == 0x000008, "Wrong alignment on UNicolaUIManager");
static_assert(sizeof(UNicolaUIManager) == 0x0007D8, "Wrong size on UNicolaUIManager");
static_assert(offsetof(UNicolaUIManager, NGI) == 0x000030, "Member 'UNicolaUIManager::NGI' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, NPC) == 0x000038, "Member 'UNicolaUIManager::NPC' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, UIStorage) == 0x000040, "Member 'UNicolaUIManager::UIStorage' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, BP_TextureManager) == 0x0006B8, "Member 'UNicolaUIManager::BP_TextureManager' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, TextureManager) == 0x0006C0, "Member 'UNicolaUIManager::TextureManager' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, UIInput) == 0x0007B0, "Member 'UNicolaUIManager::UIInput' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, BP_WidgetManager) == 0x0007B8, "Member 'UNicolaUIManager::BP_WidgetManager' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, WidgetManager) == 0x0007C0, "Member 'UNicolaUIManager::WidgetManager' has a wrong offset!");
static_assert(offsetof(UNicolaUIManager, BattleManager) == 0x0007C8, "Member 'UNicolaUIManager::BattleManager' has a wrong offset!");

// Class Nicola.NicolaVoiceFL
// 0x0000 (0x0028 - 0x0028)
class UNicolaVoiceFL final : public UBlueprintFunctionLibrary
{
public:
	static void DebugChangeUnitVoicePattern(int32 partyUnitIndex, int32 voicePatternNo);
	static int32 DebugGetUnitVoicePattern(int32 partyUnitIndex);
	static struct FADSoundPlaybackId PlayVoiceBattle2D(const class FName& GopVoiceBattleId, EUnitVoicePattern VoicePattern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NicolaVoiceFL">();
	}
	static class UNicolaVoiceFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNicolaVoiceFL>();
	}
};
static_assert(alignof(UNicolaVoiceFL) == 0x000008, "Wrong alignment on UNicolaVoiceFL");
static_assert(sizeof(UNicolaVoiceFL) == 0x000028, "Wrong size on UNicolaVoiceFL");

// Class Nicola.NotifyChangeVisibleInterface
// 0x0000 (0x0028 - 0x0028)
class INotifyChangeVisibleInterface final : public IInterface
{
public:
	void NotifyChangeVisibleActor(bool NewIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotifyChangeVisibleInterface">();
	}
	static class INotifyChangeVisibleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INotifyChangeVisibleInterface>();
	}
};
static_assert(alignof(INotifyChangeVisibleInterface) == 0x000008, "Wrong alignment on INotifyChangeVisibleInterface");
static_assert(sizeof(INotifyChangeVisibleInterface) == 0x000028, "Wrong size on INotifyChangeVisibleInterface");

// Class Nicola.NpcEventTrigger
// 0x0008 (0x0100 - 0x00F8)
class UNpcEventTrigger final : public UEventTriggerComponentBase
{
public:
	class AActor*                                 TriggerActor;                                      // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcEventTrigger">();
	}
	static class UNpcEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcEventTrigger>();
	}
};
static_assert(alignof(UNpcEventTrigger) == 0x000008, "Wrong alignment on UNpcEventTrigger");
static_assert(sizeof(UNpcEventTrigger) == 0x000100, "Wrong size on UNpcEventTrigger");
static_assert(offsetof(UNpcEventTrigger, TriggerActor) == 0x0000F8, "Member 'UNpcEventTrigger::TriggerActor' has a wrong offset!");

// Class Nicola.NpcTestAIController
// 0x0028 (0x0350 - 0x0328)
class ANpcTestAIController final : public AAIController
{
public:
	uint8                                         Pad_328[0x28];                                     // 0x0328(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitNpcController(const class UBoxComponent* PatrolVolumeComp, const class AActor* NpcActor, float NpcWaitTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTestAIController">();
	}
	static class ANpcTestAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTestAIController>();
	}
};
static_assert(alignof(ANpcTestAIController) == 0x000008, "Wrong alignment on ANpcTestAIController");
static_assert(sizeof(ANpcTestAIController) == 0x000350, "Wrong size on ANpcTestAIController");

// Class Nicola.NpcTestSpawnActor
// 0x0060 (0x0280 - 0x0220)
class ANpcTestSpawnActor final : public AActor
{
public:
	class FName                                   SpawnGopMasterId;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CharaActorBP;                                      // 0x0228(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPriorityBPSpawn;                                // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMoveWaitTime                              WaitPattern;                                       // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMoveSpeed                                 SpeedPattern;                                      // 0x0252(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMovePattern                               MovePattern;                                       // 0x0253(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcDirectionType                             DirectionType;                                     // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnScale;                                        // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAIController>              NpcAIController;                                   // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExecuteSpawnNpc;                                  // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PatrolVolume;                                      // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANicolaCharacterBase*                   SpawnNpc;                                          // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTestSpawnActor">();
	}
	static class ANpcTestSpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTestSpawnActor>();
	}
};
static_assert(alignof(ANpcTestSpawnActor) == 0x000008, "Wrong alignment on ANpcTestSpawnActor");
static_assert(sizeof(ANpcTestSpawnActor) == 0x000280, "Wrong size on ANpcTestSpawnActor");
static_assert(offsetof(ANpcTestSpawnActor, SpawnGopMasterId) == 0x000220, "Member 'ANpcTestSpawnActor::SpawnGopMasterId' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, CharaActorBP) == 0x000228, "Member 'ANpcTestSpawnActor::CharaActorBP' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, bIsPriorityBPSpawn) == 0x000250, "Member 'ANpcTestSpawnActor::bIsPriorityBPSpawn' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, WaitPattern) == 0x000251, "Member 'ANpcTestSpawnActor::WaitPattern' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, SpeedPattern) == 0x000252, "Member 'ANpcTestSpawnActor::SpeedPattern' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, MovePattern) == 0x000253, "Member 'ANpcTestSpawnActor::MovePattern' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, DirectionType) == 0x000254, "Member 'ANpcTestSpawnActor::DirectionType' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, SpawnScale) == 0x000258, "Member 'ANpcTestSpawnActor::SpawnScale' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, NpcAIController) == 0x000260, "Member 'ANpcTestSpawnActor::NpcAIController' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, bExecuteSpawnNpc) == 0x000268, "Member 'ANpcTestSpawnActor::bExecuteSpawnNpc' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, PatrolVolume) == 0x000270, "Member 'ANpcTestSpawnActor::PatrolVolume' has a wrong offset!");
static_assert(offsetof(ANpcTestSpawnActor, SpawnNpc) == 0x000278, "Member 'ANpcTestSpawnActor::SpawnNpc' has a wrong offset!");

// Class Nicola.PlayerFollowNpcAIController
// 0x0008 (0x0330 - 0x0328)
class APlayerFollowNpcAIController final : public AAIController
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyHitOtherCharacter();
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ScriptMove(const struct FVector& targetLocation, float Speed);

	bool IsMoveState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerFollowNpcAIController">();
	}
	static class APlayerFollowNpcAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerFollowNpcAIController>();
	}
};
static_assert(alignof(APlayerFollowNpcAIController) == 0x000008, "Wrong alignment on APlayerFollowNpcAIController");
static_assert(sizeof(APlayerFollowNpcAIController) == 0x000330, "Wrong size on APlayerFollowNpcAIController");

// Class Nicola.PlayerLamia
// 0x0080 (0x0650 - 0x05D0)
class APlayerLamia final : public APlayerBase
{
public:
	uint8                                         Pad_5D0[0x1C];                                     // 0x05D0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         heightHigh;                                        // 0x05EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         heightLow;                                         // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         flyPerSec;                                         // 0x05F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         fallPerSec;                                        // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         fallMountainPerSec;                                // 0x05FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         fallThreshold;                                     // 0x0600(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         forwardOffsetHighNorth;                            // 0x0604(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         forwardOffsetHighSouth;                            // 0x0608(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         forwardOffsetLowNorth;                             // 0x060C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         forwardOffsetLowSouth;                             // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         spherecastRadius;                                  // 0x0614(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              markerOffsetMin;                                   // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              markerOffsetMax;                                   // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         markerSpeed;                                       // 0x0628(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         seFadeTime;                                        // 0x062C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x8];                                      // 0x0630(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNicolaFieldMarkerComponent*            marker;                                            // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     EffectComp;                                        // 0x0640(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHeightRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLamia">();
	}
	static class APlayerLamia* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerLamia>();
	}
};
static_assert(alignof(APlayerLamia) == 0x000010, "Wrong alignment on APlayerLamia");
static_assert(sizeof(APlayerLamia) == 0x000650, "Wrong size on APlayerLamia");
static_assert(offsetof(APlayerLamia, heightHigh) == 0x0005EC, "Member 'APlayerLamia::heightHigh' has a wrong offset!");
static_assert(offsetof(APlayerLamia, heightLow) == 0x0005F0, "Member 'APlayerLamia::heightLow' has a wrong offset!");
static_assert(offsetof(APlayerLamia, flyPerSec) == 0x0005F4, "Member 'APlayerLamia::flyPerSec' has a wrong offset!");
static_assert(offsetof(APlayerLamia, fallPerSec) == 0x0005F8, "Member 'APlayerLamia::fallPerSec' has a wrong offset!");
static_assert(offsetof(APlayerLamia, fallMountainPerSec) == 0x0005FC, "Member 'APlayerLamia::fallMountainPerSec' has a wrong offset!");
static_assert(offsetof(APlayerLamia, fallThreshold) == 0x000600, "Member 'APlayerLamia::fallThreshold' has a wrong offset!");
static_assert(offsetof(APlayerLamia, forwardOffsetHighNorth) == 0x000604, "Member 'APlayerLamia::forwardOffsetHighNorth' has a wrong offset!");
static_assert(offsetof(APlayerLamia, forwardOffsetHighSouth) == 0x000608, "Member 'APlayerLamia::forwardOffsetHighSouth' has a wrong offset!");
static_assert(offsetof(APlayerLamia, forwardOffsetLowNorth) == 0x00060C, "Member 'APlayerLamia::forwardOffsetLowNorth' has a wrong offset!");
static_assert(offsetof(APlayerLamia, forwardOffsetLowSouth) == 0x000610, "Member 'APlayerLamia::forwardOffsetLowSouth' has a wrong offset!");
static_assert(offsetof(APlayerLamia, spherecastRadius) == 0x000614, "Member 'APlayerLamia::spherecastRadius' has a wrong offset!");
static_assert(offsetof(APlayerLamia, markerOffsetMin) == 0x000618, "Member 'APlayerLamia::markerOffsetMin' has a wrong offset!");
static_assert(offsetof(APlayerLamia, markerOffsetMax) == 0x000620, "Member 'APlayerLamia::markerOffsetMax' has a wrong offset!");
static_assert(offsetof(APlayerLamia, markerSpeed) == 0x000628, "Member 'APlayerLamia::markerSpeed' has a wrong offset!");
static_assert(offsetof(APlayerLamia, seFadeTime) == 0x00062C, "Member 'APlayerLamia::seFadeTime' has a wrong offset!");
static_assert(offsetof(APlayerLamia, marker) == 0x000638, "Member 'APlayerLamia::marker' has a wrong offset!");
static_assert(offsetof(APlayerLamia, EffectComp) == 0x000640, "Member 'APlayerLamia::EffectComp' has a wrong offset!");

// Class Nicola.PlayerMorph
// 0x0030 (0x0610 - 0x05E0)
class APlayerMorph : public APlayerHumanBase
{
public:
	uint8                                         Pad_5E0[0x20];                                     // 0x05E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   looksId;                                           // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMorph">();
	}
	static class APlayerMorph* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerMorph>();
	}
};
static_assert(alignof(APlayerMorph) == 0x000010, "Wrong alignment on APlayerMorph");
static_assert(sizeof(APlayerMorph) == 0x000610, "Wrong size on APlayerMorph");
static_assert(offsetof(APlayerMorph, looksId) == 0x000600, "Member 'APlayerMorph::looksId' has a wrong offset!");

// Class Nicola.PlayerKing
// 0x0000 (0x0610 - 0x0610)
class APlayerKing final : public APlayerMorph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerKing">();
	}
	static class APlayerKing* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerKing>();
	}
};
static_assert(alignof(APlayerKing) == 0x000010, "Wrong alignment on APlayerKing");
static_assert(sizeof(APlayerKing) == 0x000610, "Wrong size on APlayerKing");

// Class Nicola.PlayerMonster
// 0x0000 (0x0610 - 0x0610)
class APlayerMonster final : public APlayerMorph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMonster">();
	}
	static class APlayerMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerMonster>();
	}
};
static_assert(alignof(APlayerMonster) == 0x000010, "Wrong alignment on APlayerMonster");
static_assert(sizeof(APlayerMonster) == 0x000610, "Wrong size on APlayerMonster");

// Class Nicola.PlayerShip
// 0x0080 (0x0650 - 0x05D0)
class APlayerShip final : public APlayerBase
{
public:
	uint8                                         Pad_5D0[0x24];                                     // 0x05D0(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         topSpeed;                                          // 0x05F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         topSpeedDash;                                      // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         brakeSec;                                          // 0x05FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         searchRange;                                       // 0x0600(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           movementCurve;                                     // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         turnAnglePerSec;                                   // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         stopSeRate;                                        // 0x0614(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         moveSeRate;                                        // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         moveSeStartTime;                                   // 0x061C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         seFadeTime;                                        // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_624[0xC];                                      // 0x0624(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     EffectComp;                                        // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     fxCompStatusEffect;                                // 0x0638(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaFieldMarkerComponent*            marker;                                            // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaResearchCommandComponent*        researchCommand;                                   // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetTopSpeed() const;
	float GetTopSpeedDash() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerShip">();
	}
	static class APlayerShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerShip>();
	}
};
static_assert(alignof(APlayerShip) == 0x000010, "Wrong alignment on APlayerShip");
static_assert(sizeof(APlayerShip) == 0x000650, "Wrong size on APlayerShip");
static_assert(offsetof(APlayerShip, topSpeed) == 0x0005F4, "Member 'APlayerShip::topSpeed' has a wrong offset!");
static_assert(offsetof(APlayerShip, topSpeedDash) == 0x0005F8, "Member 'APlayerShip::topSpeedDash' has a wrong offset!");
static_assert(offsetof(APlayerShip, brakeSec) == 0x0005FC, "Member 'APlayerShip::brakeSec' has a wrong offset!");
static_assert(offsetof(APlayerShip, searchRange) == 0x000600, "Member 'APlayerShip::searchRange' has a wrong offset!");
static_assert(offsetof(APlayerShip, movementCurve) == 0x000608, "Member 'APlayerShip::movementCurve' has a wrong offset!");
static_assert(offsetof(APlayerShip, turnAnglePerSec) == 0x000610, "Member 'APlayerShip::turnAnglePerSec' has a wrong offset!");
static_assert(offsetof(APlayerShip, stopSeRate) == 0x000614, "Member 'APlayerShip::stopSeRate' has a wrong offset!");
static_assert(offsetof(APlayerShip, moveSeRate) == 0x000618, "Member 'APlayerShip::moveSeRate' has a wrong offset!");
static_assert(offsetof(APlayerShip, moveSeStartTime) == 0x00061C, "Member 'APlayerShip::moveSeStartTime' has a wrong offset!");
static_assert(offsetof(APlayerShip, seFadeTime) == 0x000620, "Member 'APlayerShip::seFadeTime' has a wrong offset!");
static_assert(offsetof(APlayerShip, EffectComp) == 0x000630, "Member 'APlayerShip::EffectComp' has a wrong offset!");
static_assert(offsetof(APlayerShip, fxCompStatusEffect) == 0x000638, "Member 'APlayerShip::fxCompStatusEffect' has a wrong offset!");
static_assert(offsetof(APlayerShip, marker) == 0x000640, "Member 'APlayerShip::marker' has a wrong offset!");
static_assert(offsetof(APlayerShip, researchCommand) == 0x000648, "Member 'APlayerShip::researchCommand' has a wrong offset!");

// Class Nicola.ProduceSequencerBGM
// 0x0050 (0x0270 - 0x0220)
class AProduceSequencerBGM final : public AProduceSequencerBase
{
public:
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBattleBGM(class FName GopBattleBgmId, float FadeSec);
	void PlayBGM(class FName GopBgmId, float FadeSec);
	void StopBGM(float fadeOutSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerBGM">();
	}
	static class AProduceSequencerBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerBGM>();
	}
};
static_assert(alignof(AProduceSequencerBGM) == 0x000008, "Wrong alignment on AProduceSequencerBGM");
static_assert(sizeof(AProduceSequencerBGM) == 0x000270, "Wrong size on AProduceSequencerBGM");

// Class Nicola.ProduceSequencerScreenShot
// 0x0028 (0x0248 - 0x0220)
class AProduceSequencerScreenShot final : public AProduceSequencerBase
{
public:
	class FString                                 EventScreenShotID;                                 // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0xC];                                      // 0x0230(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeSec;                                           // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseEventScreenShot();
	void ShowEventScreenShot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerScreenShot">();
	}
	static class AProduceSequencerScreenShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerScreenShot>();
	}
};
static_assert(alignof(AProduceSequencerScreenShot) == 0x000008, "Wrong alignment on AProduceSequencerScreenShot");
static_assert(sizeof(AProduceSequencerScreenShot) == 0x000248, "Wrong size on AProduceSequencerScreenShot");
static_assert(offsetof(AProduceSequencerScreenShot, EventScreenShotID) == 0x000220, "Member 'AProduceSequencerScreenShot::EventScreenShotID' has a wrong offset!");
static_assert(offsetof(AProduceSequencerScreenShot, FadeSec) == 0x00023C, "Member 'AProduceSequencerScreenShot::FadeSec' has a wrong offset!");

// Class Nicola.ProduceSequencerSe
// 0x0008 (0x0228 - 0x0220)
class AProduceSequencerSe final : public AProduceSequencerBase
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySE(const class FString& GopSeID);
	void StopSE();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProduceSequencerSe">();
	}
	static class AProduceSequencerSe* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProduceSequencerSe>();
	}
};
static_assert(alignof(AProduceSequencerSe) == 0x000008, "Wrong alignment on AProduceSequencerSe");
static_assert(sizeof(AProduceSequencerSe) == 0x000228, "Wrong size on AProduceSequencerSe");

// Class Nicola.PS5ActivityManager
// 0x0008 (0x0030 - 0x0028)
class UPS5ActivityManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPS5ActivityManager* GetInstance();

	void ChangeActivityAvailability(const class FString& ActivityId, bool IsAvailable);
	TArray<class FName> DebugGetAllActivityIds();
	void EndActivity(const class FString& ActivityId, EPS5ActivityOutcome ActivityOutcome);
	void StartActivity(const class FString& ActivityId);
	void TerminateActivity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5ActivityManager">();
	}
	static class UPS5ActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5ActivityManager>();
	}
};
static_assert(alignof(UPS5ActivityManager) == 0x000008, "Wrong alignment on UPS5ActivityManager");
static_assert(sizeof(UPS5ActivityManager) == 0x000030, "Wrong size on UPS5ActivityManager");

// Class Nicola.RecollectionDataFL
// 0x0000 (0x0028 - 0x0028)
class URecollectionDataFL final : public UBlueprintFunctionLibrary
{
public:
	static bool ImprintRecollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionDataFL">();
	}
	static class URecollectionDataFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionDataFL>();
	}
};
static_assert(alignof(URecollectionDataFL) == 0x000008, "Wrong alignment on URecollectionDataFL");
static_assert(sizeof(URecollectionDataFL) == 0x000028, "Wrong size on URecollectionDataFL");

// Class Nicola.RichTextBlockButtonIconDecorator
// 0x0150 (0x0260 - 0x0110)
class URichTextBlockButtonIconDecorator : public URichTextBlockMaterialDecorator
{
public:
	uint8                                         Pad_110[0x58];                                     // 0x0110(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            KeyboardIcon;                                      // 0x0168(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, EButtonIcon>                ActionButtonIdMap;                                 // 0x01F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           MultiIconActionName;                               // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           UIControlActionName;                               // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockButtonIconDecorator">();
	}
	static class URichTextBlockButtonIconDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockButtonIconDecorator>();
	}
};
static_assert(alignof(URichTextBlockButtonIconDecorator) == 0x000008, "Wrong alignment on URichTextBlockButtonIconDecorator");
static_assert(sizeof(URichTextBlockButtonIconDecorator) == 0x000260, "Wrong size on URichTextBlockButtonIconDecorator");
static_assert(offsetof(URichTextBlockButtonIconDecorator, KeyboardIcon) == 0x000168, "Member 'URichTextBlockButtonIconDecorator::KeyboardIcon' has a wrong offset!");
static_assert(offsetof(URichTextBlockButtonIconDecorator, ActionButtonIdMap) == 0x0001F0, "Member 'URichTextBlockButtonIconDecorator::ActionButtonIdMap' has a wrong offset!");
static_assert(offsetof(URichTextBlockButtonIconDecorator, MultiIconActionName) == 0x000240, "Member 'URichTextBlockButtonIconDecorator::MultiIconActionName' has a wrong offset!");
static_assert(offsetof(URichTextBlockButtonIconDecorator, UIControlActionName) == 0x000250, "Member 'URichTextBlockButtonIconDecorator::UIControlActionName' has a wrong offset!");

// Class Nicola.RockPuzzleAreaVolume
// 0x0008 (0x0260 - 0x0258)
class ARockPuzzleAreaVolume final : public APlayerTriggerVolume
{
public:
	class ARockPuzzleGimmickActor*                PuzzleGimmickActor;                                // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockPuzzleAreaVolume">();
	}
	static class ARockPuzzleAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockPuzzleAreaVolume>();
	}
};
static_assert(alignof(ARockPuzzleAreaVolume) == 0x000008, "Wrong alignment on ARockPuzzleAreaVolume");
static_assert(sizeof(ARockPuzzleAreaVolume) == 0x000260, "Wrong size on ARockPuzzleAreaVolume");
static_assert(offsetof(ARockPuzzleAreaVolume, PuzzleGimmickActor) == 0x000258, "Member 'ARockPuzzleAreaVolume::PuzzleGimmickActor' has a wrong offset!");

// Class Nicola.RockPuzzleGoalFloor
// 0x0030 (0x0250 - 0x0220)
class ARockPuzzleGoalFloor final : public AActor
{
public:
	class USkeletalMeshComponent*                 GoalFloorMesh;                                     // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        ClearAnimationAsset;                               // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          Collision;                                         // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ClearBlockingVolume;                               // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARockPuzzleGimmickActor*                PuzzleGimmickActor;                                // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARockGimmick*                           OnRideActor;                                       // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRockCheckCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRockCheckCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockPuzzleGoalFloor">();
	}
	static class ARockPuzzleGoalFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockPuzzleGoalFloor>();
	}
};
static_assert(alignof(ARockPuzzleGoalFloor) == 0x000008, "Wrong alignment on ARockPuzzleGoalFloor");
static_assert(sizeof(ARockPuzzleGoalFloor) == 0x000250, "Wrong size on ARockPuzzleGoalFloor");
static_assert(offsetof(ARockPuzzleGoalFloor, GoalFloorMesh) == 0x000220, "Member 'ARockPuzzleGoalFloor::GoalFloorMesh' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGoalFloor, ClearAnimationAsset) == 0x000228, "Member 'ARockPuzzleGoalFloor::ClearAnimationAsset' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGoalFloor, Collision) == 0x000230, "Member 'ARockPuzzleGoalFloor::Collision' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGoalFloor, ClearBlockingVolume) == 0x000238, "Member 'ARockPuzzleGoalFloor::ClearBlockingVolume' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGoalFloor, PuzzleGimmickActor) == 0x000240, "Member 'ARockPuzzleGoalFloor::PuzzleGimmickActor' has a wrong offset!");
static_assert(offsetof(ARockPuzzleGoalFloor, OnRideActor) == 0x000248, "Member 'ARockPuzzleGoalFloor::OnRideActor' has a wrong offset!");

// Class Nicola.SequenceBattleCameraManager
// 0x00F8 (0x0448 - 0x0350)
class ASequenceBattleCameraManager final : public ASequenceCameraManager
{
public:
	class ACameraActor*                           FrontCamera;                                       // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           BackCamera;                                        // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelSequence>>  levelSequences;                                    // 0x0368(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          FrontToBackSequence;                               // 0x0378(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          BackToFrontSequence;                               // 0x03A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class AActor*>            BindActorMap;                                      // 0x03C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class ULevelSequence*>                 preloadSequenceList;                               // 0x0418(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x20];                                     // 0x0428(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ASequenceBattleCameraManager* GetInstance();

	void PlaySequence(int32 Index_0, bool bJumpToEnd);
	void PlaySequenceBackToFront(bool bJumpToEnd);
	void PlaySequenceFrontToBack(bool bJumpToEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceBattleCameraManager">();
	}
	static class ASequenceBattleCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequenceBattleCameraManager>();
	}
};
static_assert(alignof(ASequenceBattleCameraManager) == 0x000008, "Wrong alignment on ASequenceBattleCameraManager");
static_assert(sizeof(ASequenceBattleCameraManager) == 0x000448, "Wrong size on ASequenceBattleCameraManager");
static_assert(offsetof(ASequenceBattleCameraManager, FrontCamera) == 0x000350, "Member 'ASequenceBattleCameraManager::FrontCamera' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, BackCamera) == 0x000358, "Member 'ASequenceBattleCameraManager::BackCamera' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, TargetActor) == 0x000360, "Member 'ASequenceBattleCameraManager::TargetActor' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, levelSequences) == 0x000368, "Member 'ASequenceBattleCameraManager::levelSequences' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, FrontToBackSequence) == 0x000378, "Member 'ASequenceBattleCameraManager::FrontToBackSequence' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, BackToFrontSequence) == 0x0003A0, "Member 'ASequenceBattleCameraManager::BackToFrontSequence' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, BindActorMap) == 0x0003C8, "Member 'ASequenceBattleCameraManager::BindActorMap' has a wrong offset!");
static_assert(offsetof(ASequenceBattleCameraManager, preloadSequenceList) == 0x000418, "Member 'ASequenceBattleCameraManager::preloadSequenceList' has a wrong offset!");

// Class Nicola.SequencerPostUpdateComponent
// 0x0050 (0x0100 - 0x00B0)
class USequencerPostUpdateComponent final : public UActorComponent
{
public:
	TSet<class ANicolaCharacterBase*>             SequencerSpawnCharacterSet;                        // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerPostUpdateComponent">();
	}
	static class USequencerPostUpdateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencerPostUpdateComponent>();
	}
};
static_assert(alignof(USequencerPostUpdateComponent) == 0x000008, "Wrong alignment on USequencerPostUpdateComponent");
static_assert(sizeof(USequencerPostUpdateComponent) == 0x000100, "Wrong size on USequencerPostUpdateComponent");
static_assert(offsetof(USequencerPostUpdateComponent, SequencerSpawnCharacterSet) == 0x0000B0, "Member 'USequencerPostUpdateComponent::SequencerSpawnCharacterSet' has a wrong offset!");

// Class Nicola.ShineChildActorBase
// 0x0000 (0x0220 - 0x0220)
class AShineChildActorBase final : public AActor
{
public:
	void OnStartShineChildActorEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShineChildActorBase">();
	}
	static class AShineChildActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShineChildActorBase>();
	}
};
static_assert(alignof(AShineChildActorBase) == 0x000008, "Wrong alignment on AShineChildActorBase");
static_assert(sizeof(AShineChildActorBase) == 0x000220, "Wrong size on AShineChildActorBase");

// Class Nicola.Ship
// 0x00B0 (0x02D8 - 0x0228)
class AShip final : public AShipBase
{
public:
	class UCapsuleComponent*                      collisionComponent;                                // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        PlayerLocation;                                    // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        EffectLocator;                                     // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShipMaterialOverrideParam>     originalMaterials;                                 // 0x0240(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       OverrideMaterials;                                 // 0x0250(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         overlapActors;                                     // 0x0268(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          lightRootComponent;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ULightComponent*, float>           lightCompInitialIntensity;                         // 0x0280(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UFXSystemComponent*                     EffectComp;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	EShipSpeedType GetShipSpeedTypeEnum() const;
	int32 GetShipSpeedTypeInt() const;
	bool IsSpeedTypeFast() const;
	bool IsSpeedTypeSlow() const;
	bool IsSpeedTypeStop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ship">();
	}
	static class AShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShip>();
	}
};
static_assert(alignof(AShip) == 0x000008, "Wrong alignment on AShip");
static_assert(sizeof(AShip) == 0x0002D8, "Wrong size on AShip");
static_assert(offsetof(AShip, collisionComponent) == 0x000228, "Member 'AShip::collisionComponent' has a wrong offset!");
static_assert(offsetof(AShip, PlayerLocation) == 0x000230, "Member 'AShip::PlayerLocation' has a wrong offset!");
static_assert(offsetof(AShip, EffectLocator) == 0x000238, "Member 'AShip::EffectLocator' has a wrong offset!");
static_assert(offsetof(AShip, originalMaterials) == 0x000240, "Member 'AShip::originalMaterials' has a wrong offset!");
static_assert(offsetof(AShip, OverrideMaterials) == 0x000250, "Member 'AShip::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(AShip, overlapActors) == 0x000268, "Member 'AShip::overlapActors' has a wrong offset!");
static_assert(offsetof(AShip, lightRootComponent) == 0x000278, "Member 'AShip::lightRootComponent' has a wrong offset!");
static_assert(offsetof(AShip, lightCompInitialIntensity) == 0x000280, "Member 'AShip::lightCompInitialIntensity' has a wrong offset!");
static_assert(offsetof(AShip, EffectComp) == 0x0002D0, "Member 'AShip::EffectComp' has a wrong offset!");

// Class Nicola.ProgressSpawnManagementActorForField
// 0x0038 (0x02B0 - 0x0278)
class AProgressSpawnManagementActorForField : public AProgressSpawnManagementActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLoopAreaActor;                                  // 0x0280(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEffectTimeManageComponent*             EffectTimeManageComp;                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x4];                                      // 0x0290(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FieldSymbolListId;                                 // 0x0294(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MapIconTag;                                        // 0x029C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EchoFluteTag;                                      // 0x02A4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressSpawnManagementActorForField">();
	}
	static class AProgressSpawnManagementActorForField* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProgressSpawnManagementActorForField>();
	}
};
static_assert(alignof(AProgressSpawnManagementActorForField) == 0x000008, "Wrong alignment on AProgressSpawnManagementActorForField");
static_assert(sizeof(AProgressSpawnManagementActorForField) == 0x0002B0, "Wrong size on AProgressSpawnManagementActorForField");
static_assert(offsetof(AProgressSpawnManagementActorForField, bIsLoopAreaActor) == 0x000280, "Member 'AProgressSpawnManagementActorForField::bIsLoopAreaActor' has a wrong offset!");
static_assert(offsetof(AProgressSpawnManagementActorForField, EffectTimeManageComp) == 0x000288, "Member 'AProgressSpawnManagementActorForField::EffectTimeManageComp' has a wrong offset!");
static_assert(offsetof(AProgressSpawnManagementActorForField, FieldSymbolListId) == 0x000294, "Member 'AProgressSpawnManagementActorForField::FieldSymbolListId' has a wrong offset!");
static_assert(offsetof(AProgressSpawnManagementActorForField, MapIconTag) == 0x00029C, "Member 'AProgressSpawnManagementActorForField::MapIconTag' has a wrong offset!");
static_assert(offsetof(AProgressSpawnManagementActorForField, EchoFluteTag) == 0x0002A4, "Member 'AProgressSpawnManagementActorForField::EchoFluteTag' has a wrong offset!");

// Class Nicola.StartPointIdentifier
// 0x0000 (0x0028 - 0x0028)
class IStartPointIdentifier final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartPointIdentifier">();
	}
	static class IStartPointIdentifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartPointIdentifier>();
	}
};
static_assert(alignof(IStartPointIdentifier) == 0x000008, "Wrong alignment on IStartPointIdentifier");
static_assert(sizeof(IStartPointIdentifier) == 0x000028, "Wrong size on IStartPointIdentifier");

// Class Nicola.StrikeStickChecker
// 0x0058 (0x0080 - 0x0028)
class UStrikeStickChecker final : public UObject
{
public:
	float                                         StrikeStickTime;                                   // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikeStickTimeMin;                                // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikeStickInputMin;                               // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4C];                                      // 0x0034(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrikeStickChecker">();
	}
	static class UStrikeStickChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrikeStickChecker>();
	}
};
static_assert(alignof(UStrikeStickChecker) == 0x000008, "Wrong alignment on UStrikeStickChecker");
static_assert(sizeof(UStrikeStickChecker) == 0x000080, "Wrong size on UStrikeStickChecker");
static_assert(offsetof(UStrikeStickChecker, StrikeStickTime) == 0x000028, "Member 'UStrikeStickChecker::StrikeStickTime' has a wrong offset!");
static_assert(offsetof(UStrikeStickChecker, StrikeStickTimeMin) == 0x00002C, "Member 'UStrikeStickChecker::StrikeStickTimeMin' has a wrong offset!");
static_assert(offsetof(UStrikeStickChecker, StrikeStickInputMin) == 0x000030, "Member 'UStrikeStickChecker::StrikeStickInputMin' has a wrong offset!");

// Class Nicola.SwkbdPS5
// 0x0000 (0x0028 - 0x0028)
class USwkbdPS5 final : public USwkbdBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwkbdPS5">();
	}
	static class USwkbdPS5* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwkbdPS5>();
	}
};
static_assert(alignof(USwkbdPS5) == 0x000008, "Wrong alignment on USwkbdPS5");
static_assert(sizeof(USwkbdPS5) == 0x000028, "Wrong size on USwkbdPS5");

// Class Nicola.SwkbdSteam
// 0x0030 (0x0058 - 0x0028)
class USwkbdSteam final : public USwkbdBase
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwkbdSteam">();
	}
	static class USwkbdSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwkbdSteam>();
	}
};
static_assert(alignof(USwkbdSteam) == 0x000008, "Wrong alignment on USwkbdSteam");
static_assert(sizeof(USwkbdSteam) == 0x000058, "Wrong size on USwkbdSteam");

// Class Nicola.SwkbdXSX
// 0x0010 (0x0038 - 0x0028)
class USwkbdXSX final : public USwkbdBase
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwkbdXSX">();
	}
	static class USwkbdXSX* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwkbdXSX>();
	}
};
static_assert(alignof(USwkbdXSX) == 0x000008, "Wrong alignment on USwkbdXSX");
static_assert(sizeof(USwkbdXSX) == 0x000038, "Wrong size on USwkbdXSX");

// Class Nicola.SystemSettingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class USystemSettingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemSettingFunctionLibrary">();
	}
	static class USystemSettingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemSettingFunctionLibrary>();
	}
};
static_assert(alignof(USystemSettingFunctionLibrary) == 0x000008, "Wrong alignment on USystemSettingFunctionLibrary");
static_assert(sizeof(USystemSettingFunctionLibrary) == 0x000028, "Wrong size on USystemSettingFunctionLibrary");

// Class Nicola.TestLamia
// 0x0190 (0x0650 - 0x04C0)
class ATestLamia final : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x7C];                                     // 0x04B8(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         movePerSec;                                        // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         dashPerSec;                                        // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         movePerStep;                                       // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Interval;                                          // 0x0540(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          reqestMove;                                        // 0x054C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0x1B];                                     // 0x054D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          useTestData;                                       // 0x0568(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   test;                                              // 0x0570(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   test2;                                             // 0x0598(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   test3;                                             // 0x05C0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   test4;                                             // 0x05E8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         testScale;                                         // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoTraceLandscape;                                 // 0x0614(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_615[0x3];                                      // 0x0615(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         depthTraceLandScape;                               // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         distanceTraceForwardOffset;                        // 0x061C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         hightTraceForwardOffset;                           // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoUseSphereForTraceLandscape;                     // 0x0624(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         radiusSphere;                                      // 0x0628(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         requiredHightFromLandscape;                        // 0x062C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         threshouldForMinZVelocity;                         // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         threshouldForMaxZVelocity;                         // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      niagaraComponentWind;                              // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   childActorComponentTarget;                         // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableGravity(bool Enable);
	float GetDashPerSec();
	float GetMovePerSec();
	float GetMovePerStep();
	float GetSpriteScale();
	bool GetTraceLandscapeFlag();
	void onChangedMovementMode(class ACharacter* Character, EMovementMode prevMode, uint8 PrevCustomMode);
	void onUpdateMovement(float Delta, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void SetDashPerSec(float Value);
	void SetMovePerSec(float Value);
	void SetPosAndAlignment(const struct FVector& Pos, EDirectionOnMap dirAlignment, EDirectionOnMap dirLeader);
	void SetTraceLandscapeFlag(bool Value);
	void Together(const struct FVector& Pos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestLamia">();
	}
	static class ATestLamia* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestLamia>();
	}
};
static_assert(alignof(ATestLamia) == 0x000010, "Wrong alignment on ATestLamia");
static_assert(sizeof(ATestLamia) == 0x000650, "Wrong size on ATestLamia");
static_assert(offsetof(ATestLamia, movePerSec) == 0x000534, "Member 'ATestLamia::movePerSec' has a wrong offset!");
static_assert(offsetof(ATestLamia, dashPerSec) == 0x000538, "Member 'ATestLamia::dashPerSec' has a wrong offset!");
static_assert(offsetof(ATestLamia, movePerStep) == 0x00053C, "Member 'ATestLamia::movePerStep' has a wrong offset!");
static_assert(offsetof(ATestLamia, Interval) == 0x000540, "Member 'ATestLamia::Interval' has a wrong offset!");
static_assert(offsetof(ATestLamia, reqestMove) == 0x00054C, "Member 'ATestLamia::reqestMove' has a wrong offset!");
static_assert(offsetof(ATestLamia, useTestData) == 0x000568, "Member 'ATestLamia::useTestData' has a wrong offset!");
static_assert(offsetof(ATestLamia, test) == 0x000570, "Member 'ATestLamia::test' has a wrong offset!");
static_assert(offsetof(ATestLamia, test2) == 0x000598, "Member 'ATestLamia::test2' has a wrong offset!");
static_assert(offsetof(ATestLamia, test3) == 0x0005C0, "Member 'ATestLamia::test3' has a wrong offset!");
static_assert(offsetof(ATestLamia, test4) == 0x0005E8, "Member 'ATestLamia::test4' has a wrong offset!");
static_assert(offsetof(ATestLamia, testScale) == 0x000610, "Member 'ATestLamia::testScale' has a wrong offset!");
static_assert(offsetof(ATestLamia, bDoTraceLandscape) == 0x000614, "Member 'ATestLamia::bDoTraceLandscape' has a wrong offset!");
static_assert(offsetof(ATestLamia, depthTraceLandScape) == 0x000618, "Member 'ATestLamia::depthTraceLandScape' has a wrong offset!");
static_assert(offsetof(ATestLamia, distanceTraceForwardOffset) == 0x00061C, "Member 'ATestLamia::distanceTraceForwardOffset' has a wrong offset!");
static_assert(offsetof(ATestLamia, hightTraceForwardOffset) == 0x000620, "Member 'ATestLamia::hightTraceForwardOffset' has a wrong offset!");
static_assert(offsetof(ATestLamia, bDoUseSphereForTraceLandscape) == 0x000624, "Member 'ATestLamia::bDoUseSphereForTraceLandscape' has a wrong offset!");
static_assert(offsetof(ATestLamia, radiusSphere) == 0x000628, "Member 'ATestLamia::radiusSphere' has a wrong offset!");
static_assert(offsetof(ATestLamia, requiredHightFromLandscape) == 0x00062C, "Member 'ATestLamia::requiredHightFromLandscape' has a wrong offset!");
static_assert(offsetof(ATestLamia, threshouldForMinZVelocity) == 0x000630, "Member 'ATestLamia::threshouldForMinZVelocity' has a wrong offset!");
static_assert(offsetof(ATestLamia, threshouldForMaxZVelocity) == 0x000634, "Member 'ATestLamia::threshouldForMaxZVelocity' has a wrong offset!");
static_assert(offsetof(ATestLamia, niagaraComponentWind) == 0x000638, "Member 'ATestLamia::niagaraComponentWind' has a wrong offset!");
static_assert(offsetof(ATestLamia, childActorComponentTarget) == 0x000640, "Member 'ATestLamia::childActorComponentTarget' has a wrong offset!");

// Class Nicola.TestShip
// 0x0120 (0x05E0 - 0x04C0)
class ATestShip final : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x40];                                     // 0x04B8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         movePerSec;                                        // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         dashPerSec;                                        // 0x04FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         movePerStep;                                       // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         movePerPush;                                       // 0x0504(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         moveFactorPush;                                    // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoMovePerStep;                                  // 0x050C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50D[0x3];                                      // 0x050D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         zValueSeaSurface;                                  // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         zValueSeaBottom;                                   // 0x0514(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         shipMeshOffsetFromSeaSurface;                      // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         shipWaveOffsetFromSeaSurface;                      // 0x051C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          testPhysicalMaterial;                              // 0x0520(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   staticMeshComponentShip;                           // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         intervalUpdateStaticMeshDir;                       // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         deltaAngleUpdateStaticMeshDir;                     // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateStaticMeshDirOnPush;                        // 0x0538(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateStaticMeshDirOnChangeInput;                 // 0x0539(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53A[0x2];                                      // 0x053A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         threshouldStaticMeshDirOnChangeInput;              // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         depthTraceLandScape;                               // 0x0540(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         adjustAngleDelta;                                  // 0x0544(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         adjustAngleMax;                                    // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0x84];                                     // 0x054C(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      niagaraComponentShipWave;                          // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDashPerSec();
	float GetMovePerSec();
	bool IsEnableWalkingByPhysicalMaterial();
	void SetDashPerSec(float Value);
	void SetEnableWalkingByPhysicalMaterial(bool Value);
	void SetMovePerSec(float Value);

	const struct FVector GetMeshDir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestShip">();
	}
	static class ATestShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestShip>();
	}
};
static_assert(alignof(ATestShip) == 0x000010, "Wrong alignment on ATestShip");
static_assert(sizeof(ATestShip) == 0x0005E0, "Wrong size on ATestShip");
static_assert(offsetof(ATestShip, movePerSec) == 0x0004F8, "Member 'ATestShip::movePerSec' has a wrong offset!");
static_assert(offsetof(ATestShip, dashPerSec) == 0x0004FC, "Member 'ATestShip::dashPerSec' has a wrong offset!");
static_assert(offsetof(ATestShip, movePerStep) == 0x000500, "Member 'ATestShip::movePerStep' has a wrong offset!");
static_assert(offsetof(ATestShip, movePerPush) == 0x000504, "Member 'ATestShip::movePerPush' has a wrong offset!");
static_assert(offsetof(ATestShip, moveFactorPush) == 0x000508, "Member 'ATestShip::moveFactorPush' has a wrong offset!");
static_assert(offsetof(ATestShip, bAutoMovePerStep) == 0x00050C, "Member 'ATestShip::bAutoMovePerStep' has a wrong offset!");
static_assert(offsetof(ATestShip, zValueSeaSurface) == 0x000510, "Member 'ATestShip::zValueSeaSurface' has a wrong offset!");
static_assert(offsetof(ATestShip, zValueSeaBottom) == 0x000514, "Member 'ATestShip::zValueSeaBottom' has a wrong offset!");
static_assert(offsetof(ATestShip, shipMeshOffsetFromSeaSurface) == 0x000518, "Member 'ATestShip::shipMeshOffsetFromSeaSurface' has a wrong offset!");
static_assert(offsetof(ATestShip, shipWaveOffsetFromSeaSurface) == 0x00051C, "Member 'ATestShip::shipWaveOffsetFromSeaSurface' has a wrong offset!");
static_assert(offsetof(ATestShip, testPhysicalMaterial) == 0x000520, "Member 'ATestShip::testPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(ATestShip, staticMeshComponentShip) == 0x000528, "Member 'ATestShip::staticMeshComponentShip' has a wrong offset!");
static_assert(offsetof(ATestShip, intervalUpdateStaticMeshDir) == 0x000530, "Member 'ATestShip::intervalUpdateStaticMeshDir' has a wrong offset!");
static_assert(offsetof(ATestShip, deltaAngleUpdateStaticMeshDir) == 0x000534, "Member 'ATestShip::deltaAngleUpdateStaticMeshDir' has a wrong offset!");
static_assert(offsetof(ATestShip, bUpdateStaticMeshDirOnPush) == 0x000538, "Member 'ATestShip::bUpdateStaticMeshDirOnPush' has a wrong offset!");
static_assert(offsetof(ATestShip, bUpdateStaticMeshDirOnChangeInput) == 0x000539, "Member 'ATestShip::bUpdateStaticMeshDirOnChangeInput' has a wrong offset!");
static_assert(offsetof(ATestShip, threshouldStaticMeshDirOnChangeInput) == 0x00053C, "Member 'ATestShip::threshouldStaticMeshDirOnChangeInput' has a wrong offset!");
static_assert(offsetof(ATestShip, depthTraceLandScape) == 0x000540, "Member 'ATestShip::depthTraceLandScape' has a wrong offset!");
static_assert(offsetof(ATestShip, adjustAngleDelta) == 0x000544, "Member 'ATestShip::adjustAngleDelta' has a wrong offset!");
static_assert(offsetof(ATestShip, adjustAngleMax) == 0x000548, "Member 'ATestShip::adjustAngleMax' has a wrong offset!");
static_assert(offsetof(ATestShip, niagaraComponentShipWave) == 0x0005D0, "Member 'ATestShip::niagaraComponentShipWave' has a wrong offset!");

// Class Nicola.TownShipLocator
// 0x0028 (0x0248 - 0x0220)
class ATownShipLocator final : public AActor
{
public:
	class USceneComponent*                        shipLocator;                                       // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        bridgeLocator;                                     // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGOPEnumSpecialEntranceType                   condition;                                         // 0x0230(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        Collision;                                         // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorListComponent*                    ActorList;                                         // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownShipLocator">();
	}
	static class ATownShipLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATownShipLocator>();
	}
};
static_assert(alignof(ATownShipLocator) == 0x000008, "Wrong alignment on ATownShipLocator");
static_assert(sizeof(ATownShipLocator) == 0x000248, "Wrong size on ATownShipLocator");
static_assert(offsetof(ATownShipLocator, shipLocator) == 0x000220, "Member 'ATownShipLocator::shipLocator' has a wrong offset!");
static_assert(offsetof(ATownShipLocator, bridgeLocator) == 0x000228, "Member 'ATownShipLocator::bridgeLocator' has a wrong offset!");
static_assert(offsetof(ATownShipLocator, condition) == 0x000230, "Member 'ATownShipLocator::condition' has a wrong offset!");
static_assert(offsetof(ATownShipLocator, Collision) == 0x000238, "Member 'ATownShipLocator::Collision' has a wrong offset!");
static_assert(offsetof(ATownShipLocator, ActorList) == 0x000240, "Member 'ATownShipLocator::ActorList' has a wrong offset!");

// Class Nicola.TriggerVolumeActor
// 0x0018 (0x0280 - 0x0268)
class ATriggerVolumeActor : public ATriggerEventActor
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxComp;                                           // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVolumeEventTrigger*                    VolumeTrigger;                                     // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerVolumeActor">();
	}
	static class ATriggerVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerVolumeActor>();
	}
};
static_assert(alignof(ATriggerVolumeActor) == 0x000008, "Wrong alignment on ATriggerVolumeActor");
static_assert(sizeof(ATriggerVolumeActor) == 0x000280, "Wrong size on ATriggerVolumeActor");
static_assert(offsetof(ATriggerVolumeActor, BoxComp) == 0x000270, "Member 'ATriggerVolumeActor::BoxComp' has a wrong offset!");
static_assert(offsetof(ATriggerVolumeActor, VolumeTrigger) == 0x000278, "Member 'ATriggerVolumeActor::VolumeTrigger' has a wrong offset!");

// Class Nicola.TriggerVolumeActorByOneFrame
// 0x0000 (0x0280 - 0x0280)
class ATriggerVolumeActorByOneFrame final : public ATriggerVolumeActor
{
public:
	static class ATriggerVolumeActorByOneFrame* SpawnOneFrameVolumeActorAndApplyParameterFromTriggerVolume(class UObject* WorldContext, class ATriggerVolumeActor* SourceVolume, TSubclassOf<class ATriggerVolumeActorByOneFrame> OneFrameVolumeClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerVolumeActorByOneFrame">();
	}
	static class ATriggerVolumeActorByOneFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerVolumeActorByOneFrame>();
	}
};
static_assert(alignof(ATriggerVolumeActorByOneFrame) == 0x000008, "Wrong alignment on ATriggerVolumeActorByOneFrame");
static_assert(sizeof(ATriggerVolumeActorByOneFrame) == 0x000280, "Wrong size on ATriggerVolumeActorByOneFrame");

// Class Nicola.RockTriggerVolumeActor
// 0x0018 (0x0280 - 0x0268)
class ARockTriggerVolumeActor final : public ATriggerEventActor
{
public:
	class UBoxComponent*                          BoxComp;                                           // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARockGimmickPersonality*                OverlapRockGimmick;                                // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRockCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockTriggerVolumeActor">();
	}
	static class ARockTriggerVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockTriggerVolumeActor>();
	}
};
static_assert(alignof(ARockTriggerVolumeActor) == 0x000008, "Wrong alignment on ARockTriggerVolumeActor");
static_assert(sizeof(ARockTriggerVolumeActor) == 0x000280, "Wrong size on ARockTriggerVolumeActor");
static_assert(offsetof(ARockTriggerVolumeActor, BoxComp) == 0x000268, "Member 'ARockTriggerVolumeActor::BoxComp' has a wrong offset!");
static_assert(offsetof(ARockTriggerVolumeActor, OverlapRockGimmick) == 0x000270, "Member 'ARockTriggerVolumeActor::OverlapRockGimmick' has a wrong offset!");

// Class Nicola.TurnGimmick
// 0x0028 (0x0250 - 0x0228)
class ATurnGimmick final : public APlayerControllableGimmick
{
public:
	float                                         TurnAngle;                                         // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x24];                                     // 0x022C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayEnterAnimation();
	void PlayEscapeAnimation(EAxis2Direction Axis);
	void PlayWaitAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnGimmick">();
	}
	static class ATurnGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATurnGimmick>();
	}
};
static_assert(alignof(ATurnGimmick) == 0x000008, "Wrong alignment on ATurnGimmick");
static_assert(sizeof(ATurnGimmick) == 0x000250, "Wrong size on ATurnGimmick");
static_assert(offsetof(ATurnGimmick, TurnAngle) == 0x000228, "Member 'ATurnGimmick::TurnAngle' has a wrong offset!");

// Class Nicola.UIBankListItem
// 0x0010 (0x0068 - 0x0058)
class UUIBankListItem final : public UUIListItem
{
public:
	class UImage*                                 UpArrow;                                           // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DownArrow;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBankListItem">();
	}
	static class UUIBankListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBankListItem>();
	}
};
static_assert(alignof(UUIBankListItem) == 0x000008, "Wrong alignment on UUIBankListItem");
static_assert(sizeof(UUIBankListItem) == 0x000068, "Wrong size on UUIBankListItem");
static_assert(offsetof(UUIBankListItem, UpArrow) == 0x000058, "Member 'UUIBankListItem::UpArrow' has a wrong offset!");
static_assert(offsetof(UUIBankListItem, DownArrow) == 0x000060, "Member 'UUIBankListItem::DownArrow' has a wrong offset!");

// Class Nicola.UIBankMoneyMenuListTop
// 0x0040 (0x00B0 - 0x0070)
class UUIBankMoneyMenuListTop final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIBankListItem*>                ViewItems;                                         // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          GoldUnit;                                          // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBankMoneyMenuListTop">();
	}
	static class UUIBankMoneyMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBankMoneyMenuListTop>();
	}
};
static_assert(alignof(UUIBankMoneyMenuListTop) == 0x000008, "Wrong alignment on UUIBankMoneyMenuListTop");
static_assert(sizeof(UUIBankMoneyMenuListTop) == 0x0000B0, "Wrong size on UUIBankMoneyMenuListTop");
static_assert(offsetof(UUIBankMoneyMenuListTop, ViewItems) == 0x000080, "Member 'UUIBankMoneyMenuListTop::ViewItems' has a wrong offset!");
static_assert(offsetof(UUIBankMoneyMenuListTop, GoldUnit) == 0x000090, "Member 'UUIBankMoneyMenuListTop::GoldUnit' has a wrong offset!");

// Class Nicola.UIBankTopMenuListTop
// 0x0000 (0x00D0 - 0x00D0)
class UUIBankTopMenuListTop final : public UUIListPage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBankTopMenuListTop">();
	}
	static class UUIBankTopMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBankTopMenuListTop>();
	}
};
static_assert(alignof(UUIBankTopMenuListTop) == 0x000008, "Wrong alignment on UUIBankTopMenuListTop");
static_assert(sizeof(UUIBankTopMenuListTop) == 0x0000D0, "Wrong size on UUIBankTopMenuListTop");

// Class Nicola.UIBar2MenuListBar
// 0x0018 (0x00E8 - 0x00D0)
class UUIBar2MenuListBar final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListBar">();
	}
	static class UUIBar2MenuListBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListBar>();
	}
};
static_assert(alignof(UUIBar2MenuListBar) == 0x000008, "Wrong alignment on UUIBar2MenuListBar");
static_assert(sizeof(UUIBar2MenuListBar) == 0x0000E8, "Wrong size on UUIBar2MenuListBar");

// Class Nicola.UIBar2MenuListBorrow
// 0x0030 (0x0100 - 0x00D0)
class UUIBar2MenuListBorrow final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListBorrow">();
	}
	static class UUIBar2MenuListBorrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListBorrow>();
	}
};
static_assert(alignof(UUIBar2MenuListBorrow) == 0x000008, "Wrong alignment on UUIBar2MenuListBorrow");
static_assert(sizeof(UUIBar2MenuListBorrow) == 0x000100, "Wrong size on UUIBar2MenuListBorrow");

// Class Nicola.UIBar2MenuListLend
// 0x0018 (0x00E8 - 0x00D0)
class UUIBar2MenuListLend final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListLend">();
	}
	static class UUIBar2MenuListLend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListLend>();
	}
};
static_assert(alignof(UUIBar2MenuListLend) == 0x000008, "Wrong alignment on UUIBar2MenuListLend");
static_assert(sizeof(UUIBar2MenuListLend) == 0x0000E8, "Wrong size on UUIBar2MenuListLend");

// Class Nicola.UIBar2MenuListParty
// 0x0018 (0x00E8 - 0x00D0)
class UUIBar2MenuListParty final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListParty">();
	}
	static class UUIBar2MenuListParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListParty>();
	}
};
static_assert(alignof(UUIBar2MenuListParty) == 0x000008, "Wrong alignment on UUIBar2MenuListParty");
static_assert(sizeof(UUIBar2MenuListParty) == 0x0000E8, "Wrong size on UUIBar2MenuListParty");

// Class Nicola.UIBar2MenuListPartyItem
// 0x0040 (0x0098 - 0x0058)
class UUIBar2MenuListPartyItem final : public UUIListItem
{
public:
	class UFlipbookWidget*                        flipbook;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLvLabel;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLvValue;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextClassLabel;                                    // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextClassText;                                     // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextPsnLabel;                                      // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextPsnText;                                       // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextEmpty;                                         // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuListPartyItem">();
	}
	static class UUIBar2MenuListPartyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuListPartyItem>();
	}
};
static_assert(alignof(UUIBar2MenuListPartyItem) == 0x000008, "Wrong alignment on UUIBar2MenuListPartyItem");
static_assert(sizeof(UUIBar2MenuListPartyItem) == 0x000098, "Wrong size on UUIBar2MenuListPartyItem");
static_assert(offsetof(UUIBar2MenuListPartyItem, flipbook) == 0x000058, "Member 'UUIBar2MenuListPartyItem::flipbook' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextLvLabel) == 0x000060, "Member 'UUIBar2MenuListPartyItem::TextLvLabel' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextLvValue) == 0x000068, "Member 'UUIBar2MenuListPartyItem::TextLvValue' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextClassLabel) == 0x000070, "Member 'UUIBar2MenuListPartyItem::TextClassLabel' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextClassText) == 0x000078, "Member 'UUIBar2MenuListPartyItem::TextClassText' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextPsnLabel) == 0x000080, "Member 'UUIBar2MenuListPartyItem::TextPsnLabel' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextPsnText) == 0x000088, "Member 'UUIBar2MenuListPartyItem::TextPsnText' has a wrong offset!");
static_assert(offsetof(UUIBar2MenuListPartyItem, TextEmpty) == 0x000090, "Member 'UUIBar2MenuListPartyItem::TextEmpty' has a wrong offset!");

// Class Nicola.UIBar2MenuWindowStatus
// 0x0010 (0x0068 - 0x0058)
class UUIBar2MenuWindowStatus final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemText2*>             WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBar2MenuWindowStatus">();
	}
	static class UUIBar2MenuWindowStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBar2MenuWindowStatus>();
	}
};
static_assert(alignof(UUIBar2MenuWindowStatus) == 0x000008, "Wrong alignment on UUIBar2MenuWindowStatus");
static_assert(sizeof(UUIBar2MenuWindowStatus) == 0x000068, "Wrong size on UUIBar2MenuWindowStatus");
static_assert(offsetof(UUIBar2MenuWindowStatus, WindowItems) == 0x000058, "Member 'UUIBar2MenuWindowStatus::WindowItems' has a wrong offset!");

// Class Nicola.UIBarMenu
// 0x02B0 (0x0328 - 0x0078)
class UUIBarMenu final : public UUIRootBase
{
public:
	class UUIBarMenuListTop*                      ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuListMember*                   ListMemberParty;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuWindowMemberEquipment*        WindowMemberEquipmentParty;                        // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuWindowMemberParam*            WindowMemberParamParty;                            // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuWindowMemberSelected*         WindowMemberSelected;                              // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuListMember*                   ListMemberStandby;                                 // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuWindowMemberEquipment*        WindowMemberEquipmentStandby;                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBarMenuWindowMemberParam*            WindowMemberParamStandby;                          // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x270];                                     // 0x00B8(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenu">();
	}
	static class UUIBarMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenu>();
	}
};
static_assert(alignof(UUIBarMenu) == 0x000008, "Wrong alignment on UUIBarMenu");
static_assert(sizeof(UUIBarMenu) == 0x000328, "Wrong size on UUIBarMenu");
static_assert(offsetof(UUIBarMenu, ListTop) == 0x000078, "Member 'UUIBarMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, ListMemberParty) == 0x000080, "Member 'UUIBarMenu::ListMemberParty' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, WindowMemberEquipmentParty) == 0x000088, "Member 'UUIBarMenu::WindowMemberEquipmentParty' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, WindowMemberParamParty) == 0x000090, "Member 'UUIBarMenu::WindowMemberParamParty' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, WindowMemberSelected) == 0x000098, "Member 'UUIBarMenu::WindowMemberSelected' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, ListMemberStandby) == 0x0000A0, "Member 'UUIBarMenu::ListMemberStandby' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, WindowMemberEquipmentStandby) == 0x0000A8, "Member 'UUIBarMenu::WindowMemberEquipmentStandby' has a wrong offset!");
static_assert(offsetof(UUIBarMenu, WindowMemberParamStandby) == 0x0000B0, "Member 'UUIBarMenu::WindowMemberParamStandby' has a wrong offset!");

// Class Nicola.UIBarMenuListItemMember
// 0x0040 (0x0098 - 0x0058)
class UUIBarMenuListItemMember final : public UUIListItem
{
public:
	class UImage*                                 IconChara;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          LvText;                                            // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          LvValueText;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitClassText;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitClassValueText;                                // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitPersonalText;                                  // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitPersonalValueText;                             // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          EmptySlotText;                                     // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenuListItemMember">();
	}
	static class UUIBarMenuListItemMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenuListItemMember>();
	}
};
static_assert(alignof(UUIBarMenuListItemMember) == 0x000008, "Wrong alignment on UUIBarMenuListItemMember");
static_assert(sizeof(UUIBarMenuListItemMember) == 0x000098, "Wrong size on UUIBarMenuListItemMember");
static_assert(offsetof(UUIBarMenuListItemMember, IconChara) == 0x000058, "Member 'UUIBarMenuListItemMember::IconChara' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, LvText) == 0x000060, "Member 'UUIBarMenuListItemMember::LvText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, LvValueText) == 0x000068, "Member 'UUIBarMenuListItemMember::LvValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, UnitClassText) == 0x000070, "Member 'UUIBarMenuListItemMember::UnitClassText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, UnitClassValueText) == 0x000078, "Member 'UUIBarMenuListItemMember::UnitClassValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, UnitPersonalText) == 0x000080, "Member 'UUIBarMenuListItemMember::UnitPersonalText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, UnitPersonalValueText) == 0x000088, "Member 'UUIBarMenuListItemMember::UnitPersonalValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuListItemMember, EmptySlotText) == 0x000090, "Member 'UUIBarMenuListItemMember::EmptySlotText' has a wrong offset!");

// Class Nicola.UIBarMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIBarMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenuListTop">();
	}
	static class UUIBarMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenuListTop>();
	}
};
static_assert(alignof(UUIBarMenuListTop) == 0x000008, "Wrong alignment on UUIBarMenuListTop");
static_assert(sizeof(UUIBarMenuListTop) == 0x0000D8, "Wrong size on UUIBarMenuListTop");

// Class Nicola.UIBarMenuWindowMemberParam
// 0x0010 (0x0068 - 0x0058)
class UUIBarMenuWindowMemberParam final : public UUIWindowBase
{
public:
	TArray<class UUIListItemText2*>               WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenuWindowMemberParam">();
	}
	static class UUIBarMenuWindowMemberParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenuWindowMemberParam>();
	}
};
static_assert(alignof(UUIBarMenuWindowMemberParam) == 0x000008, "Wrong alignment on UUIBarMenuWindowMemberParam");
static_assert(sizeof(UUIBarMenuWindowMemberParam) == 0x000068, "Wrong size on UUIBarMenuWindowMemberParam");
static_assert(offsetof(UUIBarMenuWindowMemberParam, WindowItems) == 0x000058, "Member 'UUIBarMenuWindowMemberParam::WindowItems' has a wrong offset!");

// Class Nicola.UIBarMenuWindowMemberSelected
// 0x0050 (0x00A8 - 0x0058)
class UUIBarMenuWindowMemberSelected final : public UUIWindowBase
{
public:
	class UImage*                                 IconChara;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemHighlight;                                     // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitNameValueText;                                 // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          LvText;                                            // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          LvValueText;                                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitClassText;                                     // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitClassValueText;                                // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitPersonalText;                                  // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnitPersonalValueText;                             // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          EmptySlotText;                                     // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBarMenuWindowMemberSelected">();
	}
	static class UUIBarMenuWindowMemberSelected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBarMenuWindowMemberSelected>();
	}
};
static_assert(alignof(UUIBarMenuWindowMemberSelected) == 0x000008, "Wrong alignment on UUIBarMenuWindowMemberSelected");
static_assert(sizeof(UUIBarMenuWindowMemberSelected) == 0x0000A8, "Wrong size on UUIBarMenuWindowMemberSelected");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, IconChara) == 0x000058, "Member 'UUIBarMenuWindowMemberSelected::IconChara' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, ItemHighlight) == 0x000060, "Member 'UUIBarMenuWindowMemberSelected::ItemHighlight' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, UnitNameValueText) == 0x000068, "Member 'UUIBarMenuWindowMemberSelected::UnitNameValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, LvText) == 0x000070, "Member 'UUIBarMenuWindowMemberSelected::LvText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, LvValueText) == 0x000078, "Member 'UUIBarMenuWindowMemberSelected::LvValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, UnitClassText) == 0x000080, "Member 'UUIBarMenuWindowMemberSelected::UnitClassText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, UnitClassValueText) == 0x000088, "Member 'UUIBarMenuWindowMemberSelected::UnitClassValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, UnitPersonalText) == 0x000090, "Member 'UUIBarMenuWindowMemberSelected::UnitPersonalText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, UnitPersonalValueText) == 0x000098, "Member 'UUIBarMenuWindowMemberSelected::UnitPersonalValueText' has a wrong offset!");
static_assert(offsetof(UUIBarMenuWindowMemberSelected, EmptySlotText) == 0x0000A0, "Member 'UUIBarMenuWindowMemberSelected::EmptySlotText' has a wrong offset!");

// Class Nicola.UIBattleDamagePlayItem
// 0x0050 (0x0078 - 0x0028)
class UUIBattleDamagePlayItem final : public UObject
{
public:
	class UCommonItemWidget*                      View;                                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGopTextBlock*                          TextMiss;                                          // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageSeparator;                                    // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         ImageNumbers;                                      // 0x0048(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       Slot;                                              // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleDamagePlayItem">();
	}
	static class UUIBattleDamagePlayItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleDamagePlayItem>();
	}
};
static_assert(alignof(UUIBattleDamagePlayItem) == 0x000008, "Wrong alignment on UUIBattleDamagePlayItem");
static_assert(sizeof(UUIBattleDamagePlayItem) == 0x000078, "Wrong size on UUIBattleDamagePlayItem");
static_assert(offsetof(UUIBattleDamagePlayItem, View) == 0x000028, "Member 'UUIBattleDamagePlayItem::View' has a wrong offset!");
static_assert(offsetof(UUIBattleDamagePlayItem, TextMiss) == 0x000038, "Member 'UUIBattleDamagePlayItem::TextMiss' has a wrong offset!");
static_assert(offsetof(UUIBattleDamagePlayItem, ImageSeparator) == 0x000040, "Member 'UUIBattleDamagePlayItem::ImageSeparator' has a wrong offset!");
static_assert(offsetof(UUIBattleDamagePlayItem, ImageNumbers) == 0x000048, "Member 'UUIBattleDamagePlayItem::ImageNumbers' has a wrong offset!");
static_assert(offsetof(UUIBattleDamagePlayItem, Slot) == 0x000070, "Member 'UUIBattleDamagePlayItem::Slot' has a wrong offset!");

// Class Nicola.UIBattleDamageViewItem
// 0x0020 (0x0048 - 0x0028)
class UUIBattleDamageViewItem final : public UObject
{
public:
	class UCommonBaseWidget*                      View;                                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIBattleDamagePlayItem*>        PlayItems;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleDamageViewItem">();
	}
	static class UUIBattleDamageViewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleDamageViewItem>();
	}
};
static_assert(alignof(UUIBattleDamageViewItem) == 0x000008, "Wrong alignment on UUIBattleDamageViewItem");
static_assert(sizeof(UUIBattleDamageViewItem) == 0x000048, "Wrong size on UUIBattleDamageViewItem");
static_assert(offsetof(UUIBattleDamageViewItem, View) == 0x000028, "Member 'UUIBattleDamageViewItem::View' has a wrong offset!");
static_assert(offsetof(UUIBattleDamageViewItem, PlayItems) == 0x000038, "Member 'UUIBattleDamageViewItem::PlayItems' has a wrong offset!");

// Class Nicola.UIBattleEncountMenu
// 0x0010 (0x0088 - 0x0078)
class UUIBattleEncountMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleEncountMenu">();
	}
	static class UUIBattleEncountMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleEncountMenu>();
	}
};
static_assert(alignof(UUIBattleEncountMenu) == 0x000008, "Wrong alignment on UUIBattleEncountMenu");
static_assert(sizeof(UUIBattleEncountMenu) == 0x000088, "Wrong size on UUIBattleEncountMenu");

// Class Nicola.UIBattleManager
// 0x0040 (0x0068 - 0x0028)
class UUIBattleManager final : public UObject
{
public:
	class UNicolaUIManager*                       UIManager;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWidgetManager*                       WidgetManager;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaPlayerController*                NPC;                                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DEBUG_CreatePartyMembers();
	static void DEBUG_StartMBRBattle();
	static void DEBUG_StartMBRBattle2(const class FName& encountId, const class FName& playerId1, const class FName& playerId2, const class FName& playerId3, const class FName& MapId);
	static class UUIBattleManager* GetInstance(const class UObject* InWCO);

	void DEBUG_StartResultMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleManager">();
	}
	static class UUIBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleManager>();
	}
};
static_assert(alignof(UUIBattleManager) == 0x000008, "Wrong alignment on UUIBattleManager");
static_assert(sizeof(UUIBattleManager) == 0x000068, "Wrong size on UUIBattleManager");
static_assert(offsetof(UUIBattleManager, UIManager) == 0x000028, "Member 'UUIBattleManager::UIManager' has a wrong offset!");
static_assert(offsetof(UUIBattleManager, WidgetManager) == 0x000030, "Member 'UUIBattleManager::WidgetManager' has a wrong offset!");
static_assert(offsetof(UUIBattleManager, NPC) == 0x000038, "Member 'UUIBattleManager::NPC' has a wrong offset!");

// Class Nicola.UIBattleMonsterName
// 0x0040 (0x00B0 - 0x0070)
class UUIBattleMonsterName final : public UUICtrlBase
{
public:
	TArray<class UUIBattleMonsterNameItem*>       WindowItems;                                       // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageSpeedRange1;                                  // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageSpeedRange2;                                  // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageInfoRange1;                                   // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageInfoRange2;                                   // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool DEBUG_GetDispRangeFlag();
	static void DEBUG_SetDispRangeFlag(bool InFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleMonsterName">();
	}
	static class UUIBattleMonsterName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleMonsterName>();
	}
};
static_assert(alignof(UUIBattleMonsterName) == 0x000008, "Wrong alignment on UUIBattleMonsterName");
static_assert(sizeof(UUIBattleMonsterName) == 0x0000B0, "Wrong size on UUIBattleMonsterName");
static_assert(offsetof(UUIBattleMonsterName, WindowItems) == 0x000070, "Member 'UUIBattleMonsterName::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIBattleMonsterName, ImageSpeedRange1) == 0x000080, "Member 'UUIBattleMonsterName::ImageSpeedRange1' has a wrong offset!");
static_assert(offsetof(UUIBattleMonsterName, ImageSpeedRange2) == 0x000088, "Member 'UUIBattleMonsterName::ImageSpeedRange2' has a wrong offset!");
static_assert(offsetof(UUIBattleMonsterName, ImageInfoRange1) == 0x000090, "Member 'UUIBattleMonsterName::ImageInfoRange1' has a wrong offset!");
static_assert(offsetof(UUIBattleMonsterName, ImageInfoRange2) == 0x000098, "Member 'UUIBattleMonsterName::ImageInfoRange2' has a wrong offset!");

// Class Nicola.UIBattleMonsterNameItem
// 0x0040 (0x0080 - 0x0040)
class UUIBattleMonsterNameItem final : public UUIWindowItem
{
public:
	class UCanvasPanelSlot*                       Slot;                                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageRange1;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageRange2;                                       // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleMonsterNameItem">();
	}
	static class UUIBattleMonsterNameItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleMonsterNameItem>();
	}
};
static_assert(alignof(UUIBattleMonsterNameItem) == 0x000008, "Wrong alignment on UUIBattleMonsterNameItem");
static_assert(sizeof(UUIBattleMonsterNameItem) == 0x000080, "Wrong size on UUIBattleMonsterNameItem");
static_assert(offsetof(UUIBattleMonsterNameItem, Slot) == 0x000040, "Member 'UUIBattleMonsterNameItem::Slot' has a wrong offset!");
static_assert(offsetof(UUIBattleMonsterNameItem, ImageRange1) == 0x000048, "Member 'UUIBattleMonsterNameItem::ImageRange1' has a wrong offset!");
static_assert(offsetof(UUIBattleMonsterNameItem, ImageRange2) == 0x000050, "Member 'UUIBattleMonsterNameItem::ImageRange2' has a wrong offset!");

// Class Nicola.UIBattlePlayerStatus
// 0x0030 (0x00A8 - 0x0078)
class UUIBattlePlayerStatus final : public UUIRootBase
{
public:
	class UUIBattleWindowStatus1*                 WindowStatus1;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleWindowStatus2*                 WindowStatus2;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleMonsterName*                   MonsterName;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleDamage*                        MonsterDamage;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleDamage*                        PlayerDamage;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleSpeedController*               SpeedController;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattlePlayerStatus">();
	}
	static class UUIBattlePlayerStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattlePlayerStatus>();
	}
};
static_assert(alignof(UUIBattlePlayerStatus) == 0x000008, "Wrong alignment on UUIBattlePlayerStatus");
static_assert(sizeof(UUIBattlePlayerStatus) == 0x0000A8, "Wrong size on UUIBattlePlayerStatus");
static_assert(offsetof(UUIBattlePlayerStatus, WindowStatus1) == 0x000078, "Member 'UUIBattlePlayerStatus::WindowStatus1' has a wrong offset!");
static_assert(offsetof(UUIBattlePlayerStatus, WindowStatus2) == 0x000080, "Member 'UUIBattlePlayerStatus::WindowStatus2' has a wrong offset!");
static_assert(offsetof(UUIBattlePlayerStatus, MonsterName) == 0x000088, "Member 'UUIBattlePlayerStatus::MonsterName' has a wrong offset!");
static_assert(offsetof(UUIBattlePlayerStatus, MonsterDamage) == 0x000090, "Member 'UUIBattlePlayerStatus::MonsterDamage' has a wrong offset!");
static_assert(offsetof(UUIBattlePlayerStatus, PlayerDamage) == 0x000098, "Member 'UUIBattlePlayerStatus::PlayerDamage' has a wrong offset!");
static_assert(offsetof(UUIBattlePlayerStatus, SpeedController) == 0x0000A0, "Member 'UUIBattlePlayerStatus::SpeedController' has a wrong offset!");

// Class Nicola.UIBattleResultMenu
// 0x0018 (0x0090 - 0x0078)
class UUIBattleResultMenu final : public UUIRootBase
{
public:
	class UUIBattleResultMenuWindowMessage*       WindowMessage;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleResultMenuWindowParam*         WindowParam;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleResultMenuWindowMagic*         WindowMagic;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenu">();
	}
	static class UUIBattleResultMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenu>();
	}
};
static_assert(alignof(UUIBattleResultMenu) == 0x000008, "Wrong alignment on UUIBattleResultMenu");
static_assert(sizeof(UUIBattleResultMenu) == 0x000090, "Wrong size on UUIBattleResultMenu");
static_assert(offsetof(UUIBattleResultMenu, WindowMessage) == 0x000078, "Member 'UUIBattleResultMenu::WindowMessage' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenu, WindowParam) == 0x000080, "Member 'UUIBattleResultMenu::WindowParam' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenu, WindowMagic) == 0x000088, "Member 'UUIBattleResultMenu::WindowMagic' has a wrong offset!");

// Class Nicola.UIBattleResultMenuWindowItemMagic
// 0x0010 (0x0050 - 0x0040)
class UUIBattleResultMenuWindowItemMagic final : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ItemIcon;                                          // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenuWindowItemMagic">();
	}
	static class UUIBattleResultMenuWindowItemMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenuWindowItemMagic>();
	}
};
static_assert(alignof(UUIBattleResultMenuWindowItemMagic) == 0x000008, "Wrong alignment on UUIBattleResultMenuWindowItemMagic");
static_assert(sizeof(UUIBattleResultMenuWindowItemMagic) == 0x000050, "Wrong size on UUIBattleResultMenuWindowItemMagic");
static_assert(offsetof(UUIBattleResultMenuWindowItemMagic, ItemIcon) == 0x000048, "Member 'UUIBattleResultMenuWindowItemMagic::ItemIcon' has a wrong offset!");

// Class Nicola.UIBattleResultMenuWindowMagic
// 0x0060 (0x00D0 - 0x0070)
class UUIBattleResultMenuWindowMagic final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIWindowItemPage*                      ItemPage;                                          // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem;                                          // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageBg;                                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageBgFootter;                                    // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenuWindowMagic">();
	}
	static class UUIBattleResultMenuWindowMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenuWindowMagic>();
	}
};
static_assert(alignof(UUIBattleResultMenuWindowMagic) == 0x000008, "Wrong alignment on UUIBattleResultMenuWindowMagic");
static_assert(sizeof(UUIBattleResultMenuWindowMagic) == 0x0000D0, "Wrong size on UUIBattleResultMenuWindowMagic");
static_assert(offsetof(UUIBattleResultMenuWindowMagic, WindowItems) == 0x0000A0, "Member 'UUIBattleResultMenuWindowMagic::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowMagic, ItemPage) == 0x0000B0, "Member 'UUIBattleResultMenuWindowMagic::ItemPage' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowMagic, TextItem) == 0x0000B8, "Member 'UUIBattleResultMenuWindowMagic::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowMagic, ImageBg) == 0x0000C0, "Member 'UUIBattleResultMenuWindowMagic::ImageBg' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowMagic, ImageBgFootter) == 0x0000C8, "Member 'UUIBattleResultMenuWindowMagic::ImageBgFootter' has a wrong offset!");

// Class Nicola.UIBattleResultMenuWindowParamBase
// 0x0078 (0x00E8 - 0x0070)
class UUIBattleResultMenuWindowParamBase : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x00A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFlipbookWidget*                        ItemFlipbook;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageIcon;                                         // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageLvArrow;                                      // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextName;                                          // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextLvBefore;                                      // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextLvAfter;                                       // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenuWindowParamBase">();
	}
	static class UUIBattleResultMenuWindowParamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenuWindowParamBase>();
	}
};
static_assert(alignof(UUIBattleResultMenuWindowParamBase) == 0x000008, "Wrong alignment on UUIBattleResultMenuWindowParamBase");
static_assert(sizeof(UUIBattleResultMenuWindowParamBase) == 0x0000E8, "Wrong size on UUIBattleResultMenuWindowParamBase");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, WindowItems) == 0x0000A8, "Member 'UUIBattleResultMenuWindowParamBase::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, ItemFlipbook) == 0x0000B8, "Member 'UUIBattleResultMenuWindowParamBase::ItemFlipbook' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, ImageIcon) == 0x0000C0, "Member 'UUIBattleResultMenuWindowParamBase::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, ImageLvArrow) == 0x0000C8, "Member 'UUIBattleResultMenuWindowParamBase::ImageLvArrow' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, TextName) == 0x0000D0, "Member 'UUIBattleResultMenuWindowParamBase::TextName' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, TextLvBefore) == 0x0000D8, "Member 'UUIBattleResultMenuWindowParamBase::TextLvBefore' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowParamBase, TextLvAfter) == 0x0000E0, "Member 'UUIBattleResultMenuWindowParamBase::TextLvAfter' has a wrong offset!");

// Class Nicola.UIBattleResultMenuWindowParam
// 0x0008 (0x00F0 - 0x00E8)
class UUIBattleResultMenuWindowParam final : public UUIBattleResultMenuWindowParamBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenuWindowParam">();
	}
	static class UUIBattleResultMenuWindowParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenuWindowParam>();
	}
};
static_assert(alignof(UUIBattleResultMenuWindowParam) == 0x000008, "Wrong alignment on UUIBattleResultMenuWindowParam");
static_assert(sizeof(UUIBattleResultMenuWindowParam) == 0x0000F0, "Wrong size on UUIBattleResultMenuWindowParam");

// Class Nicola.UIBattleResultMenuWindowItemParam
// 0x0020 (0x0060 - 0x0040)
class UUIBattleResultMenuWindowItemParam final : public UUIWindowItem
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem4;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleResultMenuWindowItemParam">();
	}
	static class UUIBattleResultMenuWindowItemParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleResultMenuWindowItemParam>();
	}
};
static_assert(alignof(UUIBattleResultMenuWindowItemParam) == 0x000008, "Wrong alignment on UUIBattleResultMenuWindowItemParam");
static_assert(sizeof(UUIBattleResultMenuWindowItemParam) == 0x000060, "Wrong size on UUIBattleResultMenuWindowItemParam");
static_assert(offsetof(UUIBattleResultMenuWindowItemParam, ItemIcon) == 0x000040, "Member 'UUIBattleResultMenuWindowItemParam::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowItemParam, TextItem2) == 0x000048, "Member 'UUIBattleResultMenuWindowItemParam::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowItemParam, TextItem3) == 0x000050, "Member 'UUIBattleResultMenuWindowItemParam::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIBattleResultMenuWindowItemParam, TextItem4) == 0x000058, "Member 'UUIBattleResultMenuWindowItemParam::TextItem4' has a wrong offset!");

// Class Nicola.UIBattleRetryMenuListItemResume
// 0x0048 (0x00A0 - 0x0058)
class UUIBattleRetryMenuListItemResume final : public UUIListItem
{
public:
	class UGopTextBlock*                          TextName;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextLvLabel;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextLv;                                            // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextPlace;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextTimeLabel;                                     // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextTime;                                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextDateLabel;                                     // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextDate;                                          // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          TextEmpty;                                         // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleRetryMenuListItemResume">();
	}
	static class UUIBattleRetryMenuListItemResume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleRetryMenuListItemResume>();
	}
};
static_assert(alignof(UUIBattleRetryMenuListItemResume) == 0x000008, "Wrong alignment on UUIBattleRetryMenuListItemResume");
static_assert(sizeof(UUIBattleRetryMenuListItemResume) == 0x0000A0, "Wrong size on UUIBattleRetryMenuListItemResume");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextName) == 0x000058, "Member 'UUIBattleRetryMenuListItemResume::TextName' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextLvLabel) == 0x000060, "Member 'UUIBattleRetryMenuListItemResume::TextLvLabel' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextLv) == 0x000068, "Member 'UUIBattleRetryMenuListItemResume::TextLv' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextPlace) == 0x000070, "Member 'UUIBattleRetryMenuListItemResume::TextPlace' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextTimeLabel) == 0x000078, "Member 'UUIBattleRetryMenuListItemResume::TextTimeLabel' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextTime) == 0x000080, "Member 'UUIBattleRetryMenuListItemResume::TextTime' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextDateLabel) == 0x000088, "Member 'UUIBattleRetryMenuListItemResume::TextDateLabel' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextDate) == 0x000090, "Member 'UUIBattleRetryMenuListItemResume::TextDate' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuListItemResume, TextEmpty) == 0x000098, "Member 'UUIBattleRetryMenuListItemResume::TextEmpty' has a wrong offset!");

// Class Nicola.UIBattleRetryMenuListTop
// 0x0020 (0x00F0 - 0x00D0)
class UUIBattleRetryMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleRetryMenuListTop">();
	}
	static class UUIBattleRetryMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleRetryMenuListTop>();
	}
};
static_assert(alignof(UUIBattleRetryMenuListTop) == 0x000008, "Wrong alignment on UUIBattleRetryMenuListTop");
static_assert(sizeof(UUIBattleRetryMenuListTop) == 0x0000F0, "Wrong size on UUIBattleRetryMenuListTop");

// Class Nicola.UIBattleRetryMenuWindowLoad
// 0x0018 (0x0070 - 0x0058)
class UUIBattleRetryMenuWindowLoad final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextNoData;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListSaveDataItem*          ItemSaveData;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleRetryMenuListItemResume*       ItemResumeData;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleRetryMenuWindowLoad">();
	}
	static class UUIBattleRetryMenuWindowLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleRetryMenuWindowLoad>();
	}
};
static_assert(alignof(UUIBattleRetryMenuWindowLoad) == 0x000008, "Wrong alignment on UUIBattleRetryMenuWindowLoad");
static_assert(sizeof(UUIBattleRetryMenuWindowLoad) == 0x000070, "Wrong size on UUIBattleRetryMenuWindowLoad");
static_assert(offsetof(UUIBattleRetryMenuWindowLoad, TextNoData) == 0x000058, "Member 'UUIBattleRetryMenuWindowLoad::TextNoData' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowLoad, ItemSaveData) == 0x000060, "Member 'UUIBattleRetryMenuWindowLoad::ItemSaveData' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowLoad, ItemResumeData) == 0x000068, "Member 'UUIBattleRetryMenuWindowLoad::ItemResumeData' has a wrong offset!");

// Class Nicola.UIBattleRetryMenuWindowResume
// 0x0018 (0x0070 - 0x0058)
class UUIBattleRetryMenuWindowResume final : public UUIWindowBase
{
public:
	class UUIWindowItemText2*                     ItemLocation;                                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleRetryMenuWindowItemMoney*      ItemMoney;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemMoneyAfter;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleRetryMenuWindowResume">();
	}
	static class UUIBattleRetryMenuWindowResume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleRetryMenuWindowResume>();
	}
};
static_assert(alignof(UUIBattleRetryMenuWindowResume) == 0x000008, "Wrong alignment on UUIBattleRetryMenuWindowResume");
static_assert(sizeof(UUIBattleRetryMenuWindowResume) == 0x000070, "Wrong size on UUIBattleRetryMenuWindowResume");
static_assert(offsetof(UUIBattleRetryMenuWindowResume, ItemLocation) == 0x000058, "Member 'UUIBattleRetryMenuWindowResume::ItemLocation' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowResume, ItemMoney) == 0x000060, "Member 'UUIBattleRetryMenuWindowResume::ItemMoney' has a wrong offset!");
static_assert(offsetof(UUIBattleRetryMenuWindowResume, ItemMoneyAfter) == 0x000068, "Member 'UUIBattleRetryMenuWindowResume::ItemMoneyAfter' has a wrong offset!");

// Class Nicola.UIMBRBuddyInfo
// 0x00A0 (0x00C8 - 0x0028)
class UUIMBRBuddyInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IndiNames;                                         // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x28];                                      // 0x0088(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIMBRMagicInfo>                Magics;                                            // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBuddyInfo">();
	}
	static class UUIMBRBuddyInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBuddyInfo>();
	}
};
static_assert(alignof(UUIMBRBuddyInfo) == 0x000008, "Wrong alignment on UUIMBRBuddyInfo");
static_assert(sizeof(UUIMBRBuddyInfo) == 0x0000C8, "Wrong size on UUIMBRBuddyInfo");
static_assert(offsetof(UUIMBRBuddyInfo, IndiNames) == 0x000078, "Member 'UUIMBRBuddyInfo::IndiNames' has a wrong offset!");
static_assert(offsetof(UUIMBRBuddyInfo, Magics) == 0x0000B0, "Member 'UUIMBRBuddyInfo::Magics' has a wrong offset!");

// Class Nicola.UIBattleSpeedController
// 0x0030 (0x00A0 - 0x0070)
class UUIBattleSpeedController final : public UUICtrlBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem2;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonL;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonR;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleSpeedController">();
	}
	static class UUIBattleSpeedController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleSpeedController>();
	}
};
static_assert(alignof(UUIBattleSpeedController) == 0x000008, "Wrong alignment on UUIBattleSpeedController");
static_assert(sizeof(UUIBattleSpeedController) == 0x0000A0, "Wrong size on UUIBattleSpeedController");
static_assert(offsetof(UUIBattleSpeedController, TextItem) == 0x000070, "Member 'UUIBattleSpeedController::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBattleSpeedController, TextItem2) == 0x000078, "Member 'UUIBattleSpeedController::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIBattleSpeedController, ImageButtonL) == 0x000080, "Member 'UUIBattleSpeedController::ImageButtonL' has a wrong offset!");
static_assert(offsetof(UUIBattleSpeedController, ImageButtonR) == 0x000088, "Member 'UUIBattleSpeedController::ImageButtonR' has a wrong offset!");

// Class Nicola.UIBattleStatusIcon
// 0x0010 (0x0068 - 0x0058)
class UUIBattleStatusIcon final : public UUIWindowBase
{
public:
	TArray<class UUIBattleStatusIconPanel*>       WindowPanels;                                      // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleStatusIcon">();
	}
	static class UUIBattleStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleStatusIcon>();
	}
};
static_assert(alignof(UUIBattleStatusIcon) == 0x000008, "Wrong alignment on UUIBattleStatusIcon");
static_assert(sizeof(UUIBattleStatusIcon) == 0x000068, "Wrong size on UUIBattleStatusIcon");
static_assert(offsetof(UUIBattleStatusIcon, WindowPanels) == 0x000058, "Member 'UUIBattleStatusIcon::WindowPanels' has a wrong offset!");

// Class Nicola.UIBattleStatusIconCtrl
// 0x0020 (0x0090 - 0x0070)
class UUIBattleStatusIconCtrl final : public UUICtrlBase
{
public:
	TArray<class UUIBattleStatusIcon*>            StatusIcons;                                       // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleStatusIconCtrl">();
	}
	static class UUIBattleStatusIconCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleStatusIconCtrl>();
	}
};
static_assert(alignof(UUIBattleStatusIconCtrl) == 0x000008, "Wrong alignment on UUIBattleStatusIconCtrl");
static_assert(sizeof(UUIBattleStatusIconCtrl) == 0x000090, "Wrong size on UUIBattleStatusIconCtrl");
static_assert(offsetof(UUIBattleStatusIconCtrl, StatusIcons) == 0x000070, "Member 'UUIBattleStatusIconCtrl::StatusIcons' has a wrong offset!");

// Class Nicola.UIWindowItemIcon
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemIcon : public UUIWindowItem
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemIcon">();
	}
	static class UUIWindowItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemIcon>();
	}
};
static_assert(alignof(UUIWindowItemIcon) == 0x000008, "Wrong alignment on UUIWindowItemIcon");
static_assert(sizeof(UUIWindowItemIcon) == 0x000048, "Wrong size on UUIWindowItemIcon");
static_assert(offsetof(UUIWindowItemIcon, ItemIcon) == 0x000040, "Member 'UUIWindowItemIcon::ItemIcon' has a wrong offset!");

// Class Nicola.UIBattleStatusIconItem
// 0x0008 (0x0050 - 0x0048)
class UUIBattleStatusIconItem final : public UUIWindowItemIcon
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleStatusIconItem">();
	}
	static class UUIBattleStatusIconItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleStatusIconItem>();
	}
};
static_assert(alignof(UUIBattleStatusIconItem) == 0x000008, "Wrong alignment on UUIBattleStatusIconItem");
static_assert(sizeof(UUIBattleStatusIconItem) == 0x000050, "Wrong size on UUIBattleStatusIconItem");

// Class Nicola.UIBattleTacticsListTactics
// 0x0008 (0x00D8 - 0x00D0)
class UUIBattleTacticsListTactics final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTacticsListTactics">();
	}
	static class UUIBattleTacticsListTactics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTacticsListTactics>();
	}
};
static_assert(alignof(UUIBattleTacticsListTactics) == 0x000008, "Wrong alignment on UUIBattleTacticsListTactics");
static_assert(sizeof(UUIBattleTacticsListTactics) == 0x0000D8, "Wrong size on UUIBattleTacticsListTactics");

// Class Nicola.UIBattleTacticsListUnit
// 0x0010 (0x00E0 - 0x00D0)
class UUIBattleTacticsListUnit final : public UUIListPage
{
public:
	class UGopTextBlock*                          TextGuide;                                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTacticsListUnit">();
	}
	static class UUIBattleTacticsListUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTacticsListUnit>();
	}
};
static_assert(alignof(UUIBattleTacticsListUnit) == 0x000008, "Wrong alignment on UUIBattleTacticsListUnit");
static_assert(sizeof(UUIBattleTacticsListUnit) == 0x0000E0, "Wrong size on UUIBattleTacticsListUnit");
static_assert(offsetof(UUIBattleTacticsListUnit, TextGuide) == 0x0000D0, "Member 'UUIBattleTacticsListUnit::TextGuide' has a wrong offset!");

// Class Nicola.UIBattleTopMenu
// 0x0040 (0x00B8 - 0x0078)
class UUIBattleTopMenu final : public UUIRootBase
{
public:
	class UUIBattleTopMenuListTop*                ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleTopMenuWindowShortcut*         WindowShortcut;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleTacticsListUnit*               TacticsListUnit;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleTacticsListTactics*            TacticsListTactics;                                // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleTacticsWindowTactics*          TacticsWindowTactics;                              // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleHideController*                HideController;                                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuWindowNotice*          WindowNotice;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTopMenu">();
	}
	static class UUIBattleTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTopMenu>();
	}
};
static_assert(alignof(UUIBattleTopMenu) == 0x000008, "Wrong alignment on UUIBattleTopMenu");
static_assert(sizeof(UUIBattleTopMenu) == 0x0000B8, "Wrong size on UUIBattleTopMenu");
static_assert(offsetof(UUIBattleTopMenu, ListTop) == 0x000078, "Member 'UUIBattleTopMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenu, WindowShortcut) == 0x000080, "Member 'UUIBattleTopMenu::WindowShortcut' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenu, TacticsListUnit) == 0x000088, "Member 'UUIBattleTopMenu::TacticsListUnit' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenu, TacticsListTactics) == 0x000090, "Member 'UUIBattleTopMenu::TacticsListTactics' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenu, TacticsWindowTactics) == 0x000098, "Member 'UUIBattleTopMenu::TacticsWindowTactics' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenu, HideController) == 0x0000A0, "Member 'UUIBattleTopMenu::HideController' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenu, WindowNotice) == 0x0000A8, "Member 'UUIBattleTopMenu::WindowNotice' has a wrong offset!");

// Class Nicola.UIBattleTopMenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUIBattleTopMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTopMenuListTop">();
	}
	static class UUIBattleTopMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTopMenuListTop>();
	}
};
static_assert(alignof(UUIBattleTopMenuListTop) == 0x000008, "Wrong alignment on UUIBattleTopMenuListTop");
static_assert(sizeof(UUIBattleTopMenuListTop) == 0x0000E8, "Wrong size on UUIBattleTopMenuListTop");

// Class Nicola.UIBattleTopMenuWindowShortcut
// 0x0020 (0x0078 - 0x0058)
class UUIBattleTopMenuWindowShortcut final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonLongPress*           ItemButton;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleTopMenuWindowShortcut">();
	}
	static class UUIBattleTopMenuWindowShortcut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleTopMenuWindowShortcut>();
	}
};
static_assert(alignof(UUIBattleTopMenuWindowShortcut) == 0x000008, "Wrong alignment on UUIBattleTopMenuWindowShortcut");
static_assert(sizeof(UUIBattleTopMenuWindowShortcut) == 0x000078, "Wrong size on UUIBattleTopMenuWindowShortcut");
static_assert(offsetof(UUIBattleTopMenuWindowShortcut, TextItem) == 0x000058, "Member 'UUIBattleTopMenuWindowShortcut::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenuWindowShortcut, TextItem2) == 0x000060, "Member 'UUIBattleTopMenuWindowShortcut::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIBattleTopMenuWindowShortcut, ItemButton) == 0x000068, "Member 'UUIBattleTopMenuWindowShortcut::ItemButton' has a wrong offset!");

// Class Nicola.UIBattleUnitMenu
// 0x0058 (0x00D0 - 0x0078)
class UUIBattleUnitMenu final : public UUIRootBase
{
public:
	class UUIBattleUnitMenuListUnit*              ListUnit;                                          // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuListMagic*             ListMagic;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuListItem*              ListItem;                                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuListEquip*             ListEquip;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuListEquipSlot*         ListEquipSlot;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuListTargetEnemy*       ListTargetEM;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuListTargetPlayer*      ListTargetPL;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuWindowMagic*           WindowMagic;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuWindowItem2*           WindowItem;                                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleUnitMenuWindowNotice*          WindowNotice;                                      // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenu">();
	}
	static class UUIBattleUnitMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenu>();
	}
};
static_assert(alignof(UUIBattleUnitMenu) == 0x000008, "Wrong alignment on UUIBattleUnitMenu");
static_assert(sizeof(UUIBattleUnitMenu) == 0x0000D0, "Wrong size on UUIBattleUnitMenu");
static_assert(offsetof(UUIBattleUnitMenu, ListUnit) == 0x000078, "Member 'UUIBattleUnitMenu::ListUnit' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, ListMagic) == 0x000080, "Member 'UUIBattleUnitMenu::ListMagic' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, ListItem) == 0x000088, "Member 'UUIBattleUnitMenu::ListItem' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, ListEquip) == 0x000090, "Member 'UUIBattleUnitMenu::ListEquip' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, ListEquipSlot) == 0x000098, "Member 'UUIBattleUnitMenu::ListEquipSlot' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, ListTargetEM) == 0x0000A0, "Member 'UUIBattleUnitMenu::ListTargetEM' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, ListTargetPL) == 0x0000A8, "Member 'UUIBattleUnitMenu::ListTargetPL' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, WindowMagic) == 0x0000B0, "Member 'UUIBattleUnitMenu::WindowMagic' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, WindowItem) == 0x0000B8, "Member 'UUIBattleUnitMenu::WindowItem' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenu, WindowNotice) == 0x0000C0, "Member 'UUIBattleUnitMenu::WindowNotice' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuListEquip
// 0x0008 (0x00F0 - 0x00E8)
class UUIBattleUnitMenuListEquip final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListEquip">();
	}
	static class UUIBattleUnitMenuListEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListEquip>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListEquip) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListEquip");
static_assert(sizeof(UUIBattleUnitMenuListEquip) == 0x0000F0, "Wrong size on UUIBattleUnitMenuListEquip");

// Class Nicola.UIBattleUnitMenuListEquipSlot
// 0x0010 (0x00E0 - 0x00D0)
class UUIBattleUnitMenuListEquipSlot final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListEquipSlot">();
	}
	static class UUIBattleUnitMenuListEquipSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListEquipSlot>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListEquipSlot) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListEquipSlot");
static_assert(sizeof(UUIBattleUnitMenuListEquipSlot) == 0x0000E0, "Wrong size on UUIBattleUnitMenuListEquipSlot");

// Class Nicola.UIBattleUnitMenuListMagic
// 0x0018 (0x0100 - 0x00E8)
class UUIBattleUnitMenuListMagic final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListMagic">();
	}
	static class UUIBattleUnitMenuListMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListMagic>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListMagic) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListMagic");
static_assert(sizeof(UUIBattleUnitMenuListMagic) == 0x000100, "Wrong size on UUIBattleUnitMenuListMagic");

// Class Nicola.UIBattleUnitMenuListTargetEnemy
// 0x0018 (0x00D8 - 0x00C0)
class UUIBattleUnitMenuListTargetEnemy final : public UUIListSimple
{
public:
	class UImage*                                 BGTitle;                                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBackgroundBlur*                        BlurTitle;                                         // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextTitle;                                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListTargetEnemy">();
	}
	static class UUIBattleUnitMenuListTargetEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListTargetEnemy>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListTargetEnemy) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListTargetEnemy");
static_assert(sizeof(UUIBattleUnitMenuListTargetEnemy) == 0x0000D8, "Wrong size on UUIBattleUnitMenuListTargetEnemy");
static_assert(offsetof(UUIBattleUnitMenuListTargetEnemy, BGTitle) == 0x0000C0, "Member 'UUIBattleUnitMenuListTargetEnemy::BGTitle' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetEnemy, BlurTitle) == 0x0000C8, "Member 'UUIBattleUnitMenuListTargetEnemy::BlurTitle' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetEnemy, TextTitle) == 0x0000D0, "Member 'UUIBattleUnitMenuListTargetEnemy::TextTitle' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuListTargetEnemyItem
// 0x0008 (0x0068 - 0x0060)
class UUIBattleUnitMenuListTargetEnemyItem final : public UUIListItemText2
{
public:
	class UImage*                                 ImageStatus;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListTargetEnemyItem">();
	}
	static class UUIBattleUnitMenuListTargetEnemyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListTargetEnemyItem>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListTargetEnemyItem) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListTargetEnemyItem");
static_assert(sizeof(UUIBattleUnitMenuListTargetEnemyItem) == 0x000068, "Wrong size on UUIBattleUnitMenuListTargetEnemyItem");
static_assert(offsetof(UUIBattleUnitMenuListTargetEnemyItem, ImageStatus) == 0x000060, "Member 'UUIBattleUnitMenuListTargetEnemyItem::ImageStatus' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuListTargetPlayer
// 0x0030 (0x00F0 - 0x00C0)
class UUIBattleUnitMenuListTargetPlayer final : public UUIListSimple
{
public:
	class UImage*                                 BGTitle;                                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBackgroundBlur*                        BlurTitle;                                         // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextTitle;                                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListTargetPlayer">();
	}
	static class UUIBattleUnitMenuListTargetPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListTargetPlayer>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListTargetPlayer) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListTargetPlayer");
static_assert(sizeof(UUIBattleUnitMenuListTargetPlayer) == 0x0000F0, "Wrong size on UUIBattleUnitMenuListTargetPlayer");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayer, BGTitle) == 0x0000C0, "Member 'UUIBattleUnitMenuListTargetPlayer::BGTitle' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayer, BlurTitle) == 0x0000C8, "Member 'UUIBattleUnitMenuListTargetPlayer::BlurTitle' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuListTargetPlayer, TextTitle) == 0x0000D0, "Member 'UUIBattleUnitMenuListTargetPlayer::TextTitle' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuListUnit
// 0x0018 (0x0100 - 0x00E8)
class UUIBattleUnitMenuListUnit final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuListUnit">();
	}
	static class UUIBattleUnitMenuListUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuListUnit>();
	}
};
static_assert(alignof(UUIBattleUnitMenuListUnit) == 0x000008, "Wrong alignment on UUIBattleUnitMenuListUnit");
static_assert(sizeof(UUIBattleUnitMenuListUnit) == 0x000100, "Wrong size on UUIBattleUnitMenuListUnit");

// Class Nicola.UIBattleUnitMenuWindowItem
// 0x0040 (0x0098 - 0x0058)
class UUIBattleUnitMenuWindowItem final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIBattleUnitMenuWindowItemItem*> WindowItems;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuWindowItem">();
	}
	static class UUIBattleUnitMenuWindowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuWindowItem>();
	}
};
static_assert(alignof(UUIBattleUnitMenuWindowItem) == 0x000008, "Wrong alignment on UUIBattleUnitMenuWindowItem");
static_assert(sizeof(UUIBattleUnitMenuWindowItem) == 0x000098, "Wrong size on UUIBattleUnitMenuWindowItem");
static_assert(offsetof(UUIBattleUnitMenuWindowItem, TextInfo) == 0x000058, "Member 'UUIBattleUnitMenuWindowItem::TextInfo' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuWindowItem, WindowItems) == 0x000060, "Member 'UUIBattleUnitMenuWindowItem::WindowItems' has a wrong offset!");

// Class Nicola.UISelectItemMenuWindowSub
// 0x0020 (0x0078 - 0x0058)
class UUISelectItemMenuWindowSub : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextFlavor;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemSelectItemWindowSub*         Item00;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemSelectItemWindowSub*         Item01;                                            // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemSelectItemWindowSub*         Item02;                                            // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenuWindowSub">();
	}
	static class UUISelectItemMenuWindowSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenuWindowSub>();
	}
};
static_assert(alignof(UUISelectItemMenuWindowSub) == 0x000008, "Wrong alignment on UUISelectItemMenuWindowSub");
static_assert(sizeof(UUISelectItemMenuWindowSub) == 0x000078, "Wrong size on UUISelectItemMenuWindowSub");
static_assert(offsetof(UUISelectItemMenuWindowSub, TextFlavor) == 0x000058, "Member 'UUISelectItemMenuWindowSub::TextFlavor' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenuWindowSub, Item00) == 0x000060, "Member 'UUISelectItemMenuWindowSub::Item00' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenuWindowSub, Item01) == 0x000068, "Member 'UUISelectItemMenuWindowSub::Item01' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenuWindowSub, Item02) == 0x000070, "Member 'UUISelectItemMenuWindowSub::Item02' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuWindowItem2
// 0x0000 (0x0078 - 0x0078)
class UUIBattleUnitMenuWindowItem2 final : public UUISelectItemMenuWindowSub
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuWindowItem2">();
	}
	static class UUIBattleUnitMenuWindowItem2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuWindowItem2>();
	}
};
static_assert(alignof(UUIBattleUnitMenuWindowItem2) == 0x000008, "Wrong alignment on UUIBattleUnitMenuWindowItem2");
static_assert(sizeof(UUIBattleUnitMenuWindowItem2) == 0x000078, "Wrong size on UUIBattleUnitMenuWindowItem2");

// Class Nicola.UIBattleUnitMenuWindowItemItem
// 0x0028 (0x0068 - 0x0040)
class UUIBattleUnitMenuWindowItemItem final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextValue1;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextValue2;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageEquip;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrow;                                        // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuWindowItemItem">();
	}
	static class UUIBattleUnitMenuWindowItemItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuWindowItemItem>();
	}
};
static_assert(alignof(UUIBattleUnitMenuWindowItemItem) == 0x000008, "Wrong alignment on UUIBattleUnitMenuWindowItemItem");
static_assert(sizeof(UUIBattleUnitMenuWindowItemItem) == 0x000068, "Wrong size on UUIBattleUnitMenuWindowItemItem");
static_assert(offsetof(UUIBattleUnitMenuWindowItemItem, TextValue1) == 0x000040, "Member 'UUIBattleUnitMenuWindowItemItem::TextValue1' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuWindowItemItem, TextValue2) == 0x000048, "Member 'UUIBattleUnitMenuWindowItemItem::TextValue2' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuWindowItemItem, TextSlash) == 0x000050, "Member 'UUIBattleUnitMenuWindowItemItem::TextSlash' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuWindowItemItem, ImageEquip) == 0x000058, "Member 'UUIBattleUnitMenuWindowItemItem::ImageEquip' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuWindowItemItem, ImageArrow) == 0x000060, "Member 'UUIBattleUnitMenuWindowItemItem::ImageArrow' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuWindowMagic
// 0x0010 (0x0068 - 0x0058)
class UUIBattleUnitMenuWindowMagic final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemText4*                     ItemMP;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuWindowMagic">();
	}
	static class UUIBattleUnitMenuWindowMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuWindowMagic>();
	}
};
static_assert(alignof(UUIBattleUnitMenuWindowMagic) == 0x000008, "Wrong alignment on UUIBattleUnitMenuWindowMagic");
static_assert(sizeof(UUIBattleUnitMenuWindowMagic) == 0x000068, "Wrong size on UUIBattleUnitMenuWindowMagic");
static_assert(offsetof(UUIBattleUnitMenuWindowMagic, TextInfo) == 0x000058, "Member 'UUIBattleUnitMenuWindowMagic::TextInfo' has a wrong offset!");
static_assert(offsetof(UUIBattleUnitMenuWindowMagic, ItemMP) == 0x000060, "Member 'UUIBattleUnitMenuWindowMagic::ItemMP' has a wrong offset!");

// Class Nicola.UIBattleUnitMenuWindowNotice
// 0x0008 (0x0078 - 0x0070)
class UUIBattleUnitMenuWindowNotice final : public UUICtrlBase
{
public:
	class UGopTextBlock*                          TextMessage;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleUnitMenuWindowNotice">();
	}
	static class UUIBattleUnitMenuWindowNotice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleUnitMenuWindowNotice>();
	}
};
static_assert(alignof(UUIBattleUnitMenuWindowNotice) == 0x000008, "Wrong alignment on UUIBattleUnitMenuWindowNotice");
static_assert(sizeof(UUIBattleUnitMenuWindowNotice) == 0x000078, "Wrong size on UUIBattleUnitMenuWindowNotice");
static_assert(offsetof(UUIBattleUnitMenuWindowNotice, TextMessage) == 0x000070, "Member 'UUIBattleUnitMenuWindowNotice::TextMessage' has a wrong offset!");

// Class Nicola.UIBattleWindowStatus1Player
// 0x0040 (0x0098 - 0x0058)
class UUIBattleWindowStatus1Player final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextHPValue;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageHP;                                           // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextMPValue;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMP;                                           // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleStatusIcon*                    StatusIcon;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 TargetBG;                                          // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleWindowStatus1Player">();
	}
	static class UUIBattleWindowStatus1Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleWindowStatus1Player>();
	}
};
static_assert(alignof(UUIBattleWindowStatus1Player) == 0x000008, "Wrong alignment on UUIBattleWindowStatus1Player");
static_assert(sizeof(UUIBattleWindowStatus1Player) == 0x000098, "Wrong size on UUIBattleWindowStatus1Player");
static_assert(offsetof(UUIBattleWindowStatus1Player, TextItem) == 0x000058, "Member 'UUIBattleWindowStatus1Player::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1Player, TextHPValue) == 0x000060, "Member 'UUIBattleWindowStatus1Player::TextHPValue' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1Player, ImageHP) == 0x000068, "Member 'UUIBattleWindowStatus1Player::ImageHP' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1Player, TextMPValue) == 0x000070, "Member 'UUIBattleWindowStatus1Player::TextMPValue' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1Player, ImageMP) == 0x000078, "Member 'UUIBattleWindowStatus1Player::ImageMP' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1Player, StatusIcon) == 0x000080, "Member 'UUIBattleWindowStatus1Player::StatusIcon' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus1Player, TargetBG) == 0x000088, "Member 'UUIBattleWindowStatus1Player::TargetBG' has a wrong offset!");

// Class Nicola.UIBattleWindowStatus2
// 0x0010 (0x0080 - 0x0070)
class UUIBattleWindowStatus2 final : public UUICtrlBase
{
public:
	TArray<class UUIBattleWindowStatus2Player*>   Players;                                           // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleWindowStatus2">();
	}
	static class UUIBattleWindowStatus2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleWindowStatus2>();
	}
};
static_assert(alignof(UUIBattleWindowStatus2) == 0x000008, "Wrong alignment on UUIBattleWindowStatus2");
static_assert(sizeof(UUIBattleWindowStatus2) == 0x000080, "Wrong size on UUIBattleWindowStatus2");
static_assert(offsetof(UUIBattleWindowStatus2, Players) == 0x000070, "Member 'UUIBattleWindowStatus2::Players' has a wrong offset!");

// Class Nicola.UIBattleWindowStatus2Player
// 0x0050 (0x00A8 - 0x0058)
class UUIBattleWindowStatus2Player final : public UUIWindowBase
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextHPValue;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageHP;                                           // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextMPValue;                                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMP;                                           // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCanvasPanelSlot*>               SlotDamages;                                       // 0x0088(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattleWindowStatus2Player">();
	}
	static class UUIBattleWindowStatus2Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBattleWindowStatus2Player>();
	}
};
static_assert(alignof(UUIBattleWindowStatus2Player) == 0x000008, "Wrong alignment on UUIBattleWindowStatus2Player");
static_assert(sizeof(UUIBattleWindowStatus2Player) == 0x0000A8, "Wrong size on UUIBattleWindowStatus2Player");
static_assert(offsetof(UUIBattleWindowStatus2Player, CanvasPanel) == 0x000058, "Member 'UUIBattleWindowStatus2Player::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus2Player, TextItem) == 0x000060, "Member 'UUIBattleWindowStatus2Player::TextItem' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus2Player, TextHPValue) == 0x000068, "Member 'UUIBattleWindowStatus2Player::TextHPValue' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus2Player, ImageHP) == 0x000070, "Member 'UUIBattleWindowStatus2Player::ImageHP' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus2Player, TextMPValue) == 0x000078, "Member 'UUIBattleWindowStatus2Player::TextMPValue' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus2Player, ImageMP) == 0x000080, "Member 'UUIBattleWindowStatus2Player::ImageMP' has a wrong offset!");
static_assert(offsetof(UUIBattleWindowStatus2Player, SlotDamages) == 0x000088, "Member 'UUIBattleWindowStatus2Player::SlotDamages' has a wrong offset!");

// Class Nicola.UIChurchMenuListItemPartyHeal
// 0x0010 (0x0068 - 0x0058)
class UUIChurchMenuListItemPartyHeal final : public UUIListItem
{
public:
	class UImage*                                 ImagePlayer;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFieldStatusEffectWidget*               StatusEffectWidget;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChurchMenuListItemPartyHeal">();
	}
	static class UUIChurchMenuListItemPartyHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChurchMenuListItemPartyHeal>();
	}
};
static_assert(alignof(UUIChurchMenuListItemPartyHeal) == 0x000008, "Wrong alignment on UUIChurchMenuListItemPartyHeal");
static_assert(sizeof(UUIChurchMenuListItemPartyHeal) == 0x000068, "Wrong size on UUIChurchMenuListItemPartyHeal");
static_assert(offsetof(UUIChurchMenuListItemPartyHeal, ImagePlayer) == 0x000058, "Member 'UUIChurchMenuListItemPartyHeal::ImagePlayer' has a wrong offset!");
static_assert(offsetof(UUIChurchMenuListItemPartyHeal, StatusEffectWidget) == 0x000060, "Member 'UUIChurchMenuListItemPartyHeal::StatusEffectWidget' has a wrong offset!");

// Class Nicola.UIChurchMenuListItemPartyRevive
// 0x0028 (0x0080 - 0x0058)
class UUIChurchMenuListItemPartyRevive final : public UUIListItem
{
public:
	class UImage*                                 ImagePlayer;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          HPText;                                            // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             CurrentHPValueText;                                // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             SlashText;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MaxHPValueText;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChurchMenuListItemPartyRevive">();
	}
	static class UUIChurchMenuListItemPartyRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChurchMenuListItemPartyRevive>();
	}
};
static_assert(alignof(UUIChurchMenuListItemPartyRevive) == 0x000008, "Wrong alignment on UUIChurchMenuListItemPartyRevive");
static_assert(sizeof(UUIChurchMenuListItemPartyRevive) == 0x000080, "Wrong size on UUIChurchMenuListItemPartyRevive");
static_assert(offsetof(UUIChurchMenuListItemPartyRevive, ImagePlayer) == 0x000058, "Member 'UUIChurchMenuListItemPartyRevive::ImagePlayer' has a wrong offset!");
static_assert(offsetof(UUIChurchMenuListItemPartyRevive, HPText) == 0x000060, "Member 'UUIChurchMenuListItemPartyRevive::HPText' has a wrong offset!");
static_assert(offsetof(UUIChurchMenuListItemPartyRevive, CurrentHPValueText) == 0x000068, "Member 'UUIChurchMenuListItemPartyRevive::CurrentHPValueText' has a wrong offset!");
static_assert(offsetof(UUIChurchMenuListItemPartyRevive, SlashText) == 0x000070, "Member 'UUIChurchMenuListItemPartyRevive::SlashText' has a wrong offset!");
static_assert(offsetof(UUIChurchMenuListItemPartyRevive, MaxHPValueText) == 0x000078, "Member 'UUIChurchMenuListItemPartyRevive::MaxHPValueText' has a wrong offset!");

// Class Nicola.UIChurchMenuListPartyHeal
// 0x0020 (0x00F0 - 0x00D0)
class UUIChurchMenuListPartyHeal final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChurchMenuListPartyHeal">();
	}
	static class UUIChurchMenuListPartyHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChurchMenuListPartyHeal>();
	}
};
static_assert(alignof(UUIChurchMenuListPartyHeal) == 0x000008, "Wrong alignment on UUIChurchMenuListPartyHeal");
static_assert(sizeof(UUIChurchMenuListPartyHeal) == 0x0000F0, "Wrong size on UUIChurchMenuListPartyHeal");

// Class Nicola.UIChurchMenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUIChurchMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChurchMenuListTop">();
	}
	static class UUIChurchMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChurchMenuListTop>();
	}
};
static_assert(alignof(UUIChurchMenuListTop) == 0x000008, "Wrong alignment on UUIChurchMenuListTop");
static_assert(sizeof(UUIChurchMenuListTop) == 0x0000E8, "Wrong size on UUIChurchMenuListTop");

// Class Nicola.UICommonMenuCheck
// 0x0018 (0x0090 - 0x0078)
class UUICommonMenuCheck final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool DEBUG_GetForceOpenFieldMenuFlag();
	static void DEBUG_SetForceOpenFieldMenuFlag(bool InFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonMenuCheck">();
	}
	static class UUICommonMenuCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonMenuCheck>();
	}
};
static_assert(alignof(UUICommonMenuCheck) == 0x000008, "Wrong alignment on UUICommonMenuCheck");
static_assert(sizeof(UUICommonMenuCheck) == 0x000090, "Wrong size on UUICommonMenuCheck");

// Class Nicola.UIDebugRichTextBlockMenu
// 0x0008 (0x0080 - 0x0078)
class UUIDebugRichTextBlockMenu final : public UUIRootBase
{
public:
	class UNicolaRichTextBlock*                   ItemText;                                          // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDebugRichTextBlockMenu">();
	}
	static class UUIDebugRichTextBlockMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDebugRichTextBlockMenu>();
	}
};
static_assert(alignof(UUIDebugRichTextBlockMenu) == 0x000008, "Wrong alignment on UUIDebugRichTextBlockMenu");
static_assert(sizeof(UUIDebugRichTextBlockMenu) == 0x000080, "Wrong size on UUIDebugRichTextBlockMenu");
static_assert(offsetof(UUIDebugRichTextBlockMenu, ItemText) == 0x000078, "Member 'UUIDebugRichTextBlockMenu::ItemText' has a wrong offset!");

// Class Nicola.UIDLCMenuListTop
// 0x0008 (0x00C8 - 0x00C0)
class UUIDLCMenuListTop final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDLCMenuListTop">();
	}
	static class UUIDLCMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDLCMenuListTop>();
	}
};
static_assert(alignof(UUIDLCMenuListTop) == 0x000008, "Wrong alignment on UUIDLCMenuListTop");
static_assert(sizeof(UUIDLCMenuListTop) == 0x0000C8, "Wrong size on UUIDLCMenuListTop");

// Class Nicola.UIDLCMenuWindowInfo
// 0x0018 (0x0070 - 0x0058)
class UUIDLCMenuWindowInfo final : public UUIWindowBase
{
public:
	TArray<class UUIDLCMenuWindowInfoItem*>       WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIWindowItemPage*                      ItemPage;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDLCMenuWindowInfo">();
	}
	static class UUIDLCMenuWindowInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDLCMenuWindowInfo>();
	}
};
static_assert(alignof(UUIDLCMenuWindowInfo) == 0x000008, "Wrong alignment on UUIDLCMenuWindowInfo");
static_assert(sizeof(UUIDLCMenuWindowInfo) == 0x000070, "Wrong size on UUIDLCMenuWindowInfo");
static_assert(offsetof(UUIDLCMenuWindowInfo, WindowItems) == 0x000058, "Member 'UUIDLCMenuWindowInfo::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIDLCMenuWindowInfo, ItemPage) == 0x000068, "Member 'UUIDLCMenuWindowInfo::ItemPage' has a wrong offset!");

// Class Nicola.UIEndingLogoMenu
// 0x0038 (0x00B0 - 0x0078)
class UUIEndingLogoMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemEndingLogo*                ItemLogo;                                          // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingLogoMenu">();
	}
	static class UUIEndingLogoMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingLogoMenu>();
	}
};
static_assert(alignof(UUIEndingLogoMenu) == 0x000008, "Wrong alignment on UUIEndingLogoMenu");
static_assert(sizeof(UUIEndingLogoMenu) == 0x0000B0, "Wrong size on UUIEndingLogoMenu");
static_assert(offsetof(UUIEndingLogoMenu, ItemLogo) == 0x0000A8, "Member 'UUIEndingLogoMenu::ItemLogo' has a wrong offset!");

// Class Nicola.UIEndingSaveMenu
// 0x0018 (0x0090 - 0x0078)
class UUIEndingSaveMenu final : public UUIRootBase
{
public:
	class UUIEndingSaveMenuListSave*              ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveGameDataFlow*                    SaveFlow;                                          // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingSaveMenu">();
	}
	static class UUIEndingSaveMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingSaveMenu>();
	}
};
static_assert(alignof(UUIEndingSaveMenu) == 0x000008, "Wrong alignment on UUIEndingSaveMenu");
static_assert(sizeof(UUIEndingSaveMenu) == 0x000090, "Wrong size on UUIEndingSaveMenu");
static_assert(offsetof(UUIEndingSaveMenu, ListTop) == 0x000078, "Member 'UUIEndingSaveMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIEndingSaveMenu, SaveFlow) == 0x000080, "Member 'UUIEndingSaveMenu::SaveFlow' has a wrong offset!");

// Class Nicola.UIEndingStaffRollMenu
// 0x0030 (0x00A8 - 0x0078)
class UUIEndingStaffRollMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIEndingStaffRollMenuScroll*           WindowScroll;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEndingStaffRollMenuImage*            WindowImage;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           PanelDebugParent;                                  // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemDebugInfo;                                     // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsDebugInfoVisible();
	static bool IsExecMenu();
	static void OpenMenu();
	static bool ToggleDebugInfoVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingStaffRollMenu">();
	}
	static class UUIEndingStaffRollMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingStaffRollMenu>();
	}
};
static_assert(alignof(UUIEndingStaffRollMenu) == 0x000008, "Wrong alignment on UUIEndingStaffRollMenu");
static_assert(sizeof(UUIEndingStaffRollMenu) == 0x0000A8, "Wrong size on UUIEndingStaffRollMenu");
static_assert(offsetof(UUIEndingStaffRollMenu, WindowScroll) == 0x000080, "Member 'UUIEndingStaffRollMenu::WindowScroll' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenu, WindowImage) == 0x000088, "Member 'UUIEndingStaffRollMenu::WindowImage' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenu, PanelDebugParent) == 0x000098, "Member 'UUIEndingStaffRollMenu::PanelDebugParent' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenu, ItemDebugInfo) == 0x0000A0, "Member 'UUIEndingStaffRollMenu::ItemDebugInfo' has a wrong offset!");

// Class Nicola.UIEndingStaffRollMenuImage
// 0x0080 (0x00D8 - 0x0058)
class UUIEndingStaffRollMenuImage final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIEndingStaffRollMenuImageRowData> RowDatas;                                          // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class UUIEndingStaffRollMenuItemImage*> ImageItems;                                        // 0x0088(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingStaffRollMenuImage">();
	}
	static class UUIEndingStaffRollMenuImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingStaffRollMenuImage>();
	}
};
static_assert(alignof(UUIEndingStaffRollMenuImage) == 0x000008, "Wrong alignment on UUIEndingStaffRollMenuImage");
static_assert(sizeof(UUIEndingStaffRollMenuImage) == 0x0000D8, "Wrong size on UUIEndingStaffRollMenuImage");
static_assert(offsetof(UUIEndingStaffRollMenuImage, RowDatas) == 0x000078, "Member 'UUIEndingStaffRollMenuImage::RowDatas' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuImage, ImageItems) == 0x000088, "Member 'UUIEndingStaffRollMenuImage::ImageItems' has a wrong offset!");

// Class Nicola.UIEndingStaffRollMenuItemImage
// 0x0028 (0x0068 - 0x0040)
class UUIEndingStaffRollMenuItemImage final : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemMovieImage*                ItemImage;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIWindowItemMovieImage*                ItemImage2;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingStaffRollMenuItemImage">();
	}
	static class UUIEndingStaffRollMenuItemImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingStaffRollMenuItemImage>();
	}
};
static_assert(alignof(UUIEndingStaffRollMenuItemImage) == 0x000008, "Wrong alignment on UUIEndingStaffRollMenuItemImage");
static_assert(sizeof(UUIEndingStaffRollMenuItemImage) == 0x000068, "Wrong size on UUIEndingStaffRollMenuItemImage");
static_assert(offsetof(UUIEndingStaffRollMenuItemImage, ItemImage) == 0x000058, "Member 'UUIEndingStaffRollMenuItemImage::ItemImage' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuItemImage, ItemImage2) == 0x000060, "Member 'UUIEndingStaffRollMenuItemImage::ItemImage2' has a wrong offset!");

// Class Nicola.UIEndingStaffRollMenuScroll
// 0x0088 (0x00E0 - 0x0058)
class UUIEndingStaffRollMenuScroll final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIEndingStaffRollMenuRowData>  RowDatas;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           RowImageDatas;                                     // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ScrollArea;                                        // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIWindowItem*>                  RowItem;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUIWindowItem*>                  CandiateRowItem;                                   // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEndingStaffRollMenuScroll">();
	}
	static class UUIEndingStaffRollMenuScroll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEndingStaffRollMenuScroll>();
	}
};
static_assert(alignof(UUIEndingStaffRollMenuScroll) == 0x000008, "Wrong alignment on UUIEndingStaffRollMenuScroll");
static_assert(sizeof(UUIEndingStaffRollMenuScroll) == 0x0000E0, "Wrong size on UUIEndingStaffRollMenuScroll");
static_assert(offsetof(UUIEndingStaffRollMenuScroll, RowDatas) == 0x000098, "Member 'UUIEndingStaffRollMenuScroll::RowDatas' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuScroll, RowImageDatas) == 0x0000A8, "Member 'UUIEndingStaffRollMenuScroll::RowImageDatas' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuScroll, ScrollArea) == 0x0000B8, "Member 'UUIEndingStaffRollMenuScroll::ScrollArea' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuScroll, RowItem) == 0x0000C0, "Member 'UUIEndingStaffRollMenuScroll::RowItem' has a wrong offset!");
static_assert(offsetof(UUIEndingStaffRollMenuScroll, CandiateRowItem) == 0x0000D0, "Member 'UUIEndingStaffRollMenuScroll::CandiateRowItem' has a wrong offset!");

// Class Nicola.UIEventMovieControl
// 0x0058 (0x00D0 - 0x0078)
class UUIEventMovieControl final : public UUIRootBase
{
public:
	class UCommonItemWidget*                      EventControlUI;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem;                                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem2;                                         // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonLongPress*           ItemButton;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               IconSpeedUp;                                       // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               IconPlayBack;                                      // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BPPlayEventControlUI(bool bIsSkip);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventMovieControl">();
	}
	static class UUIEventMovieControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventMovieControl>();
	}
};
static_assert(alignof(UUIEventMovieControl) == 0x000008, "Wrong alignment on UUIEventMovieControl");
static_assert(sizeof(UUIEventMovieControl) == 0x0000D0, "Wrong size on UUIEventMovieControl");
static_assert(offsetof(UUIEventMovieControl, EventControlUI) == 0x000078, "Member 'UUIEventMovieControl::EventControlUI' has a wrong offset!");
static_assert(offsetof(UUIEventMovieControl, TextItem) == 0x000080, "Member 'UUIEventMovieControl::TextItem' has a wrong offset!");
static_assert(offsetof(UUIEventMovieControl, TextItem2) == 0x000088, "Member 'UUIEventMovieControl::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIEventMovieControl, ItemButton) == 0x000090, "Member 'UUIEventMovieControl::ItemButton' has a wrong offset!");
static_assert(offsetof(UUIEventMovieControl, IconSpeedUp) == 0x000098, "Member 'UUIEventMovieControl::IconSpeedUp' has a wrong offset!");
static_assert(offsetof(UUIEventMovieControl, IconPlayBack) == 0x0000A0, "Member 'UUIEventMovieControl::IconPlayBack' has a wrong offset!");

// Class Nicola.UIEventScreenShotMenu
// 0x0038 (0x00B0 - 0x0078)
class UUIEventScreenShotMenu final : public UUIRootBase
{
public:
	class UUIWindowItemIcon*                      WindowScreenShot;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUILoadableTexture                     LoadableTextureMain;                               // 0x0080(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FUILoadableTexture>             LoadableTexturePreload;                            // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventScreenShotMenu">();
	}
	static class UUIEventScreenShotMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventScreenShotMenu>();
	}
};
static_assert(alignof(UUIEventScreenShotMenu) == 0x000008, "Wrong alignment on UUIEventScreenShotMenu");
static_assert(sizeof(UUIEventScreenShotMenu) == 0x0000B0, "Wrong size on UUIEventScreenShotMenu");
static_assert(offsetof(UUIEventScreenShotMenu, WindowScreenShot) == 0x000078, "Member 'UUIEventScreenShotMenu::WindowScreenShot' has a wrong offset!");
static_assert(offsetof(UUIEventScreenShotMenu, LoadableTextureMain) == 0x000080, "Member 'UUIEventScreenShotMenu::LoadableTextureMain' has a wrong offset!");
static_assert(offsetof(UUIEventScreenShotMenu, LoadableTexturePreload) == 0x000098, "Member 'UUIEventScreenShotMenu::LoadableTexturePreload' has a wrong offset!");

// Class Nicola.UIFieldEfxMenu
// 0x0028 (0x00A0 - 0x0078)
class UUIFieldEfxMenu final : public UUIRootBase
{
public:
	class UUIFieldEfxMenuWindowManpu*             WindowManpu;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEfxMenuWindowGuide*             WindowGuide;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DEBUG_ManpuAddItemId();
	static void DEBUG_ManpuPlayIn();
	static void DEBUG_ManpuPlayOut();
	static void DEBUG_ManpuSetPosition();
	static void GuideForceOut();
	static void GuideHide();
	static bool GuideIsPlaying(int32 InHandle);
	static void GuidePlayDecide(int32 InHandle);
	static int32 GuidePlayIn(class FName InName, const struct FVector2D& InPos);
	static void GuidePlayOut(int32 InHandle);
	static bool GuideSetPosition(int32 InHandle, const struct FVector2D& InPos);
	static void GuideShow();
	static void ManpuHide();
	static bool ManpuIsPlaying(int32 InHandle);
	static int32 ManpuPlayIn(class FName InName, const struct FVector2D& InPos);
	static void ManpuPlayOut(int32 InHandle);
	static bool ManpuSetPosition(int32 InHandle, const struct FVector2D& InPos);
	static bool ManpuSetScale(int32 InHandle, float InScale);
	static void ManpuShow();
	static void RetryGuidePlayIn();
	static void RetryGuidePlayOut();
	static void VehicleGuidePlayIn();
	static void VehicleGuidePlayOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenu">();
	}
	static class UUIFieldEfxMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenu>();
	}
};
static_assert(alignof(UUIFieldEfxMenu) == 0x000008, "Wrong alignment on UUIFieldEfxMenu");
static_assert(sizeof(UUIFieldEfxMenu) == 0x0000A0, "Wrong size on UUIFieldEfxMenu");
static_assert(offsetof(UUIFieldEfxMenu, WindowManpu) == 0x000078, "Member 'UUIFieldEfxMenu::WindowManpu' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenu, WindowGuide) == 0x000080, "Member 'UUIFieldEfxMenu::WindowGuide' has a wrong offset!");

// Class Nicola.UIFieldEfxMenuWindowGuide
// 0x0028 (0x0098 - 0x0070)
class UUIFieldEfxMenuWindowGuide final : public UUICtrlBase
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIFieldEfxMenuWindowGuideViewItem*> ViewItems;                                         // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIFieldEfxMenuWindowVehicleGuide*      VehicleGuide;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowGuide">();
	}
	static class UUIFieldEfxMenuWindowGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowGuide>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowGuide) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowGuide");
static_assert(sizeof(UUIFieldEfxMenuWindowGuide) == 0x000098, "Wrong size on UUIFieldEfxMenuWindowGuide");
static_assert(offsetof(UUIFieldEfxMenuWindowGuide, CanvasPanel) == 0x000070, "Member 'UUIFieldEfxMenuWindowGuide::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuide, ViewItems) == 0x000078, "Member 'UUIFieldEfxMenuWindowGuide::ViewItems' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuide, VehicleGuide) == 0x000088, "Member 'UUIFieldEfxMenuWindowGuide::VehicleGuide' has a wrong offset!");

// Class Nicola.UIFieldEfxMenuWindowGuidePlayItem
// 0x0050 (0x0078 - 0x0028)
class UUIFieldEfxMenuWindowGuidePlayItem final : public UObject
{
public:
	class UCommonItemWidget*                      View;                                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemButtonIcon*                ItemCursor;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Button;                                            // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Button2;                                           // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem;                                          // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       Slot;                                              // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowGuidePlayItem">();
	}
	static class UUIFieldEfxMenuWindowGuidePlayItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowGuidePlayItem>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowGuidePlayItem) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowGuidePlayItem");
static_assert(sizeof(UUIFieldEfxMenuWindowGuidePlayItem) == 0x000078, "Wrong size on UUIFieldEfxMenuWindowGuidePlayItem");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, View) == 0x000028, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::View' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, ItemCursor) == 0x000038, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::ItemCursor' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, Button) == 0x000040, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::Button' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, Button2) == 0x000048, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::Button2' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, TextItem) == 0x000050, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::TextItem' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, TextItem2) == 0x000058, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, TextItem3) == 0x000060, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuidePlayItem, Slot) == 0x000070, "Member 'UUIFieldEfxMenuWindowGuidePlayItem::Slot' has a wrong offset!");

// Class Nicola.UIFieldEfxMenuWindowGuideViewItem
// 0x0020 (0x0048 - 0x0028)
class UUIFieldEfxMenuWindowGuideViewItem final : public UObject
{
public:
	class UCommonItemWidget*                      View;                                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIFieldEfxMenuWindowGuidePlayItem*> PlayItems;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowGuideViewItem">();
	}
	static class UUIFieldEfxMenuWindowGuideViewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowGuideViewItem>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowGuideViewItem) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowGuideViewItem");
static_assert(sizeof(UUIFieldEfxMenuWindowGuideViewItem) == 0x000048, "Wrong size on UUIFieldEfxMenuWindowGuideViewItem");
static_assert(offsetof(UUIFieldEfxMenuWindowGuideViewItem, View) == 0x000028, "Member 'UUIFieldEfxMenuWindowGuideViewItem::View' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowGuideViewItem, PlayItems) == 0x000038, "Member 'UUIFieldEfxMenuWindowGuideViewItem::PlayItems' has a wrong offset!");

// Class Nicola.UIFieldEfxMenuWindowManpu
// 0x0020 (0x0090 - 0x0070)
class UUIFieldEfxMenuWindowManpu final : public UUICtrlBase
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIFieldEfxMenuWindowManpuViewItem*> ViewItems;                                         // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowManpu">();
	}
	static class UUIFieldEfxMenuWindowManpu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowManpu>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowManpu) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowManpu");
static_assert(sizeof(UUIFieldEfxMenuWindowManpu) == 0x000090, "Wrong size on UUIFieldEfxMenuWindowManpu");
static_assert(offsetof(UUIFieldEfxMenuWindowManpu, CanvasPanel) == 0x000070, "Member 'UUIFieldEfxMenuWindowManpu::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowManpu, ViewItems) == 0x000078, "Member 'UUIFieldEfxMenuWindowManpu::ViewItems' has a wrong offset!");

// Class Nicola.UIFieldEfxMenuWindowManpuPlayItem
// 0x0030 (0x0058 - 0x0028)
class UUIFieldEfxMenuWindowManpuPlayItem final : public UObject
{
public:
	class UCommonItemWidget*                      View;                                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanelSlot*                       Slot;                                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               Overlay;                                           // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowManpuPlayItem">();
	}
	static class UUIFieldEfxMenuWindowManpuPlayItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowManpuPlayItem>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowManpuPlayItem) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowManpuPlayItem");
static_assert(sizeof(UUIFieldEfxMenuWindowManpuPlayItem) == 0x000058, "Wrong size on UUIFieldEfxMenuWindowManpuPlayItem");
static_assert(offsetof(UUIFieldEfxMenuWindowManpuPlayItem, View) == 0x000028, "Member 'UUIFieldEfxMenuWindowManpuPlayItem::View' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowManpuPlayItem, Slot) == 0x000040, "Member 'UUIFieldEfxMenuWindowManpuPlayItem::Slot' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowManpuPlayItem, Overlay) == 0x000048, "Member 'UUIFieldEfxMenuWindowManpuPlayItem::Overlay' has a wrong offset!");

// Class Nicola.UIFieldEfxMenuWindowManpuViewItem
// 0x0020 (0x0048 - 0x0028)
class UUIFieldEfxMenuWindowManpuViewItem final : public UObject
{
public:
	class UCommonItemWidget*                      View;                                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIFieldEfxMenuWindowManpuPlayItem*> PlayItems;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEfxMenuWindowManpuViewItem">();
	}
	static class UUIFieldEfxMenuWindowManpuViewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEfxMenuWindowManpuViewItem>();
	}
};
static_assert(alignof(UUIFieldEfxMenuWindowManpuViewItem) == 0x000008, "Wrong alignment on UUIFieldEfxMenuWindowManpuViewItem");
static_assert(sizeof(UUIFieldEfxMenuWindowManpuViewItem) == 0x000048, "Wrong size on UUIFieldEfxMenuWindowManpuViewItem");
static_assert(offsetof(UUIFieldEfxMenuWindowManpuViewItem, View) == 0x000028, "Member 'UUIFieldEfxMenuWindowManpuViewItem::View' has a wrong offset!");
static_assert(offsetof(UUIFieldEfxMenuWindowManpuViewItem, PlayItems) == 0x000038, "Member 'UUIFieldEfxMenuWindowManpuViewItem::PlayItems' has a wrong offset!");

// Class Nicola.UIFieldEquipMenu
// 0x0030 (0x00A8 - 0x0078)
class UUIFieldEquipMenu final : public UUIRootBase
{
public:
	class UUIFieldEquipMenuListTop*               ListParty;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuListEquipSlot*         ListEquipment;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuListEquipSlot*         InfoEquipment;                                     // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuListInventory*         ListEquipItem;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowBase*                          InfoItem;                                          // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSub*             InfoItem2;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenu">();
	}
	static class UUIFieldEquipMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenu>();
	}
};
static_assert(alignof(UUIFieldEquipMenu) == 0x000008, "Wrong alignment on UUIFieldEquipMenu");
static_assert(sizeof(UUIFieldEquipMenu) == 0x0000A8, "Wrong size on UUIFieldEquipMenu");
static_assert(offsetof(UUIFieldEquipMenu, ListParty) == 0x000078, "Member 'UUIFieldEquipMenu::ListParty' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenu, ListEquipment) == 0x000080, "Member 'UUIFieldEquipMenu::ListEquipment' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenu, InfoEquipment) == 0x000088, "Member 'UUIFieldEquipMenu::InfoEquipment' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenu, ListEquipItem) == 0x000090, "Member 'UUIFieldEquipMenu::ListEquipItem' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenu, InfoItem) == 0x000098, "Member 'UUIFieldEquipMenu::InfoItem' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenu, InfoItem2) == 0x0000A0, "Member 'UUIFieldEquipMenu::InfoItem2' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuListEquipSlot
// 0x0028 (0x00F8 - 0x00D0)
class UUIFieldEquipMenuListEquipSlot final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageCharacter;                                    // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlipbookWidget*                        ItemFB;                                            // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuWindowChangeUnit*      ItemChangeUnit;                                    // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuWindowAutoEquip*       ItemAutoEquip;                                     // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuListEquipSlot">();
	}
	static class UUIFieldEquipMenuListEquipSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuListEquipSlot>();
	}
};
static_assert(alignof(UUIFieldEquipMenuListEquipSlot) == 0x000008, "Wrong alignment on UUIFieldEquipMenuListEquipSlot");
static_assert(sizeof(UUIFieldEquipMenuListEquipSlot) == 0x0000F8, "Wrong size on UUIFieldEquipMenuListEquipSlot");
static_assert(offsetof(UUIFieldEquipMenuListEquipSlot, ImageCharacter) == 0x0000D8, "Member 'UUIFieldEquipMenuListEquipSlot::ImageCharacter' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListEquipSlot, ItemFB) == 0x0000E0, "Member 'UUIFieldEquipMenuListEquipSlot::ItemFB' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListEquipSlot, ItemChangeUnit) == 0x0000E8, "Member 'UUIFieldEquipMenuListEquipSlot::ItemChangeUnit' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListEquipSlot, ItemAutoEquip) == 0x0000F0, "Member 'UUIFieldEquipMenuListEquipSlot::ItemAutoEquip' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuListInventory
// 0x0048 (0x0118 - 0x00D0)
class UUIFieldEquipMenuListInventory final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x38];                                      // 0x00D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFieldEquipMenuWindowSort*            ItemSort;                                          // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuWindowAutoEquip*       ItemHold;                                          // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuListInventory">();
	}
	static class UUIFieldEquipMenuListInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuListInventory>();
	}
};
static_assert(alignof(UUIFieldEquipMenuListInventory) == 0x000008, "Wrong alignment on UUIFieldEquipMenuListInventory");
static_assert(sizeof(UUIFieldEquipMenuListInventory) == 0x000118, "Wrong size on UUIFieldEquipMenuListInventory");
static_assert(offsetof(UUIFieldEquipMenuListInventory, ItemSort) == 0x000108, "Member 'UUIFieldEquipMenuListInventory::ItemSort' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListInventory, ItemHold) == 0x000110, "Member 'UUIFieldEquipMenuListInventory::ItemHold' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuListItemInventory
// 0x0020 (0x0088 - 0x0068)
class UUIFieldEquipMenuListItemInventory final : public UUIListItemIconDouble
{
public:
	class UImage*                                 IconEquipOther;                                    // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconCharacter;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextHoldNum;                                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextHoldUnit;                                      // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuListItemInventory">();
	}
	static class UUIFieldEquipMenuListItemInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuListItemInventory>();
	}
};
static_assert(alignof(UUIFieldEquipMenuListItemInventory) == 0x000008, "Wrong alignment on UUIFieldEquipMenuListItemInventory");
static_assert(sizeof(UUIFieldEquipMenuListItemInventory) == 0x000088, "Wrong size on UUIFieldEquipMenuListItemInventory");
static_assert(offsetof(UUIFieldEquipMenuListItemInventory, IconEquipOther) == 0x000068, "Member 'UUIFieldEquipMenuListItemInventory::IconEquipOther' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListItemInventory, IconCharacter) == 0x000070, "Member 'UUIFieldEquipMenuListItemInventory::IconCharacter' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListItemInventory, TextHoldNum) == 0x000078, "Member 'UUIFieldEquipMenuListItemInventory::TextHoldNum' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuListItemInventory, TextHoldUnit) == 0x000080, "Member 'UUIFieldEquipMenuListItemInventory::TextHoldUnit' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuListTop
// 0x0020 (0x00F0 - 0x00D0)
class UUIFieldEquipMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuListTop">();
	}
	static class UUIFieldEquipMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuListTop>();
	}
};
static_assert(alignof(UUIFieldEquipMenuListTop) == 0x000008, "Wrong alignment on UUIFieldEquipMenuListTop");
static_assert(sizeof(UUIFieldEquipMenuListTop) == 0x0000F0, "Wrong size on UUIFieldEquipMenuListTop");

// Class Nicola.UIFieldEquipMenuWindowChangeUnit
// 0x0020 (0x0078 - 0x0058)
class UUIFieldEquipMenuWindowChangeUnit final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemButtonIcon*                ImageButtonL;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWindowItemButtonIcon*                ImageButtonR;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          ItemText;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuWindowChangeUnit">();
	}
	static class UUIFieldEquipMenuWindowChangeUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuWindowChangeUnit>();
	}
};
static_assert(alignof(UUIFieldEquipMenuWindowChangeUnit) == 0x000008, "Wrong alignment on UUIFieldEquipMenuWindowChangeUnit");
static_assert(sizeof(UUIFieldEquipMenuWindowChangeUnit) == 0x000078, "Wrong size on UUIFieldEquipMenuWindowChangeUnit");
static_assert(offsetof(UUIFieldEquipMenuWindowChangeUnit, ImageButtonL) == 0x000060, "Member 'UUIFieldEquipMenuWindowChangeUnit::ImageButtonL' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuWindowChangeUnit, ImageButtonR) == 0x000068, "Member 'UUIFieldEquipMenuWindowChangeUnit::ImageButtonR' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuWindowChangeUnit, ItemText) == 0x000070, "Member 'UUIFieldEquipMenuWindowChangeUnit::ItemText' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuWindowSort
// 0x0020 (0x0078 - 0x0058)
class UUIFieldEquipMenuWindowSort final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemButtonIcon*                ImageButtonL;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWindowItemButtonIcon*                ImageButtonR;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGopTextBlock*                          ItemText;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuWindowSort">();
	}
	static class UUIFieldEquipMenuWindowSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuWindowSort>();
	}
};
static_assert(alignof(UUIFieldEquipMenuWindowSort) == 0x000008, "Wrong alignment on UUIFieldEquipMenuWindowSort");
static_assert(sizeof(UUIFieldEquipMenuWindowSort) == 0x000078, "Wrong size on UUIFieldEquipMenuWindowSort");
static_assert(offsetof(UUIFieldEquipMenuWindowSort, ImageButtonL) == 0x000060, "Member 'UUIFieldEquipMenuWindowSort::ImageButtonL' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuWindowSort, ImageButtonR) == 0x000068, "Member 'UUIFieldEquipMenuWindowSort::ImageButtonR' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuWindowSort, ItemText) == 0x000070, "Member 'UUIFieldEquipMenuWindowSort::ItemText' has a wrong offset!");

// Class Nicola.UIFieldEquipMenuItemSub
// 0x0020 (0x0078 - 0x0058)
class UUIFieldEquipMenuItemSub final : public UUIListItem
{
public:
	class UImage*                                 ImageArrow;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageEquip;                                        // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextStatusLeft;                                    // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextStatusRight;                                   // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldEquipMenuItemSub">();
	}
	static class UUIFieldEquipMenuItemSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldEquipMenuItemSub>();
	}
};
static_assert(alignof(UUIFieldEquipMenuItemSub) == 0x000008, "Wrong alignment on UUIFieldEquipMenuItemSub");
static_assert(sizeof(UUIFieldEquipMenuItemSub) == 0x000078, "Wrong size on UUIFieldEquipMenuItemSub");
static_assert(offsetof(UUIFieldEquipMenuItemSub, ImageArrow) == 0x000058, "Member 'UUIFieldEquipMenuItemSub::ImageArrow' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuItemSub, ImageEquip) == 0x000060, "Member 'UUIFieldEquipMenuItemSub::ImageEquip' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuItemSub, TextStatusLeft) == 0x000068, "Member 'UUIFieldEquipMenuItemSub::TextStatusLeft' has a wrong offset!");
static_assert(offsetof(UUIFieldEquipMenuItemSub, TextStatusRight) == 0x000070, "Member 'UUIFieldEquipMenuItemSub::TextStatusRight' has a wrong offset!");

// Class Nicola.UIFieldHandoverListSelectAccessory
// 0x0030 (0x0100 - 0x00D0)
class UUIFieldHandoverListSelectAccessory final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldHandoverListSelectAccessory">();
	}
	static class UUIFieldHandoverListSelectAccessory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldHandoverListSelectAccessory>();
	}
};
static_assert(alignof(UUIFieldHandoverListSelectAccessory) == 0x000008, "Wrong alignment on UUIFieldHandoverListSelectAccessory");
static_assert(sizeof(UUIFieldHandoverListSelectAccessory) == 0x000100, "Wrong size on UUIFieldHandoverListSelectAccessory");

// Class Nicola.UIFieldHandoverSelectMenu
// 0x0038 (0x00B0 - 0x0078)
class UUIFieldHandoverSelectMenu final : public UUIRootBase
{
public:
	class UUISelectItemMenuListTop*               ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuListInventory*         ListInventory;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSort*            WindowSort;                                        // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItem*                            ItemLiquidation;                                   // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSub*             WindowSub;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldHandoverWindowCountSelect*      WindowCountSelect;                                 // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldHandoverListSelectAccessory*    ListSelectAccessory;                               // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldHandoverSelectMenu">();
	}
	static class UUIFieldHandoverSelectMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldHandoverSelectMenu>();
	}
};
static_assert(alignof(UUIFieldHandoverSelectMenu) == 0x000008, "Wrong alignment on UUIFieldHandoverSelectMenu");
static_assert(sizeof(UUIFieldHandoverSelectMenu) == 0x0000B0, "Wrong size on UUIFieldHandoverSelectMenu");
static_assert(offsetof(UUIFieldHandoverSelectMenu, ListTop) == 0x000078, "Member 'UUIFieldHandoverSelectMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverSelectMenu, ListInventory) == 0x000080, "Member 'UUIFieldHandoverSelectMenu::ListInventory' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverSelectMenu, WindowSort) == 0x000088, "Member 'UUIFieldHandoverSelectMenu::WindowSort' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverSelectMenu, ItemLiquidation) == 0x000090, "Member 'UUIFieldHandoverSelectMenu::ItemLiquidation' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverSelectMenu, WindowSub) == 0x000098, "Member 'UUIFieldHandoverSelectMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverSelectMenu, WindowCountSelect) == 0x0000A0, "Member 'UUIFieldHandoverSelectMenu::WindowCountSelect' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverSelectMenu, ListSelectAccessory) == 0x0000A8, "Member 'UUIFieldHandoverSelectMenu::ListSelectAccessory' has a wrong offset!");

// Class Nicola.UIFieldHandoverWindowCountSelect
// 0x0030 (0x00A0 - 0x0070)
class UUIFieldHandoverWindowCountSelect final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGopTextBlock*                          TextMain;                                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextCount;                                         // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageArrowRight;                                   // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageArrowLeft;                                    // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldHandoverWindowCountSelect">();
	}
	static class UUIFieldHandoverWindowCountSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldHandoverWindowCountSelect>();
	}
};
static_assert(alignof(UUIFieldHandoverWindowCountSelect) == 0x000008, "Wrong alignment on UUIFieldHandoverWindowCountSelect");
static_assert(sizeof(UUIFieldHandoverWindowCountSelect) == 0x0000A0, "Wrong size on UUIFieldHandoverWindowCountSelect");
static_assert(offsetof(UUIFieldHandoverWindowCountSelect, TextMain) == 0x000080, "Member 'UUIFieldHandoverWindowCountSelect::TextMain' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverWindowCountSelect, TextCount) == 0x000088, "Member 'UUIFieldHandoverWindowCountSelect::TextCount' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverWindowCountSelect, ImageArrowRight) == 0x000090, "Member 'UUIFieldHandoverWindowCountSelect::ImageArrowRight' has a wrong offset!");
static_assert(offsetof(UUIFieldHandoverWindowCountSelect, ImageArrowLeft) == 0x000098, "Member 'UUIFieldHandoverWindowCountSelect::ImageArrowLeft' has a wrong offset!");

// Class Nicola.UIFieldMagicSkillMenuListItemSelectTarget
// 0x0028 (0x0088 - 0x0060)
class UUIFieldMagicSkillMenuListItemSelectTarget final : public UUIListItemText2
{
public:
	class UGopTextBlock*                          TextItem3;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem4;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem5;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageChara;                                        // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFieldStatusEffectWidget*               StatusEffectWidget;                                // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMagicSkillMenuListItemSelectTarget">();
	}
	static class UUIFieldMagicSkillMenuListItemSelectTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMagicSkillMenuListItemSelectTarget>();
	}
};
static_assert(alignof(UUIFieldMagicSkillMenuListItemSelectTarget) == 0x000008, "Wrong alignment on UUIFieldMagicSkillMenuListItemSelectTarget");
static_assert(sizeof(UUIFieldMagicSkillMenuListItemSelectTarget) == 0x000088, "Wrong size on UUIFieldMagicSkillMenuListItemSelectTarget");
static_assert(offsetof(UUIFieldMagicSkillMenuListItemSelectTarget, TextItem3) == 0x000060, "Member 'UUIFieldMagicSkillMenuListItemSelectTarget::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenuListItemSelectTarget, TextItem4) == 0x000068, "Member 'UUIFieldMagicSkillMenuListItemSelectTarget::TextItem4' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenuListItemSelectTarget, TextItem5) == 0x000070, "Member 'UUIFieldMagicSkillMenuListItemSelectTarget::TextItem5' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenuListItemSelectTarget, ImageChara) == 0x000078, "Member 'UUIFieldMagicSkillMenuListItemSelectTarget::ImageChara' has a wrong offset!");
static_assert(offsetof(UUIFieldMagicSkillMenuListItemSelectTarget, StatusEffectWidget) == 0x000080, "Member 'UUIFieldMagicSkillMenuListItemSelectTarget::StatusEffectWidget' has a wrong offset!");

// Class Nicola.UIFieldMagicSkillMenuListMagicSkill
// 0x0018 (0x00E8 - 0x00D0)
class UUIFieldMagicSkillMenuListMagicSkill final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMagicSkillMenuListMagicSkill">();
	}
	static class UUIFieldMagicSkillMenuListMagicSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMagicSkillMenuListMagicSkill>();
	}
};
static_assert(alignof(UUIFieldMagicSkillMenuListMagicSkill) == 0x000008, "Wrong alignment on UUIFieldMagicSkillMenuListMagicSkill");
static_assert(sizeof(UUIFieldMagicSkillMenuListMagicSkill) == 0x0000E8, "Wrong size on UUIFieldMagicSkillMenuListMagicSkill");

// Class Nicola.UIFieldMagicSkillMenuListSelectTarget
// 0x0028 (0x00F8 - 0x00D0)
class UUIFieldMagicSkillMenuListSelectTarget final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMagicSkillMenuListSelectTarget">();
	}
	static class UUIFieldMagicSkillMenuListSelectTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMagicSkillMenuListSelectTarget>();
	}
};
static_assert(alignof(UUIFieldMagicSkillMenuListSelectTarget) == 0x000008, "Wrong alignment on UUIFieldMagicSkillMenuListSelectTarget");
static_assert(sizeof(UUIFieldMagicSkillMenuListSelectTarget) == 0x0000F8, "Wrong size on UUIFieldMagicSkillMenuListSelectTarget");

// Class Nicola.UIFieldMemoryMenu
// 0x0048 (0x00C0 - 0x0078)
class UUIFieldMemoryMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFieldMemoryMenuListTop*              ListTop;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldMemoryMenuListNPC*              ListNPC;                                           // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ItemDelete;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemIcon*                      ItemScreenShot;                                    // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemText3*                     ItemNum;                                           // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMemoryMenu">();
	}
	static class UUIFieldMemoryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMemoryMenu>();
	}
};
static_assert(alignof(UUIFieldMemoryMenu) == 0x000008, "Wrong alignment on UUIFieldMemoryMenu");
static_assert(sizeof(UUIFieldMemoryMenu) == 0x0000C0, "Wrong size on UUIFieldMemoryMenu");
static_assert(offsetof(UUIFieldMemoryMenu, ListTop) == 0x000080, "Member 'UUIFieldMemoryMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldMemoryMenu, ListNPC) == 0x000088, "Member 'UUIFieldMemoryMenu::ListNPC' has a wrong offset!");
static_assert(offsetof(UUIFieldMemoryMenu, ItemDelete) == 0x000090, "Member 'UUIFieldMemoryMenu::ItemDelete' has a wrong offset!");
static_assert(offsetof(UUIFieldMemoryMenu, ItemScreenShot) == 0x000098, "Member 'UUIFieldMemoryMenu::ItemScreenShot' has a wrong offset!");
static_assert(offsetof(UUIFieldMemoryMenu, ItemNum) == 0x0000A0, "Member 'UUIFieldMemoryMenu::ItemNum' has a wrong offset!");

// Class Nicola.UIFieldMemoryMenuListNPC
// 0x0018 (0x00E8 - 0x00D0)
class UUIFieldMemoryMenuListNPC final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMemoryMenuListNPC">();
	}
	static class UUIFieldMemoryMenuListNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMemoryMenuListNPC>();
	}
};
static_assert(alignof(UUIFieldMemoryMenuListNPC) == 0x000008, "Wrong alignment on UUIFieldMemoryMenuListNPC");
static_assert(sizeof(UUIFieldMemoryMenuListNPC) == 0x0000E8, "Wrong size on UUIFieldMemoryMenuListNPC");

// Class Nicola.UIFieldMemoryMenuListTop
// 0x0000 (0x00D0 - 0x00D0)
class UUIFieldMemoryMenuListTop final : public UUIListPage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldMemoryMenuListTop">();
	}
	static class UUIFieldMemoryMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldMemoryMenuListTop>();
	}
};
static_assert(alignof(UUIFieldMemoryMenuListTop) == 0x000008, "Wrong alignment on UUIFieldMemoryMenuListTop");
static_assert(sizeof(UUIFieldMemoryMenuListTop) == 0x0000D0, "Wrong size on UUIFieldMemoryMenuListTop");

// Class Nicola.UIFieldTacticsContinueSaveMenu
// 0x0018 (0x0090 - 0x0078)
class UUIFieldTacticsContinueSaveMenu final : public UUIRootBase
{
public:
	class UUISaveLoadList*                        ListContinueSave;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveGameDataFlow*                    FlowSaveGameData;                                  // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsContinueSaveMenu">();
	}
	static class UUIFieldTacticsContinueSaveMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsContinueSaveMenu>();
	}
};
static_assert(alignof(UUIFieldTacticsContinueSaveMenu) == 0x000008, "Wrong alignment on UUIFieldTacticsContinueSaveMenu");
static_assert(sizeof(UUIFieldTacticsContinueSaveMenu) == 0x000090, "Wrong size on UUIFieldTacticsContinueSaveMenu");
static_assert(offsetof(UUIFieldTacticsContinueSaveMenu, ListContinueSave) == 0x000078, "Member 'UUIFieldTacticsContinueSaveMenu::ListContinueSave' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsContinueSaveMenu, FlowSaveGameData) == 0x000080, "Member 'UUIFieldTacticsContinueSaveMenu::FlowSaveGameData' has a wrong offset!");

// Class Nicola.UIFieldTacticsFormationMenuListItem
// 0x0010 (0x0068 - 0x0058)
class UUIFieldTacticsFormationMenuListItem final : public UUIListItem
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlipbookWidget*                        ItemFlipbook;                                      // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsFormationMenuListItem">();
	}
	static class UUIFieldTacticsFormationMenuListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsFormationMenuListItem>();
	}
};
static_assert(alignof(UUIFieldTacticsFormationMenuListItem) == 0x000008, "Wrong alignment on UUIFieldTacticsFormationMenuListItem");
static_assert(sizeof(UUIFieldTacticsFormationMenuListItem) == 0x000068, "Wrong size on UUIFieldTacticsFormationMenuListItem");
static_assert(offsetof(UUIFieldTacticsFormationMenuListItem, ItemIcon) == 0x000058, "Member 'UUIFieldTacticsFormationMenuListItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsFormationMenuListItem, ItemFlipbook) == 0x000060, "Member 'UUIFieldTacticsFormationMenuListItem::ItemFlipbook' has a wrong offset!");

// Class Nicola.UIFieldTacticsFormationMenuListTop
// 0x0020 (0x00C8 - 0x00A8)
class UUIFieldTacticsFormationMenuListTop final : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsFormationMenuListTop">();
	}
	static class UUIFieldTacticsFormationMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsFormationMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsFormationMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsFormationMenuListTop");
static_assert(sizeof(UUIFieldTacticsFormationMenuListTop) == 0x0000C8, "Wrong size on UUIFieldTacticsFormationMenuListTop");

// Class Nicola.UIFieldTacticsMenu
// 0x0098 (0x0110 - 0x0078)
class UUIFieldTacticsMenu final : public UUIRootBase
{
public:
	class UUIFieldTacticsMenuListTop*             ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemRich*                      ItemWindow;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsMenuWindowParty2*        WindowParty2;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuListTop*       ListStatus;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowStatus*  WindowStatus;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuListEquipSlot*         WindowEquip;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowData*    WindowData;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsTacticsMenuListTop*      ListTacticsTop;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsTacticsMenuListTop*      WindowTactics;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsTacticsMenuListTactics*  ListTactics;                                       // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowSkills*  WindowSkills;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStaticsMenuWindowCategory* WindowCategory;                                    // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsFormationMenuListTop*    ListFormationTop;                                  // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsSystemSettingMenuListTop* ListSystemSettingTop;                              // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsSystemSettingMenuListItems* ListSystemSettingItems;                            // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ItemSystemSettingReset;                            // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsSystemSettingWindowVram* WindowVRAM;                                        // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsSystemSettingMenuKeyConfigList* KeyConfig;                                         // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveGameDataFlow*                    FlowSaveGameData;                                  // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenu">();
	}
	static class UUIFieldTacticsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenu>();
	}
};
static_assert(alignof(UUIFieldTacticsMenu) == 0x000008, "Wrong alignment on UUIFieldTacticsMenu");
static_assert(sizeof(UUIFieldTacticsMenu) == 0x000110, "Wrong size on UUIFieldTacticsMenu");
static_assert(offsetof(UUIFieldTacticsMenu, ListTop) == 0x000078, "Member 'UUIFieldTacticsMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ItemWindow) == 0x000080, "Member 'UUIFieldTacticsMenu::ItemWindow' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowParty2) == 0x000088, "Member 'UUIFieldTacticsMenu::WindowParty2' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ListStatus) == 0x000090, "Member 'UUIFieldTacticsMenu::ListStatus' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowStatus) == 0x000098, "Member 'UUIFieldTacticsMenu::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowEquip) == 0x0000A0, "Member 'UUIFieldTacticsMenu::WindowEquip' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowData) == 0x0000A8, "Member 'UUIFieldTacticsMenu::WindowData' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ListTacticsTop) == 0x0000B0, "Member 'UUIFieldTacticsMenu::ListTacticsTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowTactics) == 0x0000B8, "Member 'UUIFieldTacticsMenu::WindowTactics' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ListTactics) == 0x0000C0, "Member 'UUIFieldTacticsMenu::ListTactics' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowSkills) == 0x0000C8, "Member 'UUIFieldTacticsMenu::WindowSkills' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowCategory) == 0x0000D0, "Member 'UUIFieldTacticsMenu::WindowCategory' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ListFormationTop) == 0x0000D8, "Member 'UUIFieldTacticsMenu::ListFormationTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ListSystemSettingTop) == 0x0000E0, "Member 'UUIFieldTacticsMenu::ListSystemSettingTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ListSystemSettingItems) == 0x0000E8, "Member 'UUIFieldTacticsMenu::ListSystemSettingItems' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, ItemSystemSettingReset) == 0x0000F0, "Member 'UUIFieldTacticsMenu::ItemSystemSettingReset' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, WindowVRAM) == 0x0000F8, "Member 'UUIFieldTacticsMenu::WindowVRAM' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, KeyConfig) == 0x000100, "Member 'UUIFieldTacticsMenu::KeyConfig' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenu, FlowSaveGameData) == 0x000108, "Member 'UUIFieldTacticsMenu::FlowSaveGameData' has a wrong offset!");

// Class Nicola.UIFieldTacticsMenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUIFieldTacticsMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenuListTop">();
	}
	static class UUIFieldTacticsMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsMenuListTop");
static_assert(sizeof(UUIFieldTacticsMenuListTop) == 0x0000E8, "Wrong size on UUIFieldTacticsMenuListTop");

// Class Nicola.UIFieldTacticsMenuWindowHP
// 0x0010 (0x0068 - 0x0058)
class UUIFieldTacticsMenuWindowHP final : public UUIWindowBase
{
public:
	TArray<class UUIListItemWindowHP*>            WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenuWindowHP">();
	}
	static class UUIFieldTacticsMenuWindowHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenuWindowHP>();
	}
};
static_assert(alignof(UUIFieldTacticsMenuWindowHP) == 0x000008, "Wrong alignment on UUIFieldTacticsMenuWindowHP");
static_assert(sizeof(UUIFieldTacticsMenuWindowHP) == 0x000068, "Wrong size on UUIFieldTacticsMenuWindowHP");
static_assert(offsetof(UUIFieldTacticsMenuWindowHP, WindowItems) == 0x000058, "Member 'UUIFieldTacticsMenuWindowHP::WindowItems' has a wrong offset!");

// Class Nicola.UIFieldTacticsMenuWindowParty
// 0x0010 (0x0068 - 0x0058)
class UUIFieldTacticsMenuWindowParty final : public UUIWindowBase
{
public:
	TArray<class UUIFieldTacticsMenuWindowUnit*>  WindowUnits;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenuWindowParty">();
	}
	static class UUIFieldTacticsMenuWindowParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenuWindowParty>();
	}
};
static_assert(alignof(UUIFieldTacticsMenuWindowParty) == 0x000008, "Wrong alignment on UUIFieldTacticsMenuWindowParty");
static_assert(sizeof(UUIFieldTacticsMenuWindowParty) == 0x000068, "Wrong size on UUIFieldTacticsMenuWindowParty");
static_assert(offsetof(UUIFieldTacticsMenuWindowParty, WindowUnits) == 0x000058, "Member 'UUIFieldTacticsMenuWindowParty::WindowUnits' has a wrong offset!");

// Class Nicola.UIFieldTacticsMenuWindowParty2
// 0x0010 (0x0068 - 0x0058)
class UUIFieldTacticsMenuWindowParty2 final : public UUIWindowBase
{
public:
	TArray<class UUIFieldTacticsMenuWindowUnit2*> WindowUnits;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenuWindowParty2">();
	}
	static class UUIFieldTacticsMenuWindowParty2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenuWindowParty2>();
	}
};
static_assert(alignof(UUIFieldTacticsMenuWindowParty2) == 0x000008, "Wrong alignment on UUIFieldTacticsMenuWindowParty2");
static_assert(sizeof(UUIFieldTacticsMenuWindowParty2) == 0x000068, "Wrong size on UUIFieldTacticsMenuWindowParty2");
static_assert(offsetof(UUIFieldTacticsMenuWindowParty2, WindowUnits) == 0x000058, "Member 'UUIFieldTacticsMenuWindowParty2::WindowUnits' has a wrong offset!");

// Class Nicola.UIFieldTacticsMenuWindowUnit
// 0x0038 (0x0090 - 0x0058)
class UUIFieldTacticsMenuWindowUnit final : public UUIWindowBase
{
public:
	class UFlipbookWidget*                        FlipbookIcon;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextName;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextJob;                                           // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLevelTitle;                                    // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLevelParam;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIWindowItemUnitStatus*>        WindowItems;                                       // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenuWindowUnit">();
	}
	static class UUIFieldTacticsMenuWindowUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenuWindowUnit>();
	}
};
static_assert(alignof(UUIFieldTacticsMenuWindowUnit) == 0x000008, "Wrong alignment on UUIFieldTacticsMenuWindowUnit");
static_assert(sizeof(UUIFieldTacticsMenuWindowUnit) == 0x000090, "Wrong size on UUIFieldTacticsMenuWindowUnit");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit, FlipbookIcon) == 0x000058, "Member 'UUIFieldTacticsMenuWindowUnit::FlipbookIcon' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit, TextName) == 0x000060, "Member 'UUIFieldTacticsMenuWindowUnit::TextName' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit, TextJob) == 0x000068, "Member 'UUIFieldTacticsMenuWindowUnit::TextJob' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit, TextLevelTitle) == 0x000070, "Member 'UUIFieldTacticsMenuWindowUnit::TextLevelTitle' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit, TextLevelParam) == 0x000078, "Member 'UUIFieldTacticsMenuWindowUnit::TextLevelParam' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit, WindowItems) == 0x000080, "Member 'UUIFieldTacticsMenuWindowUnit::WindowItems' has a wrong offset!");

// Class Nicola.UIFieldTacticsMenuWindowUnit2
// 0x0050 (0x00A8 - 0x0058)
class UUIFieldTacticsMenuWindowUnit2 final : public UUIWindowBase
{
public:
	class UFlipbookWidget*                        FlipbookIcon;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLevelTitle;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLevelParam;                                    // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextName;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemStatusGauge*               ItemGaugeHP;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemStatusGauge*               ItemGaugeMP;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextNextLevelTitle;                                // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextNextLevelParam;                                // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIWindowItemUnitStatus*>        WindowItems;                                       // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsMenuWindowUnit2">();
	}
	static class UUIFieldTacticsMenuWindowUnit2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsMenuWindowUnit2>();
	}
};
static_assert(alignof(UUIFieldTacticsMenuWindowUnit2) == 0x000008, "Wrong alignment on UUIFieldTacticsMenuWindowUnit2");
static_assert(sizeof(UUIFieldTacticsMenuWindowUnit2) == 0x0000A8, "Wrong size on UUIFieldTacticsMenuWindowUnit2");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, FlipbookIcon) == 0x000058, "Member 'UUIFieldTacticsMenuWindowUnit2::FlipbookIcon' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, TextLevelTitle) == 0x000060, "Member 'UUIFieldTacticsMenuWindowUnit2::TextLevelTitle' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, TextLevelParam) == 0x000068, "Member 'UUIFieldTacticsMenuWindowUnit2::TextLevelParam' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, TextName) == 0x000070, "Member 'UUIFieldTacticsMenuWindowUnit2::TextName' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, ItemGaugeHP) == 0x000078, "Member 'UUIFieldTacticsMenuWindowUnit2::ItemGaugeHP' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, ItemGaugeMP) == 0x000080, "Member 'UUIFieldTacticsMenuWindowUnit2::ItemGaugeMP' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, TextNextLevelTitle) == 0x000088, "Member 'UUIFieldTacticsMenuWindowUnit2::TextNextLevelTitle' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, TextNextLevelParam) == 0x000090, "Member 'UUIFieldTacticsMenuWindowUnit2::TextNextLevelParam' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsMenuWindowUnit2, WindowItems) == 0x000098, "Member 'UUIFieldTacticsMenuWindowUnit2::WindowItems' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenu
// 0x0050 (0x00C8 - 0x0078)
class UUIFieldTacticsRecordMenu final : public UUIRootBase
{
public:
	class UImage*                                 BG;                                                // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuListTop*       ListTop;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuWindowTop*     WindowTop;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuListMonsterTop* ListMonsterTop;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuWindowMonsterSimple* WindowMonsterSimple;                               // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuListSkill*     ListSkill;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSub*             WindowSub;                                         // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuListItem*      ListItem;                                          // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsRecordMenuMonsterDetail* MonsterDetail;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenu">();
	}
	static class UUIFieldTacticsRecordMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenu>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenu) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenu");
static_assert(sizeof(UUIFieldTacticsRecordMenu) == 0x0000C8, "Wrong size on UUIFieldTacticsRecordMenu");
static_assert(offsetof(UUIFieldTacticsRecordMenu, BG) == 0x000078, "Member 'UUIFieldTacticsRecordMenu::BG' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, ListTop) == 0x000080, "Member 'UUIFieldTacticsRecordMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, WindowTop) == 0x000088, "Member 'UUIFieldTacticsRecordMenu::WindowTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, ListMonsterTop) == 0x000090, "Member 'UUIFieldTacticsRecordMenu::ListMonsterTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, WindowMonsterSimple) == 0x000098, "Member 'UUIFieldTacticsRecordMenu::WindowMonsterSimple' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, ListSkill) == 0x0000A0, "Member 'UUIFieldTacticsRecordMenu::ListSkill' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, WindowSub) == 0x0000A8, "Member 'UUIFieldTacticsRecordMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, ListItem) == 0x0000B0, "Member 'UUIFieldTacticsRecordMenu::ListItem' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenu, MonsterDetail) == 0x0000B8, "Member 'UUIFieldTacticsRecordMenu::MonsterDetail' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuListMonsterTop
// 0x0070 (0x0140 - 0x00D0)
class UUIFieldTacticsRecordMenuListMonsterTop final : public UUIListPage
{
public:
	class UUIFieldTacticsRecordMenuWindowSort*    ItemSort;                                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x68];                                      // 0x00D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuListMonsterTop">();
	}
	static class UUIFieldTacticsRecordMenuListMonsterTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuListMonsterTop>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuListMonsterTop) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuListMonsterTop");
static_assert(sizeof(UUIFieldTacticsRecordMenuListMonsterTop) == 0x000140, "Wrong size on UUIFieldTacticsRecordMenuListMonsterTop");
static_assert(offsetof(UUIFieldTacticsRecordMenuListMonsterTop, ItemSort) == 0x0000D0, "Member 'UUIFieldTacticsRecordMenuListMonsterTop::ItemSort' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuListSkill
// 0x0030 (0x0100 - 0x00D0)
class UUIFieldTacticsRecordMenuListSkill final : public UUIListPage
{
public:
	class UUIFieldTacticsRecordMenuWindowSort*    ItemSort;                                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuListSkill">();
	}
	static class UUIFieldTacticsRecordMenuListSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuListSkill>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuListSkill) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuListSkill");
static_assert(sizeof(UUIFieldTacticsRecordMenuListSkill) == 0x000100, "Wrong size on UUIFieldTacticsRecordMenuListSkill");
static_assert(offsetof(UUIFieldTacticsRecordMenuListSkill, ItemSort) == 0x0000D0, "Member 'UUIFieldTacticsRecordMenuListSkill::ItemSort' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIFieldTacticsRecordMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuListTop">();
	}
	static class UUIFieldTacticsRecordMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuListTop");
static_assert(sizeof(UUIFieldTacticsRecordMenuListTop) == 0x0000D8, "Wrong size on UUIFieldTacticsRecordMenuListTop");

// Class Nicola.UIFieldTacticsRecordMenuMonsterDetailFlipbook
// 0x0010 (0x0050 - 0x0040)
class UUIFieldTacticsRecordMenuMonsterDetailFlipbook final : public UUIWindowItem
{
public:
	class UFlipbookWidget*                        FlipbookWidget;                                    // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIWindowItemButtonIconText*            ActionGuide;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuMonsterDetailFlipbook">();
	}
	static class UUIFieldTacticsRecordMenuMonsterDetailFlipbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuMonsterDetailFlipbook>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuMonsterDetailFlipbook) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuMonsterDetailFlipbook");
static_assert(sizeof(UUIFieldTacticsRecordMenuMonsterDetailFlipbook) == 0x000050, "Wrong size on UUIFieldTacticsRecordMenuMonsterDetailFlipbook");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetailFlipbook, FlipbookWidget) == 0x000040, "Member 'UUIFieldTacticsRecordMenuMonsterDetailFlipbook::FlipbookWidget' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuMonsterDetailFlipbook, ActionGuide) == 0x000048, "Member 'UUIFieldTacticsRecordMenuMonsterDetailFlipbook::ActionGuide' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuWindowItem
// 0x0010 (0x0050 - 0x0040)
class UUIFieldTacticsRecordMenuWindowItem final : public UUIWindowItem
{
public:
	TArray<class UUIWindowItemText2*>             WindowItems;                                       // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuWindowItem">();
	}
	static class UUIFieldTacticsRecordMenuWindowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuWindowItem>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuWindowItem) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuWindowItem");
static_assert(sizeof(UUIFieldTacticsRecordMenuWindowItem) == 0x000050, "Wrong size on UUIFieldTacticsRecordMenuWindowItem");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowItem, WindowItems) == 0x000040, "Member 'UUIFieldTacticsRecordMenuWindowItem::WindowItems' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuWindowMonsterSimple
// 0x0018 (0x0070 - 0x0058)
class UUIFieldTacticsRecordMenuWindowMonsterSimple final : public UUIWindowBase
{
public:
	class UUIFieldTacticsRecordMenuWindowItem*    KillCount;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlipbookWidget*                        FlipbookWidget;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 BlankImage;                                        // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuWindowMonsterSimple">();
	}
	static class UUIFieldTacticsRecordMenuWindowMonsterSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuWindowMonsterSimple>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuWindowMonsterSimple) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuWindowMonsterSimple");
static_assert(sizeof(UUIFieldTacticsRecordMenuWindowMonsterSimple) == 0x000070, "Wrong size on UUIFieldTacticsRecordMenuWindowMonsterSimple");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowMonsterSimple, KillCount) == 0x000058, "Member 'UUIFieldTacticsRecordMenuWindowMonsterSimple::KillCount' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowMonsterSimple, FlipbookWidget) == 0x000060, "Member 'UUIFieldTacticsRecordMenuWindowMonsterSimple::FlipbookWidget' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowMonsterSimple, BlankImage) == 0x000068, "Member 'UUIFieldTacticsRecordMenuWindowMonsterSimple::BlankImage' has a wrong offset!");

// Class Nicola.UIFieldTacticsRecordMenuWindowTop
// 0x0010 (0x0068 - 0x0058)
class UUIFieldTacticsRecordMenuWindowTop final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemText2*>             WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static int32 GetDebugRecordCount(EDEBUG_RecordCategory Index_0);
	static void SetDebugRecordCount(EDEBUG_RecordCategory Index_0, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsRecordMenuWindowTop">();
	}
	static class UUIFieldTacticsRecordMenuWindowTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsRecordMenuWindowTop>();
	}
};
static_assert(alignof(UUIFieldTacticsRecordMenuWindowTop) == 0x000008, "Wrong alignment on UUIFieldTacticsRecordMenuWindowTop");
static_assert(sizeof(UUIFieldTacticsRecordMenuWindowTop) == 0x000068, "Wrong size on UUIFieldTacticsRecordMenuWindowTop");
static_assert(offsetof(UUIFieldTacticsRecordMenuWindowTop, WindowItems) == 0x000058, "Member 'UUIFieldTacticsRecordMenuWindowTop::WindowItems' has a wrong offset!");

// Class Nicola.UIFieldTacticsStatusMenu
// 0x0030 (0x00A8 - 0x0078)
class UUIFieldTacticsStatusMenu final : public UUIRootBase
{
public:
	class UUIFieldTacticsStatusMenuListTop*       ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowStatus*  WindowStatus;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuListEquipSlot*         ListEquip;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowData*    WindowData;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIFieldTacticsStatusMenuWindowPage*     WindowPage;                                        // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsMenuWindowParty*         WindowParty;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsStatusMenu">();
	}
	static class UUIFieldTacticsStatusMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsStatusMenu>();
	}
};
static_assert(alignof(UUIFieldTacticsStatusMenu) == 0x000008, "Wrong alignment on UUIFieldTacticsStatusMenu");
static_assert(sizeof(UUIFieldTacticsStatusMenu) == 0x0000A8, "Wrong size on UUIFieldTacticsStatusMenu");
static_assert(offsetof(UUIFieldTacticsStatusMenu, ListTop) == 0x000078, "Member 'UUIFieldTacticsStatusMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenu, WindowStatus) == 0x000080, "Member 'UUIFieldTacticsStatusMenu::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenu, ListEquip) == 0x000088, "Member 'UUIFieldTacticsStatusMenu::ListEquip' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenu, WindowData) == 0x000090, "Member 'UUIFieldTacticsStatusMenu::WindowData' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenu, WindowPage) == 0x000098, "Member 'UUIFieldTacticsStatusMenu::WindowPage' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenu, WindowParty) == 0x0000A0, "Member 'UUIFieldTacticsStatusMenu::WindowParty' has a wrong offset!");

// Class Nicola.UIFieldTacticsStatusMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIFieldTacticsStatusMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsStatusMenuListTop">();
	}
	static class UUIFieldTacticsStatusMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsStatusMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsStatusMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsStatusMenuListTop");
static_assert(sizeof(UUIFieldTacticsStatusMenuListTop) == 0x0000D8, "Wrong size on UUIFieldTacticsStatusMenuListTop");

// Class Nicola.UIFieldTacticsStatusMenuWindowData
// 0x0018 (0x0070 - 0x0058)
class UUIFieldTacticsStatusMenuWindowData final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemUnitStatus*>        WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIWindowItemPage*                      ItemPage;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsStatusMenuWindowData">();
	}
	static class UUIFieldTacticsStatusMenuWindowData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsStatusMenuWindowData>();
	}
};
static_assert(alignof(UUIFieldTacticsStatusMenuWindowData) == 0x000008, "Wrong alignment on UUIFieldTacticsStatusMenuWindowData");
static_assert(sizeof(UUIFieldTacticsStatusMenuWindowData) == 0x000070, "Wrong size on UUIFieldTacticsStatusMenuWindowData");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowData, WindowItems) == 0x000058, "Member 'UUIFieldTacticsStatusMenuWindowData::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowData, ItemPage) == 0x000068, "Member 'UUIFieldTacticsStatusMenuWindowData::ItemPage' has a wrong offset!");

// Class Nicola.IFieldTacticsStatusMenuWindowPage
// 0x0028 (0x0080 - 0x0058)
class UIFieldTacticsStatusMenuWindowPage final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextTitle;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageButtonLeft;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageButtonRight;                                  // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextPage;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IFieldTacticsStatusMenuWindowPage">();
	}
	static class UIFieldTacticsStatusMenuWindowPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIFieldTacticsStatusMenuWindowPage>();
	}
};
static_assert(alignof(UIFieldTacticsStatusMenuWindowPage) == 0x000008, "Wrong alignment on UIFieldTacticsStatusMenuWindowPage");
static_assert(sizeof(UIFieldTacticsStatusMenuWindowPage) == 0x000080, "Wrong size on UIFieldTacticsStatusMenuWindowPage");
static_assert(offsetof(UIFieldTacticsStatusMenuWindowPage, TextTitle) == 0x000058, "Member 'UIFieldTacticsStatusMenuWindowPage::TextTitle' has a wrong offset!");
static_assert(offsetof(UIFieldTacticsStatusMenuWindowPage, ImageButtonLeft) == 0x000060, "Member 'UIFieldTacticsStatusMenuWindowPage::ImageButtonLeft' has a wrong offset!");
static_assert(offsetof(UIFieldTacticsStatusMenuWindowPage, ImageButtonRight) == 0x000068, "Member 'UIFieldTacticsStatusMenuWindowPage::ImageButtonRight' has a wrong offset!");
static_assert(offsetof(UIFieldTacticsStatusMenuWindowPage, TextPage) == 0x000070, "Member 'UIFieldTacticsStatusMenuWindowPage::TextPage' has a wrong offset!");

// Class Nicola.UIFieldTacticsStatusMenuWindowSkills
// 0x0060 (0x00B8 - 0x0058)
class UUIFieldTacticsStatusMenuWindowSkills final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemIcon*>              WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIWindowItemPage*                      ItemPage;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemNoViewItem;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x40];                                      // 0x0078(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsStatusMenuWindowSkills">();
	}
	static class UUIFieldTacticsStatusMenuWindowSkills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsStatusMenuWindowSkills>();
	}
};
static_assert(alignof(UUIFieldTacticsStatusMenuWindowSkills) == 0x000008, "Wrong alignment on UUIFieldTacticsStatusMenuWindowSkills");
static_assert(sizeof(UUIFieldTacticsStatusMenuWindowSkills) == 0x0000B8, "Wrong size on UUIFieldTacticsStatusMenuWindowSkills");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowSkills, WindowItems) == 0x000058, "Member 'UUIFieldTacticsStatusMenuWindowSkills::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowSkills, ItemPage) == 0x000068, "Member 'UUIFieldTacticsStatusMenuWindowSkills::ItemPage' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsStatusMenuWindowSkills, ItemNoViewItem) == 0x000070, "Member 'UUIFieldTacticsStatusMenuWindowSkills::ItemNoViewItem' has a wrong offset!");

// Class Nicola.UIFieldTacticsSystemSettingMenuKeyConfigList
// 0x0068 (0x0138 - 0x00D0)
class UUIFieldTacticsSystemSettingMenuKeyConfigList final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x68];                                      // 0x00D0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsSystemSettingMenuKeyConfigList">();
	}
	static class UUIFieldTacticsSystemSettingMenuKeyConfigList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsSystemSettingMenuKeyConfigList>();
	}
};
static_assert(alignof(UUIFieldTacticsSystemSettingMenuKeyConfigList) == 0x000008, "Wrong alignment on UUIFieldTacticsSystemSettingMenuKeyConfigList");
static_assert(sizeof(UUIFieldTacticsSystemSettingMenuKeyConfigList) == 0x000138, "Wrong size on UUIFieldTacticsSystemSettingMenuKeyConfigList");

// Class Nicola.UIFieldTacticsSystemSettingMenuListItems
// 0x0048 (0x0118 - 0x00D0)
class UUIFieldTacticsSystemSettingMenuListItems final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsSystemSettingMenuListItems">();
	}
	static class UUIFieldTacticsSystemSettingMenuListItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsSystemSettingMenuListItems>();
	}
};
static_assert(alignof(UUIFieldTacticsSystemSettingMenuListItems) == 0x000008, "Wrong alignment on UUIFieldTacticsSystemSettingMenuListItems");
static_assert(sizeof(UUIFieldTacticsSystemSettingMenuListItems) == 0x000118, "Wrong size on UUIFieldTacticsSystemSettingMenuListItems");

// Class Nicola.UIFieldTacticsSystemSettingMenuListTop
// 0x0028 (0x00F8 - 0x00D0)
class UUIFieldTacticsSystemSettingMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsSystemSettingMenuListTop">();
	}
	static class UUIFieldTacticsSystemSettingMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsSystemSettingMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsSystemSettingMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsSystemSettingMenuListTop");
static_assert(sizeof(UUIFieldTacticsSystemSettingMenuListTop) == 0x0000F8, "Wrong size on UUIFieldTacticsSystemSettingMenuListTop");

// Class Nicola.UIFieldTacticsTacticsMenuListTactics
// 0x0008 (0x00D8 - 0x00D0)
class UUIFieldTacticsTacticsMenuListTactics final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTacticsMenuListTactics">();
	}
	static class UUIFieldTacticsTacticsMenuListTactics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTacticsMenuListTactics>();
	}
};
static_assert(alignof(UUIFieldTacticsTacticsMenuListTactics) == 0x000008, "Wrong alignment on UUIFieldTacticsTacticsMenuListTactics");
static_assert(sizeof(UUIFieldTacticsTacticsMenuListTactics) == 0x0000D8, "Wrong size on UUIFieldTacticsTacticsMenuListTactics");

// Class Nicola.UIFieldTacticsTacticsMenuListItem
// 0x0008 (0x0068 - 0x0060)
class UUIFieldTacticsTacticsMenuListItem final : public UUIListItemText2
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTacticsMenuListItem">();
	}
	static class UUIFieldTacticsTacticsMenuListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTacticsMenuListItem>();
	}
};
static_assert(alignof(UUIFieldTacticsTacticsMenuListItem) == 0x000008, "Wrong alignment on UUIFieldTacticsTacticsMenuListItem");
static_assert(sizeof(UUIFieldTacticsTacticsMenuListItem) == 0x000068, "Wrong size on UUIFieldTacticsTacticsMenuListItem");
static_assert(offsetof(UUIFieldTacticsTacticsMenuListItem, ItemIcon) == 0x000060, "Member 'UUIFieldTacticsTacticsMenuListItem::ItemIcon' has a wrong offset!");

// Class Nicola.UIFieldTacticsTacticsMenuListTop
// 0x0010 (0x00E0 - 0x00D0)
class UUIFieldTacticsTacticsMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGopTextBlock*                          TextItem;                                          // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTacticsMenuListTop">();
	}
	static class UUIFieldTacticsTacticsMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTacticsMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsTacticsMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsTacticsMenuListTop");
static_assert(sizeof(UUIFieldTacticsTacticsMenuListTop) == 0x0000E0, "Wrong size on UUIFieldTacticsTacticsMenuListTop");
static_assert(offsetof(UUIFieldTacticsTacticsMenuListTop, TextItem) == 0x0000D8, "Member 'UUIFieldTacticsTacticsMenuListTop::TextItem' has a wrong offset!");

// Class Nicola.UIFieldTacticsTutorialMenuListTop
// 0x0010 (0x00E0 - 0x00D0)
class UUIFieldTacticsTutorialMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTutorialMenuListTop">();
	}
	static class UUIFieldTacticsTutorialMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTutorialMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTacticsTutorialMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTacticsTutorialMenuListTop");
static_assert(sizeof(UUIFieldTacticsTutorialMenuListTop) == 0x0000E0, "Wrong size on UUIFieldTacticsTutorialMenuListTop");

// Class Nicola.UIFieldTacticsTutorialMenuWindowExplainMain
// 0x0038 (0x0090 - 0x0058)
class UUIFieldTacticsTutorialMenuWindowExplainMain final : public UUIWindowBase
{
public:
	class UImage*                                 ItemImage;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemWindow;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaRichTextBlock*                   TextExplain;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           PanelImage;                                        // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUILoadableTexture                     loadableTexture;                                   // 0x0078(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTutorialMenuWindowExplainMain">();
	}
	static class UUIFieldTacticsTutorialMenuWindowExplainMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTutorialMenuWindowExplainMain>();
	}
};
static_assert(alignof(UUIFieldTacticsTutorialMenuWindowExplainMain) == 0x000008, "Wrong alignment on UUIFieldTacticsTutorialMenuWindowExplainMain");
static_assert(sizeof(UUIFieldTacticsTutorialMenuWindowExplainMain) == 0x000090, "Wrong size on UUIFieldTacticsTutorialMenuWindowExplainMain");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainMain, ItemImage) == 0x000058, "Member 'UUIFieldTacticsTutorialMenuWindowExplainMain::ItemImage' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainMain, ItemWindow) == 0x000060, "Member 'UUIFieldTacticsTutorialMenuWindowExplainMain::ItemWindow' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainMain, TextExplain) == 0x000068, "Member 'UUIFieldTacticsTutorialMenuWindowExplainMain::TextExplain' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainMain, PanelImage) == 0x000070, "Member 'UUIFieldTacticsTutorialMenuWindowExplainMain::PanelImage' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainMain, loadableTexture) == 0x000078, "Member 'UUIFieldTacticsTutorialMenuWindowExplainMain::loadableTexture' has a wrong offset!");

// Class Nicola.UIFieldTacticsTutorialMenuWindowExplainParent
// 0x0040 (0x00B0 - 0x0070)
class UUIFieldTacticsTutorialMenuWindowExplainParent final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFieldTacticsTutorialMenuWindowExplainMain* WindowMain;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ItemButton;                                        // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemPage*                      ItemArrow;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTacticsTutorialMenuWindowExplainParent">();
	}
	static class UUIFieldTacticsTutorialMenuWindowExplainParent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTacticsTutorialMenuWindowExplainParent>();
	}
};
static_assert(alignof(UUIFieldTacticsTutorialMenuWindowExplainParent) == 0x000008, "Wrong alignment on UUIFieldTacticsTutorialMenuWindowExplainParent");
static_assert(sizeof(UUIFieldTacticsTutorialMenuWindowExplainParent) == 0x0000B0, "Wrong size on UUIFieldTacticsTutorialMenuWindowExplainParent");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainParent, WindowMain) == 0x000090, "Member 'UUIFieldTacticsTutorialMenuWindowExplainParent::WindowMain' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainParent, ItemButton) == 0x000098, "Member 'UUIFieldTacticsTutorialMenuWindowExplainParent::ItemButton' has a wrong offset!");
static_assert(offsetof(UUIFieldTacticsTutorialMenuWindowExplainParent, ItemArrow) == 0x0000A0, "Member 'UUIFieldTacticsTutorialMenuWindowExplainParent::ItemArrow' has a wrong offset!");

// Class Nicola.UIFieldTopMenuListTop
// 0x0018 (0x0100 - 0x00E8)
class UUIFieldTopMenuListTop final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTopMenuListTop">();
	}
	static class UUIFieldTopMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTopMenuListTop>();
	}
};
static_assert(alignof(UUIFieldTopMenuListTop) == 0x000008, "Wrong alignment on UUIFieldTopMenuListTop");
static_assert(sizeof(UUIFieldTopMenuListTop) == 0x000100, "Wrong size on UUIFieldTopMenuListTop");

// Class Nicola.UIFieldTopMenuWindowLongPush
// 0x0020 (0x0078 - 0x0058)
class UUIFieldTopMenuWindowLongPush final : public UUIWindowBase
{
public:
	class UUIWindowItemButtonLongPress*           ItemGauge;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLeft;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextRight;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTopMenuWindowLongPush">();
	}
	static class UUIFieldTopMenuWindowLongPush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTopMenuWindowLongPush>();
	}
};
static_assert(alignof(UUIFieldTopMenuWindowLongPush) == 0x000008, "Wrong alignment on UUIFieldTopMenuWindowLongPush");
static_assert(sizeof(UUIFieldTopMenuWindowLongPush) == 0x000078, "Wrong size on UUIFieldTopMenuWindowLongPush");
static_assert(offsetof(UUIFieldTopMenuWindowLongPush, ItemGauge) == 0x000058, "Member 'UUIFieldTopMenuWindowLongPush::ItemGauge' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenuWindowLongPush, TextLeft) == 0x000060, "Member 'UUIFieldTopMenuWindowLongPush::TextLeft' has a wrong offset!");
static_assert(offsetof(UUIFieldTopMenuWindowLongPush, TextRight) == 0x000068, "Member 'UUIFieldTopMenuWindowLongPush::TextRight' has a wrong offset!");

// Class Nicola.UIFieldTopMenuWindowParty
// 0x0010 (0x0068 - 0x0058)
class UUIFieldTopMenuWindowParty final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemStatusMain*>        WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldTopMenuWindowParty">();
	}
	static class UUIFieldTopMenuWindowParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldTopMenuWindowParty>();
	}
};
static_assert(alignof(UUIFieldTopMenuWindowParty) == 0x000008, "Wrong alignment on UUIFieldTopMenuWindowParty");
static_assert(sizeof(UUIFieldTopMenuWindowParty) == 0x000068, "Wrong size on UUIFieldTopMenuWindowParty");
static_assert(offsetof(UUIFieldTopMenuWindowParty, WindowItems) == 0x000058, "Member 'UUIFieldTopMenuWindowParty::WindowItems' has a wrong offset!");

// Class Nicola.UIInitialMenuFlowMain
// 0x0008 (0x0078 - 0x0070)
class UUIInitialMenuFlowMain final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInitialMenuFlowMain">();
	}
	static class UUIInitialMenuFlowMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInitialMenuFlowMain>();
	}
};
static_assert(alignof(UUIInitialMenuFlowMain) == 0x000008, "Wrong alignment on UUIInitialMenuFlowMain");
static_assert(sizeof(UUIInitialMenuFlowMain) == 0x000078, "Wrong size on UUIInitialMenuFlowMain");

// Class Nicola.UIInnMenu
// 0x0310 (0x0388 - 0x0078)
class UUIInnMenu final : public UUIRootBase
{
public:
	class UUIInnMenuListTop*                      ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIInnMenuListTimeFrame*                ListTimeFrame;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     WindowMoney;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x2F8];                                     // 0x0090(0x02F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInnMenu">();
	}
	static class UUIInnMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInnMenu>();
	}
};
static_assert(alignof(UUIInnMenu) == 0x000008, "Wrong alignment on UUIInnMenu");
static_assert(sizeof(UUIInnMenu) == 0x000388, "Wrong size on UUIInnMenu");
static_assert(offsetof(UUIInnMenu, ListTop) == 0x000078, "Member 'UUIInnMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIInnMenu, ListTimeFrame) == 0x000080, "Member 'UUIInnMenu::ListTimeFrame' has a wrong offset!");
static_assert(offsetof(UUIInnMenu, WindowMoney) == 0x000088, "Member 'UUIInnMenu::WindowMoney' has a wrong offset!");

// Class Nicola.UIInnMenuListTimeFrame
// 0x0008 (0x00D8 - 0x00D0)
class UUIInnMenuListTimeFrame final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInnMenuListTimeFrame">();
	}
	static class UUIInnMenuListTimeFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInnMenuListTimeFrame>();
	}
};
static_assert(alignof(UUIInnMenuListTimeFrame) == 0x000008, "Wrong alignment on UUIInnMenuListTimeFrame");
static_assert(sizeof(UUIInnMenuListTimeFrame) == 0x0000D8, "Wrong size on UUIInnMenuListTimeFrame");

// Class Nicola.UIInnMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIInnMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInnMenuListTop">();
	}
	static class UUIInnMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInnMenuListTop>();
	}
};
static_assert(alignof(UUIInnMenuListTop) == 0x000008, "Wrong alignment on UUIInnMenuListTop");
static_assert(sizeof(UUIInnMenuListTop) == 0x0000D8, "Wrong size on UUIInnMenuListTop");

// Class Nicola.UIJobChangeMenu
// 0x0058 (0x00D0 - 0x0078)
class UUIJobChangeMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     PlayingEffectComp;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIJobChangeMenuListTop*                ListTop;                                           // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIJobChangeMenuListJob*                ListJob;                                           // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowStatus*  WindowUnitInfo;                                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldEquipMenuListEquipSlot*         WindowEquip;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowData*    WindowStatus;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemFlipbook*                  WindowUnitIcon;                                    // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowText*                          WindowSub;                                         // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIJobChangeMenuWindowStatusDiff*       WindowStatusDiff;                                  // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIJobChangeMenu">();
	}
	static class UUIJobChangeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIJobChangeMenu>();
	}
};
static_assert(alignof(UUIJobChangeMenu) == 0x000008, "Wrong alignment on UUIJobChangeMenu");
static_assert(sizeof(UUIJobChangeMenu) == 0x0000D0, "Wrong size on UUIJobChangeMenu");
static_assert(offsetof(UUIJobChangeMenu, PlayingEffectComp) == 0x000080, "Member 'UUIJobChangeMenu::PlayingEffectComp' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, ListTop) == 0x000090, "Member 'UUIJobChangeMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, ListJob) == 0x000098, "Member 'UUIJobChangeMenu::ListJob' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, WindowUnitInfo) == 0x0000A0, "Member 'UUIJobChangeMenu::WindowUnitInfo' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, WindowEquip) == 0x0000A8, "Member 'UUIJobChangeMenu::WindowEquip' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, WindowStatus) == 0x0000B0, "Member 'UUIJobChangeMenu::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, WindowUnitIcon) == 0x0000B8, "Member 'UUIJobChangeMenu::WindowUnitIcon' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, WindowSub) == 0x0000C0, "Member 'UUIJobChangeMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIJobChangeMenu, WindowStatusDiff) == 0x0000C8, "Member 'UUIJobChangeMenu::WindowStatusDiff' has a wrong offset!");

// Class Nicola.UIJobChangeMenuWindowItemStatusDiff
// 0x0008 (0x0058 - 0x0050)
class UUIJobChangeMenuWindowItemStatusDiff final : public UUIWindowItemText3
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIJobChangeMenuWindowItemStatusDiff">();
	}
	static class UUIJobChangeMenuWindowItemStatusDiff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIJobChangeMenuWindowItemStatusDiff>();
	}
};
static_assert(alignof(UUIJobChangeMenuWindowItemStatusDiff) == 0x000008, "Wrong alignment on UUIJobChangeMenuWindowItemStatusDiff");
static_assert(sizeof(UUIJobChangeMenuWindowItemStatusDiff) == 0x000058, "Wrong size on UUIJobChangeMenuWindowItemStatusDiff");
static_assert(offsetof(UUIJobChangeMenuWindowItemStatusDiff, ImageIcon) == 0x000050, "Member 'UUIJobChangeMenuWindowItemStatusDiff::ImageIcon' has a wrong offset!");

// Class Nicola.UIJobChangeMenuWindowStatusDiff
// 0x0010 (0x0068 - 0x0058)
class UUIJobChangeMenuWindowStatusDiff final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIJobChangeMenuWindowStatusDiff">();
	}
	static class UUIJobChangeMenuWindowStatusDiff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIJobChangeMenuWindowStatusDiff>();
	}
};
static_assert(alignof(UUIJobChangeMenuWindowStatusDiff) == 0x000008, "Wrong alignment on UUIJobChangeMenuWindowStatusDiff");
static_assert(sizeof(UUIJobChangeMenuWindowStatusDiff) == 0x000068, "Wrong size on UUIJobChangeMenuWindowStatusDiff");
static_assert(offsetof(UUIJobChangeMenuWindowStatusDiff, WindowItems) == 0x000058, "Member 'UUIJobChangeMenuWindowStatusDiff::WindowItems' has a wrong offset!");

// Class Nicola.UIKeyboardNameMenuEN
// 0x0000 (0x0098 - 0x0098)
class UUIKeyboardNameMenuEN : public UUIKeyboardNameMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuEN">();
	}
	static class UUIKeyboardNameMenuEN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuEN>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuEN) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuEN");
static_assert(sizeof(UUIKeyboardNameMenuEN) == 0x000098, "Wrong size on UUIKeyboardNameMenuEN");

// Class Nicola.UIKeyboardNameMenuKeyboardListTop
// 0x0030 (0x0100 - 0x00D0)
class UUIKeyboardNameMenuKeyboardListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeText(const class FText& InText);
	void OnCommitText(const class FText& InText, ETextCommit InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuKeyboardListTop">();
	}
	static class UUIKeyboardNameMenuKeyboardListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuKeyboardListTop>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuKeyboardListTop) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuKeyboardListTop");
static_assert(sizeof(UUIKeyboardNameMenuKeyboardListTop) == 0x000100, "Wrong size on UUIKeyboardNameMenuKeyboardListTop");

// Class Nicola.UIKeyboardNameMenuPFWindow
// 0x0000 (0x0058 - 0x0058)
class UUIKeyboardNameMenuPFWindow final : public UUIWindowBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuPFWindow">();
	}
	static class UUIKeyboardNameMenuPFWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuPFWindow>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuPFWindow) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuPFWindow");
static_assert(sizeof(UUIKeyboardNameMenuPFWindow) == 0x000058, "Wrong size on UUIKeyboardNameMenuPFWindow");

// Class Nicola.UIKeyboardNameMenuReal
// 0x0000 (0x0098 - 0x0098)
class UUIKeyboardNameMenuReal final : public UUIKeyboardNameMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuReal">();
	}
	static class UUIKeyboardNameMenuReal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuReal>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuReal) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuReal");
static_assert(sizeof(UUIKeyboardNameMenuReal) == 0x000098, "Wrong size on UUIKeyboardNameMenuReal");

// Class Nicola.UIKeyboardNameMenuRealEN
// 0x0000 (0x0098 - 0x0098)
class UUIKeyboardNameMenuRealEN final : public UUIKeyboardNameMenuEN
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuRealEN">();
	}
	static class UUIKeyboardNameMenuRealEN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuRealEN>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuRealEN) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuRealEN");
static_assert(sizeof(UUIKeyboardNameMenuRealEN) == 0x000098, "Wrong size on UUIKeyboardNameMenuRealEN");

// Class Nicola.UIKeyboardNameMenuWindowDisplay
// 0x0030 (0x0088 - 0x0058)
class UUIKeyboardNameMenuWindowDisplay final : public UUIWindowBase
{
public:
	TArray<class UUIListItem*>                    ListItems;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyboardNameMenuWindowDisplay">();
	}
	static class UUIKeyboardNameMenuWindowDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyboardNameMenuWindowDisplay>();
	}
};
static_assert(alignof(UUIKeyboardNameMenuWindowDisplay) == 0x000008, "Wrong alignment on UUIKeyboardNameMenuWindowDisplay");
static_assert(sizeof(UUIKeyboardNameMenuWindowDisplay) == 0x000088, "Wrong size on UUIKeyboardNameMenuWindowDisplay");
static_assert(offsetof(UUIKeyboardNameMenuWindowDisplay, ListItems) == 0x000058, "Member 'UUIKeyboardNameMenuWindowDisplay::ListItems' has a wrong offset!");

// Class Nicola.UIListItemIcon3
// 0x0008 (0x0070 - 0x0068)
class UUIListItemIcon3 final : public UUIListItemIconDouble
{
public:
	class UImage*                                 ImageIcon3;                                        // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemIcon3">();
	}
	static class UUIListItemIcon3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemIcon3>();
	}
};
static_assert(alignof(UUIListItemIcon3) == 0x000008, "Wrong alignment on UUIListItemIcon3");
static_assert(sizeof(UUIListItemIcon3) == 0x000070, "Wrong size on UUIListItemIcon3");
static_assert(offsetof(UUIListItemIcon3, ImageIcon3) == 0x000068, "Member 'UUIListItemIcon3::ImageIcon3' has a wrong offset!");

// Class Nicola.UIListItemLongPress
// 0x0008 (0x0060 - 0x0058)
class UUIListItemLongPress final : public UUIListItem
{
public:
	class UUIWindowItemButtonLongPress*           ItemLongPress;                                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemLongPress">();
	}
	static class UUIListItemLongPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemLongPress>();
	}
};
static_assert(alignof(UUIListItemLongPress) == 0x000008, "Wrong alignment on UUIListItemLongPress");
static_assert(sizeof(UUIListItemLongPress) == 0x000060, "Wrong size on UUIListItemLongPress");
static_assert(offsetof(UUIListItemLongPress, ItemLongPress) == 0x000058, "Member 'UUIListItemLongPress::ItemLongPress' has a wrong offset!");

// Class Nicola.UIListItemSelectItemWindowSub
// 0x0018 (0x0080 - 0x0068)
class UUIListItemSelectItemWindowSub final : public UUIListItemIconDouble
{
public:
	class UGopTextBlock*                          TextLeft;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextRight;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemSelectItemWindowSub">();
	}
	static class UUIListItemSelectItemWindowSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemSelectItemWindowSub>();
	}
};
static_assert(alignof(UUIListItemSelectItemWindowSub) == 0x000008, "Wrong alignment on UUIListItemSelectItemWindowSub");
static_assert(sizeof(UUIListItemSelectItemWindowSub) == 0x000080, "Wrong size on UUIListItemSelectItemWindowSub");
static_assert(offsetof(UUIListItemSelectItemWindowSub, TextLeft) == 0x000068, "Member 'UUIListItemSelectItemWindowSub::TextLeft' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectItemWindowSub, TextRight) == 0x000070, "Member 'UUIListItemSelectItemWindowSub::TextRight' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectItemWindowSub, TextSlash) == 0x000078, "Member 'UUIListItemSelectItemWindowSub::TextSlash' has a wrong offset!");

// Class Nicola.UIListItemSelectParty
// 0x0030 (0x0088 - 0x0058)
class UUIListItemSelectParty final : public UUIListItem
{
public:
	class UImage*                                 ImageChara;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextTitle;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextParamLeft;                                     // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextParamRight;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFieldStatusEffectWidget*               StatusEffectWidget;                                // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemSelectParty">();
	}
	static class UUIListItemSelectParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemSelectParty>();
	}
};
static_assert(alignof(UUIListItemSelectParty) == 0x000008, "Wrong alignment on UUIListItemSelectParty");
static_assert(sizeof(UUIListItemSelectParty) == 0x000088, "Wrong size on UUIListItemSelectParty");
static_assert(offsetof(UUIListItemSelectParty, ImageChara) == 0x000058, "Member 'UUIListItemSelectParty::ImageChara' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectParty, TextTitle) == 0x000060, "Member 'UUIListItemSelectParty::TextTitle' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectParty, TextParamLeft) == 0x000068, "Member 'UUIListItemSelectParty::TextParamLeft' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectParty, TextSlash) == 0x000070, "Member 'UUIListItemSelectParty::TextSlash' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectParty, TextParamRight) == 0x000078, "Member 'UUIListItemSelectParty::TextParamRight' has a wrong offset!");
static_assert(offsetof(UUIListItemSelectParty, StatusEffectWidget) == 0x000080, "Member 'UUIListItemSelectParty::StatusEffectWidget' has a wrong offset!");

// Class Nicola.UIListItemSystemSetting
// 0x00A0 (0x00F8 - 0x0058)
class UUIListItemSystemSetting final : public UUIListItem
{
public:
	class UCanvasPanel*                           CanvasSelect;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasGauge;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasSelect2;                                     // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasSelect3;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSelectItem;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextGaugeItem;                                     // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextGaugeItem2;                                    // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextGaugeItem3;                                    // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSelect2Item;                                   // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSelect2Item2;                                  // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSelect2Item3;                                  // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSelect3Item;                                   // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageGauge;                                        // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowLeft;                                    // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowRight;                                   // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowLeft2;                                   // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowRight2;                                  // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowLeft3;                                   // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowRight3;                                  // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemSystemSetting">();
	}
	static class UUIListItemSystemSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemSystemSetting>();
	}
};
static_assert(alignof(UUIListItemSystemSetting) == 0x000008, "Wrong alignment on UUIListItemSystemSetting");
static_assert(sizeof(UUIListItemSystemSetting) == 0x0000F8, "Wrong size on UUIListItemSystemSetting");
static_assert(offsetof(UUIListItemSystemSetting, CanvasSelect) == 0x000058, "Member 'UUIListItemSystemSetting::CanvasSelect' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, CanvasGauge) == 0x000060, "Member 'UUIListItemSystemSetting::CanvasGauge' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, CanvasSelect2) == 0x000068, "Member 'UUIListItemSystemSetting::CanvasSelect2' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, CanvasSelect3) == 0x000070, "Member 'UUIListItemSystemSetting::CanvasSelect3' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextSelectItem) == 0x000078, "Member 'UUIListItemSystemSetting::TextSelectItem' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextGaugeItem) == 0x000080, "Member 'UUIListItemSystemSetting::TextGaugeItem' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextGaugeItem2) == 0x000088, "Member 'UUIListItemSystemSetting::TextGaugeItem2' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextGaugeItem3) == 0x000090, "Member 'UUIListItemSystemSetting::TextGaugeItem3' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextSelect2Item) == 0x000098, "Member 'UUIListItemSystemSetting::TextSelect2Item' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextSelect2Item2) == 0x0000A0, "Member 'UUIListItemSystemSetting::TextSelect2Item2' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextSelect2Item3) == 0x0000A8, "Member 'UUIListItemSystemSetting::TextSelect2Item3' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, TextSelect3Item) == 0x0000B0, "Member 'UUIListItemSystemSetting::TextSelect3Item' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageGauge) == 0x0000B8, "Member 'UUIListItemSystemSetting::ImageGauge' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageArrowLeft) == 0x0000C0, "Member 'UUIListItemSystemSetting::ImageArrowLeft' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageArrowRight) == 0x0000C8, "Member 'UUIListItemSystemSetting::ImageArrowRight' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageArrowLeft2) == 0x0000D0, "Member 'UUIListItemSystemSetting::ImageArrowLeft2' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageArrowRight2) == 0x0000D8, "Member 'UUIListItemSystemSetting::ImageArrowRight2' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageArrowLeft3) == 0x0000E0, "Member 'UUIListItemSystemSetting::ImageArrowLeft3' has a wrong offset!");
static_assert(offsetof(UUIListItemSystemSetting, ImageArrowRight3) == 0x0000E8, "Member 'UUIListItemSystemSetting::ImageArrowRight3' has a wrong offset!");

// Class Nicola.UIListItemTownMapArrow
// 0x0058 (0x00C0 - 0x0068)
class UUIListItemTownMapArrow final : public UUIListItemIconDouble
{
public:
	uint8                                         Pad_68[0x40];                                      // 0x0068(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageArrowLeft;                                    // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowRight;                                   // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemTownMapArrow">();
	}
	static class UUIListItemTownMapArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemTownMapArrow>();
	}
};
static_assert(alignof(UUIListItemTownMapArrow) == 0x000008, "Wrong alignment on UUIListItemTownMapArrow");
static_assert(sizeof(UUIListItemTownMapArrow) == 0x0000C0, "Wrong size on UUIListItemTownMapArrow");
static_assert(offsetof(UUIListItemTownMapArrow, ImageArrowLeft) == 0x0000A8, "Member 'UUIListItemTownMapArrow::ImageArrowLeft' has a wrong offset!");
static_assert(offsetof(UUIListItemTownMapArrow, ImageArrowRight) == 0x0000B0, "Member 'UUIListItemTownMapArrow::ImageArrowRight' has a wrong offset!");

// Class Nicola.UIListItemTownMapLabel
// 0x0010 (0x0068 - 0x0058)
class UUIListItemTownMapLabel final : public UUIWindowItemButtonIcon2Text
{
public:
	class UImage*                                 ImageArrowLeft;                                    // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowRight;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemTownMapLabel">();
	}
	static class UUIListItemTownMapLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemTownMapLabel>();
	}
};
static_assert(alignof(UUIListItemTownMapLabel) == 0x000008, "Wrong alignment on UUIListItemTownMapLabel");
static_assert(sizeof(UUIListItemTownMapLabel) == 0x000068, "Wrong size on UUIListItemTownMapLabel");
static_assert(offsetof(UUIListItemTownMapLabel, ImageArrowLeft) == 0x000058, "Member 'UUIListItemTownMapLabel::ImageArrowLeft' has a wrong offset!");
static_assert(offsetof(UUIListItemTownMapLabel, ImageArrowRight) == 0x000060, "Member 'UUIListItemTownMapLabel::ImageArrowRight' has a wrong offset!");

// Class Nicola.UIXenlonWishListTop
// 0x0010 (0x00E0 - 0x00D0)
class UUIXenlonWishListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIXenlonWishListTop">();
	}
	static class UUIXenlonWishListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIXenlonWishListTop>();
	}
};
static_assert(alignof(UUIXenlonWishListTop) == 0x000008, "Wrong alignment on UUIXenlonWishListTop");
static_assert(sizeof(UUIXenlonWishListTop) == 0x0000E0, "Wrong size on UUIXenlonWishListTop");

// Class Nicola.UIListItemWindowHP
// 0x0020 (0x0078 - 0x0058)
class UUIListItemWindowHP final : public UUIListItem
{
public:
	class UGopTextBlock*                          TextTitle;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextCurrent;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextMax;                                           // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListItemWindowHP">();
	}
	static class UUIListItemWindowHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListItemWindowHP>();
	}
};
static_assert(alignof(UUIListItemWindowHP) == 0x000008, "Wrong alignment on UUIListItemWindowHP");
static_assert(sizeof(UUIListItemWindowHP) == 0x000078, "Wrong size on UUIListItemWindowHP");
static_assert(offsetof(UUIListItemWindowHP, TextTitle) == 0x000058, "Member 'UUIListItemWindowHP::TextTitle' has a wrong offset!");
static_assert(offsetof(UUIListItemWindowHP, TextCurrent) == 0x000060, "Member 'UUIListItemWindowHP::TextCurrent' has a wrong offset!");
static_assert(offsetof(UUIListItemWindowHP, TextSlash) == 0x000068, "Member 'UUIListItemWindowHP::TextSlash' has a wrong offset!");
static_assert(offsetof(UUIListItemWindowHP, TextMax) == 0x000070, "Member 'UUIListItemWindowHP::TextMax' has a wrong offset!");

// Class Nicola.UIListPageUDFeed
// 0x0028 (0x00D0 - 0x00A8)
class UUIListPageUDFeed final : public UUIListBase
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListPageUDFeed">();
	}
	static class UUIListPageUDFeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListPageUDFeed>();
	}
};
static_assert(alignof(UUIListPageUDFeed) == 0x000008, "Wrong alignment on UUIListPageUDFeed");
static_assert(sizeof(UUIListPageUDFeed) == 0x0000D0, "Wrong size on UUIListPageUDFeed");

// Class Nicola.UIMap2Menu
// 0x0138 (0x01B0 - 0x0078)
class UUIMap2Menu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x60];                                      // 0x0078(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMap2MenuCtrlTop*                     CtrlTop;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowCoin*                  WindowCoin;                                        // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowWorldMap*              WindowWorldMap;                                    // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowTownMap*               WindowTownMap;                                     // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapGuideMenuWindowMain*              WindowMapGuide;                                    // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuListRura*                    ListRura;                                          // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowCategory*              WindowCategory;                                    // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowFacility*              WindowFacility;                                    // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMap2MenuWindowKeyGuide*              WindowKeyGuide;                                    // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaFrontWorld;                  // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaFrontWorldOverlay;           // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaUnderground;                 // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaUndergroundAfter;            // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaAliahan;                     // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUILoadableTexture                     loadableTexture;                                   // 0x0148(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FUILoadableTexture                     LoadableTexture2;                                  // 0x0160(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x38];                                     // 0x0178(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2Menu">();
	}
	static class UUIMap2Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2Menu>();
	}
};
static_assert(alignof(UUIMap2Menu) == 0x000008, "Wrong alignment on UUIMap2Menu");
static_assert(sizeof(UUIMap2Menu) == 0x0001B0, "Wrong size on UUIMap2Menu");
static_assert(offsetof(UUIMap2Menu, CtrlTop) == 0x0000D8, "Member 'UUIMap2Menu::CtrlTop' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowCoin) == 0x0000E0, "Member 'UUIMap2Menu::WindowCoin' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowWorldMap) == 0x0000E8, "Member 'UUIMap2Menu::WindowWorldMap' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowTownMap) == 0x0000F0, "Member 'UUIMap2Menu::WindowTownMap' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowMapGuide) == 0x0000F8, "Member 'UUIMap2Menu::WindowMapGuide' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, ListRura) == 0x000100, "Member 'UUIMap2Menu::ListRura' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowCategory) == 0x000108, "Member 'UUIMap2Menu::WindowCategory' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowFacility) == 0x000110, "Member 'UUIMap2Menu::WindowFacility' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, WindowKeyGuide) == 0x000118, "Member 'UUIMap2Menu::WindowKeyGuide' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, TextureWorldMapAllAreaFrontWorld) == 0x000120, "Member 'UUIMap2Menu::TextureWorldMapAllAreaFrontWorld' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, TextureWorldMapAllAreaFrontWorldOverlay) == 0x000128, "Member 'UUIMap2Menu::TextureWorldMapAllAreaFrontWorldOverlay' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, TextureWorldMapAllAreaUnderground) == 0x000130, "Member 'UUIMap2Menu::TextureWorldMapAllAreaUnderground' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, TextureWorldMapAllAreaUndergroundAfter) == 0x000138, "Member 'UUIMap2Menu::TextureWorldMapAllAreaUndergroundAfter' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, TextureWorldMapAllAreaAliahan) == 0x000140, "Member 'UUIMap2Menu::TextureWorldMapAllAreaAliahan' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, loadableTexture) == 0x000148, "Member 'UUIMap2Menu::loadableTexture' has a wrong offset!");
static_assert(offsetof(UUIMap2Menu, LoadableTexture2) == 0x000160, "Member 'UUIMap2Menu::LoadableTexture2' has a wrong offset!");

// Class Nicola.UIMap2MenuListRura
// 0x00A0 (0x0170 - 0x00D0)
class UUIMap2MenuListRura final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0xA0];                                      // 0x00D0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuListRura">();
	}
	static class UUIMap2MenuListRura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuListRura>();
	}
};
static_assert(alignof(UUIMap2MenuListRura) == 0x000008, "Wrong alignment on UUIMap2MenuListRura");
static_assert(sizeof(UUIMap2MenuListRura) == 0x000170, "Wrong size on UUIMap2MenuListRura");

// Class Nicola.UIMap2MenuWindowCategory
// 0x0020 (0x0078 - 0x0058)
class UUIMap2MenuWindowCategory final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageLeft;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageRight;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageCategory;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowCategory">();
	}
	static class UUIMap2MenuWindowCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowCategory>();
	}
};
static_assert(alignof(UUIMap2MenuWindowCategory) == 0x000008, "Wrong alignment on UUIMap2MenuWindowCategory");
static_assert(sizeof(UUIMap2MenuWindowCategory) == 0x000078, "Wrong size on UUIMap2MenuWindowCategory");
static_assert(offsetof(UUIMap2MenuWindowCategory, TextItem) == 0x000058, "Member 'UUIMap2MenuWindowCategory::TextItem' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowCategory, ImageLeft) == 0x000060, "Member 'UUIMap2MenuWindowCategory::ImageLeft' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowCategory, ImageRight) == 0x000068, "Member 'UUIMap2MenuWindowCategory::ImageRight' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowCategory, ImageCategory) == 0x000070, "Member 'UUIMap2MenuWindowCategory::ImageCategory' has a wrong offset!");

// Class Nicola.UIMap2MenuWindowCoin
// 0x0018 (0x0070 - 0x0058)
class UUIMap2MenuWindowCoin final : public UUIWindowBase
{
public:
	class UUIWindowItemText2Icon*                 ItemMoney;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemText2Icon*                 ItemMedal;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemIcon*                      ItemTreasure;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowCoin">();
	}
	static class UUIMap2MenuWindowCoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowCoin>();
	}
};
static_assert(alignof(UUIMap2MenuWindowCoin) == 0x000008, "Wrong alignment on UUIMap2MenuWindowCoin");
static_assert(sizeof(UUIMap2MenuWindowCoin) == 0x000070, "Wrong size on UUIMap2MenuWindowCoin");
static_assert(offsetof(UUIMap2MenuWindowCoin, ItemMoney) == 0x000058, "Member 'UUIMap2MenuWindowCoin::ItemMoney' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowCoin, ItemMedal) == 0x000060, "Member 'UUIMap2MenuWindowCoin::ItemMedal' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowCoin, ItemTreasure) == 0x000068, "Member 'UUIMap2MenuWindowCoin::ItemTreasure' has a wrong offset!");

// Class Nicola.UIMap2MenuWindowFacility
// 0x0018 (0x0070 - 0x0058)
class UUIMap2MenuWindowFacility final : public UUIWindowBase
{
public:
	TArray<class UImage*>                         ImageIcons;                                        // 0x0058(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageBg;                                           // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowFacility">();
	}
	static class UUIMap2MenuWindowFacility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowFacility>();
	}
};
static_assert(alignof(UUIMap2MenuWindowFacility) == 0x000008, "Wrong alignment on UUIMap2MenuWindowFacility");
static_assert(sizeof(UUIMap2MenuWindowFacility) == 0x000070, "Wrong size on UUIMap2MenuWindowFacility");
static_assert(offsetof(UUIMap2MenuWindowFacility, ImageIcons) == 0x000058, "Member 'UUIMap2MenuWindowFacility::ImageIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowFacility, ImageBg) == 0x000068, "Member 'UUIMap2MenuWindowFacility::ImageBg' has a wrong offset!");

// Class Nicola.UIMap2MenuWindowItemKeyGuide
// 0x0008 (0x0050 - 0x0048)
class UUIMap2MenuWindowItemKeyGuide final : public UUIWindowItemIcon
{
public:
	class UUIWindowItemButtonIcon*                ItemIcon2;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowItemKeyGuide">();
	}
	static class UUIMap2MenuWindowItemKeyGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowItemKeyGuide>();
	}
};
static_assert(alignof(UUIMap2MenuWindowItemKeyGuide) == 0x000008, "Wrong alignment on UUIMap2MenuWindowItemKeyGuide");
static_assert(sizeof(UUIMap2MenuWindowItemKeyGuide) == 0x000050, "Wrong size on UUIMap2MenuWindowItemKeyGuide");
static_assert(offsetof(UUIMap2MenuWindowItemKeyGuide, ItemIcon2) == 0x000048, "Member 'UUIMap2MenuWindowItemKeyGuide::ItemIcon2' has a wrong offset!");

// Class Nicola.UIMap2MenuWindowKeyGuide
// 0x0010 (0x0068 - 0x0058)
class UUIMap2MenuWindowKeyGuide final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemButtonIcon4Text*>   ListItems;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowKeyGuide">();
	}
	static class UUIMap2MenuWindowKeyGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowKeyGuide>();
	}
};
static_assert(alignof(UUIMap2MenuWindowKeyGuide) == 0x000008, "Wrong alignment on UUIMap2MenuWindowKeyGuide");
static_assert(sizeof(UUIMap2MenuWindowKeyGuide) == 0x000068, "Wrong size on UUIMap2MenuWindowKeyGuide");
static_assert(offsetof(UUIMap2MenuWindowKeyGuide, ListItems) == 0x000058, "Member 'UUIMap2MenuWindowKeyGuide::ListItems' has a wrong offset!");

// Class Nicola.UIMap2MenuWindowTownMap
// 0x00E8 (0x0140 - 0x0058)
class UUIMap2MenuWindowTownMap final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIListItemTownMapLabel*                ItemLabel;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemTownMapArrow*                ItemArrow;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap;                                          // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasMap;                                         // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasIcon;                                        // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageFacilityIcons;                                // 0x0090(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImagePlayerIcon;                                   // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageTargetIcons;                                  // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageGuideMainIcons;                               // 0x00B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageGuideSubIcons;                                // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageDoorKeyIcons;                                 // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageShip;                                         // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageTimeFrame;                                    // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemPlayerEffect;                                  // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageDirWest;                                      // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageDirEast;                                      // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap2MenuWindowTownMap">();
	}
	static class UUIMap2MenuWindowTownMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap2MenuWindowTownMap>();
	}
};
static_assert(alignof(UUIMap2MenuWindowTownMap) == 0x000008, "Wrong alignment on UUIMap2MenuWindowTownMap");
static_assert(sizeof(UUIMap2MenuWindowTownMap) == 0x000140, "Wrong size on UUIMap2MenuWindowTownMap");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ItemLabel) == 0x000068, "Member 'UUIMap2MenuWindowTownMap::ItemLabel' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ItemArrow) == 0x000070, "Member 'UUIMap2MenuWindowTownMap::ItemArrow' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageMap) == 0x000078, "Member 'UUIMap2MenuWindowTownMap::ImageMap' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, CanvasMap) == 0x000080, "Member 'UUIMap2MenuWindowTownMap::CanvasMap' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, CanvasIcon) == 0x000088, "Member 'UUIMap2MenuWindowTownMap::CanvasIcon' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageFacilityIcons) == 0x000090, "Member 'UUIMap2MenuWindowTownMap::ImageFacilityIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImagePlayerIcon) == 0x0000A0, "Member 'UUIMap2MenuWindowTownMap::ImagePlayerIcon' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageTargetIcons) == 0x0000A8, "Member 'UUIMap2MenuWindowTownMap::ImageTargetIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageGuideMainIcons) == 0x0000B8, "Member 'UUIMap2MenuWindowTownMap::ImageGuideMainIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageGuideSubIcons) == 0x0000C8, "Member 'UUIMap2MenuWindowTownMap::ImageGuideSubIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageDoorKeyIcons) == 0x0000D8, "Member 'UUIMap2MenuWindowTownMap::ImageDoorKeyIcons' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageShip) == 0x0000E8, "Member 'UUIMap2MenuWindowTownMap::ImageShip' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageTimeFrame) == 0x0000F0, "Member 'UUIMap2MenuWindowTownMap::ImageTimeFrame' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ItemPlayerEffect) == 0x0000F8, "Member 'UUIMap2MenuWindowTownMap::ItemPlayerEffect' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageDirWest) == 0x000100, "Member 'UUIMap2MenuWindowTownMap::ImageDirWest' has a wrong offset!");
static_assert(offsetof(UUIMap2MenuWindowTownMap, ImageDirEast) == 0x000108, "Member 'UUIMap2MenuWindowTownMap::ImageDirEast' has a wrong offset!");

// Class Nicola.UIMapGuideMenuWindowList
// 0x0010 (0x0068 - 0x0058)
class UUIMapGuideMenuWindowList final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapGuideMenuWindowList">();
	}
	static class UUIMapGuideMenuWindowList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapGuideMenuWindowList>();
	}
};
static_assert(alignof(UUIMapGuideMenuWindowList) == 0x000008, "Wrong alignment on UUIMapGuideMenuWindowList");
static_assert(sizeof(UUIMapGuideMenuWindowList) == 0x000068, "Wrong size on UUIMapGuideMenuWindowList");
static_assert(offsetof(UUIMapGuideMenuWindowList, WindowItems) == 0x000058, "Member 'UUIMapGuideMenuWindowList::WindowItems' has a wrong offset!");

// Class Nicola.UIMapGuideMenuWindowMain
// 0x0018 (0x0070 - 0x0058)
class UUIMapGuideMenuWindowMain final : public UUIWindowBase
{
public:
	class UUIMapGuideMenuWindowList*              WindowList;                                        // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapGuideMenuWindowMain">();
	}
	static class UUIMapGuideMenuWindowMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapGuideMenuWindowMain>();
	}
};
static_assert(alignof(UUIMapGuideMenuWindowMain) == 0x000008, "Wrong alignment on UUIMapGuideMenuWindowMain");
static_assert(sizeof(UUIMapGuideMenuWindowMain) == 0x000070, "Wrong size on UUIMapGuideMenuWindowMain");
static_assert(offsetof(UUIMapGuideMenuWindowMain, WindowList) == 0x000058, "Member 'UUIMapGuideMenuWindowMain::WindowList' has a wrong offset!");
static_assert(offsetof(UUIMapGuideMenuWindowMain, TextItem) == 0x000060, "Member 'UUIMapGuideMenuWindowMain::TextItem' has a wrong offset!");

// Class Nicola.UIMapMenu
// 0x00F0 (0x0168 - 0x0078)
class UUIMapMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMapMenuListTop*                      ListTop;                                           // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSub*             WindowSub;                                         // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapMenuListParty*                    ListParty;                                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapMenuListRura*                     ListRura;                                          // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapMenuWindowWorldMap*               WindowWorldMap;                                    // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapMenuWindowTownMap*                WindowTownMap;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapMenuWindowKeyGuide*               WindowKeyGuide;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapMenuWindowFacility*               WindowFacility;                                    // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemTreasureChest*             ItemTreasureChest;                                 // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMapGuideMenuWindowMain*              WindowMapGuide;                                    // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaFrontWorld;                  // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaUnderground;                 // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureWorldMapAllAreaAliahan;                     // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUILoadableTexture                     loadableTexture;                                   // 0x0130(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x20];                                     // 0x0148(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenu">();
	}
	static class UUIMapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenu>();
	}
};
static_assert(alignof(UUIMapMenu) == 0x000008, "Wrong alignment on UUIMapMenu");
static_assert(sizeof(UUIMapMenu) == 0x000168, "Wrong size on UUIMapMenu");
static_assert(offsetof(UUIMapMenu, ListTop) == 0x0000A8, "Member 'UUIMapMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, WindowSub) == 0x0000B0, "Member 'UUIMapMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, ListParty) == 0x0000B8, "Member 'UUIMapMenu::ListParty' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, ListRura) == 0x0000C0, "Member 'UUIMapMenu::ListRura' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, WindowWorldMap) == 0x0000C8, "Member 'UUIMapMenu::WindowWorldMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, WindowTownMap) == 0x0000D0, "Member 'UUIMapMenu::WindowTownMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, WindowKeyGuide) == 0x0000D8, "Member 'UUIMapMenu::WindowKeyGuide' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, WindowFacility) == 0x0000E0, "Member 'UUIMapMenu::WindowFacility' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, ItemTreasureChest) == 0x0000E8, "Member 'UUIMapMenu::ItemTreasureChest' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, WindowMapGuide) == 0x0000F0, "Member 'UUIMapMenu::WindowMapGuide' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, TextureWorldMapAllAreaFrontWorld) == 0x0000F8, "Member 'UUIMapMenu::TextureWorldMapAllAreaFrontWorld' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, TextureWorldMapAllAreaUnderground) == 0x000100, "Member 'UUIMapMenu::TextureWorldMapAllAreaUnderground' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, TextureWorldMapAllAreaAliahan) == 0x000108, "Member 'UUIMapMenu::TextureWorldMapAllAreaAliahan' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, loadableTexture) == 0x000130, "Member 'UUIMapMenu::loadableTexture' has a wrong offset!");

// Class Nicola.UIMapMenuListParty
// 0x0020 (0x00F0 - 0x00D0)
class UUIMapMenuListParty final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuListParty">();
	}
	static class UUIMapMenuListParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuListParty>();
	}
};
static_assert(alignof(UUIMapMenuListParty) == 0x000008, "Wrong alignment on UUIMapMenuListParty");
static_assert(sizeof(UUIMapMenuListParty) == 0x0000F0, "Wrong size on UUIMapMenuListParty");

// Class Nicola.UIMapMenuListRura
// 0x0010 (0x00E0 - 0x00D0)
class UUIMapMenuListRura final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuListRura">();
	}
	static class UUIMapMenuListRura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuListRura>();
	}
};
static_assert(alignof(UUIMapMenuListRura) == 0x000008, "Wrong alignment on UUIMapMenuListRura");
static_assert(sizeof(UUIMapMenuListRura) == 0x0000E0, "Wrong size on UUIMapMenuListRura");

// Class Nicola.UIMapMenuListTop
// 0x0030 (0x0100 - 0x00D0)
class UUIMapMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuListTop">();
	}
	static class UUIMapMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuListTop>();
	}
};
static_assert(alignof(UUIMapMenuListTop) == 0x000008, "Wrong alignment on UUIMapMenuListTop");
static_assert(sizeof(UUIMapMenuListTop) == 0x000100, "Wrong size on UUIMapMenuListTop");

// Class Nicola.UIMapMenuWindowFacility
// 0x0010 (0x0068 - 0x0058)
class UUIMapMenuWindowFacility final : public UUIWindowBase
{
public:
	TArray<class UImage*>                         ImageIcons;                                        // 0x0058(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuWindowFacility">();
	}
	static class UUIMapMenuWindowFacility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuWindowFacility>();
	}
};
static_assert(alignof(UUIMapMenuWindowFacility) == 0x000008, "Wrong alignment on UUIMapMenuWindowFacility");
static_assert(sizeof(UUIMapMenuWindowFacility) == 0x000068, "Wrong size on UUIMapMenuWindowFacility");
static_assert(offsetof(UUIMapMenuWindowFacility, ImageIcons) == 0x000058, "Member 'UUIMapMenuWindowFacility::ImageIcons' has a wrong offset!");

// Class Nicola.UIMapMenuWindowTownMap
// 0x0090 (0x00E8 - 0x0058)
class UUIMapMenuWindowTownMap final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIListItemTownMapLabel*                ItemLabel;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemTownMapArrow*                ItemArrow;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap;                                          // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasMap;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasIcon;                                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageFacilityIcons;                                // 0x0088(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImagePlayerIcon;                                   // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageTargetIcons;                                  // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageTimeFrame;                                    // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuWindowTownMap">();
	}
	static class UUIMapMenuWindowTownMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuWindowTownMap>();
	}
};
static_assert(alignof(UUIMapMenuWindowTownMap) == 0x000008, "Wrong alignment on UUIMapMenuWindowTownMap");
static_assert(sizeof(UUIMapMenuWindowTownMap) == 0x0000E8, "Wrong size on UUIMapMenuWindowTownMap");
static_assert(offsetof(UUIMapMenuWindowTownMap, ItemLabel) == 0x000060, "Member 'UUIMapMenuWindowTownMap::ItemLabel' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, ItemArrow) == 0x000068, "Member 'UUIMapMenuWindowTownMap::ItemArrow' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, ImageMap) == 0x000070, "Member 'UUIMapMenuWindowTownMap::ImageMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, CanvasMap) == 0x000078, "Member 'UUIMapMenuWindowTownMap::CanvasMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, CanvasIcon) == 0x000080, "Member 'UUIMapMenuWindowTownMap::CanvasIcon' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, ImageFacilityIcons) == 0x000088, "Member 'UUIMapMenuWindowTownMap::ImageFacilityIcons' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, ImagePlayerIcon) == 0x000098, "Member 'UUIMapMenuWindowTownMap::ImagePlayerIcon' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, ImageTargetIcons) == 0x0000A0, "Member 'UUIMapMenuWindowTownMap::ImageTargetIcons' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowTownMap, ImageTimeFrame) == 0x0000B0, "Member 'UUIMapMenuWindowTownMap::ImageTimeFrame' has a wrong offset!");

// Class Nicola.UIMapMenuWindowWorldMap
// 0x02F0 (0x0348 - 0x0058)
class UUIMapMenuWindowWorldMap final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           CanvasIcon;                                        // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImagePlayer;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageTownIcons;                                    // 0x0078(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageDungeonIcons;                                 // 0x0088(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageTargetIcons;                                  // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageVehicleShip;                                  // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageVehicleLamia;                                 // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageVehicleGhostShip;                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ImageEchoFluteIcons;                               // 0x00C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasTown;                                        // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasDungeon;                                     // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageCursor;                                       // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap;                                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap2;                                         // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMap3;                                         // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasMap;                                         // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIListItemTownMapArrow*                ItemArrow;                                         // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UImage*>              TownIconMap;                                       // 0x0110(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, class UImage*>              DungeonIconMap;                                    // 0x0160(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageTimeFrame;                                    // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMiniMapMenuWindowDrawMap*            WindowDetails;                                     // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x20];                                     // 0x01C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMiniMapDrawIconData                   drawIconDataPlayer;                                // 0x01E0(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataLocation;                              // 0x0228(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataTarget;                                // 0x0238(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconDataShip;                                  // 0x0248(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconDataLamia;                                 // 0x0290(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconDataGhostShip;                             // 0x02D8(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDataEchoFlute;                             // 0x0320(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenuWindowWorldMap">();
	}
	static class UUIMapMenuWindowWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenuWindowWorldMap>();
	}
};
static_assert(alignof(UUIMapMenuWindowWorldMap) == 0x000008, "Wrong alignment on UUIMapMenuWindowWorldMap");
static_assert(sizeof(UUIMapMenuWindowWorldMap) == 0x000348, "Wrong size on UUIMapMenuWindowWorldMap");
static_assert(offsetof(UUIMapMenuWindowWorldMap, CanvasIcon) == 0x000068, "Member 'UUIMapMenuWindowWorldMap::CanvasIcon' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImagePlayer) == 0x000070, "Member 'UUIMapMenuWindowWorldMap::ImagePlayer' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageTownIcons) == 0x000078, "Member 'UUIMapMenuWindowWorldMap::ImageTownIcons' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageDungeonIcons) == 0x000088, "Member 'UUIMapMenuWindowWorldMap::ImageDungeonIcons' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageTargetIcons) == 0x000098, "Member 'UUIMapMenuWindowWorldMap::ImageTargetIcons' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageVehicleShip) == 0x0000A8, "Member 'UUIMapMenuWindowWorldMap::ImageVehicleShip' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageVehicleLamia) == 0x0000B0, "Member 'UUIMapMenuWindowWorldMap::ImageVehicleLamia' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageVehicleGhostShip) == 0x0000B8, "Member 'UUIMapMenuWindowWorldMap::ImageVehicleGhostShip' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageEchoFluteIcons) == 0x0000C0, "Member 'UUIMapMenuWindowWorldMap::ImageEchoFluteIcons' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, CanvasTown) == 0x0000D0, "Member 'UUIMapMenuWindowWorldMap::CanvasTown' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, CanvasDungeon) == 0x0000D8, "Member 'UUIMapMenuWindowWorldMap::CanvasDungeon' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageCursor) == 0x0000E0, "Member 'UUIMapMenuWindowWorldMap::ImageCursor' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageMap) == 0x0000E8, "Member 'UUIMapMenuWindowWorldMap::ImageMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageMap2) == 0x0000F0, "Member 'UUIMapMenuWindowWorldMap::ImageMap2' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageMap3) == 0x0000F8, "Member 'UUIMapMenuWindowWorldMap::ImageMap3' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, CanvasMap) == 0x000100, "Member 'UUIMapMenuWindowWorldMap::CanvasMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ItemArrow) == 0x000108, "Member 'UUIMapMenuWindowWorldMap::ItemArrow' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, TownIconMap) == 0x000110, "Member 'UUIMapMenuWindowWorldMap::TownIconMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, DungeonIconMap) == 0x000160, "Member 'UUIMapMenuWindowWorldMap::DungeonIconMap' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, ImageTimeFrame) == 0x0001B0, "Member 'UUIMapMenuWindowWorldMap::ImageTimeFrame' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, WindowDetails) == 0x0001B8, "Member 'UUIMapMenuWindowWorldMap::WindowDetails' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataPlayer) == 0x0001E0, "Member 'UUIMapMenuWindowWorldMap::drawIconDataPlayer' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataLocation) == 0x000228, "Member 'UUIMapMenuWindowWorldMap::drawIconDataLocation' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataTarget) == 0x000238, "Member 'UUIMapMenuWindowWorldMap::drawIconDataTarget' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataShip) == 0x000248, "Member 'UUIMapMenuWindowWorldMap::drawIconDataShip' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataLamia) == 0x000290, "Member 'UUIMapMenuWindowWorldMap::drawIconDataLamia' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataGhostShip) == 0x0002D8, "Member 'UUIMapMenuWindowWorldMap::drawIconDataGhostShip' has a wrong offset!");
static_assert(offsetof(UUIMapMenuWindowWorldMap, drawIconDataEchoFlute) == 0x000320, "Member 'UUIMapMenuWindowWorldMap::drawIconDataEchoFlute' has a wrong offset!");

// Class Nicola.UIMBRBattleEncountMenu
// 0x0018 (0x0090 - 0x0078)
class UUIMBRBattleEncountMenu final : public UUIRootBase
{
public:
	class UUIMBRBattleEncountMenuWindow*          Window;                                            // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonWindowWidget*                    Render;                                            // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleEncountMenu">();
	}
	static class UUIMBRBattleEncountMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleEncountMenu>();
	}
};
static_assert(alignof(UUIMBRBattleEncountMenu) == 0x000008, "Wrong alignment on UUIMBRBattleEncountMenu");
static_assert(sizeof(UUIMBRBattleEncountMenu) == 0x000090, "Wrong size on UUIMBRBattleEncountMenu");
static_assert(offsetof(UUIMBRBattleEncountMenu, Window) == 0x000078, "Member 'UUIMBRBattleEncountMenu::Window' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleEncountMenu, Render) == 0x000080, "Member 'UUIMBRBattleEncountMenu::Render' has a wrong offset!");

// Class Nicola.UIMBRBattleListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIMBRBattleListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleListTop">();
	}
	static class UUIMBRBattleListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleListTop>();
	}
};
static_assert(alignof(UUIMBRBattleListTop) == 0x000008, "Wrong alignment on UUIMBRBattleListTop");
static_assert(sizeof(UUIMBRBattleListTop) == 0x0000D8, "Wrong size on UUIMBRBattleListTop");

// Class Nicola.UIMBRBattleMenu
// 0x0028 (0x00A0 - 0x0078)
class UUIMBRBattleMenu final : public UUIRootBase
{
public:
	class UUIMBRBattleListTop*                    ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRBattleTacticsListUnit*            TacticsListUnit;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleTacticsListTactics*            TacticsListTactics;                                // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleTacticsWindowTactics*          TacticsWindowTactics;                              // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleMenu">();
	}
	static class UUIMBRBattleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleMenu>();
	}
};
static_assert(alignof(UUIMBRBattleMenu) == 0x000008, "Wrong alignment on UUIMBRBattleMenu");
static_assert(sizeof(UUIMBRBattleMenu) == 0x0000A0, "Wrong size on UUIMBRBattleMenu");
static_assert(offsetof(UUIMBRBattleMenu, ListTop) == 0x000078, "Member 'UUIMBRBattleMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleMenu, TacticsListUnit) == 0x000080, "Member 'UUIMBRBattleMenu::TacticsListUnit' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleMenu, TacticsListTactics) == 0x000088, "Member 'UUIMBRBattleMenu::TacticsListTactics' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleMenu, TacticsWindowTactics) == 0x000090, "Member 'UUIMBRBattleMenu::TacticsWindowTactics' has a wrong offset!");

// Class Nicola.UIMBRBattleStatus
// 0x0030 (0x00A8 - 0x0078)
class UUIMBRBattleStatus final : public UUIRootBase
{
public:
	class UUIMBRBattleWindowInfo*                 WindowInfo;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRBattleWindowStatus*               WindowStatus;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleMonsterName*                   MonsterName;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleDamage*                        MonsterDamage;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleDamage*                        PlayerDamage;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleSpeedController*               SpeedController;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleStatus">();
	}
	static class UUIMBRBattleStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleStatus>();
	}
};
static_assert(alignof(UUIMBRBattleStatus) == 0x000008, "Wrong alignment on UUIMBRBattleStatus");
static_assert(sizeof(UUIMBRBattleStatus) == 0x0000A8, "Wrong size on UUIMBRBattleStatus");
static_assert(offsetof(UUIMBRBattleStatus, WindowInfo) == 0x000078, "Member 'UUIMBRBattleStatus::WindowInfo' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleStatus, WindowStatus) == 0x000080, "Member 'UUIMBRBattleStatus::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleStatus, MonsterName) == 0x000088, "Member 'UUIMBRBattleStatus::MonsterName' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleStatus, MonsterDamage) == 0x000090, "Member 'UUIMBRBattleStatus::MonsterDamage' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleStatus, PlayerDamage) == 0x000098, "Member 'UUIMBRBattleStatus::PlayerDamage' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleStatus, SpeedController) == 0x0000A0, "Member 'UUIMBRBattleStatus::SpeedController' has a wrong offset!");

// Class Nicola.UIMBRBattleWindowInfo
// 0x0008 (0x0060 - 0x0058)
class UUIMBRBattleWindowInfo final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleWindowInfo">();
	}
	static class UUIMBRBattleWindowInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleWindowInfo>();
	}
};
static_assert(alignof(UUIMBRBattleWindowInfo) == 0x000008, "Wrong alignment on UUIMBRBattleWindowInfo");
static_assert(sizeof(UUIMBRBattleWindowInfo) == 0x000060, "Wrong size on UUIMBRBattleWindowInfo");
static_assert(offsetof(UUIMBRBattleWindowInfo, TextItem) == 0x000058, "Member 'UUIMBRBattleWindowInfo::TextItem' has a wrong offset!");

// Class Nicola.UIMBRBattleWindowStatus
// 0x0020 (0x0090 - 0x0070)
class UUIMBRBattleWindowStatus final : public UUICtrlBase
{
public:
	TArray<class UUIMBRBattleWindowStatusPlayer*> Players;                                           // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIBattleStatusIconCtrl*                StatusIconCtrl;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleWindowStatus">();
	}
	static class UUIMBRBattleWindowStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleWindowStatus>();
	}
};
static_assert(alignof(UUIMBRBattleWindowStatus) == 0x000008, "Wrong alignment on UUIMBRBattleWindowStatus");
static_assert(sizeof(UUIMBRBattleWindowStatus) == 0x000090, "Wrong size on UUIMBRBattleWindowStatus");
static_assert(offsetof(UUIMBRBattleWindowStatus, Players) == 0x000070, "Member 'UUIMBRBattleWindowStatus::Players' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatus, StatusIconCtrl) == 0x000080, "Member 'UUIMBRBattleWindowStatus::StatusIconCtrl' has a wrong offset!");

// Class Nicola.UIMBRBattleWindowStatusPlayer
// 0x0068 (0x00C0 - 0x0058)
class UUIMBRBattleWindowStatusPlayer final : public UUIWindowBase
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextItem;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlipbookWidget*                        flipbook;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextHPValue;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageHP;                                           // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextMPValue;                                       // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageMP;                                           // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBattleStatusIcon*                    StatusIcon;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 TargetBG;                                          // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCanvasPanelSlot*>               SlotDamages;                                       // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRBattleWindowStatusPlayer">();
	}
	static class UUIMBRBattleWindowStatusPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRBattleWindowStatusPlayer>();
	}
};
static_assert(alignof(UUIMBRBattleWindowStatusPlayer) == 0x000008, "Wrong alignment on UUIMBRBattleWindowStatusPlayer");
static_assert(sizeof(UUIMBRBattleWindowStatusPlayer) == 0x0000C0, "Wrong size on UUIMBRBattleWindowStatusPlayer");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, CanvasPanel) == 0x000058, "Member 'UUIMBRBattleWindowStatusPlayer::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, TextItem) == 0x000060, "Member 'UUIMBRBattleWindowStatusPlayer::TextItem' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, flipbook) == 0x000068, "Member 'UUIMBRBattleWindowStatusPlayer::flipbook' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, TextHPValue) == 0x000070, "Member 'UUIMBRBattleWindowStatusPlayer::TextHPValue' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, ImageHP) == 0x000078, "Member 'UUIMBRBattleWindowStatusPlayer::ImageHP' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, TextMPValue) == 0x000080, "Member 'UUIMBRBattleWindowStatusPlayer::TextMPValue' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, ImageMP) == 0x000088, "Member 'UUIMBRBattleWindowStatusPlayer::ImageMP' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, StatusIcon) == 0x000090, "Member 'UUIMBRBattleWindowStatusPlayer::StatusIcon' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, TargetBG) == 0x000098, "Member 'UUIMBRBattleWindowStatusPlayer::TargetBG' has a wrong offset!");
static_assert(offsetof(UUIMBRBattleWindowStatusPlayer, SlotDamages) == 0x0000A0, "Member 'UUIMBRBattleWindowStatusPlayer::SlotDamages' has a wrong offset!");

// Class Nicola.UIMBRCommonListMonster
// 0x0008 (0x00D8 - 0x00D0)
class UUIMBRCommonListMonster final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonListMonster">();
	}
	static class UUIMBRCommonListMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonListMonster>();
	}
};
static_assert(alignof(UUIMBRCommonListMonster) == 0x000008, "Wrong alignment on UUIMBRCommonListMonster");
static_assert(sizeof(UUIMBRCommonListMonster) == 0x0000D8, "Wrong size on UUIMBRCommonListMonster");

// Class Nicola.UIMBRCommonListMonsterItem
// 0x0018 (0x0070 - 0x0058)
class UUIMBRCommonListMonsterItem final : public UUIListItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonListMonsterItem">();
	}
	static class UUIMBRCommonListMonsterItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonListMonsterItem>();
	}
};
static_assert(alignof(UUIMBRCommonListMonsterItem) == 0x000008, "Wrong alignment on UUIMBRCommonListMonsterItem");
static_assert(sizeof(UUIMBRCommonListMonsterItem) == 0x000070, "Wrong size on UUIMBRCommonListMonsterItem");
static_assert(offsetof(UUIMBRCommonListMonsterItem, TextItem2) == 0x000058, "Member 'UUIMBRCommonListMonsterItem::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonListMonsterItem, TextItem3) == 0x000060, "Member 'UUIMBRCommonListMonsterItem::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonListMonsterItem, ItemIcon) == 0x000068, "Member 'UUIMBRCommonListMonsterItem::ItemIcon' has a wrong offset!");

// Class Nicola.UIMBRCommonWindowMagic
// 0x0008 (0x0060 - 0x0058)
class UUIMBRCommonWindowMagic final : public UUIWindowBase
{
public:
	class UUIMBRCommonWindowMagicItem*            ItemMagic;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonWindowMagic">();
	}
	static class UUIMBRCommonWindowMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonWindowMagic>();
	}
};
static_assert(alignof(UUIMBRCommonWindowMagic) == 0x000008, "Wrong alignment on UUIMBRCommonWindowMagic");
static_assert(sizeof(UUIMBRCommonWindowMagic) == 0x000060, "Wrong size on UUIMBRCommonWindowMagic");
static_assert(offsetof(UUIMBRCommonWindowMagic, ItemMagic) == 0x000058, "Member 'UUIMBRCommonWindowMagic::ItemMagic' has a wrong offset!");

// Class Nicola.UIMBRCommonWindowSort
// 0x0020 (0x0078 - 0x0058)
class UUIMBRCommonWindowSort final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          ItemText;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ItemButtonL;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ItemButtonR;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonWindowSort">();
	}
	static class UUIMBRCommonWindowSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonWindowSort>();
	}
};
static_assert(alignof(UUIMBRCommonWindowSort) == 0x000008, "Wrong alignment on UUIMBRCommonWindowSort");
static_assert(sizeof(UUIMBRCommonWindowSort) == 0x000078, "Wrong size on UUIMBRCommonWindowSort");
static_assert(offsetof(UUIMBRCommonWindowSort, ItemText) == 0x000058, "Member 'UUIMBRCommonWindowSort::ItemText' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowSort, ItemText2) == 0x000060, "Member 'UUIMBRCommonWindowSort::ItemText2' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowSort, ItemButtonL) == 0x000068, "Member 'UUIMBRCommonWindowSort::ItemButtonL' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowSort, ItemButtonR) == 0x000070, "Member 'UUIMBRCommonWindowSort::ItemButtonR' has a wrong offset!");

// Class Nicola.UIMBRCommonWindowSpecies
// 0x0030 (0x0088 - 0x0058)
class UUIMBRCommonWindowSpecies final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText2;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         ItemIcons;                                         // 0x0078(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonWindowSpecies">();
	}
	static class UUIMBRCommonWindowSpecies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonWindowSpecies>();
	}
};
static_assert(alignof(UUIMBRCommonWindowSpecies) == 0x000008, "Wrong alignment on UUIMBRCommonWindowSpecies");
static_assert(sizeof(UUIMBRCommonWindowSpecies) == 0x000088, "Wrong size on UUIMBRCommonWindowSpecies");
static_assert(offsetof(UUIMBRCommonWindowSpecies, WindowItems) == 0x000058, "Member 'UUIMBRCommonWindowSpecies::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowSpecies, ItemText) == 0x000068, "Member 'UUIMBRCommonWindowSpecies::ItemText' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowSpecies, ItemText2) == 0x000070, "Member 'UUIMBRCommonWindowSpecies::ItemText2' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowSpecies, ItemIcons) == 0x000078, "Member 'UUIMBRCommonWindowSpecies::ItemIcons' has a wrong offset!");

// Class Nicola.UIMBRCommonWindowStatus
// 0x0010 (0x0068 - 0x0058)
class UUIMBRCommonWindowStatus final : public UUIWindowBase
{
public:
	class UFlipbookWidget*                        flipbook;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowStatusItem*           ItemStatus;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRCommonWindowStatus">();
	}
	static class UUIMBRCommonWindowStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRCommonWindowStatus>();
	}
};
static_assert(alignof(UUIMBRCommonWindowStatus) == 0x000008, "Wrong alignment on UUIMBRCommonWindowStatus");
static_assert(sizeof(UUIMBRCommonWindowStatus) == 0x000068, "Wrong size on UUIMBRCommonWindowStatus");
static_assert(offsetof(UUIMBRCommonWindowStatus, flipbook) == 0x000058, "Member 'UUIMBRCommonWindowStatus::flipbook' has a wrong offset!");
static_assert(offsetof(UUIMBRCommonWindowStatus, ItemStatus) == 0x000060, "Member 'UUIMBRCommonWindowStatus::ItemStatus' has a wrong offset!");

// Class Nicola.UIMBRDebugFL
// 0x0000 (0x0028 - 0x0028)
class UUIMBRDebugFL final : public UBlueprintFunctionLibrary
{
public:
	static void DEBUG_AddUnscoutedSpecies();
	static void DEBUG_ClearBattleRoadRank();
	static void DEBUG_PrepareForEntry();
	static void DEBUG_PrepareForInfo();
	static void DEBUG_PrepareForZoo();
	static void DEBUG_ScoutAllMonsters();
	static void DEBUG_SetBattleRoadData();
	static void DEBUG_SetupForEntry();
	static void DEBUG_SetupForResult(bool InWin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRDebugFL">();
	}
	static class UUIMBRDebugFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRDebugFL>();
	}
};
static_assert(alignof(UUIMBRDebugFL) == 0x000008, "Wrong alignment on UUIMBRDebugFL");
static_assert(sizeof(UUIMBRDebugFL) == 0x000028, "Wrong size on UUIMBRDebugFL");

// Class Nicola.UIMBREntryMenu
// 0x0090 (0x0108 - 0x0078)
class UUIMBREntryMenu final : public UUIRootBase
{
public:
	class UUIMBREntryMenuListRank*                ListRank;                                          // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuListParty*               ListParty;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuListEntry*               ListEntry;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuWindowReward*            WindowReward;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuWindowDisp*              WindowDisp;                                        // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuWindowGuide*             WindowGuide;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuWindowEntry*             WindowEntry;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuFlowStartMatch*          FlowStartMatch;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBREntryMenuFlowResult*              FlowResult;                                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonListMonster*                ListMonster;                                       // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowSort*                 WindowSort;                                        // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowStatus*               WindowStatus;                                      // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowMagic*                WindowMagic;                                       // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowSpecies*              WindowSpecies;                                     // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonFlowReward*                 FlowReward;                                        // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenuForEntry(class FName InName);
	static void OpenMenuForResult();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenu">();
	}
	static class UUIMBREntryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenu>();
	}
};
static_assert(alignof(UUIMBREntryMenu) == 0x000008, "Wrong alignment on UUIMBREntryMenu");
static_assert(sizeof(UUIMBREntryMenu) == 0x000108, "Wrong size on UUIMBREntryMenu");
static_assert(offsetof(UUIMBREntryMenu, ListRank) == 0x000078, "Member 'UUIMBREntryMenu::ListRank' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, ListParty) == 0x000080, "Member 'UUIMBREntryMenu::ListParty' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, ListEntry) == 0x000088, "Member 'UUIMBREntryMenu::ListEntry' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowReward) == 0x000090, "Member 'UUIMBREntryMenu::WindowReward' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowDisp) == 0x000098, "Member 'UUIMBREntryMenu::WindowDisp' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowGuide) == 0x0000A0, "Member 'UUIMBREntryMenu::WindowGuide' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowEntry) == 0x0000A8, "Member 'UUIMBREntryMenu::WindowEntry' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, FlowStartMatch) == 0x0000B0, "Member 'UUIMBREntryMenu::FlowStartMatch' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, FlowResult) == 0x0000B8, "Member 'UUIMBREntryMenu::FlowResult' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, ListMonster) == 0x0000C0, "Member 'UUIMBREntryMenu::ListMonster' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowSort) == 0x0000C8, "Member 'UUIMBREntryMenu::WindowSort' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowStatus) == 0x0000D0, "Member 'UUIMBREntryMenu::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowMagic) == 0x0000D8, "Member 'UUIMBREntryMenu::WindowMagic' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, WindowSpecies) == 0x0000E0, "Member 'UUIMBREntryMenu::WindowSpecies' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenu, FlowReward) == 0x0000E8, "Member 'UUIMBREntryMenu::FlowReward' has a wrong offset!");

// Class Nicola.UIMBREntryMenuFlowResult
// 0x0010 (0x0080 - 0x0070)
class UUIMBREntryMenuFlowResult final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuFlowResult">();
	}
	static class UUIMBREntryMenuFlowResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuFlowResult>();
	}
};
static_assert(alignof(UUIMBREntryMenuFlowResult) == 0x000008, "Wrong alignment on UUIMBREntryMenuFlowResult");
static_assert(sizeof(UUIMBREntryMenuFlowResult) == 0x000080, "Wrong size on UUIMBREntryMenuFlowResult");

// Class Nicola.UIMBREntryMenuListEntry
// 0x0000 (0x00D0 - 0x00D0)
class UUIMBREntryMenuListEntry final : public UUIListPage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuListEntry">();
	}
	static class UUIMBREntryMenuListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuListEntry>();
	}
};
static_assert(alignof(UUIMBREntryMenuListEntry) == 0x000008, "Wrong alignment on UUIMBREntryMenuListEntry");
static_assert(sizeof(UUIMBREntryMenuListEntry) == 0x0000D0, "Wrong size on UUIMBREntryMenuListEntry");

// Class Nicola.UIMBREntryMenuListParty
// 0x0008 (0x00F0 - 0x00E8)
class UUIMBREntryMenuListParty final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuListParty">();
	}
	static class UUIMBREntryMenuListParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuListParty>();
	}
};
static_assert(alignof(UUIMBREntryMenuListParty) == 0x000008, "Wrong alignment on UUIMBREntryMenuListParty");
static_assert(sizeof(UUIMBREntryMenuListParty) == 0x0000F0, "Wrong size on UUIMBREntryMenuListParty");

// Class Nicola.UIMBREntryMenuListPartyItem
// 0x0018 (0x0070 - 0x0058)
class UUIMBREntryMenuListPartyItem final : public UUIListItem
{
public:
	class UFlipbookWidget*                        flipbook;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMBRCommonWindowStatusItem*           ItemStatus;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMBRCommonWindowMagicItem*            ItemMagic;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuListPartyItem">();
	}
	static class UUIMBREntryMenuListPartyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuListPartyItem>();
	}
};
static_assert(alignof(UUIMBREntryMenuListPartyItem) == 0x000008, "Wrong alignment on UUIMBREntryMenuListPartyItem");
static_assert(sizeof(UUIMBREntryMenuListPartyItem) == 0x000070, "Wrong size on UUIMBREntryMenuListPartyItem");
static_assert(offsetof(UUIMBREntryMenuListPartyItem, flipbook) == 0x000058, "Member 'UUIMBREntryMenuListPartyItem::flipbook' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuListPartyItem, ItemStatus) == 0x000060, "Member 'UUIMBREntryMenuListPartyItem::ItemStatus' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuListPartyItem, ItemMagic) == 0x000068, "Member 'UUIMBREntryMenuListPartyItem::ItemMagic' has a wrong offset!");

// Class Nicola.UIWindowItemMoney
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemMoney final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemMoney">();
	}
	static class UUIWindowItemMoney* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemMoney>();
	}
};
static_assert(alignof(UUIWindowItemMoney) == 0x000008, "Wrong alignment on UUIWindowItemMoney");
static_assert(sizeof(UUIWindowItemMoney) == 0x000048, "Wrong size on UUIWindowItemMoney");
static_assert(offsetof(UUIWindowItemMoney, TextItem2) == 0x000040, "Member 'UUIWindowItemMoney::TextItem2' has a wrong offset!");

// Class Nicola.UIMBREntryMenuListRankItem
// 0x0018 (0x0070 - 0x0058)
class UUIMBREntryMenuListRankItem final : public UUIListItem
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuListRankItem">();
	}
	static class UUIMBREntryMenuListRankItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuListRankItem>();
	}
};
static_assert(alignof(UUIMBREntryMenuListRankItem) == 0x000008, "Wrong alignment on UUIMBREntryMenuListRankItem");
static_assert(sizeof(UUIMBREntryMenuListRankItem) == 0x000070, "Wrong size on UUIMBREntryMenuListRankItem");
static_assert(offsetof(UUIMBREntryMenuListRankItem, ImageIcon) == 0x000058, "Member 'UUIMBREntryMenuListRankItem::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuListRankItem, TextItem2) == 0x000060, "Member 'UUIMBREntryMenuListRankItem::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuListRankItem, TextItem3) == 0x000068, "Member 'UUIMBREntryMenuListRankItem::TextItem3' has a wrong offset!");

// Class Nicola.UIMBREntryMenuWindowDisp
// 0x0020 (0x0078 - 0x0058)
class UUIMBREntryMenuWindowDisp final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          ItemText;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ItemButtonL;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ItemButtonR;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuWindowDisp">();
	}
	static class UUIMBREntryMenuWindowDisp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuWindowDisp>();
	}
};
static_assert(alignof(UUIMBREntryMenuWindowDisp) == 0x000008, "Wrong alignment on UUIMBREntryMenuWindowDisp");
static_assert(sizeof(UUIMBREntryMenuWindowDisp) == 0x000078, "Wrong size on UUIMBREntryMenuWindowDisp");
static_assert(offsetof(UUIMBREntryMenuWindowDisp, ItemText) == 0x000058, "Member 'UUIMBREntryMenuWindowDisp::ItemText' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowDisp, ItemText2) == 0x000060, "Member 'UUIMBREntryMenuWindowDisp::ItemText2' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowDisp, ItemButtonL) == 0x000068, "Member 'UUIMBREntryMenuWindowDisp::ItemButtonL' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowDisp, ItemButtonR) == 0x000070, "Member 'UUIMBREntryMenuWindowDisp::ItemButtonR' has a wrong offset!");

// Class Nicola.UIMBREntryMenuWindowEntry
// 0x0010 (0x0068 - 0x0058)
class UUIMBREntryMenuWindowEntry final : public UUIWindowBase
{
public:
	TArray<class UUIMBREntryMenuWindowEntryItem*> WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuWindowEntry">();
	}
	static class UUIMBREntryMenuWindowEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuWindowEntry>();
	}
};
static_assert(alignof(UUIMBREntryMenuWindowEntry) == 0x000008, "Wrong alignment on UUIMBREntryMenuWindowEntry");
static_assert(sizeof(UUIMBREntryMenuWindowEntry) == 0x000068, "Wrong size on UUIMBREntryMenuWindowEntry");
static_assert(offsetof(UUIMBREntryMenuWindowEntry, WindowItems) == 0x000058, "Member 'UUIMBREntryMenuWindowEntry::WindowItems' has a wrong offset!");

// Class Nicola.UIMBREntryMenuWindowEntryItem
// 0x0008 (0x0048 - 0x0040)
class UUIMBREntryMenuWindowEntryItem final : public UUIWindowItem
{
public:
	class UFlipbookWidget*                        flipbook;                                          // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuWindowEntryItem">();
	}
	static class UUIMBREntryMenuWindowEntryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuWindowEntryItem>();
	}
};
static_assert(alignof(UUIMBREntryMenuWindowEntryItem) == 0x000008, "Wrong alignment on UUIMBREntryMenuWindowEntryItem");
static_assert(sizeof(UUIMBREntryMenuWindowEntryItem) == 0x000048, "Wrong size on UUIMBREntryMenuWindowEntryItem");
static_assert(offsetof(UUIMBREntryMenuWindowEntryItem, flipbook) == 0x000040, "Member 'UUIMBREntryMenuWindowEntryItem::flipbook' has a wrong offset!");

// Class Nicola.UIWindowItemPage
// 0x0040 (0x0080 - 0x0040)
class UUIWindowItemPage final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextValue1;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextValue2;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowL;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageArrowR;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNicolaRichTextBlock*                   TextRich;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextGop;                                           // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemPage">();
	}
	static class UUIWindowItemPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemPage>();
	}
};
static_assert(alignof(UUIWindowItemPage) == 0x000008, "Wrong alignment on UUIWindowItemPage");
static_assert(sizeof(UUIWindowItemPage) == 0x000080, "Wrong size on UUIWindowItemPage");
static_assert(offsetof(UUIWindowItemPage, TextValue1) == 0x000040, "Member 'UUIWindowItemPage::TextValue1' has a wrong offset!");
static_assert(offsetof(UUIWindowItemPage, TextValue2) == 0x000048, "Member 'UUIWindowItemPage::TextValue2' has a wrong offset!");
static_assert(offsetof(UUIWindowItemPage, TextSlash) == 0x000050, "Member 'UUIWindowItemPage::TextSlash' has a wrong offset!");
static_assert(offsetof(UUIWindowItemPage, ImageArrowL) == 0x000058, "Member 'UUIWindowItemPage::ImageArrowL' has a wrong offset!");
static_assert(offsetof(UUIWindowItemPage, ImageArrowR) == 0x000060, "Member 'UUIWindowItemPage::ImageArrowR' has a wrong offset!");
static_assert(offsetof(UUIWindowItemPage, TextRich) == 0x000068, "Member 'UUIWindowItemPage::TextRich' has a wrong offset!");
static_assert(offsetof(UUIWindowItemPage, TextGop) == 0x000070, "Member 'UUIWindowItemPage::TextGop' has a wrong offset!");

// Class Nicola.UIMBREntryMenuWindowGuide
// 0x0010 (0x0068 - 0x0058)
class UUIMBREntryMenuWindowGuide final : public UUIWindowBase
{
public:
	class UUIWindowItemButtonIcon*                ItemButton;                                        // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuWindowGuide">();
	}
	static class UUIMBREntryMenuWindowGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuWindowGuide>();
	}
};
static_assert(alignof(UUIMBREntryMenuWindowGuide) == 0x000008, "Wrong alignment on UUIMBREntryMenuWindowGuide");
static_assert(sizeof(UUIMBREntryMenuWindowGuide) == 0x000068, "Wrong size on UUIMBREntryMenuWindowGuide");
static_assert(offsetof(UUIMBREntryMenuWindowGuide, ItemButton) == 0x000058, "Member 'UUIMBREntryMenuWindowGuide::ItemButton' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowGuide, ItemText) == 0x000060, "Member 'UUIMBREntryMenuWindowGuide::ItemText' has a wrong offset!");

// Class Nicola.UIMBREntryMenuWindowReward
// 0x0020 (0x0078 - 0x0058)
class UUIMBREntryMenuWindowReward final : public UUIWindowBase
{
public:
	TArray<class UUIMBREntryMenuWindowRewardItem*> WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIWindowItemText3*                     ItemPrize;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemPage*                      ItemPage;                                          // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuWindowReward">();
	}
	static class UUIMBREntryMenuWindowReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuWindowReward>();
	}
};
static_assert(alignof(UUIMBREntryMenuWindowReward) == 0x000008, "Wrong alignment on UUIMBREntryMenuWindowReward");
static_assert(sizeof(UUIMBREntryMenuWindowReward) == 0x000078, "Wrong size on UUIMBREntryMenuWindowReward");
static_assert(offsetof(UUIMBREntryMenuWindowReward, WindowItems) == 0x000058, "Member 'UUIMBREntryMenuWindowReward::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowReward, ItemPrize) == 0x000068, "Member 'UUIMBREntryMenuWindowReward::ItemPrize' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowReward, ItemPage) == 0x000070, "Member 'UUIMBREntryMenuWindowReward::ItemPage' has a wrong offset!");

// Class Nicola.UIMBREntryMenuWindowRewardItem
// 0x0018 (0x0058 - 0x0040)
class UUIMBREntryMenuWindowRewardItem final : public UUIWindowItem
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBREntryMenuWindowRewardItem">();
	}
	static class UUIMBREntryMenuWindowRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBREntryMenuWindowRewardItem>();
	}
};
static_assert(alignof(UUIMBREntryMenuWindowRewardItem) == 0x000008, "Wrong alignment on UUIMBREntryMenuWindowRewardItem");
static_assert(sizeof(UUIMBREntryMenuWindowRewardItem) == 0x000058, "Wrong size on UUIMBREntryMenuWindowRewardItem");
static_assert(offsetof(UUIMBREntryMenuWindowRewardItem, ItemIcon) == 0x000040, "Member 'UUIMBREntryMenuWindowRewardItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowRewardItem, TextItem2) == 0x000048, "Member 'UUIMBREntryMenuWindowRewardItem::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIMBREntryMenuWindowRewardItem, TextItem3) == 0x000050, "Member 'UUIMBREntryMenuWindowRewardItem::TextItem3' has a wrong offset!");

// Class Nicola.UIMBRInfoMenu
// 0x0028 (0x00A0 - 0x0078)
class UUIMBRInfoMenu final : public UUIRootBase
{
public:
	class UUIMBRInfoMenuListTop*                  ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRInfoMenu">();
	}
	static class UUIMBRInfoMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRInfoMenu>();
	}
};
static_assert(alignof(UUIMBRInfoMenu) == 0x000008, "Wrong alignment on UUIMBRInfoMenu");
static_assert(sizeof(UUIMBRInfoMenu) == 0x0000A0, "Wrong size on UUIMBRInfoMenu");
static_assert(offsetof(UUIMBRInfoMenu, ListTop) == 0x000078, "Member 'UUIMBRInfoMenu::ListTop' has a wrong offset!");

// Class Nicola.UIMBRInfoMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIMBRInfoMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRInfoMenuListTop">();
	}
	static class UUIMBRInfoMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRInfoMenuListTop>();
	}
};
static_assert(alignof(UUIMBRInfoMenuListTop) == 0x000008, "Wrong alignment on UUIMBRInfoMenuListTop");
static_assert(sizeof(UUIMBRInfoMenuListTop) == 0x0000D8, "Wrong size on UUIMBRInfoMenuListTop");

// Class Nicola.UIMBRRecruitMenu
// 0x0020 (0x0098 - 0x0078)
class UUIMBRRecruitMenu final : public UUIRootBase
{
public:
	class UUIMBRRecruitMenuWindowMessage*         WindowMessage;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRRecruitMenuWindowParam*           WindowParam;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRRecruitMenuWindowMonster*         WindowMonster;                                     // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRRecruitMenuWindowBreeder*         WindowBreeder;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void OpenMenu(class FName RecruitMonsterSpeciesID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRRecruitMenu">();
	}
	static class UUIMBRRecruitMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRRecruitMenu>();
	}
};
static_assert(alignof(UUIMBRRecruitMenu) == 0x000008, "Wrong alignment on UUIMBRRecruitMenu");
static_assert(sizeof(UUIMBRRecruitMenu) == 0x000098, "Wrong size on UUIMBRRecruitMenu");
static_assert(offsetof(UUIMBRRecruitMenu, WindowMessage) == 0x000078, "Member 'UUIMBRRecruitMenu::WindowMessage' has a wrong offset!");
static_assert(offsetof(UUIMBRRecruitMenu, WindowParam) == 0x000080, "Member 'UUIMBRRecruitMenu::WindowParam' has a wrong offset!");
static_assert(offsetof(UUIMBRRecruitMenu, WindowMonster) == 0x000088, "Member 'UUIMBRRecruitMenu::WindowMonster' has a wrong offset!");
static_assert(offsetof(UUIMBRRecruitMenu, WindowBreeder) == 0x000090, "Member 'UUIMBRRecruitMenu::WindowBreeder' has a wrong offset!");

// Class Nicola.UIMBRRecruitMenuWindowBreeder
// 0x0010 (0x0068 - 0x0058)
class UUIMBRRecruitMenuWindowBreeder final : public UUIWindowBase
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRRecruitMenuWindowBreeder">();
	}
	static class UUIMBRRecruitMenuWindowBreeder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRRecruitMenuWindowBreeder>();
	}
};
static_assert(alignof(UUIMBRRecruitMenuWindowBreeder) == 0x000008, "Wrong alignment on UUIMBRRecruitMenuWindowBreeder");
static_assert(sizeof(UUIMBRRecruitMenuWindowBreeder) == 0x000068, "Wrong size on UUIMBRRecruitMenuWindowBreeder");
static_assert(offsetof(UUIMBRRecruitMenuWindowBreeder, ImageIcon) == 0x000058, "Member 'UUIMBRRecruitMenuWindowBreeder::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUIMBRRecruitMenuWindowBreeder, ItemText) == 0x000060, "Member 'UUIMBRRecruitMenuWindowBreeder::ItemText' has a wrong offset!");

// Class Nicola.UIMBRRecruitMenuWindowMessage
// 0x0020 (0x0090 - 0x0070)
class UUIMBRRecruitMenuWindowMessage final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRRecruitMenuWindowMessage">();
	}
	static class UUIMBRRecruitMenuWindowMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRRecruitMenuWindowMessage>();
	}
};
static_assert(alignof(UUIMBRRecruitMenuWindowMessage) == 0x000008, "Wrong alignment on UUIMBRRecruitMenuWindowMessage");
static_assert(sizeof(UUIMBRRecruitMenuWindowMessage) == 0x000090, "Wrong size on UUIMBRRecruitMenuWindowMessage");

// Class Nicola.UIWindowItemTreasureChest
// 0x0000 (0x0040 - 0x0040)
class UUIWindowItemTreasureChest final : public UUIWindowItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemTreasureChest">();
	}
	static class UUIWindowItemTreasureChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemTreasureChest>();
	}
};
static_assert(alignof(UUIWindowItemTreasureChest) == 0x000008, "Wrong alignment on UUIWindowItemTreasureChest");
static_assert(sizeof(UUIWindowItemTreasureChest) == 0x000040, "Wrong size on UUIWindowItemTreasureChest");

// Class Nicola.UIMBRRecruitMenuWindowMonster
// 0x0018 (0x0070 - 0x0058)
class UUIMBRRecruitMenuWindowMonster final : public UUIWindowBase
{
public:
	class UFlipbookWidget*                        ImageMonster;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextGuide;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextMonster;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRRecruitMenuWindowMonster">();
	}
	static class UUIMBRRecruitMenuWindowMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRRecruitMenuWindowMonster>();
	}
};
static_assert(alignof(UUIMBRRecruitMenuWindowMonster) == 0x000008, "Wrong alignment on UUIMBRRecruitMenuWindowMonster");
static_assert(sizeof(UUIMBRRecruitMenuWindowMonster) == 0x000070, "Wrong size on UUIMBRRecruitMenuWindowMonster");
static_assert(offsetof(UUIMBRRecruitMenuWindowMonster, ImageMonster) == 0x000058, "Member 'UUIMBRRecruitMenuWindowMonster::ImageMonster' has a wrong offset!");
static_assert(offsetof(UUIMBRRecruitMenuWindowMonster, TextGuide) == 0x000060, "Member 'UUIMBRRecruitMenuWindowMonster::TextGuide' has a wrong offset!");
static_assert(offsetof(UUIMBRRecruitMenuWindowMonster, TextMonster) == 0x000068, "Member 'UUIMBRRecruitMenuWindowMonster::TextMonster' has a wrong offset!");

// Class Nicola.UIMBRRecruitMenuWindowParam
// 0x0008 (0x00F0 - 0x00E8)
class UUIMBRRecruitMenuWindowParam final : public UUIBattleResultMenuWindowParamBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRRecruitMenuWindowParam">();
	}
	static class UUIMBRRecruitMenuWindowParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRRecruitMenuWindowParam>();
	}
};
static_assert(alignof(UUIMBRRecruitMenuWindowParam) == 0x000008, "Wrong alignment on UUIMBRRecruitMenuWindowParam");
static_assert(sizeof(UUIMBRRecruitMenuWindowParam) == 0x0000F0, "Wrong size on UUIMBRRecruitMenuWindowParam");

// Class Nicola.UIMBRZooMenu
// 0x0050 (0x00C8 - 0x0078)
class UUIMBRZooMenu final : public UUIRootBase
{
public:
	class UUIMBRCommonListMonster*                ListMonster;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowSort*                 WindowSort;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowStatus*               WindowStatus;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowMagic*                WindowMagic;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonWindowSpecies*              WindowSpecies;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRCommonFlowReward*                 FlowReward_C;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMBRZooMenuFlowReward*                FlowReward_Z;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRZooMenu">();
	}
	static class UUIMBRZooMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRZooMenu>();
	}
};
static_assert(alignof(UUIMBRZooMenu) == 0x000008, "Wrong alignment on UUIMBRZooMenu");
static_assert(sizeof(UUIMBRZooMenu) == 0x0000C8, "Wrong size on UUIMBRZooMenu");
static_assert(offsetof(UUIMBRZooMenu, ListMonster) == 0x000078, "Member 'UUIMBRZooMenu::ListMonster' has a wrong offset!");
static_assert(offsetof(UUIMBRZooMenu, WindowSort) == 0x000080, "Member 'UUIMBRZooMenu::WindowSort' has a wrong offset!");
static_assert(offsetof(UUIMBRZooMenu, WindowStatus) == 0x000088, "Member 'UUIMBRZooMenu::WindowStatus' has a wrong offset!");
static_assert(offsetof(UUIMBRZooMenu, WindowMagic) == 0x000090, "Member 'UUIMBRZooMenu::WindowMagic' has a wrong offset!");
static_assert(offsetof(UUIMBRZooMenu, WindowSpecies) == 0x000098, "Member 'UUIMBRZooMenu::WindowSpecies' has a wrong offset!");
static_assert(offsetof(UUIMBRZooMenu, FlowReward_C) == 0x0000A0, "Member 'UUIMBRZooMenu::FlowReward_C' has a wrong offset!");
static_assert(offsetof(UUIMBRZooMenu, FlowReward_Z) == 0x0000A8, "Member 'UUIMBRZooMenu::FlowReward_Z' has a wrong offset!");

// Class Nicola.UIMBRZooMenuFlowReward
// 0x0008 (0x0078 - 0x0070)
class UUIMBRZooMenuFlowReward final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMBRZooMenuFlowReward">();
	}
	static class UUIMBRZooMenuFlowReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMBRZooMenuFlowReward>();
	}
};
static_assert(alignof(UUIMBRZooMenuFlowReward) == 0x000008, "Wrong alignment on UUIMBRZooMenuFlowReward");
static_assert(sizeof(UUIMBRZooMenuFlowReward) == 0x000078, "Wrong size on UUIMBRZooMenuFlowReward");

// Class Nicola.UIMedalRewardMenu
// 0x0018 (0x0090 - 0x0078)
class UUIMedalRewardMenu final : public UUIRootBase
{
public:
	class UUIMedalRewardMenuListTop*              ListReward;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMedalRewardMenuWindowSub*            WindowSub;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMedal*                     WindowMedal;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalRewardMenu">();
	}
	static class UUIMedalRewardMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalRewardMenu>();
	}
};
static_assert(alignof(UUIMedalRewardMenu) == 0x000008, "Wrong alignment on UUIMedalRewardMenu");
static_assert(sizeof(UUIMedalRewardMenu) == 0x000090, "Wrong size on UUIMedalRewardMenu");
static_assert(offsetof(UUIMedalRewardMenu, ListReward) == 0x000078, "Member 'UUIMedalRewardMenu::ListReward' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenu, WindowSub) == 0x000080, "Member 'UUIMedalRewardMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenu, WindowMedal) == 0x000088, "Member 'UUIMedalRewardMenu::WindowMedal' has a wrong offset!");

// Class Nicola.UIMedalRewardMenuListItemReward
// 0x0010 (0x0070 - 0x0060)
class UUIMedalRewardMenuListItemReward final : public UUIListItemIcon
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalRewardMenuListItemReward">();
	}
	static class UUIMedalRewardMenuListItemReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalRewardMenuListItemReward>();
	}
};
static_assert(alignof(UUIMedalRewardMenuListItemReward) == 0x000008, "Wrong alignment on UUIMedalRewardMenuListItemReward");
static_assert(sizeof(UUIMedalRewardMenuListItemReward) == 0x000070, "Wrong size on UUIMedalRewardMenuListItemReward");
static_assert(offsetof(UUIMedalRewardMenuListItemReward, TextItem2) == 0x000060, "Member 'UUIMedalRewardMenuListItemReward::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenuListItemReward, TextItem3) == 0x000068, "Member 'UUIMedalRewardMenuListItemReward::TextItem3' has a wrong offset!");

// Class Nicola.UIMedalRewardMenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUIMedalRewardMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalRewardMenuListTop">();
	}
	static class UUIMedalRewardMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalRewardMenuListTop>();
	}
};
static_assert(alignof(UUIMedalRewardMenuListTop) == 0x000008, "Wrong alignment on UUIMedalRewardMenuListTop");
static_assert(sizeof(UUIMedalRewardMenuListTop) == 0x0000E8, "Wrong size on UUIMedalRewardMenuListTop");

// Class Nicola.UIMedalRewardMenuItemSub
// 0x0028 (0x0080 - 0x0058)
class UUIMedalRewardMenuItemSub final : public UUIListItem
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem4;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalRewardMenuItemSub">();
	}
	static class UUIMedalRewardMenuItemSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalRewardMenuItemSub>();
	}
};
static_assert(alignof(UUIMedalRewardMenuItemSub) == 0x000008, "Wrong alignment on UUIMedalRewardMenuItemSub");
static_assert(sizeof(UUIMedalRewardMenuItemSub) == 0x000080, "Wrong size on UUIMedalRewardMenuItemSub");
static_assert(offsetof(UUIMedalRewardMenuItemSub, ItemIcon) == 0x000058, "Member 'UUIMedalRewardMenuItemSub::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenuItemSub, ItemIcon2) == 0x000060, "Member 'UUIMedalRewardMenuItemSub::ItemIcon2' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenuItemSub, TextItem2) == 0x000068, "Member 'UUIMedalRewardMenuItemSub::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenuItemSub, TextItem3) == 0x000070, "Member 'UUIMedalRewardMenuItemSub::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenuItemSub, TextItem4) == 0x000078, "Member 'UUIMedalRewardMenuItemSub::TextItem4' has a wrong offset!");

// Class Nicola.UIMedalRewardMenuWindowSub
// 0x0018 (0x0070 - 0x0058)
class UUIMedalRewardMenuWindowSub final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   ItemText;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIMedalRewardMenuItemSub*>      ItemStatus;                                        // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalRewardMenuWindowSub">();
	}
	static class UUIMedalRewardMenuWindowSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalRewardMenuWindowSub>();
	}
};
static_assert(alignof(UUIMedalRewardMenuWindowSub) == 0x000008, "Wrong alignment on UUIMedalRewardMenuWindowSub");
static_assert(sizeof(UUIMedalRewardMenuWindowSub) == 0x000070, "Wrong size on UUIMedalRewardMenuWindowSub");
static_assert(offsetof(UUIMedalRewardMenuWindowSub, ItemText) == 0x000058, "Member 'UUIMedalRewardMenuWindowSub::ItemText' has a wrong offset!");
static_assert(offsetof(UUIMedalRewardMenuWindowSub, ItemStatus) == 0x000060, "Member 'UUIMedalRewardMenuWindowSub::ItemStatus' has a wrong offset!");

// Class Nicola.UIMedalTradeMenu
// 0x0010 (0x0088 - 0x0078)
class UUIMedalTradeMenu final : public UUIRootBase
{
public:
	class UUIMedalTradeMenuWindowMessage*         WindowMessage;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMedal*                     WindowMedal;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void SetupDebugMedalCount(int32 TotalNum, int32 DepositeNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMedalTradeMenu">();
	}
	static class UUIMedalTradeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMedalTradeMenu>();
	}
};
static_assert(alignof(UUIMedalTradeMenu) == 0x000008, "Wrong alignment on UUIMedalTradeMenu");
static_assert(sizeof(UUIMedalTradeMenu) == 0x000088, "Wrong size on UUIMedalTradeMenu");
static_assert(offsetof(UUIMedalTradeMenu, WindowMessage) == 0x000078, "Member 'UUIMedalTradeMenu::WindowMessage' has a wrong offset!");
static_assert(offsetof(UUIMedalTradeMenu, WindowMedal) == 0x000080, "Member 'UUIMedalTradeMenu::WindowMedal' has a wrong offset!");

// Class Nicola.UIMemberCreateMenu
// 0x00A8 (0x0120 - 0x0078)
class UUIMemberCreateMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x40];                                      // 0x0078(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMemberCreateMenuListParty*           ListParty;                                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListMember*          ListMember;                                        // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListJob*             ListJob;                                           // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListStyle*           ListStyle;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListLooks*           ListLooks;                                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListColor*           ListColor;                                         // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListVoice*           ListVoice;                                         // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListSeed*            ListSeed;                                          // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuWindowEquip*                 ListEquip;                                         // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBar2MenuWindowStatus*                WindowStatusS;                                     // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsStatusMenuWindowData*    WindowStatusL;                                     // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuWindowInfo*          WindowUnitInfo;                                    // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowText*                          WindowSub;                                         // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenu">();
	}
	static class UUIMemberCreateMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenu>();
	}
};
static_assert(alignof(UUIMemberCreateMenu) == 0x000008, "Wrong alignment on UUIMemberCreateMenu");
static_assert(sizeof(UUIMemberCreateMenu) == 0x000120, "Wrong size on UUIMemberCreateMenu");
static_assert(offsetof(UUIMemberCreateMenu, ListParty) == 0x0000B8, "Member 'UUIMemberCreateMenu::ListParty' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListMember) == 0x0000C0, "Member 'UUIMemberCreateMenu::ListMember' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListJob) == 0x0000C8, "Member 'UUIMemberCreateMenu::ListJob' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListStyle) == 0x0000D0, "Member 'UUIMemberCreateMenu::ListStyle' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListLooks) == 0x0000D8, "Member 'UUIMemberCreateMenu::ListLooks' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListColor) == 0x0000E0, "Member 'UUIMemberCreateMenu::ListColor' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListVoice) == 0x0000E8, "Member 'UUIMemberCreateMenu::ListVoice' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListSeed) == 0x0000F0, "Member 'UUIMemberCreateMenu::ListSeed' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, ListEquip) == 0x0000F8, "Member 'UUIMemberCreateMenu::ListEquip' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, WindowStatusS) == 0x000100, "Member 'UUIMemberCreateMenu::WindowStatusS' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, WindowStatusL) == 0x000108, "Member 'UUIMemberCreateMenu::WindowStatusL' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, WindowUnitInfo) == 0x000110, "Member 'UUIMemberCreateMenu::WindowUnitInfo' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenu, WindowSub) == 0x000118, "Member 'UUIMemberCreateMenu::WindowSub' has a wrong offset!");

// Class Nicola.UIMemberCreateMenuListColor
// 0x0010 (0x00F8 - 0x00E8)
class UUIMemberCreateMenuListColor final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListColor">();
	}
	static class UUIMemberCreateMenuListColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListColor>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListColor) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListColor");
static_assert(sizeof(UUIMemberCreateMenuListColor) == 0x0000F8, "Wrong size on UUIMemberCreateMenuListColor");

// Class Nicola.UIMemberCreateMenuListItemLooks
// 0x0010 (0x0070 - 0x0060)
class UUIMemberCreateMenuListItemLooks final : public UUIListItemIcon
{
public:
	class UFlipbookWidget*                        ItemFlipbook;                                      // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlipbookWidget*                        ItemFlipbook2;                                     // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListItemLooks">();
	}
	static class UUIMemberCreateMenuListItemLooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListItemLooks>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListItemLooks) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListItemLooks");
static_assert(sizeof(UUIMemberCreateMenuListItemLooks) == 0x000070, "Wrong size on UUIMemberCreateMenuListItemLooks");
static_assert(offsetof(UUIMemberCreateMenuListItemLooks, ItemFlipbook) == 0x000060, "Member 'UUIMemberCreateMenuListItemLooks::ItemFlipbook' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuListItemLooks, ItemFlipbook2) == 0x000068, "Member 'UUIMemberCreateMenuListItemLooks::ItemFlipbook2' has a wrong offset!");

// Class Nicola.UIMemberCreateMenuListMember
// 0x0008 (0x00D8 - 0x00D0)
class UUIMemberCreateMenuListMember final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListMember">();
	}
	static class UUIMemberCreateMenuListMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListMember>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListMember) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListMember");
static_assert(sizeof(UUIMemberCreateMenuListMember) == 0x0000D8, "Wrong size on UUIMemberCreateMenuListMember");

// Class Nicola.UIMemberCreateMenuListParty
// 0x0030 (0x0100 - 0x00D0)
class UUIMemberCreateMenuListParty final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListParty">();
	}
	static class UUIMemberCreateMenuListParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListParty>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListParty) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListParty");
static_assert(sizeof(UUIMemberCreateMenuListParty) == 0x000100, "Wrong size on UUIMemberCreateMenuListParty");

// Class Nicola.UIMemberCreateMenuListSeed
// 0x0020 (0x00F0 - 0x00D0)
class UUIMemberCreateMenuListSeed final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListSeed">();
	}
	static class UUIMemberCreateMenuListSeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListSeed>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListSeed) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListSeed");
static_assert(sizeof(UUIMemberCreateMenuListSeed) == 0x0000F0, "Wrong size on UUIMemberCreateMenuListSeed");

// Class Nicola.UIMemberCreateMenuListSelection
// 0x0008 (0x00D8 - 0x00D0)
class UUIMemberCreateMenuListSelection final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListSelection">();
	}
	static class UUIMemberCreateMenuListSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListSelection>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListSelection) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListSelection");
static_assert(sizeof(UUIMemberCreateMenuListSelection) == 0x0000D8, "Wrong size on UUIMemberCreateMenuListSelection");

// Class Nicola.UIMemberCreateMenuListItemStyle
// 0x0020 (0x0078 - 0x0058)
class UUIMemberCreateMenuListItemStyle final : public UUIListItem
{
public:
	TArray<class UImage*>                         ImageIcon;                                         // 0x0058(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UFlipbookWidget*>                ItemFlipbook;                                      // 0x0068(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListItemStyle">();
	}
	static class UUIMemberCreateMenuListItemStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListItemStyle>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListItemStyle) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListItemStyle");
static_assert(sizeof(UUIMemberCreateMenuListItemStyle) == 0x000078, "Wrong size on UUIMemberCreateMenuListItemStyle");
static_assert(offsetof(UUIMemberCreateMenuListItemStyle, ImageIcon) == 0x000058, "Member 'UUIMemberCreateMenuListItemStyle::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuListItemStyle, ItemFlipbook) == 0x000068, "Member 'UUIMemberCreateMenuListItemStyle::ItemFlipbook' has a wrong offset!");

// Class Nicola.UIMemberCreateMenuListStyle
// 0x0008 (0x00F0 - 0x00E8)
class UUIMemberCreateMenuListStyle final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListStyle">();
	}
	static class UUIMemberCreateMenuListStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListStyle>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListStyle) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListStyle");
static_assert(sizeof(UUIMemberCreateMenuListStyle) == 0x0000F0, "Wrong size on UUIMemberCreateMenuListStyle");

// Class Nicola.UIMemberCreateMenuListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIMemberCreateMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListTop">();
	}
	static class UUIMemberCreateMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListTop>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListTop) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListTop");
static_assert(sizeof(UUIMemberCreateMenuListTop) == 0x0000D8, "Wrong size on UUIMemberCreateMenuListTop");

// Class Nicola.UIMemberCreateMenuListVoice
// 0x0070 (0x0158 - 0x00E8)
class UUIMemberCreateMenuListVoice final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x68];                                      // 0x00E8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMemberCreateMenuWindowItemVoiceGuide* ItemVoicePreview;                                  // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuListVoice">();
	}
	static class UUIMemberCreateMenuListVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuListVoice>();
	}
};
static_assert(alignof(UUIMemberCreateMenuListVoice) == 0x000008, "Wrong alignment on UUIMemberCreateMenuListVoice");
static_assert(sizeof(UUIMemberCreateMenuListVoice) == 0x000158, "Wrong size on UUIMemberCreateMenuListVoice");
static_assert(offsetof(UUIMemberCreateMenuListVoice, ItemVoicePreview) == 0x000150, "Member 'UUIMemberCreateMenuListVoice::ItemVoicePreview' has a wrong offset!");

// Class Nicola.UIMemberCreateMenuWindowItemVoiceGuide
// 0x0010 (0x0050 - 0x0040)
class UUIMemberCreateMenuWindowItemVoiceGuide final : public UUIWindowItem
{
public:
	class UUIWindowItemButtonIcon*                ButtonIcon;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonItemWidget*                      IconVoice;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberCreateMenuWindowItemVoiceGuide">();
	}
	static class UUIMemberCreateMenuWindowItemVoiceGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberCreateMenuWindowItemVoiceGuide>();
	}
};
static_assert(alignof(UUIMemberCreateMenuWindowItemVoiceGuide) == 0x000008, "Wrong alignment on UUIMemberCreateMenuWindowItemVoiceGuide");
static_assert(sizeof(UUIMemberCreateMenuWindowItemVoiceGuide) == 0x000050, "Wrong size on UUIMemberCreateMenuWindowItemVoiceGuide");
static_assert(offsetof(UUIMemberCreateMenuWindowItemVoiceGuide, ButtonIcon) == 0x000040, "Member 'UUIMemberCreateMenuWindowItemVoiceGuide::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UUIMemberCreateMenuWindowItemVoiceGuide, IconVoice) == 0x000048, "Member 'UUIMemberCreateMenuWindowItemVoiceGuide::IconVoice' has a wrong offset!");

// Class Nicola.UIMessageWindow
// 0x0038 (0x00B0 - 0x0078)
class UUIMessageWindow final : public UUIRootBase
{
public:
	class UUIMessageWindowMain*                   WindowMessageTop;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMessageWindowMain*                   WindowMessageCenter;                               // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMessageWindowMain*                   WindowMessageBottom;                               // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMessageWindowListYesNo*              ListYesNo;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMessageWindowListChoices*            ListChoices;                                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaRichTextBlock*                   WidthCheckTextBlock;                               // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMessageWindow">();
	}
	static class UUIMessageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMessageWindow>();
	}
};
static_assert(alignof(UUIMessageWindow) == 0x000008, "Wrong alignment on UUIMessageWindow");
static_assert(sizeof(UUIMessageWindow) == 0x0000B0, "Wrong size on UUIMessageWindow");
static_assert(offsetof(UUIMessageWindow, WindowMessageTop) == 0x000078, "Member 'UUIMessageWindow::WindowMessageTop' has a wrong offset!");
static_assert(offsetof(UUIMessageWindow, WindowMessageCenter) == 0x000080, "Member 'UUIMessageWindow::WindowMessageCenter' has a wrong offset!");
static_assert(offsetof(UUIMessageWindow, WindowMessageBottom) == 0x000088, "Member 'UUIMessageWindow::WindowMessageBottom' has a wrong offset!");
static_assert(offsetof(UUIMessageWindow, ListYesNo) == 0x000090, "Member 'UUIMessageWindow::ListYesNo' has a wrong offset!");
static_assert(offsetof(UUIMessageWindow, ListChoices) == 0x000098, "Member 'UUIMessageWindow::ListChoices' has a wrong offset!");
static_assert(offsetof(UUIMessageWindow, WidthCheckTextBlock) == 0x0000A0, "Member 'UUIMessageWindow::WidthCheckTextBlock' has a wrong offset!");

// Class Nicola.UIMessageWindowListChoices
// 0x0008 (0x00D8 - 0x00D0)
class UUIMessageWindowListChoices final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMessageWindowListChoices">();
	}
	static class UUIMessageWindowListChoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMessageWindowListChoices>();
	}
};
static_assert(alignof(UUIMessageWindowListChoices) == 0x000008, "Wrong alignment on UUIMessageWindowListChoices");
static_assert(sizeof(UUIMessageWindowListChoices) == 0x0000D8, "Wrong size on UUIMessageWindowListChoices");

// Class Nicola.UIMessageWindowListText
// 0x0050 (0x00A8 - 0x0058)
class UUIMessageWindowListText final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemRich*>              WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UUIMessageWindowMain*                   WindowMain;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMessageWindowListText">();
	}
	static class UUIMessageWindowListText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMessageWindowListText>();
	}
};
static_assert(alignof(UUIMessageWindowListText) == 0x000008, "Wrong alignment on UUIMessageWindowListText");
static_assert(sizeof(UUIMessageWindowListText) == 0x0000A8, "Wrong size on UUIMessageWindowListText");
static_assert(offsetof(UUIMessageWindowListText, WindowItems) == 0x000058, "Member 'UUIMessageWindowListText::WindowItems' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowListText, WindowMain) == 0x000068, "Member 'UUIMessageWindowListText::WindowMain' has a wrong offset!");

// Class Nicola.UIMessageWindowListYesNo
// 0x0008 (0x00D8 - 0x00D0)
class UUIMessageWindowListYesNo final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMessageWindowListYesNo">();
	}
	static class UUIMessageWindowListYesNo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMessageWindowListYesNo>();
	}
};
static_assert(alignof(UUIMessageWindowListYesNo) == 0x000008, "Wrong alignment on UUIMessageWindowListYesNo");
static_assert(sizeof(UUIMessageWindowListYesNo) == 0x0000D8, "Wrong size on UUIMessageWindowListYesNo");

// Class Nicola.UIMessageWindowMain
// 0x0090 (0x0100 - 0x0070)
class UUIMessageWindowMain final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMessageWindowListText*               List;                                              // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               OverlayNormal;                                     // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               OverlayName;                                       // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextName;                                          // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                WindowBox;                                         // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageArrow;                                        // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaSizeBox*                         SizeBox;                                           // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMessageWindowMain">();
	}
	static class UUIMessageWindowMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMessageWindowMain>();
	}
};
static_assert(alignof(UUIMessageWindowMain) == 0x000008, "Wrong alignment on UUIMessageWindowMain");
static_assert(sizeof(UUIMessageWindowMain) == 0x000100, "Wrong size on UUIMessageWindowMain");
static_assert(offsetof(UUIMessageWindowMain, List) == 0x000080, "Member 'UUIMessageWindowMain::List' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowMain, OverlayNormal) == 0x000088, "Member 'UUIMessageWindowMain::OverlayNormal' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowMain, OverlayName) == 0x000090, "Member 'UUIMessageWindowMain::OverlayName' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowMain, TextName) == 0x000098, "Member 'UUIMessageWindowMain::TextName' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowMain, WindowBox) == 0x0000A0, "Member 'UUIMessageWindowMain::WindowBox' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowMain, ImageArrow) == 0x0000A8, "Member 'UUIMessageWindowMain::ImageArrow' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowMain, SizeBox) == 0x0000B0, "Member 'UUIMessageWindowMain::SizeBox' has a wrong offset!");

// Class Nicola.UIMessageWindowXRMessageRoot
// 0x0018 (0x0090 - 0x0078)
class UUIMessageWindowXRMessageRoot final : public UUIRootBase
{
public:
	class UUIMessageWindowMain*                   WindowMessageCenter;                               // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaRichTextBlock*                   WidthCheckTextBlock;                               // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMessageWindowXRMessageRoot">();
	}
	static class UUIMessageWindowXRMessageRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMessageWindowXRMessageRoot>();
	}
};
static_assert(alignof(UUIMessageWindowXRMessageRoot) == 0x000008, "Wrong alignment on UUIMessageWindowXRMessageRoot");
static_assert(sizeof(UUIMessageWindowXRMessageRoot) == 0x000090, "Wrong size on UUIMessageWindowXRMessageRoot");
static_assert(offsetof(UUIMessageWindowXRMessageRoot, WindowMessageCenter) == 0x000078, "Member 'UUIMessageWindowXRMessageRoot::WindowMessageCenter' has a wrong offset!");
static_assert(offsetof(UUIMessageWindowXRMessageRoot, WidthCheckTextBlock) == 0x000080, "Member 'UUIMessageWindowXRMessageRoot::WidthCheckTextBlock' has a wrong offset!");

// Class Nicola.UIMiniMapMenuWindowDrawMap
// 0x00B8 (0x0110 - 0x0058)
class UUIMiniMapMenuWindowDrawMap final : public UUIWindowBase
{
public:
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureImageMap;                                   // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TextureImageMapOverlay;                            // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialMapAppend;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDatas;                                     // 0x00C0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialMapRender;                                 // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMapMenuWindowDrawMap">();
	}
	static class UUIMiniMapMenuWindowDrawMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMapMenuWindowDrawMap>();
	}
};
static_assert(alignof(UUIMiniMapMenuWindowDrawMap) == 0x000008, "Wrong alignment on UUIMiniMapMenuWindowDrawMap");
static_assert(sizeof(UUIMiniMapMenuWindowDrawMap) == 0x000110, "Wrong size on UUIMiniMapMenuWindowDrawMap");
static_assert(offsetof(UUIMiniMapMenuWindowDrawMap, TextureRenderTarget) == 0x0000A0, "Member 'UUIMiniMapMenuWindowDrawMap::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowDrawMap, TextureImageMap) == 0x0000A8, "Member 'UUIMiniMapMenuWindowDrawMap::TextureImageMap' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowDrawMap, TextureImageMapOverlay) == 0x0000B0, "Member 'UUIMiniMapMenuWindowDrawMap::TextureImageMapOverlay' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowDrawMap, MaterialMapAppend) == 0x0000B8, "Member 'UUIMiniMapMenuWindowDrawMap::MaterialMapAppend' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowDrawMap, drawIconDatas) == 0x0000C0, "Member 'UUIMiniMapMenuWindowDrawMap::drawIconDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowDrawMap, MaterialMapRender) == 0x0000D0, "Member 'UUIMiniMapMenuWindowDrawMap::MaterialMapRender' has a wrong offset!");

// Class Nicola.UIMiniMapMenuWindowMain
// 0x01F0 (0x0248 - 0x0058)
class UUIMiniMapMenuWindowMain final : public UUIWindowBase
{
public:
	class UImage*                                 ImagePlayer;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMiniMapMenuWindowDrawMap*            WindowDrawMap;                                     // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUILoadableTexture                     loadableTexture;                                   // 0x0068(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FUILoadableTexture                     LoadableTexture2;                                  // 0x0080(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMiniMapDrawIconData>           drawIconDatas;                                     // 0x00B0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconTargetDatas;                               // 0x00C0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           deleteIconTargetDatas;                             // 0x00D0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconShipData;                                  // 0x00E0(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconLamiaData;                                 // 0x0128(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMiniMapDrawIconData                   drawIconGhostShipData;                             // 0x0170(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconRemiramaDatas;                             // 0x01B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconEchoFluteDatas;                            // 0x01C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconGuideMainDatas;                            // 0x01D8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconGuideSubDatas;                             // 0x01E8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconDoorKeyDatas;                              // 0x01F8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMiniMapDrawIconData>           drawIconCrossMarkDatas;                            // 0x0208(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x30];                                     // 0x0218(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMapMenuWindowMain">();
	}
	static class UUIMiniMapMenuWindowMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMapMenuWindowMain>();
	}
};
static_assert(alignof(UUIMiniMapMenuWindowMain) == 0x000008, "Wrong alignment on UUIMiniMapMenuWindowMain");
static_assert(sizeof(UUIMiniMapMenuWindowMain) == 0x000248, "Wrong size on UUIMiniMapMenuWindowMain");
static_assert(offsetof(UUIMiniMapMenuWindowMain, ImagePlayer) == 0x000058, "Member 'UUIMiniMapMenuWindowMain::ImagePlayer' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, WindowDrawMap) == 0x000060, "Member 'UUIMiniMapMenuWindowMain::WindowDrawMap' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, loadableTexture) == 0x000068, "Member 'UUIMiniMapMenuWindowMain::loadableTexture' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, LoadableTexture2) == 0x000080, "Member 'UUIMiniMapMenuWindowMain::LoadableTexture2' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconDatas) == 0x0000B0, "Member 'UUIMiniMapMenuWindowMain::drawIconDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconTargetDatas) == 0x0000C0, "Member 'UUIMiniMapMenuWindowMain::drawIconTargetDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, deleteIconTargetDatas) == 0x0000D0, "Member 'UUIMiniMapMenuWindowMain::deleteIconTargetDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconShipData) == 0x0000E0, "Member 'UUIMiniMapMenuWindowMain::drawIconShipData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconLamiaData) == 0x000128, "Member 'UUIMiniMapMenuWindowMain::drawIconLamiaData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconGhostShipData) == 0x000170, "Member 'UUIMiniMapMenuWindowMain::drawIconGhostShipData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconRemiramaDatas) == 0x0001B8, "Member 'UUIMiniMapMenuWindowMain::drawIconRemiramaDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconEchoFluteDatas) == 0x0001C8, "Member 'UUIMiniMapMenuWindowMain::drawIconEchoFluteDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconGuideMainDatas) == 0x0001D8, "Member 'UUIMiniMapMenuWindowMain::drawIconGuideMainDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconGuideSubDatas) == 0x0001E8, "Member 'UUIMiniMapMenuWindowMain::drawIconGuideSubDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconDoorKeyDatas) == 0x0001F8, "Member 'UUIMiniMapMenuWindowMain::drawIconDoorKeyDatas' has a wrong offset!");
static_assert(offsetof(UUIMiniMapMenuWindowMain, drawIconCrossMarkDatas) == 0x000208, "Member 'UUIMiniMapMenuWindowMain::drawIconCrossMarkDatas' has a wrong offset!");

// Class Nicola.UIMouseClickData
// 0x0030 (0x0058 - 0x0028)
class UUIMouseClickData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonWindowWidget*                    Widget;                                            // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageClick;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageHover1;                                       // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageHover2;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool DEBUG_GetDispRangeFlag();
	static void DEBUG_SetDispRangeFlag(bool InFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMouseClickData">();
	}
	static class UUIMouseClickData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMouseClickData>();
	}
};
static_assert(alignof(UUIMouseClickData) == 0x000008, "Wrong alignment on UUIMouseClickData");
static_assert(sizeof(UUIMouseClickData) == 0x000058, "Wrong size on UUIMouseClickData");
static_assert(offsetof(UUIMouseClickData, Widget) == 0x000030, "Member 'UUIMouseClickData::Widget' has a wrong offset!");
static_assert(offsetof(UUIMouseClickData, ImageClick) == 0x000038, "Member 'UUIMouseClickData::ImageClick' has a wrong offset!");
static_assert(offsetof(UUIMouseClickData, ImageHover1) == 0x000040, "Member 'UUIMouseClickData::ImageHover1' has a wrong offset!");
static_assert(offsetof(UUIMouseClickData, ImageHover2) == 0x000048, "Member 'UUIMouseClickData::ImageHover2' has a wrong offset!");

// Class Nicola.UIRenameMenu
// 0x0018 (0x0090 - 0x0078)
class UUIRenameMenu final : public UUIRootBase
{
public:
	class UUIRenameMenuController*                Controller;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIRenameMenuListParty*                 ListParty;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     ItemMoney;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenameMenu">();
	}
	static class UUIRenameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenameMenu>();
	}
};
static_assert(alignof(UUIRenameMenu) == 0x000008, "Wrong alignment on UUIRenameMenu");
static_assert(sizeof(UUIRenameMenu) == 0x000090, "Wrong size on UUIRenameMenu");
static_assert(offsetof(UUIRenameMenu, Controller) == 0x000078, "Member 'UUIRenameMenu::Controller' has a wrong offset!");
static_assert(offsetof(UUIRenameMenu, ListParty) == 0x000080, "Member 'UUIRenameMenu::ListParty' has a wrong offset!");
static_assert(offsetof(UUIRenameMenu, ItemMoney) == 0x000088, "Member 'UUIRenameMenu::ItemMoney' has a wrong offset!");

// Class Nicola.UITownNameMenu
// 0x0018 (0x0090 - 0x0078)
class UUITownNameMenu final : public UUIRootBase
{
public:
	class UUIWindowItemTownName*                  ItemTownName;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITownNameMenu">();
	}
	static class UUITownNameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITownNameMenu>();
	}
};
static_assert(alignof(UUITownNameMenu) == 0x000008, "Wrong alignment on UUITownNameMenu");
static_assert(sizeof(UUITownNameMenu) == 0x000090, "Wrong size on UUITownNameMenu");
static_assert(offsetof(UUITownNameMenu, ItemTownName) == 0x000078, "Member 'UUITownNameMenu::ItemTownName' has a wrong offset!");

// Class Nicola.UIRenameMenuController
// 0x0030 (0x00A0 - 0x0070)
class UUIRenameMenuController final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenameMenuController">();
	}
	static class UUIRenameMenuController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenameMenuController>();
	}
};
static_assert(alignof(UUIRenameMenuController) == 0x000008, "Wrong alignment on UUIRenameMenuController");
static_assert(sizeof(UUIRenameMenuController) == 0x0000A0, "Wrong size on UUIRenameMenuController");

// Class Nicola.UIRenameMenuListParty
// 0x0010 (0x00E0 - 0x00D0)
class UUIRenameMenuListParty final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenameMenuListParty">();
	}
	static class UUIRenameMenuListParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenameMenuListParty>();
	}
};
static_assert(alignof(UUIRenameMenuListParty) == 0x000008, "Wrong alignment on UUIRenameMenuListParty");
static_assert(sizeof(UUIRenameMenuListParty) == 0x0000E0, "Wrong size on UUIRenameMenuListParty");

// Class Nicola.UISaveGameDataFlow
// 0x0020 (0x0090 - 0x0070)
class UUISaveGameDataFlow final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveGameDataFlow">();
	}
	static class UUISaveGameDataFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveGameDataFlow>();
	}
};
static_assert(alignof(UUISaveGameDataFlow) == 0x000008, "Wrong alignment on UUISaveGameDataFlow");
static_assert(sizeof(UUISaveGameDataFlow) == 0x000090, "Wrong size on UUISaveGameDataFlow");

// Class Nicola.UISaveIconMenu
// 0x0010 (0x0088 - 0x0078)
class UUISaveIconMenu final : public UUIRootBase
{
public:
	class UUISaveIconMenuWindowSave*              WindowSave;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveIconMenu">();
	}
	static class UUISaveIconMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveIconMenu>();
	}
};
static_assert(alignof(UUISaveIconMenu) == 0x000008, "Wrong alignment on UUISaveIconMenu");
static_assert(sizeof(UUISaveIconMenu) == 0x000088, "Wrong size on UUISaveIconMenu");
static_assert(offsetof(UUISaveIconMenu, WindowSave) == 0x000078, "Member 'UUISaveIconMenu::WindowSave' has a wrong offset!");

// Class Nicola.UIVisualChangeMenu
// 0x0078 (0x00F0 - 0x0078)
class UUIVisualChangeMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     PlayingEffectComp;                                 // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIVisualChangeMenuListTop*             ListTop;                                           // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListLooks*           ListLooks;                                         // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListColor*           ListColor;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListVoice*           ListVoice;                                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMemberCreateMenuListItemLooks*       WindowLooks;                                       // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     WindowMoney;                                       // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVisualChangeMenu">();
	}
	static class UUIVisualChangeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVisualChangeMenu>();
	}
};
static_assert(alignof(UUIVisualChangeMenu) == 0x000008, "Wrong alignment on UUIVisualChangeMenu");
static_assert(sizeof(UUIVisualChangeMenu) == 0x0000F0, "Wrong size on UUIVisualChangeMenu");
static_assert(offsetof(UUIVisualChangeMenu, PlayingEffectComp) == 0x0000B0, "Member 'UUIVisualChangeMenu::PlayingEffectComp' has a wrong offset!");
static_assert(offsetof(UUIVisualChangeMenu, ListTop) == 0x0000C0, "Member 'UUIVisualChangeMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIVisualChangeMenu, ListLooks) == 0x0000C8, "Member 'UUIVisualChangeMenu::ListLooks' has a wrong offset!");
static_assert(offsetof(UUIVisualChangeMenu, ListColor) == 0x0000D0, "Member 'UUIVisualChangeMenu::ListColor' has a wrong offset!");
static_assert(offsetof(UUIVisualChangeMenu, ListVoice) == 0x0000D8, "Member 'UUIVisualChangeMenu::ListVoice' has a wrong offset!");
static_assert(offsetof(UUIVisualChangeMenu, WindowLooks) == 0x0000E0, "Member 'UUIVisualChangeMenu::WindowLooks' has a wrong offset!");
static_assert(offsetof(UUIVisualChangeMenu, WindowMoney) == 0x0000E8, "Member 'UUIVisualChangeMenu::WindowMoney' has a wrong offset!");

// Class Nicola.UISaveIconMenuWindowSave
// 0x0018 (0x0088 - 0x0070)
class UUISaveIconMenuWindowSave final : public UUICtrlBase
{
public:
	TArray<class UUISaveIconMenuWindowSaveItem*>  ViewItems;                                         // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveIconMenuWindowSave">();
	}
	static class UUISaveIconMenuWindowSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveIconMenuWindowSave>();
	}
};
static_assert(alignof(UUISaveIconMenuWindowSave) == 0x000008, "Wrong alignment on UUISaveIconMenuWindowSave");
static_assert(sizeof(UUISaveIconMenuWindowSave) == 0x000088, "Wrong size on UUISaveIconMenuWindowSave");
static_assert(offsetof(UUISaveIconMenuWindowSave, ViewItems) == 0x000070, "Member 'UUISaveIconMenuWindowSave::ViewItems' has a wrong offset!");

// Class Nicola.UISaveIconMenuWindowSaveItem
// 0x0010 (0x0050 - 0x0040)
class UUISaveIconMenuWindowSaveItem final : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveIconMenuWindowSaveItem">();
	}
	static class UUISaveIconMenuWindowSaveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveIconMenuWindowSaveItem>();
	}
};
static_assert(alignof(UUISaveIconMenuWindowSaveItem) == 0x000008, "Wrong alignment on UUISaveIconMenuWindowSaveItem");
static_assert(sizeof(UUISaveIconMenuWindowSaveItem) == 0x000050, "Wrong size on UUISaveIconMenuWindowSaveItem");

// Class Nicola.UISaveLoadListItem
// 0x0048 (0x00A0 - 0x0058)
class UUISaveLoadListItem final : public UUIListItem
{
public:
	class UGopTextBlock*                          PlayerNameValueText;                               // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          LvText;                                            // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          LvValueText;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          PlaceValueText;                                    // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          PlayTimeText;                                      // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          PlayTimeValueText;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          SaveDateText;                                      // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          SaveDateValueText;                                 // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          UnusedText;                                        // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadListItem">();
	}
	static class UUISaveLoadListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadListItem>();
	}
};
static_assert(alignof(UUISaveLoadListItem) == 0x000008, "Wrong alignment on UUISaveLoadListItem");
static_assert(sizeof(UUISaveLoadListItem) == 0x0000A0, "Wrong size on UUISaveLoadListItem");
static_assert(offsetof(UUISaveLoadListItem, PlayerNameValueText) == 0x000058, "Member 'UUISaveLoadListItem::PlayerNameValueText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, LvText) == 0x000060, "Member 'UUISaveLoadListItem::LvText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, LvValueText) == 0x000068, "Member 'UUISaveLoadListItem::LvValueText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, PlaceValueText) == 0x000070, "Member 'UUISaveLoadListItem::PlaceValueText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, PlayTimeText) == 0x000078, "Member 'UUISaveLoadListItem::PlayTimeText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, PlayTimeValueText) == 0x000080, "Member 'UUISaveLoadListItem::PlayTimeValueText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, SaveDateText) == 0x000088, "Member 'UUISaveLoadListItem::SaveDateText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, SaveDateValueText) == 0x000090, "Member 'UUISaveLoadListItem::SaveDateValueText' has a wrong offset!");
static_assert(offsetof(UUISaveLoadListItem, UnusedText) == 0x000098, "Member 'UUISaveLoadListItem::UnusedText' has a wrong offset!");

// Class Nicola.UISelectItemMenu
// 0x0068 (0x00E0 - 0x0078)
class UUISelectItemMenu final : public UUIRootBase
{
public:
	class UUISelectItemMenuListTop*               ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMedal*                     ItemMedal;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     ItemMoney;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuListInventory*         ListInventory;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSort*            WindowSort;                                        // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ItemLiquidation;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuWindowSub*             WindowSub;                                         // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuListAction*            ListAction;                                        // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIShopMenuWindowCountSelect*           WindowCountSelect;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldHandoverListSelectAccessory*    ListSelectAccessory;                               // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISelectItemMenuListSelectParty*       ListSelectParty;                                   // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldHandoverWindowCountSelect*      WindowCountSelect2;                                // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenu">();
	}
	static class UUISelectItemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenu>();
	}
};
static_assert(alignof(UUISelectItemMenu) == 0x000008, "Wrong alignment on UUISelectItemMenu");
static_assert(sizeof(UUISelectItemMenu) == 0x0000E0, "Wrong size on UUISelectItemMenu");
static_assert(offsetof(UUISelectItemMenu, ListTop) == 0x000078, "Member 'UUISelectItemMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ItemMedal) == 0x000080, "Member 'UUISelectItemMenu::ItemMedal' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ItemMoney) == 0x000088, "Member 'UUISelectItemMenu::ItemMoney' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ListInventory) == 0x000090, "Member 'UUISelectItemMenu::ListInventory' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, WindowSort) == 0x000098, "Member 'UUISelectItemMenu::WindowSort' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ItemLiquidation) == 0x0000A0, "Member 'UUISelectItemMenu::ItemLiquidation' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, WindowSub) == 0x0000A8, "Member 'UUISelectItemMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ListAction) == 0x0000B0, "Member 'UUISelectItemMenu::ListAction' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, WindowCountSelect) == 0x0000B8, "Member 'UUISelectItemMenu::WindowCountSelect' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ListSelectAccessory) == 0x0000C0, "Member 'UUISelectItemMenu::ListSelectAccessory' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, ListSelectParty) == 0x0000C8, "Member 'UUISelectItemMenu::ListSelectParty' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenu, WindowCountSelect2) == 0x0000D0, "Member 'UUISelectItemMenu::WindowCountSelect2' has a wrong offset!");

// Class Nicola.UISelectItemMenuListAction
// 0x0048 (0x0118 - 0x00D0)
class UUISelectItemMenuListAction final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenuListAction">();
	}
	static class UUISelectItemMenuListAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenuListAction>();
	}
};
static_assert(alignof(UUISelectItemMenuListAction) == 0x000008, "Wrong alignment on UUISelectItemMenuListAction");
static_assert(sizeof(UUISelectItemMenuListAction) == 0x000118, "Wrong size on UUISelectItemMenuListAction");

// Class Nicola.UISelectItemMenuListInventory
// 0x0030 (0x0100 - 0x00D0)
class UUISelectItemMenuListInventory final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenuListInventory">();
	}
	static class UUISelectItemMenuListInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenuListInventory>();
	}
};
static_assert(alignof(UUISelectItemMenuListInventory) == 0x000008, "Wrong alignment on UUISelectItemMenuListInventory");
static_assert(sizeof(UUISelectItemMenuListInventory) == 0x000100, "Wrong size on UUISelectItemMenuListInventory");

// Class Nicola.UISelectItemMenuListSelectParty
// 0x0058 (0x0128 - 0x00D0)
class UUISelectItemMenuListSelectParty final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x58];                                      // 0x00D0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenuListSelectParty">();
	}
	static class UUISelectItemMenuListSelectParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenuListSelectParty>();
	}
};
static_assert(alignof(UUISelectItemMenuListSelectParty) == 0x000008, "Wrong alignment on UUISelectItemMenuListSelectParty");
static_assert(sizeof(UUISelectItemMenuListSelectParty) == 0x000128, "Wrong size on UUISelectItemMenuListSelectParty");

// Class Nicola.UISelectItemMenuListTop
// 0x0048 (0x0118 - 0x00D0)
class UUISelectItemMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenuListTop">();
	}
	static class UUISelectItemMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenuListTop>();
	}
};
static_assert(alignof(UUISelectItemMenuListTop) == 0x000008, "Wrong alignment on UUISelectItemMenuListTop");
static_assert(sizeof(UUISelectItemMenuListTop) == 0x000118, "Wrong size on UUISelectItemMenuListTop");

// Class Nicola.UIWindowItemFlipbook
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemFlipbook final : public UUIWindowItem
{
public:
	class UFlipbookWidget*                        ItemFlipbook;                                      // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemFlipbook">();
	}
	static class UUIWindowItemFlipbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemFlipbook>();
	}
};
static_assert(alignof(UUIWindowItemFlipbook) == 0x000008, "Wrong alignment on UUIWindowItemFlipbook");
static_assert(sizeof(UUIWindowItemFlipbook) == 0x000048, "Wrong size on UUIWindowItemFlipbook");
static_assert(offsetof(UUIWindowItemFlipbook, ItemFlipbook) == 0x000040, "Member 'UUIWindowItemFlipbook::ItemFlipbook' has a wrong offset!");

// Class Nicola.UISelectItemMenuWindowSort
// 0x0020 (0x0078 - 0x0058)
class UUISelectItemMenuWindowSort final : public UUIWindowBase
{
public:
	class UUIWindowItemButtonIcon*                ImageButtonLeft;                                   // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonRight;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextSort;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectItemMenuWindowSort">();
	}
	static class UUISelectItemMenuWindowSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectItemMenuWindowSort>();
	}
};
static_assert(alignof(UUISelectItemMenuWindowSort) == 0x000008, "Wrong alignment on UUISelectItemMenuWindowSort");
static_assert(sizeof(UUISelectItemMenuWindowSort) == 0x000078, "Wrong size on UUISelectItemMenuWindowSort");
static_assert(offsetof(UUISelectItemMenuWindowSort, ImageButtonLeft) == 0x000058, "Member 'UUISelectItemMenuWindowSort::ImageButtonLeft' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenuWindowSort, ImageButtonRight) == 0x000060, "Member 'UUISelectItemMenuWindowSort::ImageButtonRight' has a wrong offset!");
static_assert(offsetof(UUISelectItemMenuWindowSort, TextSort) == 0x000068, "Member 'UUISelectItemMenuWindowSort::TextSort' has a wrong offset!");

// Class Nicola.UIShopMenu
// 0x0080 (0x00F8 - 0x0078)
class UUIShopMenu final : public UUIRootBase
{
public:
	uint8                                         Pad_78[0x48];                                      // 0x0078(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIShopMenuWindowShop*                  WindowShop;                                        // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIShopMenuListTop*                     ListTop;                                           // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIShopMenuListBuyTop*                  ListBuyTop;                                        // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIShopMenuWindowSub*                   WindowSub;                                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIShopMenuWindowCompareEquip*          WindowCompareEquip;                                // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIShopMenuWindowCountSelect*           WindowCountSelect;                                 // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemMoney*                     ItemMoney;                                         // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void ShopUIDebugPreparation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenu">();
	}
	static class UUIShopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenu>();
	}
};
static_assert(alignof(UUIShopMenu) == 0x000008, "Wrong alignment on UUIShopMenu");
static_assert(sizeof(UUIShopMenu) == 0x0000F8, "Wrong size on UUIShopMenu");
static_assert(offsetof(UUIShopMenu, WindowShop) == 0x0000C0, "Member 'UUIShopMenu::WindowShop' has a wrong offset!");
static_assert(offsetof(UUIShopMenu, ListTop) == 0x0000C8, "Member 'UUIShopMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUIShopMenu, ListBuyTop) == 0x0000D0, "Member 'UUIShopMenu::ListBuyTop' has a wrong offset!");
static_assert(offsetof(UUIShopMenu, WindowSub) == 0x0000D8, "Member 'UUIShopMenu::WindowSub' has a wrong offset!");
static_assert(offsetof(UUIShopMenu, WindowCompareEquip) == 0x0000E0, "Member 'UUIShopMenu::WindowCompareEquip' has a wrong offset!");
static_assert(offsetof(UUIShopMenu, WindowCountSelect) == 0x0000E8, "Member 'UUIShopMenu::WindowCountSelect' has a wrong offset!");
static_assert(offsetof(UUIShopMenu, ItemMoney) == 0x0000F0, "Member 'UUIShopMenu::ItemMoney' has a wrong offset!");

// Class Nicola.UIShopMenuListBuyTop
// 0x0008 (0x00D8 - 0x00D0)
class UUIShopMenuListBuyTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuListBuyTop">();
	}
	static class UUIShopMenuListBuyTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuListBuyTop>();
	}
};
static_assert(alignof(UUIShopMenuListBuyTop) == 0x000008, "Wrong alignment on UUIShopMenuListBuyTop");
static_assert(sizeof(UUIShopMenuListBuyTop) == 0x0000D8, "Wrong size on UUIShopMenuListBuyTop");

// Class Nicola.UIShopMenuListItemBuyTop
// 0x0020 (0x0078 - 0x0058)
class UUIShopMenuListItemBuyTop final : public UUIListItem
{
public:
	class UImage*                                 ImageHighlight;                                    // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageItemType;                                     // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuListItemBuyTop">();
	}
	static class UUIShopMenuListItemBuyTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuListItemBuyTop>();
	}
};
static_assert(alignof(UUIShopMenuListItemBuyTop) == 0x000008, "Wrong alignment on UUIShopMenuListItemBuyTop");
static_assert(sizeof(UUIShopMenuListItemBuyTop) == 0x000078, "Wrong size on UUIShopMenuListItemBuyTop");
static_assert(offsetof(UUIShopMenuListItemBuyTop, ImageHighlight) == 0x000058, "Member 'UUIShopMenuListItemBuyTop::ImageHighlight' has a wrong offset!");
static_assert(offsetof(UUIShopMenuListItemBuyTop, ImageItemType) == 0x000060, "Member 'UUIShopMenuListItemBuyTop::ImageItemType' has a wrong offset!");
static_assert(offsetof(UUIShopMenuListItemBuyTop, TextItem2) == 0x000068, "Member 'UUIShopMenuListItemBuyTop::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIShopMenuListItemBuyTop, TextItem3) == 0x000070, "Member 'UUIShopMenuListItemBuyTop::TextItem3' has a wrong offset!");

// Class Nicola.UIShopMenuWindowCompareEquip
// 0x0018 (0x0070 - 0x0058)
class UUIShopMenuWindowCompareEquip final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextStatus;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIShopMenuWindowItemCompareEquip*> WindowItems;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuWindowCompareEquip">();
	}
	static class UUIShopMenuWindowCompareEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuWindowCompareEquip>();
	}
};
static_assert(alignof(UUIShopMenuWindowCompareEquip) == 0x000008, "Wrong alignment on UUIShopMenuWindowCompareEquip");
static_assert(sizeof(UUIShopMenuWindowCompareEquip) == 0x000070, "Wrong size on UUIShopMenuWindowCompareEquip");
static_assert(offsetof(UUIShopMenuWindowCompareEquip, TextStatus) == 0x000058, "Member 'UUIShopMenuWindowCompareEquip::TextStatus' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowCompareEquip, WindowItems) == 0x000060, "Member 'UUIShopMenuWindowCompareEquip::WindowItems' has a wrong offset!");

// Class Nicola.UIShopMenuWindowItemCompareEquip
// 0x0030 (0x0070 - 0x0040)
class UUIShopMenuWindowItemCompareEquip final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem4;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageCharaHalf;                                    // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageEquipment;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageUpDown;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuWindowItemCompareEquip">();
	}
	static class UUIShopMenuWindowItemCompareEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuWindowItemCompareEquip>();
	}
};
static_assert(alignof(UUIShopMenuWindowItemCompareEquip) == 0x000008, "Wrong alignment on UUIShopMenuWindowItemCompareEquip");
static_assert(sizeof(UUIShopMenuWindowItemCompareEquip) == 0x000070, "Wrong size on UUIShopMenuWindowItemCompareEquip");
static_assert(offsetof(UUIShopMenuWindowItemCompareEquip, TextItem2) == 0x000040, "Member 'UUIShopMenuWindowItemCompareEquip::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowItemCompareEquip, TextItem3) == 0x000048, "Member 'UUIShopMenuWindowItemCompareEquip::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowItemCompareEquip, TextItem4) == 0x000050, "Member 'UUIShopMenuWindowItemCompareEquip::TextItem4' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowItemCompareEquip, ImageCharaHalf) == 0x000058, "Member 'UUIShopMenuWindowItemCompareEquip::ImageCharaHalf' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowItemCompareEquip, ImageEquipment) == 0x000060, "Member 'UUIShopMenuWindowItemCompareEquip::ImageEquipment' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowItemCompareEquip, ImageUpDown) == 0x000068, "Member 'UUIShopMenuWindowItemCompareEquip::ImageUpDown' has a wrong offset!");

// Class Nicola.UIShopMenuWindowItemShop
// 0x0010 (0x0050 - 0x0040)
class UUIShopMenuWindowItemShop final : public UUIWindowItem
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem2;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuWindowItemShop">();
	}
	static class UUIShopMenuWindowItemShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuWindowItemShop>();
	}
};
static_assert(alignof(UUIShopMenuWindowItemShop) == 0x000008, "Wrong alignment on UUIShopMenuWindowItemShop");
static_assert(sizeof(UUIShopMenuWindowItemShop) == 0x000050, "Wrong size on UUIShopMenuWindowItemShop");
static_assert(offsetof(UUIShopMenuWindowItemShop, ImageIcon) == 0x000040, "Member 'UUIShopMenuWindowItemShop::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUIShopMenuWindowItemShop, TextItem2) == 0x000048, "Member 'UUIShopMenuWindowItemShop::TextItem2' has a wrong offset!");

// Class Nicola.UIShopMenuWindowShop
// 0x0010 (0x0068 - 0x0058)
class UUIShopMenuWindowShop final : public UUIWindowBase
{
public:
	TArray<class UUIShopMenuWindowItemShop*>      WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopMenuWindowShop">();
	}
	static class UUIShopMenuWindowShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopMenuWindowShop>();
	}
};
static_assert(alignof(UUIShopMenuWindowShop) == 0x000008, "Wrong alignment on UUIShopMenuWindowShop");
static_assert(sizeof(UUIShopMenuWindowShop) == 0x000068, "Wrong size on UUIShopMenuWindowShop");
static_assert(offsetof(UUIShopMenuWindowShop, WindowItems) == 0x000058, "Member 'UUIShopMenuWindowShop::WindowItems' has a wrong offset!");

// Class Nicola.UITestCommonListCross
// 0x0008 (0x00F0 - 0x00E8)
class UUITestCommonListCross final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommonListCross">();
	}
	static class UUITestCommonListCross* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommonListCross>();
	}
};
static_assert(alignof(UUITestCommonListCross) == 0x000008, "Wrong alignment on UUITestCommonListCross");
static_assert(sizeof(UUITestCommonListCross) == 0x0000F0, "Wrong size on UUITestCommonListCross");

// Class Nicola.UITestCommonListPage
// 0x0008 (0x00D8 - 0x00D0)
class UUITestCommonListPage final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommonListPage">();
	}
	static class UUITestCommonListPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommonListPage>();
	}
};
static_assert(alignof(UUITestCommonListPage) == 0x000008, "Wrong alignment on UUITestCommonListPage");
static_assert(sizeof(UUITestCommonListPage) == 0x0000D8, "Wrong size on UUITestCommonListPage");

// Class Nicola.UITestCommonListTop
// 0x0008 (0x00D8 - 0x00D0)
class UUITestCommonListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommonListTop">();
	}
	static class UUITestCommonListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommonListTop>();
	}
};
static_assert(alignof(UUITestCommonListTop) == 0x000008, "Wrong alignment on UUITestCommonListTop");
static_assert(sizeof(UUITestCommonListTop) == 0x0000D8, "Wrong size on UUITestCommonListTop");

// Class Nicola.UITestCommonWindow1
// 0x0010 (0x0068 - 0x0058)
class UUITestCommonWindow1 final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestCommonWindow1">();
	}
	static class UUITestCommonWindow1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestCommonWindow1>();
	}
};
static_assert(alignof(UUITestCommonWindow1) == 0x000008, "Wrong alignment on UUITestCommonWindow1");
static_assert(sizeof(UUITestCommonWindow1) == 0x000068, "Wrong size on UUITestCommonWindow1");
static_assert(offsetof(UUITestCommonWindow1, WindowItems) == 0x000058, "Member 'UUITestCommonWindow1::WindowItems' has a wrong offset!");

// Class Nicola.UITestMenu
// 0x0010 (0x0088 - 0x0078)
class UUITestMenu final : public UUIRootBase
{
public:
	class UUITestMenuListTop*                     ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestMenuWindow1*                     Window1;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMenu">();
	}
	static class UUITestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMenu>();
	}
};
static_assert(alignof(UUITestMenu) == 0x000008, "Wrong alignment on UUITestMenu");
static_assert(sizeof(UUITestMenu) == 0x000088, "Wrong size on UUITestMenu");
static_assert(offsetof(UUITestMenu, ListTop) == 0x000078, "Member 'UUITestMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUITestMenu, Window1) == 0x000080, "Member 'UUITestMenu::Window1' has a wrong offset!");

// Class Nicola.UITestMenuWindow1
// 0x0010 (0x0068 - 0x0058)
class UUITestMenuWindow1 final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItem*>                  WindowItems;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMenuWindow1">();
	}
	static class UUITestMenuWindow1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMenuWindow1>();
	}
};
static_assert(alignof(UUITestMenuWindow1) == 0x000008, "Wrong alignment on UUITestMenuWindow1");
static_assert(sizeof(UUITestMenuWindow1) == 0x000068, "Wrong size on UUITestMenuWindow1");
static_assert(offsetof(UUITestMenuWindow1, WindowItems) == 0x000058, "Member 'UUITestMenuWindow1::WindowItems' has a wrong offset!");

// Class Nicola.UITestMouseMenuListCrossH1
// 0x0008 (0x00F0 - 0x00E8)
class UUITestMouseMenuListCrossH1 final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListCrossH1">();
	}
	static class UUITestMouseMenuListCrossH1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListCrossH1>();
	}
};
static_assert(alignof(UUITestMouseMenuListCrossH1) == 0x000008, "Wrong alignment on UUITestMouseMenuListCrossH1");
static_assert(sizeof(UUITestMouseMenuListCrossH1) == 0x0000F0, "Wrong size on UUITestMouseMenuListCrossH1");

// Class Nicola.UITestMouseMenuListCrossV1
// 0x0008 (0x00F0 - 0x00E8)
class UUITestMouseMenuListCrossV1 final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListCrossV1">();
	}
	static class UUITestMouseMenuListCrossV1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListCrossV1>();
	}
};
static_assert(alignof(UUITestMouseMenuListCrossV1) == 0x000008, "Wrong alignment on UUITestMouseMenuListCrossV1");
static_assert(sizeof(UUITestMouseMenuListCrossV1) == 0x0000F0, "Wrong size on UUITestMouseMenuListCrossV1");

// Class Nicola.UITestMouseMenuListPage1
// 0x0008 (0x00D8 - 0x00D0)
class UUITestMouseMenuListPage1 final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListPage1">();
	}
	static class UUITestMouseMenuListPage1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListPage1>();
	}
};
static_assert(alignof(UUITestMouseMenuListPage1) == 0x000008, "Wrong alignment on UUITestMouseMenuListPage1");
static_assert(sizeof(UUITestMouseMenuListPage1) == 0x0000D8, "Wrong size on UUITestMouseMenuListPage1");

// Class Nicola.UITestMouseMenuListSimple1
// 0x0008 (0x00C8 - 0x00C0)
class UUITestMouseMenuListSimple1 final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuListSimple1">();
	}
	static class UUITestMouseMenuListSimple1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuListSimple1>();
	}
};
static_assert(alignof(UUITestMouseMenuListSimple1) == 0x000008, "Wrong alignment on UUITestMouseMenuListSimple1");
static_assert(sizeof(UUITestMouseMenuListSimple1) == 0x0000C8, "Wrong size on UUITestMouseMenuListSimple1");

// Class Nicola.UITestMouseMenuWindowSort
// 0x0020 (0x0078 - 0x0058)
class UUITestMouseMenuWindowSort final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          ItemText;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          ItemText2;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonL;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIcon*                ImageButtonR;                                      // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestMouseMenuWindowSort">();
	}
	static class UUITestMouseMenuWindowSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestMouseMenuWindowSort>();
	}
};
static_assert(alignof(UUITestMouseMenuWindowSort) == 0x000008, "Wrong alignment on UUITestMouseMenuWindowSort");
static_assert(sizeof(UUITestMouseMenuWindowSort) == 0x000078, "Wrong size on UUITestMouseMenuWindowSort");
static_assert(offsetof(UUITestMouseMenuWindowSort, ItemText) == 0x000058, "Member 'UUITestMouseMenuWindowSort::ItemText' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowSort, ItemText2) == 0x000060, "Member 'UUITestMouseMenuWindowSort::ItemText2' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowSort, ImageButtonL) == 0x000068, "Member 'UUITestMouseMenuWindowSort::ImageButtonL' has a wrong offset!");
static_assert(offsetof(UUITestMouseMenuWindowSort, ImageButtonR) == 0x000070, "Member 'UUITestMouseMenuWindowSort::ImageButtonR' has a wrong offset!");

// Class Nicola.UITestScrollMenu
// 0x0008 (0x0080 - 0x0078)
class UUITestScrollMenu final : public UUIRootBase
{
public:
	class UUITestScrollMenuListTop*               ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestScrollMenu">();
	}
	static class UUITestScrollMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestScrollMenu>();
	}
};
static_assert(alignof(UUITestScrollMenu) == 0x000008, "Wrong alignment on UUITestScrollMenu");
static_assert(sizeof(UUITestScrollMenu) == 0x000080, "Wrong size on UUITestScrollMenu");
static_assert(offsetof(UUITestScrollMenu, ListTop) == 0x000078, "Member 'UUITestScrollMenu::ListTop' has a wrong offset!");

// Class Nicola.UITestScrollMenuListTop
// 0x0010 (0x00D0 - 0x00C0)
class UUITestScrollMenuListTop final : public UUIListSimple
{
public:
	class UMultiIconImage2*                       StatusIcon;                                        // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestScrollMenuListTop">();
	}
	static class UUITestScrollMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestScrollMenuListTop>();
	}
};
static_assert(alignof(UUITestScrollMenuListTop) == 0x000008, "Wrong alignment on UUITestScrollMenuListTop");
static_assert(sizeof(UUITestScrollMenuListTop) == 0x0000D0, "Wrong size on UUITestScrollMenuListTop");
static_assert(offsetof(UUITestScrollMenuListTop, StatusIcon) == 0x0000C0, "Member 'UUITestScrollMenuListTop::StatusIcon' has a wrong offset!");

// Class Nicola.UITestWindowMenu
// 0x0028 (0x00A0 - 0x0078)
class UUITestWindowMenu final : public UUIRootBase
{
public:
	class UUITestWindowMenuList1*                 List1;                                             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestWindowMenuList2*                 List2;                                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestWindowMenuList3*                 List3;                                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestWindowMenuWindow1*               Window1;                                           // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITestWindowMenuWindow2*               Window2;                                           // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenu">();
	}
	static class UUITestWindowMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenu>();
	}
};
static_assert(alignof(UUITestWindowMenu) == 0x000008, "Wrong alignment on UUITestWindowMenu");
static_assert(sizeof(UUITestWindowMenu) == 0x0000A0, "Wrong size on UUITestWindowMenu");
static_assert(offsetof(UUITestWindowMenu, List1) == 0x000078, "Member 'UUITestWindowMenu::List1' has a wrong offset!");
static_assert(offsetof(UUITestWindowMenu, List2) == 0x000080, "Member 'UUITestWindowMenu::List2' has a wrong offset!");
static_assert(offsetof(UUITestWindowMenu, List3) == 0x000088, "Member 'UUITestWindowMenu::List3' has a wrong offset!");
static_assert(offsetof(UUITestWindowMenu, Window1) == 0x000090, "Member 'UUITestWindowMenu::Window1' has a wrong offset!");
static_assert(offsetof(UUITestWindowMenu, Window2) == 0x000098, "Member 'UUITestWindowMenu::Window2' has a wrong offset!");

// Class Nicola.UITestWindowMenu2
// 0x0000 (0x0078 - 0x0078)
class UUITestWindowMenu2 final : public UUIRootBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenu2">();
	}
	static class UUITestWindowMenu2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenu2>();
	}
};
static_assert(alignof(UUITestWindowMenu2) == 0x000008, "Wrong alignment on UUITestWindowMenu2");
static_assert(sizeof(UUITestWindowMenu2) == 0x000078, "Wrong size on UUITestWindowMenu2");

// Class Nicola.UITestWindowMenuList1
// 0x0008 (0x00D8 - 0x00D0)
class UUITestWindowMenuList1 final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenuList1">();
	}
	static class UUITestWindowMenuList1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenuList1>();
	}
};
static_assert(alignof(UUITestWindowMenuList1) == 0x000008, "Wrong alignment on UUITestWindowMenuList1");
static_assert(sizeof(UUITestWindowMenuList1) == 0x0000D8, "Wrong size on UUITestWindowMenuList1");

// Class Nicola.UITestWindowMenuList2
// 0x0008 (0x00F0 - 0x00E8)
class UUITestWindowMenuList2 final : public UUIListCrossV
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenuList2">();
	}
	static class UUITestWindowMenuList2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenuList2>();
	}
};
static_assert(alignof(UUITestWindowMenuList2) == 0x000008, "Wrong alignment on UUITestWindowMenuList2");
static_assert(sizeof(UUITestWindowMenuList2) == 0x0000F0, "Wrong size on UUITestWindowMenuList2");

// Class Nicola.UITestWindowMenuWindow1
// 0x0010 (0x0068 - 0x0058)
class UUITestWindowMenuWindow1 final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemText4*                     TextMP;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenuWindow1">();
	}
	static class UUITestWindowMenuWindow1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenuWindow1>();
	}
};
static_assert(alignof(UUITestWindowMenuWindow1) == 0x000008, "Wrong alignment on UUITestWindowMenuWindow1");
static_assert(sizeof(UUITestWindowMenuWindow1) == 0x000068, "Wrong size on UUITestWindowMenuWindow1");
static_assert(offsetof(UUITestWindowMenuWindow1, TextInfo) == 0x000058, "Member 'UUITestWindowMenuWindow1::TextInfo' has a wrong offset!");
static_assert(offsetof(UUITestWindowMenuWindow1, TextMP) == 0x000060, "Member 'UUITestWindowMenuWindow1::TextMP' has a wrong offset!");

// Class Nicola.UITestWindowMenuWindow2
// 0x0008 (0x0060 - 0x0058)
class UUITestWindowMenuWindow2 final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestWindowMenuWindow2">();
	}
	static class UUITestWindowMenuWindow2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITestWindowMenuWindow2>();
	}
};
static_assert(alignof(UUITestWindowMenuWindow2) == 0x000008, "Wrong alignment on UUITestWindowMenuWindow2");
static_assert(sizeof(UUITestWindowMenuWindow2) == 0x000060, "Wrong size on UUITestWindowMenuWindow2");
static_assert(offsetof(UUITestWindowMenuWindow2, TextInfo) == 0x000058, "Member 'UUITestWindowMenuWindow2::TextInfo' has a wrong offset!");

// Class Nicola.UITextureManager
// 0x0018 (0x0040 - 0x0028)
class UUITextureManager : public UObject
{
public:
	TArray<struct FUITextureGroupData>            GroupDatas;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TransparentTexture;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureManager">();
	}
	static class UUITextureManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextureManager>();
	}
};
static_assert(alignof(UUITextureManager) == 0x000008, "Wrong alignment on UUITextureManager");
static_assert(sizeof(UUITextureManager) == 0x000040, "Wrong size on UUITextureManager");
static_assert(offsetof(UUITextureManager, GroupDatas) == 0x000028, "Member 'UUITextureManager::GroupDatas' has a wrong offset!");
static_assert(offsetof(UUITextureManager, TransparentTexture) == 0x000038, "Member 'UUITextureManager::TransparentTexture' has a wrong offset!");

// Class Nicola.UITitle2Menu
// 0x0110 (0x0188 - 0x0078)
class UUITitle2Menu final : public UUIRootBase
{
public:
	class UUITitle2MenuListTop*                   ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListBook*                  ListBook;                                          // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListSaveData*              ListSave1;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListSaveData*              ListSave2;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListStyle*                 ListStyle;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListVoice*                 ListVoice;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListGameMode*              ListGameMode;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListLanguageTop*           ListLanguageTop;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListLanguageText*          ListLanguageText;                                  // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuListLanguageVoice*         ListLanguageVoice;                                 // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuWindowConfirm*             WindowConfirm;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuWindowConfig*              WindowConfig;                                      // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuWindowGameMode*            WindowGameMode;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuWindowLanguage*            WindowLanguage;                                    // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2MenuFlowNewGame*               FlowNewGame;                                       // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveGameDataFlow*                    FlowSaveGameData;                                  // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2SystemSettingMenuListTop*      ListSetting1;                                      // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle2SystemSettingMenuListItems*    ListSetting2;                                      // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemButtonIconText*            ButtonHelp;                                        // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItemRich*                      ItemWindow;                                        // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFieldTacticsSystemSettingWindowVram* WindowVRAM;                                        // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x68];                                     // 0x0120(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2Menu">();
	}
	static class UUITitle2Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2Menu>();
	}
};
static_assert(alignof(UUITitle2Menu) == 0x000008, "Wrong alignment on UUITitle2Menu");
static_assert(sizeof(UUITitle2Menu) == 0x000188, "Wrong size on UUITitle2Menu");
static_assert(offsetof(UUITitle2Menu, ListTop) == 0x000078, "Member 'UUITitle2Menu::ListTop' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListBook) == 0x000080, "Member 'UUITitle2Menu::ListBook' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListSave1) == 0x000088, "Member 'UUITitle2Menu::ListSave1' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListSave2) == 0x000090, "Member 'UUITitle2Menu::ListSave2' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListStyle) == 0x000098, "Member 'UUITitle2Menu::ListStyle' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListVoice) == 0x0000A0, "Member 'UUITitle2Menu::ListVoice' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListGameMode) == 0x0000A8, "Member 'UUITitle2Menu::ListGameMode' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListLanguageTop) == 0x0000B0, "Member 'UUITitle2Menu::ListLanguageTop' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListLanguageText) == 0x0000B8, "Member 'UUITitle2Menu::ListLanguageText' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListLanguageVoice) == 0x0000C0, "Member 'UUITitle2Menu::ListLanguageVoice' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, WindowConfirm) == 0x0000C8, "Member 'UUITitle2Menu::WindowConfirm' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, WindowConfig) == 0x0000D0, "Member 'UUITitle2Menu::WindowConfig' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, WindowGameMode) == 0x0000D8, "Member 'UUITitle2Menu::WindowGameMode' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, WindowLanguage) == 0x0000E0, "Member 'UUITitle2Menu::WindowLanguage' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, FlowNewGame) == 0x0000E8, "Member 'UUITitle2Menu::FlowNewGame' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, FlowSaveGameData) == 0x0000F0, "Member 'UUITitle2Menu::FlowSaveGameData' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListSetting1) == 0x0000F8, "Member 'UUITitle2Menu::ListSetting1' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ListSetting2) == 0x000100, "Member 'UUITitle2Menu::ListSetting2' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ButtonHelp) == 0x000108, "Member 'UUITitle2Menu::ButtonHelp' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, ItemWindow) == 0x000110, "Member 'UUITitle2Menu::ItemWindow' has a wrong offset!");
static_assert(offsetof(UUITitle2Menu, WindowVRAM) == 0x000118, "Member 'UUITitle2Menu::WindowVRAM' has a wrong offset!");

// Class Nicola.UITitle2MenuFlowNewGame
// 0x0008 (0x0078 - 0x0070)
class UUITitle2MenuFlowNewGame final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuFlowNewGame">();
	}
	static class UUITitle2MenuFlowNewGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuFlowNewGame>();
	}
};
static_assert(alignof(UUITitle2MenuFlowNewGame) == 0x000008, "Wrong alignment on UUITitle2MenuFlowNewGame");
static_assert(sizeof(UUITitle2MenuFlowNewGame) == 0x000078, "Wrong size on UUITitle2MenuFlowNewGame");

// Class Nicola.UITitle2MenuListBook
// 0x0018 (0x00E8 - 0x00D0)
class UUITitle2MenuListBook final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListBook">();
	}
	static class UUITitle2MenuListBook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListBook>();
	}
};
static_assert(alignof(UUITitle2MenuListBook) == 0x000008, "Wrong alignment on UUITitle2MenuListBook");
static_assert(sizeof(UUITitle2MenuListBook) == 0x0000E8, "Wrong size on UUITitle2MenuListBook");

// Class Nicola.UITitle2MenuListGameMode
// 0x0008 (0x00C8 - 0x00C0)
class UUITitle2MenuListGameMode final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListGameMode">();
	}
	static class UUITitle2MenuListGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListGameMode>();
	}
};
static_assert(alignof(UUITitle2MenuListGameMode) == 0x000008, "Wrong alignment on UUITitle2MenuListGameMode");
static_assert(sizeof(UUITitle2MenuListGameMode) == 0x0000C8, "Wrong size on UUITitle2MenuListGameMode");

// Class Nicola.UITitle2MenuListLanguageTop
// 0x0018 (0x00D8 - 0x00C0)
class UUITitle2MenuListLanguageTop final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListLanguageTop">();
	}
	static class UUITitle2MenuListLanguageTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListLanguageTop>();
	}
};
static_assert(alignof(UUITitle2MenuListLanguageTop) == 0x000008, "Wrong alignment on UUITitle2MenuListLanguageTop");
static_assert(sizeof(UUITitle2MenuListLanguageTop) == 0x0000D8, "Wrong size on UUITitle2MenuListLanguageTop");

// Class Nicola.UITitle2MenuListLanguageVoice
// 0x0010 (0x00D0 - 0x00C0)
class UUITitle2MenuListLanguageVoice final : public UUIListSimple
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListLanguageVoice">();
	}
	static class UUITitle2MenuListLanguageVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListLanguageVoice>();
	}
};
static_assert(alignof(UUITitle2MenuListLanguageVoice) == 0x000008, "Wrong alignment on UUITitle2MenuListLanguageVoice");
static_assert(sizeof(UUITitle2MenuListLanguageVoice) == 0x0000D0, "Wrong size on UUITitle2MenuListLanguageVoice");

// Class Nicola.UITitle2MenuListSaveData
// 0x0020 (0x00F0 - 0x00D0)
class UUITitle2MenuListSaveData final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListSaveData">();
	}
	static class UUITitle2MenuListSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListSaveData>();
	}
};
static_assert(alignof(UUITitle2MenuListSaveData) == 0x000008, "Wrong alignment on UUITitle2MenuListSaveData");
static_assert(sizeof(UUITitle2MenuListSaveData) == 0x0000F0, "Wrong size on UUITitle2MenuListSaveData");

// Class Nicola.UITitle2MenuListSaveDataItem
// 0x0048 (0x00A0 - 0x0058)
class UUITitle2MenuListSaveDataItem final : public UUIListItem
{
public:
	class UGopTextBlock*                          TextName;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLvLabel;                                       // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextLvValue;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextPlace;                                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextTimeLabel;                                     // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextTimeValue;                                     // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextDateLabel;                                     // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextDateValue;                                     // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextEmpty;                                         // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListSaveDataItem">();
	}
	static class UUITitle2MenuListSaveDataItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListSaveDataItem>();
	}
};
static_assert(alignof(UUITitle2MenuListSaveDataItem) == 0x000008, "Wrong alignment on UUITitle2MenuListSaveDataItem");
static_assert(sizeof(UUITitle2MenuListSaveDataItem) == 0x0000A0, "Wrong size on UUITitle2MenuListSaveDataItem");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextName) == 0x000058, "Member 'UUITitle2MenuListSaveDataItem::TextName' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextLvLabel) == 0x000060, "Member 'UUITitle2MenuListSaveDataItem::TextLvLabel' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextLvValue) == 0x000068, "Member 'UUITitle2MenuListSaveDataItem::TextLvValue' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextPlace) == 0x000070, "Member 'UUITitle2MenuListSaveDataItem::TextPlace' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextTimeLabel) == 0x000078, "Member 'UUITitle2MenuListSaveDataItem::TextTimeLabel' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextTimeValue) == 0x000080, "Member 'UUITitle2MenuListSaveDataItem::TextTimeValue' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextDateLabel) == 0x000088, "Member 'UUITitle2MenuListSaveDataItem::TextDateLabel' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextDateValue) == 0x000090, "Member 'UUITitle2MenuListSaveDataItem::TextDateValue' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuListSaveDataItem, TextEmpty) == 0x000098, "Member 'UUITitle2MenuListSaveDataItem::TextEmpty' has a wrong offset!");

// Class Nicola.UITitle2MenuListStyle
// 0x0008 (0x00F0 - 0x00E8)
class UUITitle2MenuListStyle final : public UUIListCrossH
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListStyle">();
	}
	static class UUITitle2MenuListStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListStyle>();
	}
};
static_assert(alignof(UUITitle2MenuListStyle) == 0x000008, "Wrong alignment on UUITitle2MenuListStyle");
static_assert(sizeof(UUITitle2MenuListStyle) == 0x0000F0, "Wrong size on UUITitle2MenuListStyle");

// Class Nicola.UITitle2MenuListStyleItem
// 0x0010 (0x0068 - 0x0058)
class UUITitle2MenuListStyleItem final : public UUIListItem
{
public:
	TArray<class UFlipbookWidget*>                Flipbooks;                                         // 0x0058(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListStyleItem">();
	}
	static class UUITitle2MenuListStyleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListStyleItem>();
	}
};
static_assert(alignof(UUITitle2MenuListStyleItem) == 0x000008, "Wrong alignment on UUITitle2MenuListStyleItem");
static_assert(sizeof(UUITitle2MenuListStyleItem) == 0x000068, "Wrong size on UUITitle2MenuListStyleItem");
static_assert(offsetof(UUITitle2MenuListStyleItem, Flipbooks) == 0x000058, "Member 'UUITitle2MenuListStyleItem::Flipbooks' has a wrong offset!");

// Class Nicola.UITitle2MenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUITitle2MenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuListTop">();
	}
	static class UUITitle2MenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuListTop>();
	}
};
static_assert(alignof(UUITitle2MenuListTop) == 0x000008, "Wrong alignment on UUITitle2MenuListTop");
static_assert(sizeof(UUITitle2MenuListTop) == 0x0000E8, "Wrong size on UUITitle2MenuListTop");

// Class Nicola.UITitle2MenuWindowConfig
// 0x0020 (0x0078 - 0x0058)
class UUITitle2MenuWindowConfig final : public UUIWindowBase
{
public:
	TArray<class UUIWindowItemText2*>             Items;                                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EItemType>                             ItemTypes;                                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuWindowConfig">();
	}
	static class UUITitle2MenuWindowConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuWindowConfig>();
	}
};
static_assert(alignof(UUITitle2MenuWindowConfig) == 0x000008, "Wrong alignment on UUITitle2MenuWindowConfig");
static_assert(sizeof(UUITitle2MenuWindowConfig) == 0x000078, "Wrong size on UUITitle2MenuWindowConfig");
static_assert(offsetof(UUITitle2MenuWindowConfig, Items) == 0x000058, "Member 'UUITitle2MenuWindowConfig::Items' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuWindowConfig, ItemTypes) == 0x000068, "Member 'UUITitle2MenuWindowConfig::ItemTypes' has a wrong offset!");

// Class Nicola.UITitle2MenuWindowConfirm
// 0x0018 (0x0070 - 0x0058)
class UUITitle2MenuWindowConfirm final : public UUIWindowBase
{
public:
	class UGopTextBlock*                          TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUITitle2MenuListStyleItem*>     Items;                                             // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuWindowConfirm">();
	}
	static class UUITitle2MenuWindowConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuWindowConfirm>();
	}
};
static_assert(alignof(UUITitle2MenuWindowConfirm) == 0x000008, "Wrong alignment on UUITitle2MenuWindowConfirm");
static_assert(sizeof(UUITitle2MenuWindowConfirm) == 0x000070, "Wrong size on UUITitle2MenuWindowConfirm");
static_assert(offsetof(UUITitle2MenuWindowConfirm, TextItem) == 0x000058, "Member 'UUITitle2MenuWindowConfirm::TextItem' has a wrong offset!");
static_assert(offsetof(UUITitle2MenuWindowConfirm, Items) == 0x000060, "Member 'UUITitle2MenuWindowConfirm::Items' has a wrong offset!");

// Class Nicola.UITitle2MenuWindowGameMode
// 0x0008 (0x0060 - 0x0058)
class UUITitle2MenuWindowGameMode final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuWindowGameMode">();
	}
	static class UUITitle2MenuWindowGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuWindowGameMode>();
	}
};
static_assert(alignof(UUITitle2MenuWindowGameMode) == 0x000008, "Wrong alignment on UUITitle2MenuWindowGameMode");
static_assert(sizeof(UUITitle2MenuWindowGameMode) == 0x000060, "Wrong size on UUITitle2MenuWindowGameMode");
static_assert(offsetof(UUITitle2MenuWindowGameMode, TextInfo) == 0x000058, "Member 'UUITitle2MenuWindowGameMode::TextInfo' has a wrong offset!");

// Class Nicola.UITitle2MenuWindowLanguage
// 0x0008 (0x0060 - 0x0058)
class UUITitle2MenuWindowLanguage final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextInfo;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2MenuWindowLanguage">();
	}
	static class UUITitle2MenuWindowLanguage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2MenuWindowLanguage>();
	}
};
static_assert(alignof(UUITitle2MenuWindowLanguage) == 0x000008, "Wrong alignment on UUITitle2MenuWindowLanguage");
static_assert(sizeof(UUITitle2MenuWindowLanguage) == 0x000060, "Wrong size on UUITitle2MenuWindowLanguage");
static_assert(offsetof(UUITitle2MenuWindowLanguage, TextInfo) == 0x000058, "Member 'UUITitle2MenuWindowLanguage::TextInfo' has a wrong offset!");

// Class Nicola.UITitle2SystemSettingMenuListItems
// 0x0038 (0x0108 - 0x00D0)
class UUITitle2SystemSettingMenuListItems final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x38];                                      // 0x00D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2SystemSettingMenuListItems">();
	}
	static class UUITitle2SystemSettingMenuListItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2SystemSettingMenuListItems>();
	}
};
static_assert(alignof(UUITitle2SystemSettingMenuListItems) == 0x000008, "Wrong alignment on UUITitle2SystemSettingMenuListItems");
static_assert(sizeof(UUITitle2SystemSettingMenuListItems) == 0x000108, "Wrong size on UUITitle2SystemSettingMenuListItems");

// Class Nicola.UITitle2SystemSettingMenuListTop
// 0x0018 (0x00E8 - 0x00D0)
class UUITitle2SystemSettingMenuListTop final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle2SystemSettingMenuListTop">();
	}
	static class UUITitle2SystemSettingMenuListTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle2SystemSettingMenuListTop>();
	}
};
static_assert(alignof(UUITitle2SystemSettingMenuListTop) == 0x000008, "Wrong alignment on UUITitle2SystemSettingMenuListTop");
static_assert(sizeof(UUITitle2SystemSettingMenuListTop) == 0x0000E8, "Wrong size on UUITitle2SystemSettingMenuListTop");

// Class Nicola.UITitleDemoMenu
// 0x0040 (0x00B8 - 0x0078)
class UUITitleDemoMenu final : public UUIRootBase
{
public:
	class UUITitleDemoMenuListTop*                ListTop;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitleDemoMenuWindowTitle*            WindowTitleDemo;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          WindowCopyright;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextGamerTag;                                      // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGopTextBlock*                          TextVersion;                                       // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitleDemoMenuWindowItemOpening*      WindowMovie;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIInitialMenuFlowSaveData*             FlowSaveData;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsExecMenu();
	static void OpenMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleDemoMenu">();
	}
	static class UUITitleDemoMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleDemoMenu>();
	}
};
static_assert(alignof(UUITitleDemoMenu) == 0x000008, "Wrong alignment on UUITitleDemoMenu");
static_assert(sizeof(UUITitleDemoMenu) == 0x0000B8, "Wrong size on UUITitleDemoMenu");
static_assert(offsetof(UUITitleDemoMenu, ListTop) == 0x000078, "Member 'UUITitleDemoMenu::ListTop' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenu, WindowTitleDemo) == 0x000080, "Member 'UUITitleDemoMenu::WindowTitleDemo' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenu, WindowCopyright) == 0x000088, "Member 'UUITitleDemoMenu::WindowCopyright' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenu, TextGamerTag) == 0x000090, "Member 'UUITitleDemoMenu::TextGamerTag' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenu, TextVersion) == 0x000098, "Member 'UUITitleDemoMenu::TextVersion' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenu, WindowMovie) == 0x0000A0, "Member 'UUITitleDemoMenu::WindowMovie' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenu, FlowSaveData) == 0x0000A8, "Member 'UUITitleDemoMenu::FlowSaveData' has a wrong offset!");

// Class Nicola.UITitleDemoMenuWindowItemOpening
// 0x0010 (0x0050 - 0x0040)
class UUITitleDemoMenuWindowItemOpening final : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWindowItemMovieImage*                ItemMovie;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleDemoMenuWindowItemOpening">();
	}
	static class UUITitleDemoMenuWindowItemOpening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleDemoMenuWindowItemOpening>();
	}
};
static_assert(alignof(UUITitleDemoMenuWindowItemOpening) == 0x000008, "Wrong alignment on UUITitleDemoMenuWindowItemOpening");
static_assert(sizeof(UUITitleDemoMenuWindowItemOpening) == 0x000050, "Wrong size on UUITitleDemoMenuWindowItemOpening");
static_assert(offsetof(UUITitleDemoMenuWindowItemOpening, ItemMovie) == 0x000048, "Member 'UUITitleDemoMenuWindowItemOpening::ItemMovie' has a wrong offset!");

// Class Nicola.UITitleDemoMenuWindowItemTitleBack
// 0x0018 (0x0058 - 0x0040)
class UUITitleDemoMenuWindowItemTitleBack final : public UUIWindowItem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTitleBackImage>                ImageDatas;                                        // 0x0048(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleDemoMenuWindowItemTitleBack">();
	}
	static class UUITitleDemoMenuWindowItemTitleBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleDemoMenuWindowItemTitleBack>();
	}
};
static_assert(alignof(UUITitleDemoMenuWindowItemTitleBack) == 0x000008, "Wrong alignment on UUITitleDemoMenuWindowItemTitleBack");
static_assert(sizeof(UUITitleDemoMenuWindowItemTitleBack) == 0x000058, "Wrong size on UUITitleDemoMenuWindowItemTitleBack");
static_assert(offsetof(UUITitleDemoMenuWindowItemTitleBack, ImageDatas) == 0x000048, "Member 'UUITitleDemoMenuWindowItemTitleBack::ImageDatas' has a wrong offset!");

// Class Nicola.UITitleDemoMenuWindowTitle
// 0x0030 (0x00A0 - 0x0070)
class UUITitleDemoMenuWindowTitle final : public UUICtrlBase
{
public:
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageBg;                                           // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWindowItem*                          ItemTitleLogo;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitleDemoMenuWindowItemTitleBack*    ItemTitleBack;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleDemoMenuWindowTitle">();
	}
	static class UUITitleDemoMenuWindowTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleDemoMenuWindowTitle>();
	}
};
static_assert(alignof(UUITitleDemoMenuWindowTitle) == 0x000008, "Wrong alignment on UUITitleDemoMenuWindowTitle");
static_assert(sizeof(UUITitleDemoMenuWindowTitle) == 0x0000A0, "Wrong size on UUITitleDemoMenuWindowTitle");
static_assert(offsetof(UUITitleDemoMenuWindowTitle, ImageBg) == 0x000088, "Member 'UUITitleDemoMenuWindowTitle::ImageBg' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenuWindowTitle, ItemTitleLogo) == 0x000090, "Member 'UUITitleDemoMenuWindowTitle::ItemTitleLogo' has a wrong offset!");
static_assert(offsetof(UUITitleDemoMenuWindowTitle, ItemTitleBack) == 0x000098, "Member 'UUITitleDemoMenuWindowTitle::ItemTitleBack' has a wrong offset!");

// Class Nicola.UITitleMenuListStartQuest
// 0x0008 (0x00D8 - 0x00D0)
class UUITitleMenuListStartQuest final : public UUIListPage
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenuListStartQuest">();
	}
	static class UUITitleMenuListStartQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenuListStartQuest>();
	}
};
static_assert(alignof(UUITitleMenuListStartQuest) == 0x000008, "Wrong alignment on UUITitleMenuListStartQuest");
static_assert(sizeof(UUITitleMenuListStartQuest) == 0x0000D8, "Wrong size on UUITitleMenuListStartQuest");

// Class Nicola.UITutorialCtrlTop
// 0x0020 (0x0090 - 0x0070)
class UUITutorialCtrlTop final : public UUICtrlBase
{
public:
	struct FUILoadableTexture                     loadableTexture;                                   // 0x0070(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialCtrlTop">();
	}
	static class UUITutorialCtrlTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorialCtrlTop>();
	}
};
static_assert(alignof(UUITutorialCtrlTop) == 0x000008, "Wrong alignment on UUITutorialCtrlTop");
static_assert(sizeof(UUITutorialCtrlTop) == 0x000090, "Wrong size on UUITutorialCtrlTop");
static_assert(offsetof(UUITutorialCtrlTop, loadableTexture) == 0x000070, "Member 'UUITutorialCtrlTop::loadableTexture' has a wrong offset!");

// Class Nicola.UIWidgetManager
// 0x02F0 (0x0318 - 0x0028)
class UUIWidgetManager : public UObject
{
public:
	class UNicolaGameInstance*                    NGI;                                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANicolaPlayerController*                NPC;                                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNicolaUIManager*                       UIManager;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EUIWidgetId, TSubclassOf<class UCommonWindowWidget>> BP_Residents;                                      // 0x0040(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EUIWidgetId, struct FSoftClassPath>      BP_Menus;                                          // 0x0090(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EUIWidgetId, class UCommonWindowWidget*> ViewResidents;                                     // 0x00E0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EUIWidgetId, class UCommonWindowWidget*> ViewMenus;                                         // 0x0130(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EUIWidgetId, class UUIRootBase*>         RootResidents;                                     // 0x0180(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EUIWidgetId, class UUIRootBase*>         RootMenus;                                         // 0x01D0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<EUIWidgetId>                           ReqStartWidgetIds;                                 // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EUIWidgetId>                           ReqLoadWidgetIds;                                  // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   LoadingView;                                       // 0x0250(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIRootBase*>                    ExecMenus;                                         // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUICtrlBase*>                    UpdateCtrls;                                       // 0x0298(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUICtrlBase*>                    AddUpdateCtrls;                                    // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UCommonRootWidget*, ESlateVisibility> DEBUG_HideWidgets;                                 // 0x02C8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UUIWidgetManager* GetInstance();

	void ClearTitleMenuStorage();
	bool DEBUG_GetHideUI_MV();
	bool DEBUG_GetHideUI_SS();
	void DEBUG_SetHideUI_MV(bool InFlag);
	void DEBUG_SetHideUI_SS(bool InFlag);
	void DebugShowMessage(const class FString& InMessage);
	ETitleMenuMessage GetTitleMenuMessage();
	int32 GetTitleMenuSelectedSaveSlotIndex();
	bool IsTitleMenuEnd();
	void OpenBankMenu();
	void OpenBarMenu();
	void OpenFieldMenuTop();
	void OpenFieldPopup();
	void OpenInnMenu(class FName InInnId, int32 InCallMemberIndex, bool InDoChangeMap);
	void OpenMedalRewardMenu();
	void OpenMedalTradeMenu();
	void OpenMemberCreateMenu();
	void OpenShopMenuTest(class FName InShopId);
	void OpenTestWidget();
	void OpenTitleMenu();
	void OpenTutorialTest(class FName InGopId);
	void OpenXenlonWishMenu();
	bool StartMenu(EUIWidgetId InId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidgetManager">();
	}
	static class UUIWidgetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidgetManager>();
	}
};
static_assert(alignof(UUIWidgetManager) == 0x000008, "Wrong alignment on UUIWidgetManager");
static_assert(sizeof(UUIWidgetManager) == 0x000318, "Wrong size on UUIWidgetManager");
static_assert(offsetof(UUIWidgetManager, NGI) == 0x000028, "Member 'UUIWidgetManager::NGI' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, NPC) == 0x000030, "Member 'UUIWidgetManager::NPC' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, UIManager) == 0x000038, "Member 'UUIWidgetManager::UIManager' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, BP_Residents) == 0x000040, "Member 'UUIWidgetManager::BP_Residents' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, BP_Menus) == 0x000090, "Member 'UUIWidgetManager::BP_Menus' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, ViewResidents) == 0x0000E0, "Member 'UUIWidgetManager::ViewResidents' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, ViewMenus) == 0x000130, "Member 'UUIWidgetManager::ViewMenus' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, RootResidents) == 0x000180, "Member 'UUIWidgetManager::RootResidents' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, RootMenus) == 0x0001D0, "Member 'UUIWidgetManager::RootMenus' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, ReqStartWidgetIds) == 0x000220, "Member 'UUIWidgetManager::ReqStartWidgetIds' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, ReqLoadWidgetIds) == 0x000230, "Member 'UUIWidgetManager::ReqLoadWidgetIds' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, LoadingView) == 0x000250, "Member 'UUIWidgetManager::LoadingView' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, ExecMenus) == 0x000288, "Member 'UUIWidgetManager::ExecMenus' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, UpdateCtrls) == 0x000298, "Member 'UUIWidgetManager::UpdateCtrls' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, AddUpdateCtrls) == 0x0002A8, "Member 'UUIWidgetManager::AddUpdateCtrls' has a wrong offset!");
static_assert(offsetof(UUIWidgetManager, DEBUG_HideWidgets) == 0x0002C8, "Member 'UUIWidgetManager::DEBUG_HideWidgets' has a wrong offset!");

// Class Nicola.UIWindowItemButtonLongPress
// 0x0008 (0x0050 - 0x0048)
class UUIWindowItemButtonLongPress final : public UUIWindowItemButtonIcon
{
public:
	class UButtonIconLongPressWidget*             LongPress;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemButtonLongPress">();
	}
	static class UUIWindowItemButtonLongPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemButtonLongPress>();
	}
};
static_assert(alignof(UUIWindowItemButtonLongPress) == 0x000008, "Wrong alignment on UUIWindowItemButtonLongPress");
static_assert(sizeof(UUIWindowItemButtonLongPress) == 0x000050, "Wrong size on UUIWindowItemButtonLongPress");
static_assert(offsetof(UUIWindowItemButtonLongPress, LongPress) == 0x000048, "Member 'UUIWindowItemButtonLongPress::LongPress' has a wrong offset!");

// Class Nicola.UIWindowItemEndingLogo
// 0x0000 (0x0040 - 0x0040)
class UUIWindowItemEndingLogo final : public UUIWindowItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemEndingLogo">();
	}
	static class UUIWindowItemEndingLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemEndingLogo>();
	}
};
static_assert(alignof(UUIWindowItemEndingLogo) == 0x000008, "Wrong alignment on UUIWindowItemEndingLogo");
static_assert(sizeof(UUIWindowItemEndingLogo) == 0x000040, "Wrong size on UUIWindowItemEndingLogo");

// Class Nicola.UIWindowItemLongPress
// 0x0010 (0x0050 - 0x0040)
class UUIWindowItemLongPress final : public UUIWindowItem
{
public:
	class UImage*                                 ItemGauge;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemLongPress">();
	}
	static class UUIWindowItemLongPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemLongPress>();
	}
};
static_assert(alignof(UUIWindowItemLongPress) == 0x000008, "Wrong alignment on UUIWindowItemLongPress");
static_assert(sizeof(UUIWindowItemLongPress) == 0x000050, "Wrong size on UUIWindowItemLongPress");
static_assert(offsetof(UUIWindowItemLongPress, ItemGauge) == 0x000040, "Member 'UUIWindowItemLongPress::ItemGauge' has a wrong offset!");
static_assert(offsetof(UUIWindowItemLongPress, ItemIcon) == 0x000048, "Member 'UUIWindowItemLongPress::ItemIcon' has a wrong offset!");

// Class Nicola.UIWindowItemMedal
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemMedal final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemMedal">();
	}
	static class UUIWindowItemMedal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemMedal>();
	}
};
static_assert(alignof(UUIWindowItemMedal) == 0x000008, "Wrong alignment on UUIWindowItemMedal");
static_assert(sizeof(UUIWindowItemMedal) == 0x000048, "Wrong size on UUIWindowItemMedal");
static_assert(offsetof(UUIWindowItemMedal, TextItem2) == 0x000040, "Member 'UUIWindowItemMedal::TextItem2' has a wrong offset!");

// Class Nicola.UIWindowItemRich
// 0x0008 (0x0048 - 0x0040)
class UUIWindowItemRich final : public UUIWindowItem
{
public:
	class UNicolaRichTextBlock*                   RichTextItem;                                      // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemRich">();
	}
	static class UUIWindowItemRich* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemRich>();
	}
};
static_assert(alignof(UUIWindowItemRich) == 0x000008, "Wrong alignment on UUIWindowItemRich");
static_assert(sizeof(UUIWindowItemRich) == 0x000048, "Wrong size on UUIWindowItemRich");
static_assert(offsetof(UUIWindowItemRich, RichTextItem) == 0x000040, "Member 'UUIWindowItemRich::RichTextItem' has a wrong offset!");

// Class Nicola.UIWindowItemStatusGauge
// 0x0010 (0x0050 - 0x0040)
class UUIWindowItemStatusGauge final : public UUIWindowItem
{
public:
	class UImage*                                 ImageGauge;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextTitle;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemStatusGauge">();
	}
	static class UUIWindowItemStatusGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemStatusGauge>();
	}
};
static_assert(alignof(UUIWindowItemStatusGauge) == 0x000008, "Wrong alignment on UUIWindowItemStatusGauge");
static_assert(sizeof(UUIWindowItemStatusGauge) == 0x000050, "Wrong size on UUIWindowItemStatusGauge");
static_assert(offsetof(UUIWindowItemStatusGauge, ImageGauge) == 0x000040, "Member 'UUIWindowItemStatusGauge::ImageGauge' has a wrong offset!");
static_assert(offsetof(UUIWindowItemStatusGauge, TextTitle) == 0x000048, "Member 'UUIWindowItemStatusGauge::TextTitle' has a wrong offset!");

// Class Nicola.UIWindowItemText4
// 0x0018 (0x0058 - 0x0040)
class UUIWindowItemText4 final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextItem2;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem3;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextItem4;                                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemText4">();
	}
	static class UUIWindowItemText4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemText4>();
	}
};
static_assert(alignof(UUIWindowItemText4) == 0x000008, "Wrong alignment on UUIWindowItemText4");
static_assert(sizeof(UUIWindowItemText4) == 0x000058, "Wrong size on UUIWindowItemText4");
static_assert(offsetof(UUIWindowItemText4, TextItem2) == 0x000040, "Member 'UUIWindowItemText4::TextItem2' has a wrong offset!");
static_assert(offsetof(UUIWindowItemText4, TextItem3) == 0x000048, "Member 'UUIWindowItemText4::TextItem3' has a wrong offset!");
static_assert(offsetof(UUIWindowItemText4, TextItem4) == 0x000050, "Member 'UUIWindowItemText4::TextItem4' has a wrong offset!");

// Class Nicola.UIWindowItemUnitStatus
// 0x0018 (0x0058 - 0x0040)
class UUIWindowItemUnitStatus final : public UUIWindowItem
{
public:
	class UGopTextBlock*                          TextParamLeft;                                     // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextSlash;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGopTextBlock*                          TextParamRight;                                    // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowItemUnitStatus">();
	}
	static class UUIWindowItemUnitStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowItemUnitStatus>();
	}
};
static_assert(alignof(UUIWindowItemUnitStatus) == 0x000008, "Wrong alignment on UUIWindowItemUnitStatus");
static_assert(sizeof(UUIWindowItemUnitStatus) == 0x000058, "Wrong size on UUIWindowItemUnitStatus");
static_assert(offsetof(UUIWindowItemUnitStatus, TextParamLeft) == 0x000040, "Member 'UUIWindowItemUnitStatus::TextParamLeft' has a wrong offset!");
static_assert(offsetof(UUIWindowItemUnitStatus, TextSlash) == 0x000048, "Member 'UUIWindowItemUnitStatus::TextSlash' has a wrong offset!");
static_assert(offsetof(UUIWindowItemUnitStatus, TextParamRight) == 0x000050, "Member 'UUIWindowItemUnitStatus::TextParamRight' has a wrong offset!");

// Class Nicola.UIWindowText
// 0x0008 (0x0060 - 0x0058)
class UUIWindowText final : public UUIWindowBase
{
public:
	class UNicolaRichTextBlock*                   TextItem;                                          // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWindowText">();
	}
	static class UUIWindowText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWindowText>();
	}
};
static_assert(alignof(UUIWindowText) == 0x000008, "Wrong alignment on UUIWindowText");
static_assert(sizeof(UUIWindowText) == 0x000060, "Wrong size on UUIWindowText");
static_assert(offsetof(UUIWindowText, TextItem) == 0x000058, "Member 'UUIWindowText::TextItem' has a wrong offset!");

// Class Nicola.VehicleEventTrigger
// 0x0010 (0x0490 - 0x0480)
class UVehicleEventTrigger final : public USphereComponent
{
public:
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDestroyedParent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleEventTrigger">();
	}
	static class UVehicleEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleEventTrigger>();
	}
};
static_assert(alignof(UVehicleEventTrigger) == 0x000010, "Wrong alignment on UVehicleEventTrigger");
static_assert(sizeof(UVehicleEventTrigger) == 0x000490, "Wrong size on UVehicleEventTrigger");

// Class Nicola.WidgetSoundSuperVisionContent
// 0x0038 (0x0298 - 0x0260)
class UWidgetSoundSuperVisionContent final : public UUserWidget
{
public:
	class UBorder*                                BorderBackGround;                                  // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcherDirtyMark;                           // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBoxSoundName;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBoxSoundId;                                    // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextSoundName;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextSoundId;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextSoundVolumeRate;                               // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetSoundSuperVisionContent">();
	}
	static class UWidgetSoundSuperVisionContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetSoundSuperVisionContent>();
	}
};
static_assert(alignof(UWidgetSoundSuperVisionContent) == 0x000008, "Wrong alignment on UWidgetSoundSuperVisionContent");
static_assert(sizeof(UWidgetSoundSuperVisionContent) == 0x000298, "Wrong size on UWidgetSoundSuperVisionContent");
static_assert(offsetof(UWidgetSoundSuperVisionContent, BorderBackGround) == 0x000260, "Member 'UWidgetSoundSuperVisionContent::BorderBackGround' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionContent, WidgetSwitcherDirtyMark) == 0x000268, "Member 'UWidgetSoundSuperVisionContent::WidgetSwitcherDirtyMark' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionContent, SizeBoxSoundName) == 0x000270, "Member 'UWidgetSoundSuperVisionContent::SizeBoxSoundName' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionContent, SizeBoxSoundId) == 0x000278, "Member 'UWidgetSoundSuperVisionContent::SizeBoxSoundId' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionContent, TextSoundName) == 0x000280, "Member 'UWidgetSoundSuperVisionContent::TextSoundName' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionContent, TextSoundId) == 0x000288, "Member 'UWidgetSoundSuperVisionContent::TextSoundId' has a wrong offset!");
static_assert(offsetof(UWidgetSoundSuperVisionContent, TextSoundVolumeRate) == 0x000290, "Member 'UWidgetSoundSuperVisionContent::TextSoundVolumeRate' has a wrong offset!");

}

