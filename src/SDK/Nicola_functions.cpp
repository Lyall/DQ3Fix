#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Nicola

#include "Basic.hpp"

#include "Nicola_classes.hpp"
#include "Nicola_parameters.hpp"


namespace SDK
{

// Function Nicola.TriggerEventActor.GetTriggerType
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEventTriggerType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEventTriggerType ATriggerEventActor::GetTriggerType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerEventActor", "GetTriggerType");

	Params::TriggerEventActor_GetTriggerType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ActorListMan.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UActorListMan*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorListMan* UActorListMan::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorListMan", "GetInstance");

	Params::ActorListMan_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ActorListMan.GetActorList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActorType                              actorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UActorListMan::GetActorList(EActorType actorType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorListMan", "GetActorList");

	Params::ActorListMan_GetActorList Parms{};

	Parms.actorType = actorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ActorListMan.GetActorListInRange
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActorType                              actorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UActorListMan::GetActorListInRange(EActorType actorType, const struct FVector& Center, float Radius, bool bIgnoreZ) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorListMan", "GetActorListInRange");

	Params::ActorListMan_GetActorListInRange Parms{};

	Parms.actorType = actorType;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.bIgnoreZ = bIgnoreZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LevelLoaderActor.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALevelLoaderActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLoaderActor", "OnOverlapBegin");

	Params::LevelLoaderActor_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ButtonGuideComponent.BP_CloseButtonGuide
// (Final, Native, Private, BlueprintCallable)

void UButtonGuideComponent::BP_CloseButtonGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonGuideComponent", "BP_CloseButtonGuide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ButtonGuideComponent.BP_ShowButtonGuide
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonGuideComponent::BP_ShowButtonGuide(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonGuideComponent", "BP_ShowButtonGuide");

	Params::ButtonGuideComponent_BP_ShowButtonGuide Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPaperFlipbookComponent.PlayNewFlipbook
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPaperFlipbook*                   NewFlipbook                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReverse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   mReservedStartFrame                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   mReservedPlayRate                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPaperFlipbookComponent::PlayNewFlipbook(class UPaperFlipbook* NewFlipbook, bool bLoop, bool bReverse, int32 mReservedStartFrame, float mReservedPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPaperFlipbookComponent", "PlayNewFlipbook");

	Params::NicolaPaperFlipbookComponent_PlayNewFlipbook Parms{};

	Parms.NewFlipbook = NewFlipbook;
	Parms.bLoop = bLoop;
	Parms.bReverse = bReverse;
	Parms.mReservedStartFrame = mReservedStartFrame;
	Parms.mReservedPlayRate = mReservedPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugGetDlcFlags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaPlatformDebugFL::DebugGetDlcFlags(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugGetDlcFlags");

	Params::NicolaPlatformDebugFL_DebugGetDlcFlags Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetDisplayTestConsoleCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InCmd                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InQuality                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetDisplayTestConsoleCommand(class UObject* WorldContextObject, const class FString& InCmd, int32 InQuality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetDisplayTestConsoleCommand");

	Params::NicolaPlatformDebugFL_DebugSetDisplayTestConsoleCommand Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InCmd = std::move(InCmd);
	Parms.InQuality = InQuality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetDlcFlags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetDlcFlags(int32 ID, bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetDlcFlags");

	Params::NicolaPlatformDebugFL_DebugSetDlcFlags Parms{};

	Parms.ID = ID;
	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetMaxFps
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FPS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetMaxFps(class UObject* WorldContextObject, int32 FPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetMaxFps");

	Params::NicolaPlatformDebugFL_DebugSetMaxFps Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FPS = FPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetMouseCursorVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetMouseCursorVisibility(class UObject* WorldContextObject, bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetMouseCursorVisibility");

	Params::NicolaPlatformDebugFL_DebugSetMouseCursorVisibility Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetMouseLockMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetMouseLockMode(class UObject* WorldContextObject, bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetMouseLockMode");

	Params::NicolaPlatformDebugFL_DebugSetMouseLockMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetShowMouseCursorAlways
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetShowMouseCursorAlways(class UObject* WorldContextObject, bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetShowMouseCursorAlways");

	Params::NicolaPlatformDebugFL_DebugSetShowMouseCursorAlways Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetUnfocusPadEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetUnfocusPadEnable(class UObject* WorldContextObject, bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetUnfocusPadEnable");

	Params::NicolaPlatformDebugFL_DebugSetUnfocusPadEnable Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetUnfocusSoundEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetUnfocusSoundEnable(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetUnfocusSoundEnable");

	Params::NicolaPlatformDebugFL_DebugSetUnfocusSoundEnable Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetVSync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetVSync(class UObject* WorldContextObject, bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetVSync");

	Params::NicolaPlatformDebugFL_DebugSetVSync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetWindowMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWindowMode                             InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetWindowMode(EWindowMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetWindowMode");

	Params::NicolaPlatformDebugFL_DebugSetWindowMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlatformDebugFL.DebugSetWindowResolution
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        InResolution                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaPlatformDebugFL::DebugSetWindowResolution(const struct FIntPoint& InResolution)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaPlatformDebugFL", "DebugSetWindowResolution");

	Params::NicolaPlatformDebugFL_DebugSetWindowResolution Parms{};

	Parms.InResolution = std::move(InResolution);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaMiscFL.ExecConsoleCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNicolaMiscFL::ExecConsoleCommand(class UObject* WorldContextObject, const class FString& Command, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "ExecConsoleCommand");

	Params::NicolaMiscFL_ExecConsoleCommand Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Command = std::move(Command);
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.GetActorLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* UNicolaMiscFL::GetActorLevel(class AActor* TARGET)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "GetActorLevel");

	Params::NicolaMiscFL_GetActorLevel Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.GetMeshNumTriangles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   lod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaMiscFL::GetMeshNumTriangles(class UStaticMesh* Mesh, int32 lod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "GetMeshNumTriangles");

	Params::NicolaMiscFL_GetMeshNumTriangles Parms{};

	Parms.Mesh = Mesh;
	Parms.lod = lod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.HasActorBegunPlay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaMiscFL::HasActorBegunPlay(class AActor* TARGET)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "HasActorBegunPlay");

	Params::NicolaMiscFL_HasActorBegunPlay Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.IsEditing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaMiscFL::IsEditing(const class UObject* InWorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "IsEditing");

	Params::NicolaMiscFL_IsEditing Parms{};

	Parms.InWorldContextObject = InWorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.IsVisibleLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaMiscFL::IsVisibleLevel(class ULevel* Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "IsVisibleLevel");

	Params::NicolaMiscFL_IsVisibleLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.IsWithEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaMiscFL::IsWithEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "IsWithEditor");

	Params::NicolaMiscFL_IsWithEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.SetVisibleActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaMiscFL::SetVisibleActor(class AActor* TARGET, bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "SetVisibleActor");

	Params::NicolaMiscFL_SetVisibleActor Parms{};

	Parms.TARGET = TARGET;
	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaMiscFL.SortStringArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UNicolaMiscFL::SortStringArray(const TArray<class FString>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "SortStringArray");

	Params::NicolaMiscFL_SortStringArray Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.SplitPath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DirPart                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FilenamePart                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ExtensionPart                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaMiscFL::SplitPath(const class FString& Path, class FString* DirPart, class FString* FilenamePart, class FString* ExtensionPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "SplitPath");

	Params::NicolaMiscFL_SplitPath Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DirPart != nullptr)
		*DirPart = std::move(Parms.DirPart);

	if (FilenamePart != nullptr)
		*FilenamePart = std::move(Parms.FilenamePart);

	if (ExtensionPart != nullptr)
		*ExtensionPart = std::move(Parms.ExtensionPart);
}


// Function Nicola.NicolaMiscFL.StringArrayToTextArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UNicolaMiscFL::StringArrayToTextArray(const TArray<class FString>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "StringArrayToTextArray");

	Params::NicolaMiscFL_StringArrayToTextArray Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.StringSetToSortedArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<class FString>                     Values                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UNicolaMiscFL::StringSetToSortedArray(const TSet<class FString>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "StringSetToSortedArray");

	Params::NicolaMiscFL_StringSetToSortedArray Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaMiscFL.TextArrayToStringArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FText>                     Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UNicolaMiscFL::TextArrayToStringArray(const TArray<class FText>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaMiscFL", "TextArrayToStringArray");

	Params::NicolaMiscFL_TextArrayToStringArray Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleBlendActor.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    menable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleBlendActor::SetEnable(bool menable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleBlendActor", "SetEnable");

	Params::BattleBlendActor_SetEnable Parms{};

	Parms.menable = menable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleBlendActor.SetRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   mrate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleBlendActor::SetRate(float mrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleBlendActor", "SetRate");

	Params::BattleBlendActor_SetRate Parms{};

	Parms.mrate = mrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ABattleCameraControl*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABattleCameraControl* ABattleCameraControl::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraControl", "GetInstance");

	Params::BattleCameraControl_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraControl.AllLoadCameraSetting_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::AllLoadCameraSetting_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "AllLoadCameraSetting_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.AllSaveCameraSetting_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::AllSaveCameraSetting_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "AllSaveCameraSetting_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.ChangeBattleCameraByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   typeIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    misFree                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::ChangeBattleCameraByIndex(int32 typeIndex, float BlendTime, bool misFree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeBattleCameraByIndex");

	Params::BattleCameraControl_ChangeBattleCameraByIndex Parms{};

	Parms.typeIndex = typeIndex;
	Parms.BlendTime = BlendTime;
	Parms.misFree = misFree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.ChangeBillboad_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::ChangeBillboad_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeBillboad_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.ChangeBillboard
// (Final, Native, Public, BlueprintCallable)

void ABattleCameraControl::ChangeBillboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeBillboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.ChangeDebugVisible_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::ChangeDebugVisible_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeDebugVisible_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.ChangeScale
// (Final, Native, Public, BlueprintCallable)

void ABattleCameraControl::ChangeScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.ChangeScale_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::ChangeScale_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeScale_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.ChangeScaleMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBattleTestActorMode                    Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::ChangeScaleMode(EBattleTestActorMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeScaleMode");

	Params::BattleCameraControl_ChangeScaleMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.ChangeUI_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::ChangeUI_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "ChangeUI_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.DebugGetMonsterLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          outWorldLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          outRelativeLocation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::DebugGetMonsterLocation(int32 SlotIndex, struct FVector* outWorldLocation, struct FVector* outRelativeLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "DebugGetMonsterLocation");

	Params::BattleCameraControl_DebugGetMonsterLocation Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outWorldLocation != nullptr)
		*outWorldLocation = std::move(Parms.outWorldLocation);

	if (outRelativeLocation != nullptr)
		*outRelativeLocation = std::move(Parms.outRelativeLocation);
}


// Function Nicola.BattleCameraControl.DebugGetPlayerLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   formationIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          outWorldLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          outRelativeLocation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::DebugGetPlayerLocation(int32 formationIndex, struct FVector* outWorldLocation, struct FVector* outRelativeLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "DebugGetPlayerLocation");

	Params::BattleCameraControl_DebugGetPlayerLocation Parms{};

	Parms.formationIndex = formationIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outWorldLocation != nullptr)
		*outWorldLocation = std::move(Parms.outWorldLocation);

	if (outRelativeLocation != nullptr)
		*outRelativeLocation = std::move(Parms.outRelativeLocation);
}


// Function Nicola.BattleCameraControl.FreeCameraToCurrentCamera
// (Final, Native, Public, BlueprintCallable)

void ABattleCameraControl::FreeCameraToCurrentCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "FreeCameraToCurrentCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.GetCameraActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EBattleCameraSettingType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACameraActor*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACameraActor* ABattleCameraControl::GetCameraActor(EBattleCameraSettingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "GetCameraActor");

	Params::BattleCameraControl_GetCameraActor Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraControl.GetEnemyBattlePositionLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABattlePositionLine*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABattlePositionLine* ABattleCameraControl::GetEnemyBattlePositionLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "GetEnemyBattlePositionLine");

	Params::BattleCameraControl_GetEnemyBattlePositionLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraControl.GetPositionLines
// (Final, Native, Public, BlueprintCallable)

void ABattleCameraControl::GetPositionLines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "GetPositionLines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.Init_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::Init_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "Init_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.LoadSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           settingFile                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleCameraSettingType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::LoadSetting(const class FString& settingFile, EBattleCameraSettingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "LoadSetting");

	Params::BattleCameraControl_LoadSetting Parms{};

	Parms.settingFile = std::move(settingFile);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.OnChangeCamera_BP
// (Event, Public, BlueprintEvent)

void ABattleCameraControl::OnChangeCamera_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "OnChangeCamera_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraControl.OnChangeFreeCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::OnChangeFreeCamera(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "OnChangeFreeCamera");

	Params::BattleCameraControl_OnChangeFreeCamera Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.OnInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::OnInput(class FName Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "OnInput");

	Params::BattleCameraControl_OnInput Parms{};

	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.PlaySequenceBackToFront
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    GoToEndAndStop                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDragon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    doCrossFade                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::PlaySequenceBackToFront(bool GoToEndAndStop, bool isDragon, bool doCrossFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "PlaySequenceBackToFront");

	Params::BattleCameraControl_PlaySequenceBackToFront Parms{};

	Parms.GoToEndAndStop = GoToEndAndStop;
	Parms.isDragon = isDragon;
	Parms.doCrossFade = doCrossFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.PlaySequenceFrontToBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    GoToEndAndStop                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDragon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    doCrossFade                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::PlaySequenceFrontToBack(bool GoToEndAndStop, bool isDragon, bool doCrossFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "PlaySequenceFrontToBack");

	Params::BattleCameraControl_PlaySequenceFrontToBack Parms{};

	Parms.GoToEndAndStop = GoToEndAndStop;
	Parms.isDragon = isDragon;
	Parms.doCrossFade = doCrossFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.SaveSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           settingFile                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleCameraSettingType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::SaveSetting(const class FString& settingFile, EBattleCameraSettingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "SaveSetting");

	Params::BattleCameraControl_SaveSetting Parms{};

	Parms.settingFile = std::move(settingFile);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.UpdateActionInput
// (Final, Native, Public, BlueprintCallable)

void ABattleCameraControl::UpdateActionInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "UpdateActionInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.UpdateDistanceRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraControl::UpdateDistanceRate(bool isForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "UpdateDistanceRate");

	Params::BattleCameraControl_UpdateDistanceRate Parms{};

	Parms.isForce = isForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraControl.IsOpenDebugMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABattleCameraControl::IsOpenDebugMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraControl", "IsOpenDebugMenu");

	Params::BattleCameraControl_IsOpenDebugMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraSequenceControl.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ABattleCameraSequenceControl*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABattleCameraSequenceControl* ABattleCameraSequenceControl::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSequenceControl", "GetInstance");

	Params::BattleCameraSequenceControl_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraSequenceControl.OnPlaySequenceFinished
// (Final, Native, Private)

void ABattleCameraSequenceControl::OnPlaySequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraSequenceControl", "OnPlaySequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCameraSequenceControl.PlaySequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class ULevelSequence>    sequenceSoftObjectPtr                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    GoToEndAndStop                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCameraSequenceControl::PlaySequence(TSoftObjectPtr<class ULevelSequence> sequenceSoftObjectPtr, bool GoToEndAndStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCameraSequenceControl", "PlaySequence");

	Params::BattleCameraSequenceControl_PlaySequence Parms{};

	Parms.sequenceSoftObjectPtr = sequenceSoftObjectPtr;
	Parms.GoToEndAndStop = GoToEndAndStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchLevel.OnVisibleLevel
// (Event, Public, BlueprintEvent)

void ANicolaResearchLevel::OnVisibleLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchLevel", "OnVisibleLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.BattleCameraSettingFL.CameraSettingToMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<class FName, struct FBattleCameraSetting>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, struct FBattleCameraSetting> UBattleCameraSettingFL::CameraSettingToMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "CameraSettingToMap");

	Params::BattleCameraSettingFL_CameraSettingToMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraSettingFL.GetCameraSettingDirPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBattleCameraSettingFL::GetCameraSettingDirPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "GetCameraSettingDirPath");

	Params::BattleCameraSettingFL_GetCameraSettingDirPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraSettingFL.GetDistanceRate
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Now                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleCameraSettingFL::GetDistanceRate(const struct FVector& Start, const struct FVector& End, const struct FVector& Now)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "GetDistanceRate");

	Params::BattleCameraSettingFL_GetDistanceRate Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Now = std::move(Now);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleCameraSettingFL.LoadCameraSetting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EBattleCameraSettingType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBattleCameraSetting             OutCameraSetting                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::LoadCameraSetting(EBattleCameraSettingType Type, struct FBattleCameraSetting* OutCameraSetting, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "LoadCameraSetting");

	Params::BattleCameraSettingFL_LoadCameraSetting Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCameraSetting != nullptr)
		*OutCameraSetting = std::move(Parms.OutCameraSetting);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCameraSettingFL.LoadCameraSettingByFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EBattleCameraSettingType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SettingFilePath                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBattleCameraSetting             OutCameraSetting                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::LoadCameraSettingByFile(EBattleCameraSettingType Type, const class FString& SettingFilePath, struct FBattleCameraSetting* OutCameraSetting, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "LoadCameraSettingByFile");

	Params::BattleCameraSettingFL_LoadCameraSettingByFile Parms{};

	Parms.Type = Type;
	Parms.SettingFilePath = std::move(SettingFilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCameraSetting != nullptr)
		*OutCameraSetting = std::move(Parms.OutCameraSetting);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCameraSettingFL.LoadCameraSettingByFileOrAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EBattleCameraSettingType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SettingFilePath                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBattleCameraSetting             OutCameraSetting                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::LoadCameraSettingByFileOrAsset(EBattleCameraSettingType Type, const class FString& SettingFilePath, struct FBattleCameraSetting* OutCameraSetting, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "LoadCameraSettingByFileOrAsset");

	Params::BattleCameraSettingFL_LoadCameraSettingByFileOrAsset Parms{};

	Parms.Type = Type;
	Parms.SettingFilePath = std::move(SettingFilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCameraSetting != nullptr)
		*OutCameraSetting = std::move(Parms.OutCameraSetting);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCameraSettingFL.SaveCameraSetting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBattleCameraSetting             InCameraSetting                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::SaveCameraSetting(const struct FBattleCameraSetting& InCameraSetting, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "SaveCameraSetting");

	Params::BattleCameraSettingFL_SaveCameraSetting Parms{};

	Parms.InCameraSetting = std::move(InCameraSetting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCameraSettingFL.SaveCameraSettingByFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBattleCameraSetting             InCameraSetting                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           SettingFilePath                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::SaveCameraSettingByFile(const struct FBattleCameraSetting& InCameraSetting, const class FString& SettingFilePath, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "SaveCameraSettingByFile");

	Params::BattleCameraSettingFL_SaveCameraSettingByFile Parms{};

	Parms.InCameraSetting = std::move(InCameraSetting);
	Parms.SettingFilePath = std::move(SettingFilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCameraSettingFL.TextFileLoad
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FileData                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::TextFileLoad(const class FString& FilePath, class FString* FileData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "TextFileLoad");

	Params::BattleCameraSettingFL_TextFileLoad Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FileData != nullptr)
		*FileData = std::move(Parms.FileData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCameraSettingFL.TextFileSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FileData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleCameraSettingFL::TextFileSave(const class FString& FilePath, const class FString& FileData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleCameraSettingFL", "TextFileSave");

	Params::BattleCameraSettingFL_TextFileSave Parms{};

	Parms.FilePath = std::move(FilePath);
	Parms.FileData = std::move(FileData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Nicola.BattleCharaOpacity.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    menable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCharaOpacity::SetEnable(bool menable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCharaOpacity", "SetEnable");

	Params::BattleCharaOpacity_SetEnable Parms{};

	Parms.menable = menable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleCharaOpacity.SetOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   mopacity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleCharaOpacity::SetOpacity(float mopacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleCharaOpacity", "SetOpacity");

	Params::BattleCharaOpacity_SetOpacity Parms{};

	Parms.mopacity = mopacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIInitialMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIInitialMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIInitialMenu", "IsExecMenu");

	Params::UIInitialMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIInitialMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIInitialMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIInitialMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleDebugFL.GetBattleEncountIdMonsterNameMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class FString, class FName>        outMap                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UBattleDebugFL::GetBattleEncountIdMonsterNameMap(TMap<class FString, class FName>* outMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleDebugFL", "GetBattleEncountIdMonsterNameMap");

	Params::BattleDebugFL_GetBattleEncountIdMonsterNameMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outMap != nullptr)
		*outMap = std::move(Parms.outMap);
}


// Function Nicola.BattleDebugFL.GetBattleEncountIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     outArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBattleDebugFL::GetBattleEncountIds(TArray<class FName>* outArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleDebugFL", "GetBattleEncountIds");

	Params::BattleDebugFL_GetBattleEncountIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outArray != nullptr)
		*outArray = std::move(Parms.outArray);
}


// Function Nicola.BattleDebugFL.GetBattleFieldIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     outArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBattleDebugFL::GetBattleFieldIds(TArray<class FName>* outArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleDebugFL", "GetBattleFieldIds");

	Params::BattleDebugFL_GetBattleFieldIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outArray != nullptr)
		*outArray = std::move(Parms.outArray);
}


// Function Nicola.BattleDebugFL.GetBattleMonsterIdsFromEncountId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             encountId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     outArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   outMonsterNames                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBattleDebugFL::GetBattleMonsterIdsFromEncountId(class FName encountId, TArray<class FName>* outArray, TArray<class FString>* outMonsterNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleDebugFL", "GetBattleMonsterIdsFromEncountId");

	Params::BattleDebugFL_GetBattleMonsterIdsFromEncountId Parms{};

	Parms.encountId = encountId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outArray != nullptr)
		*outArray = std::move(Parms.outArray);

	if (outMonsterNames != nullptr)
		*outMonsterNames = std::move(Parms.outMonsterNames);
}


// Function Nicola.BattleDebugFL.StartDebugBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FBattleEncountInfo               Info                                                   (Parm, NativeAccessSpecifierPublic)
// EMapTimeFrame                           Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleDebugFL::StartDebugBattle(const struct FBattleEncountInfo& Info, EMapTimeFrame Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleDebugFL", "StartDebugBattle");

	Params::BattleDebugFL_StartDebugBattle Parms{};

	Parms.Info = std::move(Info);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleEffectManager.OnEndTransitionBattle
// (Final, Native, Public, BlueprintCallable)

void UBattleEffectManager::OnEndTransitionBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "OnEndTransitionBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleEffectManager.PlayEffectAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Particle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UBattleEffectManager::PlayEffectAtLocation(class UFXSystemAsset* Particle, const struct FVector& Location, const struct FRotator& Rotation, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "PlayEffectAtLocation");

	Params::BattleEffectManager_PlayEffectAtLocation Parms{};

	Parms.Particle = Particle;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleEffectManager.PlayEffectOnUnit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Particle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleUnitType                         unitType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANicolaCharacterBase*             Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   formationIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleEffectLocationType               LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAttach                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UBattleEffectManager::PlayEffectOnUnit(class UFXSystemAsset* Particle, EBattleUnitType unitType, class ANicolaCharacterBase* Character, int32 formationIndex, EBattleEffectLocationType LocationType, float Scale, bool bAttach)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "PlayEffectOnUnit");

	Params::BattleEffectManager_PlayEffectOnUnit Parms{};

	Parms.Particle = Particle;
	Parms.unitType = unitType;
	Parms.Character = Character;
	Parms.formationIndex = formationIndex;
	Parms.LocationType = LocationType;
	Parms.Scale = Scale;
	Parms.bAttach = bAttach;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleEffectManager.PlayMovingEndLocationEffect
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Particle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          moveTargetLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   moveSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   waitSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UBattleEffectManager::PlayMovingEndLocationEffect(class UFXSystemAsset* Particle, const struct FVector& StartLocation, const struct FVector& EndLocation, const struct FVector& moveTargetLocation, float moveSec, float waitSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "PlayMovingEndLocationEffect");

	Params::BattleEffectManager_PlayMovingEndLocationEffect Parms{};

	Parms.Particle = Particle;
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.moveTargetLocation = std::move(moveTargetLocation);
	Parms.moveSec = moveSec;
	Parms.waitSec = waitSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleEffectManager.PlayUnitToAllEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Particle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleUnitType                         startUnitType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANicolaCharacterBase*             startCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   startCharacterFormationIndex                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleEffectLocationType               startLocationType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTargetIsUserSide                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UBattleEffectManager::PlayUnitToAllEffect(class UFXSystemAsset* Particle, EBattleUnitType startUnitType, const class ANicolaCharacterBase* startCharacter, int32 startCharacterFormationIndex, EBattleEffectLocationType startLocationType, bool bTargetIsUserSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "PlayUnitToAllEffect");

	Params::BattleEffectManager_PlayUnitToAllEffect Parms{};

	Parms.Particle = Particle;
	Parms.startUnitType = startUnitType;
	Parms.startCharacter = startCharacter;
	Parms.startCharacterFormationIndex = startCharacterFormationIndex;
	Parms.startLocationType = startLocationType;
	Parms.bTargetIsUserSide = bTargetIsUserSide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleEffectManager.PlayUnitToUnitEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Particle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleUnitType                         startUnitType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANicolaCharacterBase*             startCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   startCharacterFormationIndex                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleEffectLocationType               startLocationType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleUnitType                         endUnitType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANicolaCharacterBase*             endCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   endCharacterFormationIndex                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBattleEffectLocationType               endLocationType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UBattleEffectManager::PlayUnitToUnitEffect(class UFXSystemAsset* Particle, EBattleUnitType startUnitType, class ANicolaCharacterBase* startCharacter, int32 startCharacterFormationIndex, EBattleEffectLocationType startLocationType, EBattleUnitType endUnitType, class ANicolaCharacterBase* endCharacter, int32 endCharacterFormationIndex, EBattleEffectLocationType endLocationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "PlayUnitToUnitEffect");

	Params::BattleEffectManager_PlayUnitToUnitEffect Parms{};

	Parms.Particle = Particle;
	Parms.startUnitType = startUnitType;
	Parms.startCharacter = startCharacter;
	Parms.startCharacterFormationIndex = startCharacterFormationIndex;
	Parms.startLocationType = startLocationType;
	Parms.endUnitType = endUnitType;
	Parms.endCharacter = endCharacter;
	Parms.endCharacterFormationIndex = endCharacterFormationIndex;
	Parms.endLocationType = endLocationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleEffectManager.UpdateActionCameraPlayerLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   partyMembaerNum                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleEffectManager::UpdateActionCameraPlayerLocation(int32 partyMembaerNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleEffectManager", "UpdateActionCameraPlayerLocation");

	Params::BattleEffectManager_UpdateActionCameraPlayerLocation Parms{};

	Parms.partyMembaerNum = partyMembaerNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleFL.GetPrevBattleEncountMonsterId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBattleFL::GetPrevBattleEncountMonsterId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleFL", "GetPrevBattleEncountMonsterId");

	Params::BattleFL_GetPrevBattleEncountMonsterId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleFL.IsRunningBattle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleFL::IsRunningBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleFL", "IsRunningBattle");

	Params::BattleFL_IsRunningBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleFL.StartBattle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBattleEncountInfo               encountInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleFL::StartBattle(const struct FBattleEncountInfo& encountInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleFL", "StartBattle");

	Params::BattleFL_StartBattle Parms{};

	Parms.encountInfo = std::move(encountInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCameraActor.SetAperture
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::SetAperture(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetAperture");

	Params::NicolaCameraActor_SetAperture Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.SetCameraRotation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANicolaCameraActor::SetCameraRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetCameraRotation");

	Params::NicolaCameraActor_SetCameraRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCameraActor.SetCameraTargetDistance
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaCameraActor::SetCameraTargetDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetCameraTargetDistance");

	Params::NicolaCameraActor_SetCameraTargetDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCameraActor.SetCameraTargetOffset
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaCameraActor::SetCameraTargetOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetCameraTargetOffset");

	Params::NicolaCameraActor_SetCameraTargetOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCameraActor.SetDepthBlurAmount
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::SetDepthBlurAmount(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetDepthBlurAmount");

	Params::NicolaCameraActor_SetDepthBlurAmount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.SetDepthBlurRadius
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::SetDepthBlurRadius(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetDepthBlurRadius");

	Params::NicolaCameraActor_SetDepthBlurRadius Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.SetFieldOfView
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::SetFieldOfView(float FOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetFieldOfView");

	Params::NicolaCameraActor_SetFieldOfView Parms{};

	Parms.FOV = FOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.SetNearDOFPower
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::SetNearDOFPower(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "SetNearDOFPower");

	Params::NicolaCameraActor_SetNearDOFPower Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.CalcFieldOfViewFromFocalLength
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   FocalLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::CalcFieldOfViewFromFocalLength(float FocalLength) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "CalcFieldOfViewFromFocalLength");

	Params::NicolaCameraActor_CalcFieldOfViewFromFocalLength Parms{};

	Parms.FocalLength = FocalLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.CalcFocalLengthFromFieldOfView
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::CalcFocalLengthFromFieldOfView(float FOV) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "CalcFocalLengthFromFieldOfView");

	Params::NicolaCameraActor_CalcFocalLengthFromFieldOfView Parms{};

	Parms.FOV = FOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetAperture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::GetAperture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetAperture");

	Params::NicolaCameraActor_GetAperture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetCameraRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANicolaCameraActor::GetCameraRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetCameraRotation");

	Params::NicolaCameraActor_GetCameraRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetCameraTargetDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::GetCameraTargetDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetCameraTargetDistance");

	Params::NicolaCameraActor_GetCameraTargetDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetCameraTargetLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANicolaCameraActor::GetCameraTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetCameraTargetLocation");

	Params::NicolaCameraActor_GetCameraTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetCameraTargetOffset
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANicolaCameraActor::GetCameraTargetOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetCameraTargetOffset");

	Params::NicolaCameraActor_GetCameraTargetOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetDepthBlurAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::GetDepthBlurAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetDepthBlurAmount");

	Params::NicolaCameraActor_GetDepthBlurAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetDepthBlurRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::GetDepthBlurRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetDepthBlurRadius");

	Params::NicolaCameraActor_GetDepthBlurRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetFieldOfView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::GetFieldOfView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetFieldOfView");

	Params::NicolaCameraActor_GetFieldOfView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActor.GetNearDOFPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaCameraActor::GetNearDOFPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActor", "GetNearDOFPower");

	Params::NicolaCameraActor_GetNearDOFPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCameraActorControllable.SetDebugControlFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaCameraActorControllable::SetDebugControlFlag(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCameraActorControllable", "SetDebugControlFlag");

	Params::NicolaCameraActorControllable_SetDebugControlFlag Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattlePositionLine.GetChildAll
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   arr                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ABattlePositionLine::GetChildAll(class AActor* TARGET, TArray<class AActor*>* arr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePositionLine", "GetChildAll");

	Params::BattlePositionLine_GetChildAll Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (arr != nullptr)
		*arr = std::move(Parms.arr);
}


// Function Nicola.BattlePositionLine.Setup
// (Final, Native, Public, BlueprintCallable)

void ABattlePositionLine::Setup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePositionLine", "Setup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattlePositionLine.SetupFromActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ABattlePositionLine::SetupFromActors(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePositionLine", "SetupFromActors");

	Params::BattlePositionLine_SetupFromActors Parms{};

	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattlePositionLine.SetupFromCharacters
// (Final, Native, Public, BlueprintCallable)

void ABattlePositionLine::SetupFromCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePositionLine", "SetupFromCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattlePositionLine.UpdatePositionLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattlePositionLine::UpdatePositionLine(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePositionLine", "UpdatePositionLine");

	Params::BattlePositionLine_UpdatePositionLine Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattlePositionLine.UpdateRootTransform
// (Final, Native, Public, BlueprintCallable)

void ABattlePositionLine::UpdateRootTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePositionLine", "UpdateRootTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleRoadFL.OnWhiteOutWhenBattleStart
// (Final, Native, Static, Public, BlueprintCallable)

void UBattleRoadFL::OnWhiteOutWhenBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleRoadFL", "OnWhiteOutWhenBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleRoadStartEffectManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ABattleRoadStartEffectManager*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABattleRoadStartEffectManager* ABattleRoadStartEffectManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleRoadStartEffectManager", "GetInstance");

	Params::BattleRoadStartEffectManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.BattleSimpleMenuButton.OnClicked
// (Final, Native, Public)

void UBattleSimpleMenuButton::OnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuButton", "OnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.FadeIn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::FadeIn(const struct FADSoundPlaybackId& PlaybackId, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "FadeIn");

	Params::NicolaSoundFL_FadeIn Parms{};

	Parms.PlaybackId = std::move(PlaybackId);
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.FadeInCategoryVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::FadeInCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "FadeInCategoryVolumeRate");

	Params::NicolaSoundFL_FadeInCategoryVolumeRate Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.FadeOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoStop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::FadeOut(const struct FADSoundPlaybackId& PlaybackId, float DurationSec, bool bAutoStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "FadeOut");

	Params::NicolaSoundFL_FadeOut Parms{};

	Parms.PlaybackId = std::move(PlaybackId);
	Parms.DurationSec = DurationSec;
	Parms.bAutoStop = bAutoStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.FadeOutCategoryVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoStop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::FadeOutCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec, bool bAutoStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "FadeOutCategoryVolumeRate");

	Params::NicolaSoundFL_FadeOutCategoryVolumeRate Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.DurationSec = DurationSec;
	Parms.bAutoStop = bAutoStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.GetSEGopList_Event
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSoundFL::GetSEGopList_Event(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "GetSEGopList_Event");

	Params::NicolaSoundFL_GetSEGopList_Event Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSoundFL.GetSEGopList_Magic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSoundFL::GetSEGopList_Magic(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "GetSEGopList_Magic");

	Params::NicolaSoundFL_GetSEGopList_Magic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSoundFL.GetSEGopList_System
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSoundFL::GetSEGopList_System(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "GetSEGopList_System");

	Params::NicolaSoundFL_GetSEGopList_System Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSoundFL.GetSEGopList_Weapon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSoundFL::GetSEGopList_Weapon(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "GetSEGopList_Weapon");

	Params::NicolaSoundFL_GetSEGopList_Weapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSoundFL.GetSoundGopList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ENicolaSoundDataTableType               DataType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSoundFL::GetSoundGopList(ENicolaSoundDataTableType DataType, TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "GetSoundGopList");

	Params::NicolaSoundFL_GetSoundGopList Parms{};

	Parms.DataType = DataType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSoundFL.IsLoop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSoundFL::IsLoop(const struct FADSoundPlaybackId& PlaybackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "IsLoop");

	Params::NicolaSoundFL_IsLoop Parms{};

	Parms.PlaybackId = std::move(PlaybackId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.IsPaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSoundFL::IsPaused(const struct FADSoundPlaybackId& PlaybackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "IsPaused");

	Params::NicolaSoundFL_IsPaused Parms{};

	Parms.PlaybackId = std::move(PlaybackId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.IsPlaying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSoundFL::IsPlaying(const struct FADSoundPlaybackId& PlaybackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "IsPlaying");

	Params::NicolaSoundFL_IsPlaying Parms{};

	Parms.PlaybackId = std::move(PlaybackId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.IsPlayingBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSoundFL::IsPlayingBgm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "IsPlayingBgm");

	Params::NicolaSoundFL_IsPlayingBgm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.IsPlayingJingle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSoundFL::IsPlayingJingle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "IsPlayingJingle");

	Params::NicolaSoundFL_IsPlayingJingle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.Pause
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::Pause(const struct FADSoundPlaybackId& PlaybackId, bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "Pause");

	Params::NicolaSoundFL_Pause Parms{};

	Parms.PlaybackId = std::move(PlaybackId);
	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.PauseMainBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::PauseMainBGM(bool bPause, float FadeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PauseMainBGM");

	Params::NicolaSoundFL_PauseMainBGM Parms{};

	Parms.bPause = bPause;
	Parms.FadeSec = FadeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.PlayBattleBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   fadeOutSec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::PlayBattleBGM(class FName GopId, float fadeOutSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlayBattleBGM");

	Params::NicolaSoundFL_PlayBattleBGM Parms{};

	Parms.GopId = GopId;
	Parms.fadeOutSec = fadeOutSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.PlayBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::PlayBGM(class FName GopId, float FadeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlayBGM");

	Params::NicolaSoundFL_PlayBGM Parms{};

	Parms.GopId = GopId;
	Parms.FadeSec = FadeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.PlayMainBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::PlayMainBGM(class FName GopId, float FadeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlayMainBGM");

	Params::NicolaSoundFL_PlayMainBGM Parms{};

	Parms.GopId = GopId;
	Parms.FadeSec = FadeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.PlaySE
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Owner                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlaySE(const class FName& GopId, const struct FVector& Location, const class UObject* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlaySE");

	Params::NicolaSoundFL_PlaySE Parms{};

	Parms.GopId = GopId;
	Parms.Location = std::move(Location);
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.PlaySE2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Owner                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlaySE2D(const class FName& GopId, const class UObject* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlaySE2D");

	Params::NicolaSoundFL_PlaySE2D Parms{};

	Parms.GopId = GopId;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.PlaySEEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlaySEEvent(const class FName& GopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlaySEEvent");

	Params::NicolaSoundFL_PlaySEEvent Parms{};

	Parms.GopId = GopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.PlaySEMagic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlaySEMagic(const class FName& GopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlaySEMagic");

	Params::NicolaSoundFL_PlaySEMagic Parms{};

	Parms.GopId = GopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.PlaySEUI
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlaySEUI(const class FName& GopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlaySEUI");

	Params::NicolaSoundFL_PlaySEUI Parms{};

	Parms.GopId = GopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.PlaySEWeapon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlaySEWeapon(const class FName& GopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlaySEWeapon");

	Params::NicolaSoundFL_PlaySEWeapon Parms{};

	Parms.GopId = GopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.PlayVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GopVoiceId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundFL::PlayVoice(class FName GopVoiceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "PlayVoice");

	Params::NicolaSoundFL_PlayVoice Parms{};

	Parms.GopVoiceId = GopVoiceId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundFL.RequestPlayJingle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             JingleGopIDSoundBgm                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBgmPlayerManagerMEPlayRequestType      BgmPlayerManagerMEPlayRequestType                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentBgmFadeOutSec                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBgmPlayerManagerLineTypeOnMEEnd        BgmPlayerManagerLineTypeOnMEEnd                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NextBgmFadeInSec                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NextGopIDSoundBgm                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::RequestPlayJingle(const class FName& JingleGopIDSoundBgm, EBgmPlayerManagerMEPlayRequestType BgmPlayerManagerMEPlayRequestType, float CurrentBgmFadeOutSec, EBgmPlayerManagerLineTypeOnMEEnd BgmPlayerManagerLineTypeOnMEEnd, float NextBgmFadeInSec, const class FName& NextGopIDSoundBgm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "RequestPlayJingle");

	Params::NicolaSoundFL_RequestPlayJingle Parms{};

	Parms.JingleGopIDSoundBgm = JingleGopIDSoundBgm;
	Parms.BgmPlayerManagerMEPlayRequestType = BgmPlayerManagerMEPlayRequestType;
	Parms.CurrentBgmFadeOutSec = CurrentBgmFadeOutSec;
	Parms.BgmPlayerManagerLineTypeOnMEEnd = BgmPlayerManagerLineTypeOnMEEnd;
	Parms.NextBgmFadeInSec = NextBgmFadeInSec;
	Parms.NextGopIDSoundBgm = NextGopIDSoundBgm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.RequestPlayJingleTemporary
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             JingleGopIDSoundBgm                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentBgmFadeOutSec                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NextBgmFadeInSec                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::RequestPlayJingleTemporary(const class FName& JingleGopIDSoundBgm, float CurrentBgmFadeOutSec, float NextBgmFadeInSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "RequestPlayJingleTemporary");

	Params::NicolaSoundFL_RequestPlayJingleTemporary Parms{};

	Parms.JingleGopIDSoundBgm = JingleGopIDSoundBgm;
	Parms.CurrentBgmFadeOutSec = CurrentBgmFadeOutSec;
	Parms.NextBgmFadeInSec = NextBgmFadeInSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.RequestPlayJingleTemporaryDefaultFade
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             JingleGopIDSoundBgm                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::RequestPlayJingleTemporaryDefaultFade(const class FName& JingleGopIDSoundBgm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "RequestPlayJingleTemporaryDefaultFade");

	Params::NicolaSoundFL_RequestPlayJingleTemporaryDefaultFade Parms{};

	Parms.JingleGopIDSoundBgm = JingleGopIDSoundBgm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.SetAisacParamById
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AisacId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AisacValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::SetAisacParamById(const struct FADSoundPlaybackId& PlaybackId, int32 AisacId, float AisacValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "SetAisacParamById");

	Params::NicolaSoundFL_SetAisacParamById Parms{};

	Parms.PlaybackId = std::move(PlaybackId);
	Parms.AisacId = AisacId;
	Parms.AisacValue = AisacValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.SetCategoryVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::SetCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float TargetRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "SetCategoryVolumeRate");

	Params::NicolaSoundFL_SetCategoryVolumeRate Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.TargetRate = TargetRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.SetDebugDrawFlag_AttenuationShapeAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::SetDebugDrawFlag_AttenuationShapeAll(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "SetDebugDrawFlag_AttenuationShapeAll");

	Params::NicolaSoundFL_SetDebugDrawFlag_AttenuationShapeAll Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.SetMuteByCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::SetMuteByCategory(const ENicolaSoundCategory SoundCategory, bool bMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "SetMuteByCategory");

	Params::NicolaSoundFL_SetMuteByCategory Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.bMute = bMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.SetVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::SetVolumeRate(const struct FADSoundPlaybackId& PlaybackId, float TargetRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "SetVolumeRate");

	Params::NicolaSoundFL_SetVolumeRate Parms{};

	Parms.PlaybackId = std::move(PlaybackId);
	Parms.TargetRate = TargetRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.Stop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::Stop(const struct FADSoundPlaybackId& PlaybackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "Stop");

	Params::NicolaSoundFL_Stop Parms{};

	Parms.PlaybackId = std::move(PlaybackId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.StopAll
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaSoundFL::StopAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "StopAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.StopBattleBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   fadeOutSec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::StopBattleBGM(float fadeOutSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "StopBattleBGM");

	Params::NicolaSoundFL_StopBattleBGM Parms{};

	Parms.fadeOutSec = fadeOutSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.StopBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   fadeOutSec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::StopBGM(float fadeOutSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "StopBGM");

	Params::NicolaSoundFL_StopBGM Parms{};

	Parms.fadeOutSec = fadeOutSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.StopByCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::StopByCategory(const ENicolaSoundCategory SoundCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "StopByCategory");

	Params::NicolaSoundFL_StopByCategory Parms{};

	Parms.SoundCategory = SoundCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.StopMainBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   fadeOutSec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::StopMainBGM(float fadeOutSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "StopMainBGM");

	Params::NicolaSoundFL_StopMainBGM Parms{};

	Parms.fadeOutSec = fadeOutSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.TransitionCategoryVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::TransitionCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float TargetRate, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "TransitionCategoryVolumeRate");

	Params::NicolaSoundFL_TransitionCategoryVolumeRate Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.TargetRate = TargetRate;
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundFL.TransitionVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FADSoundPlaybackId               PlaybackId                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundFL::TransitionVolumeRate(const struct FADSoundPlaybackId& PlaybackId, float TargetRate, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSoundFL", "TransitionVolumeRate");

	Params::NicolaSoundFL_TransitionVolumeRate Parms{};

	Parms.PlaybackId = std::move(PlaybackId);
	Parms.TargetRate = TargetRate;
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuInput.OnCancel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuInput::OnCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuInput", "OnCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuInput.OnDown
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuInput::OnDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuInput", "OnDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuInput.OnEnter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuInput::OnEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuInput", "OnEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuInput.OnLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuInput::OnLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuInput", "OnLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuInput.OnRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuInput::OnRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuInput", "OnRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuInput.OnUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuInput::OnUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuInput", "OnUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundAmbientCoastAreaActor.OnBeginOverlapOther
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Other                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaSoundAmbientCoastAreaActor::OnBeginOverlapOther(const class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundAmbientCoastAreaActor", "OnBeginOverlapOther");

	Params::NicolaSoundAmbientCoastAreaActor_OnBeginOverlapOther Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundAmbientCoastAreaActor.OnEndOverlapOther
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Other                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaSoundAmbientCoastAreaActor::OnEndOverlapOther(const class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundAmbientCoastAreaActor", "OnEndOverlapOther");

	Params::NicolaSoundAmbientCoastAreaActor_OnEndOverlapOther Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundAmbientCoastAreaActor.GetAreaCollisionCentralAxis
// (Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANicolaSoundAmbientCoastAreaActor::GetAreaCollisionCentralAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundAmbientCoastAreaActor", "GetAreaCollisionCentralAxis");

	Params::NicolaSoundAmbientCoastAreaActor_GetAreaCollisionCentralAxis Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundAmbientCoastAreaActor.GetAreaCollisionComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UCapsuleComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* ANicolaSoundAmbientCoastAreaActor::GetAreaCollisionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundAmbientCoastAreaActor", "GetAreaCollisionComponent");

	Params::NicolaSoundAmbientCoastAreaActor_GetAreaCollisionComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Nicola.BattleSimpleMenuItemInterface.OnFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuItemInterface::OnFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuItemInterface", "OnFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuItemInterface.OnOutFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuItemInterface::OnOutFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuItemInterface", "OnOutFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSimpleMenuItemInterface.OnSelect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleSimpleMenuItemInterface::OnSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSimpleMenuItemInterface", "OnSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleSpeedInterface.OnChangeBattleSpeed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleSpeedInterface::OnChangeBattleSpeed(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSpeedInterface", "OnChangeBattleSpeed");

	Params::BattleSpeedInterface_OnChangeBattleSpeed Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleTestCharaActor.DestroyCharacter
// (Final, Native, Public, BlueprintCallable)

void ABattleTestCharaActor::DestroyCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleTestCharaActor", "DestroyCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleTestCharaActor.SetAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimationType                          animationType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLoop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleTestCharaActor::SetAnimation(EAnimationType animationType, bool IsLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleTestCharaActor", "SetAnimation");

	Params::BattleTestCharaActor_SetAnimation Parms{};

	Parms.animationType = animationType;
	Parms.IsLoop = IsLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleTestCharaActor.SpawnCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleTestCharaActor::SpawnCharacter(class FName GopId, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleTestCharaActor", "SpawnCharacter");

	Params::BattleTestCharaActor_SpawnCharacter Parms{};

	Parms.GopId = GopId;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleTestCharaActor.SpawnCharacterFromBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             loadAssetPtr                                           (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABattleTestCharaActor::SpawnCharacterFromBP(TSoftClassPtr<class UClass> loadAssetPtr, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleTestCharaActor", "SpawnCharacterFromBP");

	Params::BattleTestCharaActor_SpawnCharacterFromBP Parms{};

	Parms.loadAssetPtr = loadAssetPtr;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleTestCharaActor.UpdateScaleFromGopUnitLooks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABattleTestCharaActor::UpdateScaleFromGopUnitLooks(bool isEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleTestCharaActor", "UpdateScaleFromGopUnitLooks");

	Params::BattleTestCharaActor_UpdateScaleFromGopUnitLooks Parms{};

	Parms.isEnable = isEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundSourceInterface.OnStopAllSound
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void INicolaSoundSourceInterface::OnStopAllSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundSourceInterface", "OnStopAllSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.ClearMessage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleUIDrawer::ClearMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "ClearMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.DestroyWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleUIDrawer::DestroyWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "DestroyWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.InitWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleUIDrawer::InitWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "InitWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectHowToUse
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>                     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectHowToUse(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectHowToUse");

	Params::BattleUIDrawer_OpenSelectHowToUse Parms{};

	Parms.Items = std::move(Items);
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectItem
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>                     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectItem(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectItem");

	Params::BattleUIDrawer_OpenSelectItem Parms{};

	Parms.Items = std::move(Items);
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectPartyCommand
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectPartyCommand(const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectPartyCommand");

	Params::BattleUIDrawer_OpenSelectPartyCommand Parms{};

	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectSkill
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>                     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectSkill(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectSkill");

	Params::BattleUIDrawer_OpenSelectSkill Parms{};

	Parms.Items = std::move(Items);
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectTactics
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectTactics(const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectTactics");

	Params::BattleUIDrawer_OpenSelectTactics Parms{};

	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectTarget
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>                     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectTarget(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectTarget");

	Params::BattleUIDrawer_OpenSelectTarget Parms{};

	Parms.Items = std::move(Items);
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectText
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>                     Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectText(const TArray<class FText>& Items, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectText");

	Params::BattleUIDrawer_OpenSelectText Parms{};

	Parms.Items = std::move(Items);
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.OpenSelectUnitCommand
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   charaIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::OpenSelectUnitCommand(int32 charaIndex, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "OpenSelectUnitCommand");

	Params::BattleUIDrawer_OpenSelectUnitCommand Parms{};

	Parms.charaIndex = charaIndex;
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.SetVisibleWidget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleUIDrawer::SetVisibleWidget(bool flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "SetVisibleWidget");

	Params::BattleUIDrawer_SetVisibleWidget Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.ShowMessage
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>                   messages                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TScriptInterface<class IBattleUIReceiver>receiver                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void IBattleUIDrawer::ShowMessage(const TArray<class FString>& messages, const TScriptInterface<class IBattleUIReceiver>& receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "ShowMessage");

	Params::BattleUIDrawer_ShowMessage Parms{};

	Parms.messages = std::move(messages);
	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIDrawer.UpdateCharaInfo
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   charaIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBattleCharaInfoViewData         viewData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IBattleUIDrawer::UpdateCharaInfo(int32 charaIndex, const struct FBattleCharaInfoViewData& viewData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIDrawer", "UpdateCharaInfo");

	Params::BattleUIDrawer_UpdateCharaInfo Parms{};

	Parms.charaIndex = charaIndex;
	Parms.viewData = std::move(viewData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnCancel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleUIReceiver::OnCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnCompleteShowMessage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBattleUIReceiver::OnCompleteShowMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnCompleteShowMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnSelectId
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             selectId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleUIReceiver::OnSelectId(class FName selectId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnSelectId");

	Params::BattleUIReceiver_OnSelectId Parms{};

	Parms.selectId = selectId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnSelectIndex
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   selectIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleUIReceiver::OnSelectIndex(int32 selectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnSelectIndex");

	Params::BattleUIReceiver_OnSelectIndex Parms{};

	Parms.selectIndex = selectIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnSelectPartyCommand
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattlePartyCommand                     Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleUIReceiver::OnSelectPartyCommand(EBattlePartyCommand Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnSelectPartyCommand");

	Params::BattleUIReceiver_OnSelectPartyCommand Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnSelectTactics
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattleTactics                          tactics                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleUIReceiver::OnSelectTactics(EBattleTactics tactics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnSelectTactics");

	Params::BattleUIReceiver_OnSelectTactics Parms{};

	Parms.tactics = tactics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BattleUIReceiver.OnSelectUnitCommand
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattleUnitCommand                      Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBattleUIReceiver::OnSelectUnitCommand(EBattleUnitCommand Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleUIReceiver", "OnSelectUnitCommand");

	Params::BattleUIReceiver_OnSelectUnitCommand Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerBase.onChangedMovementMode
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           prevMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PrevCustomMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerBase::onChangedMovementMode(class ACharacter* Character, EMovementMode prevMode, uint8 PrevCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBase", "onChangedMovementMode");

	Params::PlayerBase_onChangedMovementMode Parms{};

	Parms.Character = Character;
	Parms.prevMode = prevMode;
	Parms.PrevCustomMode = PrevCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerBase.onUpdateMovement
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerBase::onUpdateMovement(float Delta, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBase", "onUpdateMovement");

	Params::PlayerBase_onUpdateMovement Parms{};

	Parms.Delta = Delta;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerBase.GetDashPerSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerBase::GetDashPerSec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBase", "GetDashPerSec");

	Params::PlayerBase_GetDashPerSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PlayerBase.GetMovePerSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerBase::GetMovePerSec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBase", "GetMovePerSec");

	Params::PlayerBase_GetMovePerSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PlayerBase.GetPartyMemberLog_Debug
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APlayerBase::GetPartyMemberLog_Debug(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBase", "GetPartyMemberLog_Debug");

	Params::PlayerBase_GetPartyMemberLog_Debug Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.Breadcrumbman.SetPosAndAlignment
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionOnMap                         dirAlignment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionOnMap                         dirLeader                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreadcrumbman::SetPosAndAlignment(const struct FVector& Pos, EDirectionOnMap dirAlignment, EDirectionOnMap dirLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Breadcrumbman", "SetPosAndAlignment");

	Params::Breadcrumbman_SetPosAndAlignment Parms{};

	Parms.Pos = std::move(Pos);
	Parms.dirAlignment = dirAlignment;
	Parms.dirLeader = dirLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.Breadcrumbman.Together
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreadcrumbman::Together(const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Breadcrumbman", "Together");

	Params::Breadcrumbman_Together Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaManaMovieActor.onManaComponentStatusChanged
// (Final, Native, Private)
// Parameters:
// EManaComponentStatus                    InManaComponentStatus                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManaComponent*                   InManaComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaManaMovieActor::onManaComponentStatusChanged(EManaComponentStatus InManaComponentStatus, class UManaComponent* InManaComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaManaMovieActor", "onManaComponentStatusChanged");

	Params::NicolaManaMovieActor_onManaComponentStatusChanged Parms{};

	Parms.InManaComponentStatus = InManaComponentStatus;
	Parms.InManaComponent = InManaComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.BuildingWithJumpPoint.SetJumpMapLevelAndStart
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             jumpPointKey                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             mapLevelId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             playerStartId                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABuildingWithJumpPoint::SetJumpMapLevelAndStart(const class FName jumpPointKey, const class FName mapLevelId, const class FName playerStartId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildingWithJumpPoint", "SetJumpMapLevelAndStart");

	Params::BuildingWithJumpPoint_SetJumpMapLevelAndStart Parms{};

	Parms.jumpPointKey = jumpPointKey;
	Parms.mapLevelId = mapLevelId;
	Parms.playerStartId = playerStartId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLocalizeFL.ChangeNicolaLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaLanguage                         NicolaLanguage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENicolaLanguageChangeFlag               NicolaLanguageChangeFlags                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLocalizeFL::ChangeNicolaLanguage(ENicolaLanguage NicolaLanguage, ENicolaLanguageChangeFlag NicolaLanguageChangeFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaLocalizeFL", "ChangeNicolaLanguage");

	Params::NicolaLocalizeFL_ChangeNicolaLanguage Parms{};

	Parms.NicolaLanguage = NicolaLanguage;
	Parms.NicolaLanguageChangeFlags = NicolaLanguageChangeFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLocalizeFL.GetCurrentLanguageText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENicolaLanguage                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENicolaLanguage UNicolaLocalizeFL::GetCurrentLanguageText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaLocalizeFL", "GetCurrentLanguageText");

	Params::NicolaLocalizeFL_GetCurrentLanguageText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CommonBaseWidget.PauseAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InAnimationName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonBaseWidget::PauseAnim(class FName InAnimationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonBaseWidget", "PauseAnim");

	Params::CommonBaseWidget_PauseAnim Parms{};

	Parms.InAnimationName = InAnimationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CommonBaseWidget.PlayAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InAnimationName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSamePrefixExclusion                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNoWarn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonBaseWidget::PlayAnim(class FName InAnimationName, bool bSamePrefixExclusion, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool InNoWarn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonBaseWidget", "PlayAnim");

	Params::CommonBaseWidget_PlayAnim Parms{};

	Parms.InAnimationName = InAnimationName;
	Parms.bSamePrefixExclusion = bSamePrefixExclusion;
	Parms.StartAtTime = StartAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.InNoWarn = InNoWarn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CommonBaseWidget.PlayAnimR
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InAnimationName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSamePrefixExclusion                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonBaseWidget::PlayAnimR(class FName InAnimationName, bool bSamePrefixExclusion, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonBaseWidget", "PlayAnimR");

	Params::CommonBaseWidget_PlayAnimR Parms{};

	Parms.InAnimationName = InAnimationName;
	Parms.bSamePrefixExclusion = bSamePrefixExclusion;
	Parms.StartAtTime = StartAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CommonBaseWidget.PlayAnimTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InAnimationName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSamePrefixExclusion                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndAtTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonBaseWidget::PlayAnimTo(class FName InAnimationName, bool bSamePrefixExclusion, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonBaseWidget", "PlayAnimTo");

	Params::CommonBaseWidget_PlayAnimTo Parms{};

	Parms.InAnimationName = InAnimationName;
	Parms.bSamePrefixExclusion = bSamePrefixExclusion;
	Parms.StartAtTime = StartAtTime;
	Parms.EndAtTime = EndAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CommonBaseWidget.StopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InAnimationName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonBaseWidget::StopAnim(class FName InAnimationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonBaseWidget", "StopAnim");

	Params::CommonBaseWidget_StopAnim Parms{};

	Parms.InAnimationName = InAnimationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaBlueprints.RunLua
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ULuaAsset*                        LuaAsset                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaBlueprints::RunLua(const class ULuaAsset* LuaAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaBlueprints", "RunLua");

	Params::LuaBlueprints_RunLua Parms{};

	Parms.LuaAsset = LuaAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.CaptureSubsystem.GetCaptureTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCaptureSubsystem::GetCaptureTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CaptureSubsystem", "GetCaptureTexture");

	Params::CaptureSubsystem_GetCaptureTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CaptureSubsystem.LoadTextureByteData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   captureNo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCaptureSubsystem::LoadTextureByteData(int32 captureNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CaptureSubsystem", "LoadTextureByteData");

	Params::CaptureSubsystem_LoadTextureByteData Parms{};

	Parms.captureNo = captureNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.CaptureSubsystem.OnComplateSaveTexture
// (Final, Native, Private)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCaptureSubsystem::OnComplateSaveTexture(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CaptureSubsystem", "OnComplateSaveTexture");

	Params::CaptureSubsystem_OnComplateSaveTexture Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugAutoSystem.StartDoorListOutput
// (Final, Native, Public, BlueprintCallable)

void UDebugAutoSystem::StartDoorListOutput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugAutoSystem", "StartDoorListOutput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaScriptMgr.BP_ReloadRequestExecuteEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bBaseScriptReload                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaScriptMgr::BP_ReloadRequestExecuteEvent(bool bBaseScriptReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaScriptMgr", "BP_ReloadRequestExecuteEvent");

	Params::LuaScriptMgr_BP_ReloadRequestExecuteEvent Parms{};

	Parms.bBaseScriptReload = bBaseScriptReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaScriptMgr.BP_RequestExecuteEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MapName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             luaFileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             luaEventName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaScriptMgr::BP_RequestExecuteEvent(class FName MapName, class FName luaFileName, class FName luaEventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaScriptMgr", "BP_RequestExecuteEvent");

	Params::LuaScriptMgr_BP_RequestExecuteEvent Parms{};

	Parms.MapName = MapName;
	Parms.luaFileName = luaFileName;
	Parms.luaEventName = luaEventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaScriptMgr.GetFlagList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UDebugMenuFlag*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDebugMenuFlag*> ULuaScriptMgr::GetFlagList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaScriptMgr", "GetFlagList");

	Params::LuaScriptMgr_GetFlagList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaScriptMgr.GetTriggerList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULuaScriptMgr::GetTriggerList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaScriptMgr", "GetTriggerList");

	Params::LuaScriptMgr_GetTriggerList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaScriptMgr.BP_ReloadBaseScript
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BaseScriptName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULuaScriptMgr::BP_ReloadBaseScript(const class FName& BaseScriptName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuaScriptMgr", "BP_ReloadBaseScript");

	Params::LuaScriptMgr_BP_ReloadBaseScript Parms{};

	Parms.BaseScriptName = BaseScriptName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaScriptMgr.BP_RequestExecuteTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TriggerName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaScriptMgr::BP_RequestExecuteTrigger(class FName TriggerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuaScriptMgr", "BP_RequestExecuteTrigger");

	Params::LuaScriptMgr_BP_RequestExecuteTrigger Parms{};

	Parms.TriggerName = TriggerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaScriptMgr.BP_RequestReoadCurrentLevelScript
// (Final, Native, Public, BlueprintCallable)

void ULuaScriptMgr::BP_RequestReoadCurrentLevelScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuaScriptMgr", "BP_RequestReoadCurrentLevelScript");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaScriptMgr.BP_RequestReoadLevelScript
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             szLuaFileName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaScriptMgr::BP_RequestReoadLevelScript(const class FName& szLuaFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuaScriptMgr", "BP_RequestReoadLevelScript");

	Params::LuaScriptMgr_BP_RequestReoadLevelScript Parms{};

	Parms.szLuaFileName = szLuaFileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugBattleLocationWidget.UpdateLocationText
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABattleCameraControl*             battleCameraControll                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugBattleLocationWidget::UpdateLocationText(class ABattleCameraControl* battleCameraControll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugBattleLocationWidget", "UpdateLocationText");

	Params::DebugBattleLocationWidget_UpdateLocationText Parms{};

	Parms.battleCameraControll = battleCameraControll;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.DebugMenuCategoryData.GetItems
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FDebugMenuCustomItem>     outItems                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDebugMenuCategoryData::GetItems(TArray<struct FDebugMenuCustomItem>* outItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenuCategoryData", "GetItems");

	Params::DebugMenuCategoryData_GetItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outItems != nullptr)
		*outItems = std::move(Parms.outItems);
}


// Function Nicola.DebugMenuFL.ExecCommandByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::ExecCommandByName(const class FString& Category, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "ExecCommandByName");

	Params::DebugMenuFL_ExecCommandByName Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.ExecCommandChangeSelectItemByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::ExecCommandChangeSelectItemByName(const class FString& Category, const class FString& Name_0, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "ExecCommandChangeSelectItemByName");

	Params::DebugMenuFL_ExecCommandChangeSelectItemByName Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.ExecCommandChangeToggleByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::ExecCommandChangeToggleByName(const class FString& Category, const class FString& Name_0, bool flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "ExecCommandChangeToggleByName");

	Params::DebugMenuFL_ExecCommandChangeToggleByName Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);
	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.ExecCommandChangeValueByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::ExecCommandChangeValueByName(const class FString& Category, const class FString& Name_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "ExecCommandChangeValueByName");

	Params::DebugMenuFL_ExecCommandChangeValueByName Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.OnCloseDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::OnCloseDebugMenu(const class FString& Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "OnCloseDebugMenu");

	Params::DebugMenuFL_OnCloseDebugMenu Parms{};

	Parms.Category = std::move(Category);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.OnGetCheckBoxState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::OnGetCheckBoxState(const class FString& Category, const class FString& Name_0, bool* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "OnGetCheckBoxState");

	Params::DebugMenuFL_OnGetCheckBoxState Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;
}


// Function Nicola.DebugMenuFL.OnGetSelectItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     outItems                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::OnGetSelectItem(const class FString& Category, const class FString& Name_0, TArray<class FText>* outItems, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "OnGetSelectItem");

	Params::DebugMenuFL_OnGetSelectItem Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outItems != nullptr)
		*outItems = std::move(Parms.outItems);

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;
}


// Function Nicola.DebugMenuFL.OnInitSpinValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   outMin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   outMax                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   outFixedPointColumn                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    outLoop                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenuFL::OnInitSpinValue(const class FString& Category, const class FString& Name_0, int32* OutValue, int32* outMin, int32* outMax, int32* outFixedPointColumn, bool* outLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "OnInitSpinValue");

	Params::DebugMenuFL_OnInitSpinValue Parms{};

	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	if (outMin != nullptr)
		*outMin = Parms.outMin;

	if (outMax != nullptr)
		*outMax = Parms.outMax;

	if (outFixedPointColumn != nullptr)
		*outFixedPointColumn = Parms.outFixedPointColumn;

	if (outLoop != nullptr)
		*outLoop = Parms.outLoop;
}


// Function Nicola.DebugMenuFL.OnOpenDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDebugMenuCategoryData*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDebugMenuCategoryData* UDebugMenuFL::OnOpenDebugMenu(const class FString& Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "OnOpenDebugMenu");

	Params::DebugMenuFL_OnOpenDebugMenu Parms{};

	Parms.Category = std::move(Category);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.DebugMenuFL.RegisterDebugMenuCloseAllMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       closeAllMenuDelegate                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDebugMenuFL::RegisterDebugMenuCloseAllMenu(const class FString& Category, const TDelegate<void()>& closeAllMenuDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "RegisterDebugMenuCloseAllMenu");

	Params::DebugMenuFL_RegisterDebugMenuCloseAllMenu Parms{};

	Parms.Category = std::move(Category);
	Parms.closeAllMenuDelegate = closeAllMenuDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.RegisterDebugMenuCloseMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       closeThisMenuDelegate                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDebugMenuFL::RegisterDebugMenuCloseMenu(const class FString& Category, const TDelegate<void()>& closeThisMenuDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "RegisterDebugMenuCloseMenu");

	Params::DebugMenuFL_RegisterDebugMenuCloseMenu Parms{};

	Parms.Category = std::move(Category);
	Parms.closeThisMenuDelegate = closeThisMenuDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.RegisterDebugMenuGetSelectIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       menuDelegate                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDebugMenuFL::RegisterDebugMenuGetSelectIndex(const class FString& Category, const TDelegate<void()>& menuDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "RegisterDebugMenuGetSelectIndex");

	Params::DebugMenuFL_RegisterDebugMenuGetSelectIndex Parms{};

	Parms.Category = std::move(Category);
	Parms.menuDelegate = menuDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.RegisterDebugMenuOpenSubMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Category)>openSubMenuDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDebugMenuFL::RegisterDebugMenuOpenSubMenu(const class FString& Category, const TDelegate<void(const class FString& Category)>& openSubMenuDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "RegisterDebugMenuOpenSubMenu");

	Params::DebugMenuFL_RegisterDebugMenuOpenSubMenu Parms{};

	Parms.Category = std::move(Category);
	Parms.openSubMenuDelegate = openSubMenuDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuFL.RegisterDebugMenuSetSelectIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 Index)>            menuDelegate                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDebugMenuFL::RegisterDebugMenuSetSelectIndex(const class FString& Category, const TDelegate<void(int32 Index)>& menuDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DebugMenuFL", "RegisterDebugMenuSetSelectIndex");

	Params::DebugMenuFL_RegisterDebugMenuSetSelectIndex Parms{};

	Parms.Category = std::move(Category);
	Parms.menuDelegate = menuDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapTimeManager.DebugSetMapTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTimeManager::DebugSetMapTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTimeManager", "DebugSetMapTime");

	Params::MapTimeManager_DebugSetMapTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapTimeManager.GetMapTimeForBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMapTimeForBP                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMapTimeForBP UMapTimeManager::GetMapTimeForBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTimeManager", "GetMapTimeForBP");

	Params::MapTimeManager_GetMapTimeForBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UITestMouseMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUITestMouseMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITestMouseMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DLCBoxEvent.OnEndDLCBoxEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsEndPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADLCBoxEvent::OnEndDLCBoxEffect(bool IsEndPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLCBoxEvent", "OnEndDLCBoxEffect");

	Params::DLCBoxEvent_OnEndDLCBoxEffect Parms{};

	Parms.IsEndPlay = IsEndPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.DLCBoxEvent.OnStartDLCBoxEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsBeginPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADLCBoxEvent::OnStartDLCBoxEffect(bool IsBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLCBoxEvent", "OnStartDLCBoxEffect");

	Params::DLCBoxEvent_OnStartDLCBoxEffect Parms{};

	Parms.IsBeginPlay = IsBeginPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.MapParameterCollectionManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMapParameterCollectionManager*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapParameterCollectionManager* UMapParameterCollectionManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapParameterCollectionManager", "GetInstance");

	Params::MapParameterCollectionManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MangaIconActorBase.CloseMangaIcon
// (Final, Native, Public, BlueprintCallable)

void AMangaIconActorBase::CloseMangaIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MangaIconActorBase", "CloseMangaIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MangaIconActorBase.ShowMangaIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             IconID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMangaIconActorBase::ShowMangaIcon(const class FName& IconID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MangaIconActorBase", "ShowMangaIcon");

	Params::MangaIconActorBase_ShowMangaIcon Parms{};

	Parms.IconID = IconID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EffectFL.SpawnEffectByGopId
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectFL::SpawnEffectByGopId(const class FName& GopId, const struct FVector& Location, const struct FRotator& Rotator, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EffectFL", "SpawnEffectByGopId");

	Params::EffectFL_SpawnEffectByGopId Parms{};

	Parms.GopId = GopId;
	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventCommandInterface.GetScriptInfo
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           CommandName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     TagList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                     Args                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void IEventCommandInterface::GetScriptInfo(class FString* CommandName, TArray<class FName>* TagList, TArray<class FName>* Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventCommandInterface", "GetScriptInfo");

	Params::EventCommandInterface_GetScriptInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CommandName != nullptr)
		*CommandName = std::move(Parms.CommandName);

	if (TagList != nullptr)
		*TagList = std::move(Parms.TagList);

	if (Args != nullptr)
		*Args = std::move(Parms.Args);
}


// Function Nicola.EventCommandInterface.ExistScriptCommand
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEventCommandInterface::ExistScriptCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventCommandInterface", "ExistScriptCommand");

	Params::EventCommandInterface_ExistScriptCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ProduceSequencerMessage.CloseMessageWindow
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerMessage::CloseMessageWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerMessage", "CloseMessageWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerMessage.PlayMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MessageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerMessage::PlayMessage(const class FString& MessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerMessage", "PlayMessage");

	Params::ProduceSequencerMessage_PlayMessage Parms{};

	Parms.MessageId = std::move(MessageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugFL.GetMemoryInfoString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           outUsed                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           outAvailable                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugFL::GetMemoryInfoString(class FString* outUsed, class FString* outAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugFL", "GetMemoryInfoString");

	Params::NicolaDebugFL_GetMemoryInfoString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outUsed != nullptr)
		*outUsed = std::move(Parms.outUsed);

	if (outAvailable != nullptr)
		*outAvailable = std::move(Parms.outAvailable);
}


// Function Nicola.NicolaDebugFL.OnChangeDebugActionFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugActionFlags                       DebugActionFlag                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugFL::OnChangeDebugActionFlag(EDebugActionFlags DebugActionFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugFL", "OnChangeDebugActionFlag");

	Params::NicolaDebugFL_OnChangeDebugActionFlag Parms{};

	Parms.DebugActionFlag = DebugActionFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugFL.OnChangeDebugEtcFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugEtcFlags                          DebugEtcFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugFL::OnChangeDebugEtcFlag(EDebugEtcFlags DebugEtcFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugFL", "OnChangeDebugEtcFlag");

	Params::NicolaDebugFL_OnChangeDebugEtcFlag Parms{};

	Parms.DebugEtcFlag = DebugEtcFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugFL.UpdateDebugParameterCollection
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugFL::UpdateDebugParameterCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugFL", "UpdateDebugParameterCollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.GetDebugMangaIconOffsetHeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEventMangaIconComponent::GetDebugMangaIconOffsetHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "GetDebugMangaIconOffsetHeight");

	Params::EventMangaIconComponent_GetDebugMangaIconOffsetHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.EventMangaIconComponent.GetDebugManpuBaseScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEventMangaIconComponent::GetDebugManpuBaseScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "GetDebugManpuBaseScale");

	Params::EventMangaIconComponent_GetDebugManpuBaseScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.EventMangaIconComponent.GetDebugMenuManpuId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OutId                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventMangaIconComponent::GetDebugMenuManpuId(class FName* OutId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "GetDebugMenuManpuId");

	Params::EventMangaIconComponent_GetDebugMenuManpuId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutId != nullptr)
		*OutId = Parms.OutId;

	return Parms.ReturnValue;
}


// Function Nicola.EventMangaIconComponent.IsEnableDebugIconBaseScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventMangaIconComponent::IsEnableDebugIconBaseScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "IsEnableDebugIconBaseScale");

	Params::EventMangaIconComponent_IsEnableDebugIconBaseScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.EventMangaIconComponent.IsEnableDebugMangaIconOffset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventMangaIconComponent::IsEnableDebugMangaIconOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "IsEnableDebugMangaIconOffset");

	Params::EventMangaIconComponent_IsEnableDebugMangaIconOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.EventMangaIconComponent.SetDebugMangaIconOffsetHeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventMangaIconComponent::SetDebugMangaIconOffsetHeight(float Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "SetDebugMangaIconOffsetHeight");

	Params::EventMangaIconComponent_SetDebugMangaIconOffsetHeight Parms{};

	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.SetDebugManpuBaseScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventMangaIconComponent::SetDebugManpuBaseScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "SetDebugManpuBaseScale");

	Params::EventMangaIconComponent_SetDebugManpuBaseScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.SetDebugMenuManpuId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventMangaIconComponent::SetDebugMenuManpuId(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "SetDebugMenuManpuId");

	Params::EventMangaIconComponent_SetDebugMenuManpuId Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.SetEnableDebugIconBaseScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventMangaIconComponent::SetEnableDebugIconBaseScale(bool flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "SetEnableDebugIconBaseScale");

	Params::EventMangaIconComponent_SetEnableDebugIconBaseScale Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.SetEnableDebugMangaIconOffset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventMangaIconComponent::SetEnableDebugMangaIconOffset(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventMangaIconComponent", "SetEnableDebugMangaIconOffset");

	Params::EventMangaIconComponent_SetEnableDebugMangaIconOffset Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.BP_CloseMangaIcon
// (Final, Native, Protected, BlueprintCallable)

void UEventMangaIconComponent::BP_CloseMangaIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventMangaIconComponent", "BP_CloseMangaIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.BP_ForceAllCloseMangaIcon
// (Final, Native, Protected, BlueprintCallable)

void UEventMangaIconComponent::BP_ForceAllCloseMangaIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventMangaIconComponent", "BP_ForceAllCloseMangaIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.EventMangaIconComponent.BP_ShowMangaIcon
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventMangaIconComponent::BP_ShowMangaIcon(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventMangaIconComponent", "BP_ShowMangaIcon");

	Params::EventMangaIconComponent_BP_ShowMangaIcon Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerME.PlayME
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MEGopId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerME::PlayME(class FName MEGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerME", "PlayME");

	Params::ProduceSequencerME_PlayME Parms{};

	Parms.MEGopId = MEGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.FadeSubsystem.FadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::FadeIn(EFadingPriority EFadingPriority, float Timer, bool InForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "FadeIn");

	Params::FadeSubsystem_FadeIn Parms{};

	Parms.EFadingPriority = EFadingPriority;
	Parms.Timer = Timer;
	Parms.InForce = InForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.FadeSubsystem.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::FadeOut(EFadingPriority EFadingPriority, float Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "FadeOut");

	Params::FadeSubsystem_FadeOut Parms{};

	Parms.EFadingPriority = EFadingPriority;
	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.FadeSubsystem.Fading
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bFadeIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAfterFadeOut                           InAfterFadeOut                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::Fading(bool bFadeIn, float Timer, EAfterFadeOut InAfterFadeOut, const struct FLinearColor& FadeColor, bool InForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "Fading");

	Params::FadeSubsystem_Fading Parms{};

	Parms.bFadeIn = bFadeIn;
	Parms.Timer = Timer;
	Parms.InAfterFadeOut = InAfterFadeOut;
	Parms.FadeColor = std::move(FadeColor);
	Parms.InForce = InForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.FadeSubsystem.IsFadeInEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFadeSubsystem::IsFadeInEnd(EFadingPriority EFadingPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "IsFadeInEnd");

	Params::FadeSubsystem_IsFadeInEnd Parms{};

	Parms.EFadingPriority = EFadingPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.FadeSubsystem.IsFadeOutEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFadeSubsystem::IsFadeOutEnd(EFadingPriority EFadingPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "IsFadeOutEnd");

	Params::FadeSubsystem_IsFadeOutEnd Parms{};

	Parms.EFadingPriority = EFadingPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.FadeSubsystem.IsInFading
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFadeSubsystem::IsInFading(EFadingPriority EFadingPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "IsInFading");

	Params::FadeSubsystem_IsInFading Parms{};

	Parms.EFadingPriority = EFadingPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.FadeSubsystem.NowloadEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::NowloadEnd(float Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "NowloadEnd");

	Params::FadeSubsystem_NowloadEnd Parms{};

	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.FadeSubsystem.NowloadStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    tips                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFadeSubsystem::NowloadStart(float Timer, bool tips)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "NowloadStart");

	Params::FadeSubsystem_NowloadStart Parms{};

	Parms.Timer = Timer;
	Parms.tips = tips;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.FadeSubsystem.SetFadeColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UFadeSubsystem::SetFadeColor(EFadingPriority EFadingPriority, const struct FLinearColor& FadeColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "SetFadeColor");

	Params::FadeSubsystem_SetFadeColor Parms{};

	Parms.EFadingPriority = EFadingPriority;
	Parms.FadeColor = std::move(FadeColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.FadeSubsystem.GetFadeColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFadingPriority                         EFadingPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UFadeSubsystem::GetFadeColor(EFadingPriority EFadingPriority) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeSubsystem", "GetFadeColor");

	Params::FadeSubsystem_GetFadeColor Parms{};

	Parms.EFadingPriority = EFadingPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ResearchCommandInterface.OnCallCommand
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IResearchCommandInterface::OnCallCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResearchCommandInterface", "OnCallCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.RockGimmick.OnMoveCollisionBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARockGimmick::OnMoveCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RockGimmick", "OnMoveCollisionBeginOverlap");

	Params::RockGimmick_OnMoveCollisionBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerCameraManager.DebugMenuResetCamera
// (Final, Native, Public, BlueprintCallable)

void ANicolaPlayerCameraManager::DebugMenuResetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerCameraManager", "DebugMenuResetCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerCameraManager.PlayEventSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isInvisibleNpc                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isJumpToEnd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaPlayerCameraManager::PlayEventSequence(int32 Index_0, bool isInvisibleNpc, bool isJumpToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerCameraManager", "PlayEventSequence");

	Params::NicolaPlayerCameraManager_PlayEventSequence Parms{};

	Parms.Index_0 = Index_0;
	Parms.isInvisibleNpc = isInvisibleNpc;
	Parms.isJumpToEnd = isJumpToEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerCameraManager.GetBattleCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANicolaCameraActor*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANicolaCameraActor* ANicolaPlayerCameraManager::GetBattleCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerCameraManager", "GetBattleCamera");

	Params::NicolaPlayerCameraManager_GetBattleCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerCameraManager.GetCurrentTraceCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANicolaCameraActor*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANicolaCameraActor* ANicolaPlayerCameraManager::GetCurrentTraceCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerCameraManager", "GetCurrentTraceCamera");

	Params::NicolaPlayerCameraManager_GetCurrentTraceCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ProduceSequencerItemGetIcon.PlayItemGetIcon
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerItemGetIcon::PlayItemGetIcon(const class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerItemGetIcon", "PlayItemGetIcon");

	Params::ProduceSequencerItemGetIcon_PlayItemGetIcon Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerControllerBase.ClearActionInput
// (Final, Native, Public, BlueprintCallable)

void ANicolaPlayerControllerBase::ClearActionInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "ClearActionInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerControllerBase.ResetActionInput
// (Final, Native, Public, BlueprintCallable)

void ANicolaPlayerControllerBase::ResetActionInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "ResetActionInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerControllerBase.SetActionInputMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaPlayerControllerBase::SetActionInputMode(ENicolaInputMode inputMode, bool flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "SetActionInputMode");

	Params::NicolaPlayerControllerBase_SetActionInputMode Parms{};

	Parms.inputMode = inputMode;
	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaPlayerControllerBase.GetActionInputMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENicolaInputMode ANicolaPlayerControllerBase::GetActionInputMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "GetActionInputMode");

	Params::NicolaPlayerControllerBase_GetActionInputMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.GetAnalogStickL
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D ANicolaPlayerControllerBase::GetAnalogStickL(ENicolaInputMode inputMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "GetAnalogStickL");

	Params::NicolaPlayerControllerBase_GetAnalogStickL Parms{};

	Parms.inputMode = inputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.GetAnalogStickR
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D ANicolaPlayerControllerBase::GetAnalogStickR(ENicolaInputMode inputMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "GetAnalogStickR");

	Params::NicolaPlayerControllerBase_GetAnalogStickR Parms{};

	Parms.inputMode = inputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsActionInputModeGamePlayWithoutNoInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsActionInputModeGamePlayWithoutNoInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsActionInputModeGamePlayWithoutNoInput");

	Params::NicolaPlayerControllerBase_IsActionInputModeGamePlayWithoutNoInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsActionOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENicolaAction                           action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsActionOn(ENicolaInputMode inputMode, ENicolaAction action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsActionOn");

	Params::NicolaPlayerControllerBase_IsActionOn Parms{};

	Parms.inputMode = inputMode;
	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsActionRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENicolaAction                           action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsActionRelease(ENicolaInputMode inputMode, ENicolaAction action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsActionRelease");

	Params::NicolaPlayerControllerBase_IsActionRelease Parms{};

	Parms.inputMode = inputMode;
	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsActionTrigger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENicolaAction                           action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsActionTrigger(ENicolaInputMode inputMode, ENicolaAction action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsActionTrigger");

	Params::NicolaPlayerControllerBase_IsActionTrigger Parms{};

	Parms.inputMode = inputMode;
	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsActionTriggerRepeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENicolaAction                           action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsActionTriggerRepeat(ENicolaInputMode inputMode, ENicolaAction action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsActionTriggerRepeat");

	Params::NicolaPlayerControllerBase_IsActionTriggerRepeat Parms{};

	Parms.inputMode = inputMode;
	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsButtonOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaButton                           Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsButtonOn(ENicolaButton Button) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsButtonOn");

	Params::NicolaPlayerControllerBase_IsButtonOn Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsButtonRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaButton                           Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsButtonRelease(ENicolaButton Button) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsButtonRelease");

	Params::NicolaPlayerControllerBase_IsButtonRelease Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsButtonTrigger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaButton                           Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsButtonTrigger(ENicolaButton Button) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsButtonTrigger");

	Params::NicolaPlayerControllerBase_IsButtonTrigger Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaPlayerControllerBase.IsButtonTriggerRepeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaButton                           Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaPlayerControllerBase::IsButtonTriggerRepeat(ENicolaButton Button) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaPlayerControllerBase", "IsButtonTriggerRepeat");

	Params::NicolaPlayerControllerBase_IsButtonTriggerRepeat Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.SearchEventGimmick.OnEndEffectSearchObject
// (Final, Native, Private, BlueprintCallable)

void ASearchEventGimmick::OnEndEffectSearchObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchEventGimmick", "OnEndEffectSearchObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SearchEventGimmick.OnPostChangeLevelBlueprint
// (Event, Protected, BlueprintEvent)

void ASearchEventGimmick::OnPostChangeLevelBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchEventGimmick", "OnPostChangeLevelBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.SearchEventGimmick.OpenedBehaviourBlueprint
// (Event, Protected, BlueprintEvent)

void ASearchEventGimmick::OpenedBehaviourBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchEventGimmick", "OpenedBehaviourBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.SearchEventGimmick.PlayEffectSearchObjectBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             PlayEffectName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchEventGimmick::PlayEffectSearchObjectBP(class FName PlayEffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchEventGimmick", "PlayEffectSearchObjectBP");

	Params::SearchEventGimmick_PlayEffectSearchObjectBP Parms{};

	Parms.PlayEffectName = PlayEffectName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.ProduceSequencerEnding.ChangeAnimationLogo
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerEnding::ChangeAnimationLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerEnding", "ChangeAnimationLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerEnding.StartAnimationLogo
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerEnding::StartAnimationLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerEnding", "StartAnimationLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerEnding.StartFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerEnding::StartFadeOut(float FadeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerEnding", "StartFadeOut");

	Params::ProduceSequencerEnding_StartFadeOut Parms{};

	Parms.FadeSec = FadeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCameraFL.GetCurrentCamera
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANicolaCameraActor*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANicolaCameraActor* UNicolaCameraFL::GetCurrentCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCameraFL", "GetCurrentCamera");

	Params::NicolaCameraFL_GetCurrentCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.FlipbookWidgetBase.Update
// (Final, Native, Public)

void UFlipbookWidgetBase::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlipbookWidgetBase", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugAmbientOcclusion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugAmbientOcclusion(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugAmbientOcclusion");

	Params::NicolaCharacterFL_DebugAmbientOcclusion Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugBloom
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugBloom(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugBloom");

	Params::NicolaCharacterFL_DebugBloom Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugChangeCharaColor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   b                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ColorPower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   metallicPower                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugChangeCharaColor(int32 Index_0, float R, float G, float b, float ColorPower, float metallicPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugChangeCharaColor");

	Params::NicolaCharacterFL_DebugChangeCharaColor Parms{};

	Parms.Index_0 = Index_0;
	Parms.R = R;
	Parms.G = G;
	Parms.b = b;
	Parms.ColorPower = ColorPower;
	Parms.metallicPower = metallicPower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugGetAperture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaCharacterFL::DebugGetAperture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugGetAperture");

	Params::NicolaCharacterFL_DebugGetAperture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCharacterFL.DebugGetCharaColor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   b                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ColorPower                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   metallicPower                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaCharacterFL::DebugGetCharaColor(int32 Index_0, float* R, float* G, float* b, float* ColorPower, float* metallicPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugGetCharaColor");

	Params::NicolaCharacterFL_DebugGetCharaColor Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (b != nullptr)
		*b = Parms.b;

	if (ColorPower != nullptr)
		*ColorPower = Parms.ColorPower;

	if (metallicPower != nullptr)
		*metallicPower = Parms.metallicPower;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCharacterFL.DebugGetNearDOF
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaCharacterFL::DebugGetNearDOF()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugGetNearDOF");

	Params::NicolaCharacterFL_DebugGetNearDOF Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCharacterFL.DebugMotionBlur
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugMotionBlur(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugMotionBlur");

	Params::NicolaCharacterFL_DebugMotionBlur Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugSceneFringe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugSceneFringe(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugSceneFringe");

	Params::NicolaCharacterFL_DebugSceneFringe Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugSetAperture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugSetAperture(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugSetAperture");

	Params::NicolaCharacterFL_DebugSetAperture Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.DebugSetNearDOF
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterFL::DebugSetNearDOF(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "DebugSetNearDOF");

	Params::NicolaCharacterFL_DebugSetNearDOF Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterFL.GetCharactersFromParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class ANicolaCharacterBase*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ANicolaCharacterBase*> UNicolaCharacterFL::GetCharactersFromParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "GetCharactersFromParty");

	Params::NicolaCharacterFL_GetCharactersFromParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCharacterFL.SpawnUnit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUnitCommonCreateOption          UnitCommonCreateOption                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FUnitInstanceCreateOption        UnitInstanceCreateOption                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUnitLooksActorCreateOption      UnitLooksActorCreateOption                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ANicolaCharacterBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANicolaCharacterBase* UNicolaCharacterFL::SpawnUnit(const struct FUnitCommonCreateOption& UnitCommonCreateOption, const struct FUnitInstanceCreateOption& UnitInstanceCreateOption, const struct FUnitLooksActorCreateOption& UnitLooksActorCreateOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterFL", "SpawnUnit");

	Params::NicolaCharacterFL_SpawnUnit Parms{};

	Parms.UnitCommonCreateOption = std::move(UnitCommonCreateOption);
	Parms.UnitInstanceCreateOption = std::move(UnitInstanceCreateOption);
	Parms.UnitLooksActorCreateOption = std::move(UnitLooksActorCreateOption);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GameDataCoreFL.AddGameMoney
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isBank                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataCoreFL::AddGameMoney(int32 Value, bool isBank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "AddGameMoney");

	Params::GameDataCoreFL_AddGameMoney Parms{};

	Parms.Value = Value;
	Parms.isBank = isBank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GameDataCoreFL.AddMiniMedal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   addCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataCoreFL::AddMiniMedal(int32 addCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "AddMiniMedal");

	Params::GameDataCoreFL_AddMiniMedal Parms{};

	Parms.addCount = addCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.AddMonsterKillCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InMonsterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAddCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataCoreFL::AddMonsterKillCount(class FName InMonsterId, int32 InAddCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "AddMonsterKillCount");

	Params::GameDataCoreFL_AddMonsterKillCount Parms{};

	Parms.InMonsterId = InMonsterId;
	Parms.InAddCount = InAddCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.BP_DebugDisconnectControllerMessage
// (Final, Native, Static, Public, BlueprintCallable)

void UGameDataCoreFL::BP_DebugDisconnectControllerMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "BP_DebugDisconnectControllerMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.BP_DebugGetGOPEnumFlag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDebugGOPFlagType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   flagIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataCoreFL::BP_DebugGetGOPEnumFlag(const EDebugGOPFlagType Type, int32 flagIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "BP_DebugGetGOPEnumFlag");

	Params::GameDataCoreFL_BP_DebugGetGOPEnumFlag Parms{};

	Parms.Type = Type;
	Parms.flagIndex = flagIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GameDataCoreFL.BP_DebugGetGOPEnumFlagNameList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugGOPFlagType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGameDataCoreFL::BP_DebugGetGOPEnumFlagNameList(const EDebugGOPFlagType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "BP_DebugGetGOPEnumFlagNameList");

	Params::GameDataCoreFL_BP_DebugGetGOPEnumFlagNameList Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GameDataCoreFL.BP_DebugSetGOPEnumFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugGOPFlagType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   flagIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataCoreFL::BP_DebugSetGOPEnumFlag(const EDebugGOPFlagType Type, int32 flagIndex, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "BP_DebugSetGOPEnumFlag");

	Params::GameDataCoreFL_BP_DebugSetGOPEnumFlag Parms{};

	Parms.Type = Type;
	Parms.flagIndex = flagIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.DebugAddGamePlayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   addValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataCoreFL::DebugAddGamePlayTime(int32 addValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "DebugAddGamePlayTime");

	Params::GameDataCoreFL_DebugAddGamePlayTime Parms{};

	Parms.addValue = addValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.DebugAllRuraPointUnlock
// (Final, Native, Static, Public, BlueprintCallable)

void UGameDataCoreFL::DebugAllRuraPointUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "DebugAllRuraPointUnlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.GetAllMonsterUnitMasterID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameDataCoreFL::GetAllMonsterUnitMasterID(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "GetAllMonsterUnitMasterID");

	Params::GameDataCoreFL_GetAllMonsterUnitMasterID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.GameDataCoreFL.GetGameMoney
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataCoreFL::GetGameMoney()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "GetGameMoney");

	Params::GameDataCoreFL_GetGameMoney Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GameDataCoreFL.ReduceGameMoney
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataCoreFL::ReduceGameMoney(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "ReduceGameMoney");

	Params::GameDataCoreFL_ReduceGameMoney Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GameDataCoreFL.SetAllMonsterAddLibrary
// (Final, Native, Static, Public, BlueprintCallable)

void UGameDataCoreFL::SetAllMonsterAddLibrary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "SetAllMonsterAddLibrary");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataCoreFL.SetCanRuraVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsCanRura                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataCoreFL::SetCanRuraVolume(bool bIsCanRura)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataCoreFL", "SetCanRuraVolume");

	Params::GameDataCoreFL_SetCanRuraVolume Parms{};

	Parms.bIsCanRura = bIsCanRura;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataFL.DebugCallSetupAfterLoaded
// (Final, Native, Static, Public, BlueprintCallable)

void UGameDataFL::DebugCallSetupAfterLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataFL", "DebugCallSetupAfterLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GameDataFL.GetGameMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameMode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameMode UGameDataFL::GetGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataFL", "GetGameMode");

	Params::GameDataFL_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCheatManager.DisableEncount
// (Final, Exec, Native, Public)

void UNicolaCheatManager::DisableEncount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "DisableEncount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.DisableShipStep
// (Final, Exec, Native, Public)

void UNicolaCheatManager::DisableShipStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "DisableShipStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.EnableEncount
// (Final, Exec, Native, Public)

void UNicolaCheatManager::EnableEncount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "EnableEncount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.EnableShipStep
// (Final, Exec, Native, Public)

void UNicolaCheatManager::EnableShipStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "EnableShipStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.FindTextGopId
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCheatManager::FindTextGopId(const class FName& GopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "FindTextGopId");

	Params::NicolaCheatManager_FindTextGopId Parms{};

	Parms.GopId = GopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.HelloWorld
// (Final, Exec, Native, Public)

void UNicolaCheatManager::HelloWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "HelloWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.ImprintRecollection
// (Final, Exec, Native, Public)

void UNicolaCheatManager::ImprintRecollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "ImprintRecollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.LuaDebugExec
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           funcName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCheatManager::LuaDebugExec(const class FString& funcName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "LuaDebugExec");

	Params::NicolaCheatManager_LuaDebugExec Parms{};

	Parms.funcName = std::move(funcName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.ResetEncount
// (Final, Exec, Native, Public)

void UNicolaCheatManager::ResetEncount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "ResetEncount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.SetNearDOF
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DOFPower                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCheatManager::SetNearDOF(const float DOFPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "SetNearDOF");

	Params::NicolaCheatManager_SetNearDOF Parms{};

	Parms.DOFPower = DOFPower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCheatManager.StartBattle
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             BattleMapID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCheatManager::StartBattle(const class FName& BattleMapID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCheatManager", "StartBattle");

	Params::NicolaCheatManager_StartBattle Parms{};

	Parms.BattleMapID = BattleMapID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.GopFL.GetDataTableEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EEventTableType                         TableType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGopEventType                           GopType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataTable*                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDataTable* UGopFL::GetDataTableEvent(EEventTableType TableType, EGopEventType GopType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GopFL", "GetDataTableEvent");

	Params::GopFL_GetDataTableEvent Parms{};

	Parms.TableType = TableType;
	Parms.GopType = GopType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.GopTextBlock.DebugSetGopID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InGop                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           InArg00                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGopTextBlock::DebugSetGopID(const class FText& InGop, const class FString& InArg00)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GopTextBlock", "DebugSetGopID");

	Params::GopTextBlock_DebugSetGopID Parms{};

	Parms.InGop = std::move(InGop);
	Parms.InArg00 = std::move(InArg00);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.HealGimmick.PlayHealAnimation
// (Event, Protected, BlueprintEvent)

void AHealGimmick::PlayHealAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealGimmick", "PlayHealAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.InputFL.GetLeftStickTilt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInputFL::GetLeftStickTilt(ENicolaInputMode inputMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputFL", "GetLeftStickTilt");

	Params::InputFL_GetLeftStickTilt Parms{};

	Parms.inputMode = inputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.InputFL.IsAnyDirectionalKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENicolaInputMode                        inputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputFL::IsAnyDirectionalKey(ENicolaInputMode inputMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InputFL", "IsAnyDirectionalKey");

	Params::InputFL_IsAnyDirectionalKey Parms{};

	Parms.inputMode = inputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.InterpFloat.CancelTransition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCallDelegate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpFloat::CancelTransition(bool bCallDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpFloat", "CancelTransition");

	Params::InterpFloat_CancelTransition Parms{};

	Parms.bCallDelegate = bCallDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.InterpFloat.Clamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewClampValueMin                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewClampValueMax                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpFloat::Clamp(float NewClampValueMin, float NewClampValueMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpFloat", "Clamp");

	Params::InterpFloat_Clamp Parms{};

	Parms.NewClampValueMin = NewClampValueMin;
	Parms.NewClampValueMax = NewClampValueMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.InterpFloat.SetCurrentValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCurrentValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpFloat::SetCurrentValue(float NewCurrentValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpFloat", "SetCurrentValue");

	Params::InterpFloat_SetCurrentValue Parms{};

	Parms.NewCurrentValue = NewCurrentValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.InterpFloat.StartTransition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTargetValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDurationSec                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpFloat::StartTransition(float NewTargetValue, float NewDurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpFloat", "StartTransition");

	Params::InterpFloat_StartTransition Parms{};

	Parms.NewTargetValue = NewTargetValue;
	Parms.NewDurationSec = NewDurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.InterpFloat.GetCurrentValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInterpFloat::GetCurrentValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpFloat", "GetCurrentValue");

	Params::InterpFloat_GetCurrentValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.InterpFloat.IsOnTransition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterpFloat::IsOnTransition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpFloat", "IsOnTransition");

	Params::InterpFloat_IsOnTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LevelFL.IsEndMakingMapData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelFL::IsEndMakingMapData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelFL", "IsEndMakingMapData");

	Params::LevelFL_IsEndMakingMapData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LevelFL.ReturnTitle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelFL::ReturnTitle(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelFL", "ReturnTitle");

	Params::LevelFL_ReturnTitle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.ActivateVariation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             variationName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingFL::ActivateVariation(class FName variationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "ActivateVariation");

	Params::LightingFL_ActivateVariation Parms{};

	Parms.variationName = variationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.DeactivateVariation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             variationName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingFL::DeactivateVariation(class FName variationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "DeactivateVariation");

	Params::LightingFL_DeactivateVariation Parms{};

	Parms.variationName = variationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.DebugCatchDirectionalLight
// (Final, Native, Static, Public, BlueprintCallable)

void ULightingFL::DebugCatchDirectionalLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "DebugCatchDirectionalLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.DebugCatchLightDirRotator
// (Final, Native, Static, Public, BlueprintCallable)

void ULightingFL::DebugCatchLightDirRotator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "DebugCatchLightDirRotator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.GetFieldSymbolLightingRate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULightingFL::GetFieldSymbolLightingRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "GetFieldSymbolLightingRate");

	Params::LightingFL_GetFieldSymbolLightingRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LightingFL.IsCatchingDirectionalLight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightingFL::IsCatchingDirectionalLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "IsCatchingDirectionalLight");

	Params::LightingFL_IsCatchingDirectionalLight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LightingFL.IsCatchingLightDirRotator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightingFL::IsCatchingLightDirRotator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "IsCatchingLightDirRotator");

	Params::LightingFL_IsCatchingLightDirRotator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LightingFL.ReleaseDirectionalLight
// (Final, Native, Static, Public, BlueprintCallable)

void ULightingFL::ReleaseDirectionalLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "ReleaseDirectionalLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.ReleaseLightDirRotator
// (Final, Native, Static, Public, BlueprintCallable)

void ULightingFL::ReleaseLightDirRotator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "ReleaseLightDirRotator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.RequestLightDirRotatorUpdating
// (Final, Native, Static, Public, BlueprintCallable)

void ULightingFL::RequestLightDirRotatorUpdating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "RequestLightDirRotatorUpdating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.SetDirectionalLightInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MapId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapTimeFrame                           MapTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             subLevelId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingFL::SetDirectionalLightInfo(class FName MapId, EMapTimeFrame MapTime, class FName subLevelId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "SetDirectionalLightInfo");

	Params::LightingFL_SetDirectionalLightInfo Parms{};

	Parms.MapId = MapId;
	Parms.MapTime = MapTime;
	Parms.subLevelId = subLevelId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.SetLightDirRotatorInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MapId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapTimeFrame                           MapTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             subLevelId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingFL::SetLightDirRotatorInfo(class FName MapId, EMapTimeFrame MapTime, class FName subLevelId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "SetLightDirRotatorInfo");

	Params::LightingFL_SetLightDirRotatorInfo Parms{};

	Parms.MapId = MapId;
	Parms.MapTime = MapTime;
	Parms.subLevelId = subLevelId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.SetVisibleLightingActors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetByRotator                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingFL::SetVisibleLightingActors(bool bVisible, bool bSetByRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "SetVisibleLightingActors");

	Params::LightingFL_SetVisibleLightingActors Parms{};

	Parms.bVisible = bVisible;
	Parms.bSetByRotator = bSetByRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LightingFL.UpdateFieldSymbolLighting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   lightingRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingFL::UpdateFieldSymbolLighting(float lightingRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingFL", "UpdateFieldSymbolLighting");

	Params::LightingFL_UpdateFieldSymbolLighting Parms{};

	Parms.lightingRate = lightingRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.BP_GetSystemFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   flagNo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULuaFunctionLibrary::BP_GetSystemFlag(int32 flagNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "BP_GetSystemFlag");

	Params::LuaFunctionLibrary_BP_GetSystemFlag Parms{};

	Parms.flagNo = flagNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.BP_GetSystemFlagByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             FlagName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULuaFunctionLibrary::BP_GetSystemFlagByName(class FName FlagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "BP_GetSystemFlagByName");

	Params::LuaFunctionLibrary_BP_GetSystemFlagByName Parms{};

	Parms.FlagName = FlagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.BP_SetSystemFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   flagNo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::BP_SetSystemFlag(int32 flagNo, bool flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "BP_SetSystemFlag");

	Params::LuaFunctionLibrary_BP_SetSystemFlag Parms{};

	Parms.flagNo = flagNo;
	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.BP_SetSystemFlagByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             FlagName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::BP_SetSystemFlagByName(class FName FlagName, bool flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "BP_SetSystemFlagByName");

	Params::LuaFunctionLibrary_BP_SetSystemFlagByName Parms{};

	Parms.FlagName = FlagName;
	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.DebugAllEventPlay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StartTitle                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::DebugAllEventPlay(const class FString& StartTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "DebugAllEventPlay");

	Params::LuaFunctionLibrary_DebugAllEventPlay Parms{};

	Parms.StartTitle = std::move(StartTitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.DebugChangeActorVisibility
// (Final, Native, Static, Public, BlueprintCallable)

void ULuaFunctionLibrary::DebugChangeActorVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "DebugChangeActorVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.FindLuaLevelScript
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           levelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExist                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULuaFunctionLibrary::FindLuaLevelScript(const class FString& levelName, bool* bExist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "FindLuaLevelScript");

	Params::LuaFunctionLibrary_FindLuaLevelScript Parms{};

	Parms.levelName = std::move(levelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bExist != nullptr)
		*bExist = Parms.bExist;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.GetActionInputMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENicolaInputMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENicolaInputMode ULuaFunctionLibrary::GetActionInputMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "GetActionInputMode");

	Params::LuaFunctionLibrary_GetActionInputMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.GetSystemGlobalVariableByInteger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELuaSysGlobal                           sysGlobalInfo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULuaFunctionLibrary::GetSystemGlobalVariableByInteger(ELuaSysGlobal sysGlobalInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "GetSystemGlobalVariableByInteger");

	Params::LuaFunctionLibrary_GetSystemGlobalVariableByInteger Parms{};

	Parms.sysGlobalInfo = sysGlobalInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.GetSystemVariableByInteger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELuaSysInfo                             sysInfo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULuaFunctionLibrary::GetSystemVariableByInteger(ELuaSysInfo sysInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "GetSystemVariableByInteger");

	Params::LuaFunctionLibrary_GetSystemVariableByInteger Parms{};

	Parms.sysInfo = sysInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.LoadTextResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           dir                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           fname                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           outputText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDebugMenuResource*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDebugMenuResource* ULuaFunctionLibrary::LoadTextResource(const class FString& dir, const class FString& fname, const class FString& outputText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "LoadTextResource");

	Params::LuaFunctionLibrary_LoadTextResource Parms{};

	Parms.dir = std::move(dir);
	Parms.fname = std::move(fname);
	Parms.outputText = std::move(outputText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.OutputLuaFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           dir                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           fname                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           outputText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULuaFunctionLibrary::OutputLuaFile(const class FString& dir, const class FString& fname, const class FString& outputText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "OutputLuaFile");

	Params::LuaFunctionLibrary_OutputLuaFile Parms{};

	Parms.dir = std::move(dir);
	Parms.fname = std::move(fname);
	Parms.outputText = std::move(outputText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.LuaFunctionLibrary.ScenarioInitialize
// (Final, Native, Static, Public, BlueprintCallable)

void ULuaFunctionLibrary::ScenarioInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "ScenarioInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetBattleOrderCommandToLua
// (Final, Native, Static, Public, BlueprintCallable)

void ULuaFunctionLibrary::SetBattleOrderCommandToLua()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetBattleOrderCommandToLua");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetLuaLevelScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           levelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ScriptName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::SetLuaLevelScript(const class FString& levelName, const class FString& ScriptName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetLuaLevelScript");

	Params::LuaFunctionLibrary_SetLuaLevelScript Parms{};

	Parms.levelName = std::move(levelName);
	Parms.ScriptName = std::move(ScriptName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetMessageActionCommandToLua
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Argment                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::SetMessageActionCommandToLua(const class FString& TagName, const class FString& Argment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetMessageActionCommandToLua");

	Params::LuaFunctionLibrary_SetMessageActionCommandToLua Parms{};

	Parms.TagName = std::move(TagName);
	Parms.Argment = std::move(Argment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetMessageCommandToLua
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MessageCommand                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::SetMessageCommandToLua(const class FString& MessageCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetMessageCommandToLua");

	Params::LuaFunctionLibrary_SetMessageCommandToLua Parms{};

	Parms.MessageCommand = std::move(MessageCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetStandByCommandToLua
// (Final, Native, Static, Public, BlueprintCallable)

void ULuaFunctionLibrary::SetStandByCommandToLua()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetStandByCommandToLua");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetSystemGlobalVariableByInteger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELuaSysGlobal                           sysGlobalInfo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::SetSystemGlobalVariableByInteger(ELuaSysGlobal sysGlobalInfo, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetSystemGlobalVariableByInteger");

	Params::LuaFunctionLibrary_SetSystemGlobalVariableByInteger Parms{};

	Parms.sysGlobalInfo = sysGlobalInfo;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.LuaFunctionLibrary.SetSystemVariableByInteger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELuaSysInfo                             sysInfo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuaFunctionLibrary::SetSystemVariableByInteger(ELuaSysInfo sysInfo, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LuaFunctionLibrary", "SetSystemVariableByInteger");

	Params::LuaFunctionLibrary_SetSystemVariableByInteger Parms{};

	Parms.sysInfo = sysInfo;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.DebugMenuItem.GetChildMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDebugMenuResource*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDebugMenuResource* UDebugMenuItem::GetChildMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenuItem", "GetChildMenu");

	Params::DebugMenuItem_GetChildMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.DebugMenuItem.IsChildMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDebugMenuItem::IsChildMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenuItem", "IsChildMenu");

	Params::DebugMenuItem_IsChildMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldPopup.BPPlayPopup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InNum                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldPopup::BPPlayPopup(int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldPopup", "BPPlayPopup");

	Params::UIFieldPopup_BPPlayPopup Parms{};

	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldPopup.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldPopup::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldPopup", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapFL.AllPlayerStartOverlapTest_Debug
// (Final, Native, Static, Public, BlueprintCallable)

void UMapFL::AllPlayerStartOverlapTest_Debug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "AllPlayerStartOverlapTest_Debug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapFL.CanLanding
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        surfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::CanLanding(EPhysicalSurface surfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "CanLanding");

	Params::MapFL_CanLanding Parms{};

	Parms.surfaceType = surfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.CanSwim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        surfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::CanSwim(EPhysicalSurface surfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "CanSwim");

	Params::MapFL_CanSwim Parms{};

	Parms.surfaceType = surfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.CanWalk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        surfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::CanWalk(EPhysicalSurface surfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "CanWalk");

	Params::MapFL_CanWalk Parms{};

	Parms.surfaceType = surfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.DecalTest_Debug
// (Final, Native, Static, Public, BlueprintCallable)

void UMapFL::DecalTest_Debug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "DecalTest_Debug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapFL.GetActorLevelTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UMapFL::GetActorLevelTransform(const class AActor* TARGET)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetActorLevelTransform");

	Params::MapFL_GetActorLevelTransform Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.GetActorLevelTransformFromActorLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UMapFL::GetActorLevelTransformFromActorLocation(const class AActor* TARGET)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetActorLevelTransformFromActorLocation");

	Params::MapFL_GetActorLevelTransformFromActorLocation Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.GetCurrentMapId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UMapFL::GetCurrentMapId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetCurrentMapId");

	Params::MapFL_GetCurrentMapId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.GetFloorMapName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PrefixId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapFL::GetFloorMapName(const class FString& PrefixId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetFloorMapName");

	Params::MapFL_GetFloorMapName Parms{};

	Parms.PrefixId = std::move(PrefixId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.GetFloorMapNameID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PrefixId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMapFL::GetFloorMapNameID(const class FString& PrefixId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetFloorMapNameID");

	Params::MapFL_GetFloorMapNameID Parms{};

	Parms.PrefixId = std::move(PrefixId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.GetLanternTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    outValidTable                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGOP_LanternTable                outTable                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UMapFL::GetLanternTable(bool* outValidTable, struct FGOP_LanternTable* outTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetLanternTable");

	Params::MapFL_GetLanternTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outValidTable != nullptr)
		*outValidTable = Parms.outValidTable;

	if (outTable != nullptr)
		*outTable = std::move(Parms.outTable);
}


// Function Nicola.MapFL.GetMapIdsByPrefixId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PrefixId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMapFL::GetMapIdsByPrefixId(const class FName& PrefixId, TArray<class FName>* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetMapIdsByPrefixId");

	Params::MapFL_GetMapIdsByPrefixId Parms{};

	Parms.PrefixId = PrefixId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Nicola.MapFL.GetMapPrefixIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMapFL::GetMapPrefixIds(TArray<class FName>* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "GetMapPrefixIds");

	Params::MapFL_GetMapPrefixIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Nicola.MapFL.SetActorLevelLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::SetActorLevelLocation(class AActor* TARGET, const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "SetActorLevelLocation");

	Params::MapFL_SetActorLevelLocation Parms{};

	Parms.TARGET = TARGET;
	Parms.NewLocation = std::move(NewLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.SetActorLevelLocationAndRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::SetActorLevelLocationAndRotation(class AActor* TARGET, const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "SetActorLevelLocationAndRotation");

	Params::MapFL_SetActorLevelLocationAndRotation Parms{};

	Parms.TARGET = TARGET;
	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.SetActorLevelRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTeleportPhysics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::SetActorLevelRotation(class AActor* TARGET, const struct FRotator& NewRotation, bool bTeleportPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "SetActorLevelRotation");

	Params::MapFL_SetActorLevelRotation Parms{};

	Parms.TARGET = TARGET;
	Parms.NewRotation = std::move(NewRotation);
	Parms.bTeleportPhysics = bTeleportPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.SetActorLevelTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapFL::SetActorLevelTransform(class AActor* TARGET, const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "SetActorLevelTransform");

	Params::MapFL_SetActorLevelTransform Parms{};

	Parms.TARGET = TARGET;
	Parms.NewTransform = std::move(NewTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function Nicola.MapFL.StartMapTransition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MapId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapFL::StartMapTransition(const class FName& MapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapFL", "StartMapTransition");

	Params::MapFL_StartMapTransition Parms{};

	Parms.MapId = MapId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapTimeFL.GetEnableTimePassedFlags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    outIsInSystemProcessing                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    outIsInEventProcessing                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    outIsInBattle                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    outIsInUIOpening                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    outIsInUppergroundField                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTimeFL::GetEnableTimePassedFlags(bool& outIsInSystemProcessing, bool& outIsInEventProcessing, bool& outIsInBattle, bool& outIsInUIOpening, bool& outIsInUppergroundField)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "GetEnableTimePassedFlags");

	Params::MapTimeFL_GetEnableTimePassedFlags Parms{};

	Parms.outIsInSystemProcessing = outIsInSystemProcessing;
	Parms.outIsInEventProcessing = outIsInEventProcessing;
	Parms.outIsInBattle = outIsInBattle;
	Parms.outIsInUIOpening = outIsInUIOpening;
	Parms.outIsInUppergroundField = outIsInUppergroundField;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	outIsInSystemProcessing = Parms.outIsInSystemProcessing;
	outIsInEventProcessing = Parms.outIsInEventProcessing;
	outIsInBattle = Parms.outIsInBattle;
	outIsInUIOpening = Parms.outIsInUIOpening;
	outIsInUppergroundField = Parms.outIsInUppergroundField;
}


// Function Nicola.MapTimeFL.GetFieldTimeFrame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFieldTimeFrame                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFieldTimeFrame UMapTimeFL::GetFieldTimeFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "GetFieldTimeFrame");

	Params::MapTimeFL_GetFieldTimeFrame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapTimeFL.GetMapMaterialTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMapTimeFL::GetMapMaterialTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "GetMapMaterialTime");

	Params::MapTimeFL_GetMapMaterialTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapTimeFL.GetMapTimeFrame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMapTimeFrame                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMapTimeFrame UMapTimeFL::GetMapTimeFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "GetMapTimeFrame");

	Params::MapTimeFL_GetMapTimeFrame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapTimeFL.GetMapTimeHour
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMapTimeFL::GetMapTimeHour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "GetMapTimeHour");

	Params::MapTimeFL_GetMapTimeHour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapTimeFL.IsEnableTimePassed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapTimeFL::IsEnableTimePassed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "IsEnableTimePassed");

	Params::MapTimeFL_IsEnableTimePassed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.MapTimeFL.SetFieldTimeFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFieldTimeFrame                         FieldTimeFrame                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTimeFL::SetFieldTimeFrame(EFieldTimeFrame FieldTimeFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "SetFieldTimeFrame");

	Params::MapTimeFL_SetFieldTimeFrame Parms{};

	Parms.FieldTimeFrame = FieldTimeFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapTimeFL.SetMapTimeFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMapTimeFrame                           MapTimeFrame                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTimeFL::SetMapTimeFrame(EMapTimeFrame MapTimeFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "SetMapTimeFrame");

	Params::MapTimeFL_SetMapTimeFrame Parms{};

	Parms.MapTimeFrame = MapTimeFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.MapTimeFL.SetMapTimeHour
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTimeFL::SetMapTimeHour(int32 hour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapTimeFL", "SetMapTimeHour");

	Params::MapTimeFL_SetMapTimeHour Parms{};

	Parms.hour = hour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIChurchMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIChurchMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIChurchMenu", "IsExecMenu");

	Params::UIChurchMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIChurchMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EChurchMenuMenuMode                     InMenuMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InGopId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCallMemberIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIChurchMenu::OpenMenu(EChurchMenuMenuMode InMenuMode, class FName InGopId, int32 InCallMemberIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIChurchMenu", "OpenMenu");

	Params::UIChurchMenu_OpenMenu Parms{};

	Parms.InMenuMode = InMenuMode;
	Parms.InGopId = InGopId;
	Parms.InCallMemberIndex = InCallMemberIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNicolaAchievementManager*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaAchievementManager* UNicolaAchievementManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaAchievementManager", "GetInstance");

	Params::NicolaAchievementManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.CountupAchievementValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   addValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaAchievementManager::CountupAchievementValue(EAchievement AchievementID, int32 addValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "CountupAchievementValue");

	Params::NicolaAchievementManager_CountupAchievementValue Parms{};

	Parms.AchievementID = AchievementID;
	Parms.addValue = addValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.DebugSetCountValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaAchievementManager::DebugSetCountValue(EAchievement AchievementID, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "DebugSetCountValue");

	Params::NicolaAchievementManager_DebugSetCountValue Parms{};

	Parms.AchievementID = AchievementID;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.IsUnlockedAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaAchievementManager::IsUnlockedAchievement(EAchievement AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "IsUnlockedAchievement");

	Params::NicolaAchievementManager_IsUnlockedAchievement Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.OnFinishCacheAchievements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaAchievementManager::OnFinishCacheAchievements(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "OnFinishCacheAchievements");

	Params::NicolaAchievementManager_OnFinishCacheAchievements Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.OnStartCacheAchievements
// (Final, Native, Public, BlueprintCallable)

void UNicolaAchievementManager::OnStartCacheAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "OnStartCacheAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.RequestResetAchievements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaAchievementManager::RequestResetAchievements(bool bResetCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "RequestResetAchievements");

	Params::NicolaAchievementManager_RequestResetAchievements Parms{};

	Parms.bResetCount = bResetCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.RequestUnlockAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaAchievementManager::RequestUnlockAchievement(EAchievement AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "RequestUnlockAchievement");

	Params::NicolaAchievementManager_RequestUnlockAchievement Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaAchievementManager.RequestUnlockAchievementIfAchievedCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaAchievementManager::RequestUnlockAchievementIfAchievedCount(EAchievement AchievementID, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "RequestUnlockAchievementIfAchievedCount");

	Params::NicolaAchievementManager_RequestUnlockAchievementIfAchievedCount Parms{};

	Parms.AchievementID = AchievementID;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.DebugGetAchievementNameToEnum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAchievement                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAchievement UNicolaAchievementManager::DebugGetAchievementNameToEnum(const class FName& InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "DebugGetAchievementNameToEnum");

	Params::NicolaAchievementManager_DebugGetAchievementNameToEnum Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.DebugGetCountLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaAchievementManager::DebugGetCountLimit(EAchievement AchievementID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "DebugGetCountLimit");

	Params::NicolaAchievementManager_DebugGetCountLimit Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.DebugGetCountValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaAchievementManager::DebugGetCountValue(EAchievement AchievementID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "DebugGetCountValue");

	Params::NicolaAchievementManager_DebugGetCountValue Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.IsInitializedAchievementSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaAchievementManager::IsInitializedAchievementSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "IsInitializedAchievementSystem");

	Params::NicolaAchievementManager_IsInitializedAchievementSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaAchievementManager.IsValidAchievement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAchievement                            AchievementID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValidPlatinum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaAchievementManager::IsValidAchievement(EAchievement AchievementID, bool bValidPlatinum) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaAchievementManager", "IsValidAchievement");

	Params::NicolaAchievementManager_IsValidAchievement Parms{};

	Parms.AchievementID = AchievementID;
	Parms.bValidPlatinum = bValidPlatinum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaActionComponent.PlaySequencerAnimation
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EAnimationType                          animationType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLoop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaActionComponent::PlaySequencerAnimation(EAnimationType animationType, bool IsLoop, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaActionComponent", "PlaySequencerAnimation");

	Params::NicolaActionComponent_PlaySequencerAnimation Parms{};

	Parms.animationType = animationType;
	Parms.IsLoop = IsLoop;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaActionComponent.StopSequencerAnimation
// (Final, Native, Private, BlueprintCallable)

void UNicolaActionComponent::StopSequencerAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaActionComponent", "StopSequencerAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaActionInputModeInterface.OnChangeActionInputMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENicolaInputMode                        prevInputMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENicolaInputMode                        newInputMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INicolaActionInputModeInterface::OnChangeActionInputMode(ENicolaInputMode prevInputMode, ENicolaInputMode newInputMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaActionInputModeInterface", "OnChangeActionInputMode");

	Params::NicolaActionInputModeInterface_OnChangeActionInputMode Parms{};

	Parms.prevInputMode = prevInputMode;
	Parms.newInputMode = newInputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleCameraActor.SetFocusRelativeOffset
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANicolaBattleCameraActor::SetFocusRelativeOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaBattleCameraActor", "SetFocusRelativeOffset");

	Params::NicolaBattleCameraActor_SetFocusRelativeOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleCameraActor.GetFocusRelativeOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANicolaBattleCameraActor::GetFocusRelativeOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaBattleCameraActor", "GetFocusRelativeOffset");

	Params::NicolaBattleCameraActor_GetFocusRelativeOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleRoadDebugFL.AddScoutMonster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InSpecyId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAddCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::AddScoutMonster(class FName InSpecyId, int32 InAddCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "AddScoutMonster");

	Params::NicolaBattleRoadDebugFL_AddScoutMonster Parms{};

	Parms.InSpecyId = InSpecyId;
	Parms.InAddCount = InAddCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.AddScoutMonsterSpecies
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InAddCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::AddScoutMonsterSpecies(int32 InAddCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "AddScoutMonsterSpecies");

	Params::NicolaBattleRoadDebugFL_AddScoutMonsterSpecies Parms{};

	Parms.InAddCount = InAddCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.GetBattleRoadMonsterNameSpeciesIdMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class FString, class FName>        outMap                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::GetBattleRoadMonsterNameSpeciesIdMap(TMap<class FString, class FName>* outMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetBattleRoadMonsterNameSpeciesIdMap");

	Params::NicolaBattleRoadDebugFL_GetBattleRoadMonsterNameSpeciesIdMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outMap != nullptr)
		*outMap = std::move(Parms.outMap);
}


// Function Nicola.NicolaBattleRoadDebugFL.GetGopMonsterSpeciesIdList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     OutGopIdList                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::GetGopMonsterSpeciesIdList(TArray<class FName>* OutGopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetGopMonsterSpeciesIdList");

	Params::NicolaBattleRoadDebugFL_GetGopMonsterSpeciesIdList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGopIdList != nullptr)
		*OutGopIdList = std::move(Parms.OutGopIdList);
}


// Function Nicola.NicolaBattleRoadDebugFL.GetMBRClearRankIdList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     OutList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::GetMBRClearRankIdList(TArray<class FName>* OutList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetMBRClearRankIdList");

	Params::NicolaBattleRoadDebugFL_GetMBRClearRankIdList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);
}


// Function Nicola.NicolaBattleRoadDebugFL.GetMBRRankName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaBattleRoadDebugFL::GetMBRRankName(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetMBRRankName");

	Params::NicolaBattleRoadDebugFL_GetMBRRankName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleRoadDebugFL.GetMonsterName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InSpecyId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBattleMonster                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaBattleRoadDebugFL::GetMonsterName(const class FName& InSpecyId, bool bBattleMonster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetMonsterName");

	Params::NicolaBattleRoadDebugFL_GetMonsterName Parms{};

	Parms.InSpecyId = InSpecyId;
	Parms.bBattleMonster = bBattleMonster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleRoadDebugFL.GetMonsterScoutNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InSpecyId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaBattleRoadDebugFL::GetMonsterScoutNum(const class FName& InSpecyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetMonsterScoutNum");

	Params::NicolaBattleRoadDebugFL_GetMonsterScoutNum Parms{};

	Parms.InSpecyId = InSpecyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleRoadDebugFL.GetMonsterScoutNumMax
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InSpecyId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaBattleRoadDebugFL::GetMonsterScoutNumMax(const class FName& InSpecyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetMonsterScoutNumMax");

	Params::NicolaBattleRoadDebugFL_GetMonsterScoutNumMax Parms{};

	Parms.InSpecyId = InSpecyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleRoadDebugFL.GetMonsterSpecyName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InSpecyId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaBattleRoadDebugFL::GetMonsterSpecyName(const class FName& InSpecyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "GetMonsterSpecyName");

	Params::NicolaBattleRoadDebugFL_GetMonsterSpecyName Parms{};

	Parms.InSpecyId = InSpecyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaBattleRoadDebugFL.ResetScoutMonsters
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaBattleRoadDebugFL::ResetScoutMonsters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "ResetScoutMonsters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.ScoutAllMonster
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaBattleRoadDebugFL::ScoutAllMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "ScoutAllMonster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.SetMBRAllRankNotCleared
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaBattleRoadDebugFL::SetMBRAllRankNotCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "SetMBRAllRankNotCleared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.SetMBRRankCleared
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InAll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::SetMBRRankCleared(bool InAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "SetMBRRankCleared");

	Params::NicolaBattleRoadDebugFL_SetMBRRankCleared Parms{};

	Parms.InAll = InAll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.SetScoutMonsterNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InSpecyId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::SetScoutMonsterNum(class FName InSpecyId, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "SetScoutMonsterNum");

	Params::NicolaBattleRoadDebugFL_SetScoutMonsterNum Parms{};

	Parms.InSpecyId = InSpecyId;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.SubScoutMonster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InSpecyId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSubCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::SubScoutMonster(class FName InSpecyId, int32 InSubCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "SubScoutMonster");

	Params::NicolaBattleRoadDebugFL_SubScoutMonster Parms{};

	Parms.InSpecyId = InSpecyId;
	Parms.InSubCount = InSubCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaBattleRoadDebugFL.SubScoutMonsterSpecies
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InSubCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaBattleRoadDebugFL::SubScoutMonsterSpecies(int32 InSubCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaBattleRoadDebugFL", "SubScoutMonsterSpecies");

	Params::NicolaBattleRoadDebugFL_SubScoutMonsterSpecies Parms{};

	Parms.InSubCount = InSubCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.VisualizeEventObjectActor.SetVisibleActors
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             Tag                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualizeEventObjectActor::SetVisibleActors(const class FName Tag, bool IsVisible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualizeEventObjectActor", "SetVisibleActors");

	Params::VisualizeEventObjectActor_SetVisibleActors Parms{};

	Parms.Tag = Tag;
	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterBase.ChangeVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaCharacterBase::ChangeVisibility(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCharacterBase", "ChangeVisibility");

	Params::NicolaCharacterBase_ChangeVisibility Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterBase.OnBeginFieldPlayer
// (Event, Protected, BlueprintEvent)

void ANicolaCharacterBase::OnBeginFieldPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCharacterBase", "OnBeginFieldPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaCharacterBase.OnBeginTownDungeonPlayer
// (Event, Protected, BlueprintEvent)

void ANicolaCharacterBase::OnBeginTownDungeonPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCharacterBase", "OnBeginTownDungeonPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaCharacterBase.StartRotationYawBP
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         TargetRotator                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaCharacterBase::StartRotationYawBP(const struct FRotator& TargetRotator, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCharacterBase", "StartRotationYawBP");

	Params::NicolaCharacterBase_StartRotationYawBP Parms{};

	Parms.TargetRotator = std::move(TargetRotator);
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterBase.GetActionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaActionComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaActionComponent* ANicolaCharacterBase::GetActionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaCharacterBase", "GetActionComponent");

	Params::NicolaCharacterBase_GetActionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaCharacterDebugFL.DebugSpawnAndAlignCharacter
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// EUnitClassType                          ClassType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   looksNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   spaceWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   spaceDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBattle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterDebugFL::DebugSpawnAndAlignCharacter(EUnitClassType ClassType, int32 looksNo, float spaceWidth, float spaceDepth, bool bBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterDebugFL", "DebugSpawnAndAlignCharacter");

	Params::NicolaCharacterDebugFL_DebugSpawnAndAlignCharacter Parms{};

	Parms.ClassType = ClassType;
	Parms.looksNo = looksNo;
	Parms.spaceWidth = spaceWidth;
	Parms.spaceDepth = spaceDepth;
	Parms.bBattle = bBattle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaCharacterDebugFL.DebugSpawnAndAlignCoffin
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// EUnitClassType                          ClassType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   looksNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   spaceWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   spaceDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBattle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaCharacterDebugFL::DebugSpawnAndAlignCoffin(EUnitClassType ClassType, int32 looksNo, float spaceWidth, float spaceDepth, bool bBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaCharacterDebugFL", "DebugSpawnAndAlignCoffin");

	Params::NicolaCharacterDebugFL_DebugSpawnAndAlignCoffin Parms{};

	Parms.ClassType = ClassType;
	Parms.looksNo = looksNo;
	Parms.spaceWidth = spaceWidth;
	Parms.spaceDepth = spaceDepth;
	Parms.bBattle = bBattle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIBattleRetryMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIBattleRetryMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleRetryMenu", "IsExecMenu");

	Params::UIBattleRetryMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIBattleRetryMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InDummyEventId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIBattleRetryMenu::OpenMenu(class FName InDummyEventId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleRetryMenu", "OpenMenu");

	Params::UIBattleRetryMenu_OpenMenu Parms{};

	Parms.InDummyEventId = InDummyEventId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaControllInterface.OnControllerUpdate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ANicolaPlayerControllerBase*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INicolaControllInterface::OnControllerUpdate(const class ANicolaPlayerControllerBase* PlayerController, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaControllInterface", "OnControllerUpdate");

	Params::NicolaControllInterface_OnControllerUpdate Parms{};

	Parms.PlayerController = PlayerController;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIDLCMenu.DEBUG_Prepare
// (Final, Native, Static, Public, BlueprintCallable)

void UUIDLCMenu::DEBUG_Prepare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIDLCMenu", "DEBUG_Prepare");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIDLCMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIDLCMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIDLCMenu", "IsExecMenu");

	Params::UIDLCMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIDLCMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIDLCMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIDLCMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDataAssetEvent.GetDebugEnableEventFastForwardTimeRate
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDataAssetEvent::GetDebugEnableEventFastForwardTimeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDataAssetEvent", "GetDebugEnableEventFastForwardTimeRate");

	Params::NicolaDataAssetEvent_GetDebugEnableEventFastForwardTimeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDataAssetEvent.GetDebugEventFastForwardTimeRate
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDataAssetEvent::GetDebugEventFastForwardTimeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDataAssetEvent", "GetDebugEventFastForwardTimeRate");

	Params::NicolaDataAssetEvent_GetDebugEventFastForwardTimeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDataAssetEvent.SetDebugEnableEventFastForwardTimeRate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDataAssetEvent::SetDebugEnableEventFastForwardTimeRate(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDataAssetEvent", "SetDebugEnableEventFastForwardTimeRate");

	Params::NicolaDataAssetEvent_SetDebugEnableEventFastForwardTimeRate Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDataAssetEvent.SetDebugEventFastForwardTimeRate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDataAssetEvent::SetDebugEventFastForwardTimeRate(float InRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDataAssetEvent", "SetDebugEventFastForwardTimeRate");

	Params::NicolaDataAssetEvent_SetDebugEventFastForwardTimeRate Parms{};

	Parms.InRate = InRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugActionFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugActionFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugActionFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugBattleActionId
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugBattleActionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugBattleActionId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugBattleActionPattern
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugBattleActionPattern()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugBattleActionPattern");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugBattleFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugBattleFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugBattleFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugBattlePlayAction
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugBattlePlayAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugBattlePlayAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugBattleRandomAction
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugBattleRandomAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugBattleRandomAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugDrawFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugDrawFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugDrawFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugEtcFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugEtcFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugEtcFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugForcePersuade
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugForcePersuade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugForcePersuade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugLogLevels
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugLogLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugLogLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugMapTimeProgressRate
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugMapTimeProgressRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugMapTimeProgressRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugMapTimeProgressSecondsPerHour
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugMapTimeProgressSecondsPerHour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugMapTimeProgressSecondsPerHour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugMapTimeStart
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugMapTimeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugMapTimeStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugSkillFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugSkillFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugSkillFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugSkillTransformTarget
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugSkillTransformTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugSkillTransformTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugSoundFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugSoundFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugSoundFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugUnitPersonality
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugUnitPersonality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugUnitPersonality");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugVoteResult
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugVoteResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugVoteResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearDebugWorldMapFlags
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearDebugWorldMapFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearDebugWorldMapFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearElapsedTimeBattle
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearElapsedTimeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearElapsedTimeBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearElapsedTimeBattleType
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearElapsedTimeBattleType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearElapsedTimeBattleType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearEtcData
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearEtcData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearEtcData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearGameClearCount
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearGameClearCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearGameClearCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearGameTypeVersion
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearGameTypeVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearGameTypeVersion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.ClearSaveLoadErrorCode
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaDebugSetting::ClearSaveLoadErrorCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "ClearSaveLoadErrorCode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.GetBattleAttackAlwaysDeadType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetBattleAttackAlwaysDeadType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetBattleAttackAlwaysDeadType");

	Params::NicolaDebugSetting_GetBattleAttackAlwaysDeadType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetBattleAttackDamageZeroType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetBattleAttackDamageZeroType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetBattleAttackDamageZeroType");

	Params::NicolaDebugSetting_GetBattleAttackDamageZeroType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetBattleDropItemRarity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetBattleDropItemRarity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetBattleDropItemRarity");

	Params::NicolaDebugSetting_GetBattleDropItemRarity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetBgmVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetBgmVolumeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetBgmVolumeRate");

	Params::NicolaDebugSetting_GetBgmVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetCameraSpeedRateH
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetCameraSpeedRateH()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetCameraSpeedRateH");

	Params::NicolaDebugSetting_GetCameraSpeedRateH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetCameraSpeedRateV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetCameraSpeedRateV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetCameraSpeedRateV");

	Params::NicolaDebugSetting_GetCameraSpeedRateV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetCursorBaseRotateByStickAxisDotMin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetCursorBaseRotateByStickAxisDotMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetCursorBaseRotateByStickAxisDotMin");

	Params::NicolaDebugSetting_GetCursorBaseRotateByStickAxisDotMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetCursorBaseRotateByStickAxisSizeMin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetCursorBaseRotateByStickAxisSizeMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetCursorBaseRotateByStickAxisSizeMin");

	Params::NicolaDebugSetting_GetCursorBaseRotateByStickAxisSizeMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugBattleActionId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaDebugSetting::GetDebugBattleActionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugBattleActionId");

	Params::NicolaDebugSetting_GetDebugBattleActionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugBattleActionPattern
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetDebugBattleActionPattern()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugBattleActionPattern");

	Params::NicolaDebugSetting_GetDebugBattleActionPattern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugBattlePlayAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaDebugSetting::GetDebugBattlePlayAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugBattlePlayAction");

	Params::NicolaDebugSetting_GetDebugBattlePlayAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugBattleRandomAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetDebugBattleRandomAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugBattleRandomAction");

	Params::NicolaDebugSetting_GetDebugBattleRandomAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugForcePersuade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDebugForcePersuade                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDebugForcePersuade UNicolaDebugSetting::GetDebugForcePersuade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugForcePersuade");

	Params::NicolaDebugSetting_GetDebugForcePersuade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugLogLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             logCategory                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UNicolaDebugSetting::GetDebugLogLevel(class FName logCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugLogLevel");

	Params::NicolaDebugSetting_GetDebugLogLevel Parms{};

	Parms.logCategory = logCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugMapTimeProgressRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetDebugMapTimeProgressRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugMapTimeProgressRate");

	Params::NicolaDebugSetting_GetDebugMapTimeProgressRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugMapTimeProgressSecondsPerHour
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetDebugMapTimeProgressSecondsPerHour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugMapTimeProgressSecondsPerHour");

	Params::NicolaDebugSetting_GetDebugMapTimeProgressSecondsPerHour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugMapTimeStart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetDebugMapTimeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugMapTimeStart");

	Params::NicolaDebugSetting_GetDebugMapTimeStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugSkillTransformTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetDebugSkillTransformTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugSkillTransformTarget");

	Params::NicolaDebugSetting_GetDebugSkillTransformTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugUnitPersonality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaDebugSetting::GetDebugUnitPersonality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugUnitPersonality");

	Params::NicolaDebugSetting_GetDebugUnitPersonality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetDebugVoteResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDebugVoteResult                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDebugVoteResult UNicolaDebugSetting::GetDebugVoteResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetDebugVoteResult");

	Params::NicolaDebugSetting_GetDebugVoteResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetElapsedTimeBattle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetElapsedTimeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetElapsedTimeBattle");

	Params::NicolaDebugSetting_GetElapsedTimeBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetElapsedTimeBattleType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetElapsedTimeBattleType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetElapsedTimeBattleType");

	Params::NicolaDebugSetting_GetElapsedTimeBattleType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetEnableCursorBaseRotateByStickCheck
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::GetEnableCursorBaseRotateByStickCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetEnableCursorBaseRotateByStickCheck");

	Params::NicolaDebugSetting_GetEnableCursorBaseRotateByStickCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetEnableForceFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::GetEnableForceFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetEnableForceFeedback");

	Params::NicolaDebugSetting_GetEnableForceFeedback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetGameClearCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetGameClearCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetGameClearCount");

	Params::NicolaDebugSetting_GetGameClearCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetGameTypeVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetGameTypeVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetGameTypeVersion");

	Params::NicolaDebugSetting_GetGameTypeVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetPostProcessGainRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetPostProcessGainRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetPostProcessGainRate");

	Params::NicolaDebugSetting_GetPostProcessGainRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetQuickCameraRotation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::GetQuickCameraRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetQuickCameraRotation");

	Params::NicolaDebugSetting_GetQuickCameraRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetReverseCameraH
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::GetReverseCameraH()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetReverseCameraH");

	Params::NicolaDebugSetting_GetReverseCameraH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetReverseCameraV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::GetReverseCameraV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetReverseCameraV");

	Params::NicolaDebugSetting_GetReverseCameraV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetSaveLoadErrorCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaDebugSetting::GetSaveLoadErrorCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetSaveLoadErrorCode");

	Params::NicolaDebugSetting_GetSaveLoadErrorCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetSeVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetSeVolumeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetSeVolumeRate");

	Params::NicolaDebugSetting_GetSeVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.GetVoiceVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaDebugSetting::GetVoiceVolumeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "GetVoiceVolumeRate");

	Params::NicolaDebugSetting_GetVoiceVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugActionFlagOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugActionFlags                       flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugActionFlagOn(EDebugActionFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugActionFlagOn");

	Params::NicolaDebugSetting_IsDebugActionFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugBattleFlagOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugBattleFlags                       flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugBattleFlagOn(EDebugBattleFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugBattleFlagOn");

	Params::NicolaDebugSetting_IsDebugBattleFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugDrawFlagOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugDrawFlags                         flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugDrawFlagOn(EDebugDrawFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugDrawFlagOn");

	Params::NicolaDebugSetting_IsDebugDrawFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugEtcFlagOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugEtcFlags                          flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugEtcFlagOn(EDebugEtcFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugEtcFlagOn");

	Params::NicolaDebugSetting_IsDebugEtcFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugSkillFlagOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugSkillFlags                        flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugSkillFlagOn(EDebugSkillFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugSkillFlagOn");

	Params::NicolaDebugSetting_IsDebugSkillFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugSoundFlagOn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDebugSoundFlags                        flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugSoundFlagOn(EDebugSoundFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugSoundFlagOn");

	Params::NicolaDebugSetting_IsDebugSoundFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.IsDebugWorldMapFlagOn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDebugWorldMapFlags                     flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaDebugSetting::IsDebugWorldMapFlagOn(EDebugWorldMapFlags flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "IsDebugWorldMapFlagOn");

	Params::NicolaDebugSetting_IsDebugWorldMapFlagOn Parms{};

	Parms.flag = flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.Reset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNicolaDebugSetting*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaDebugSetting* UNicolaDebugSetting::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "Reset");

	Params::NicolaDebugSetting_Reset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaDebugSetting.SetBattleAttackAlwaysDeadType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetBattleAttackAlwaysDeadType(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetBattleAttackAlwaysDeadType");

	Params::NicolaDebugSetting_SetBattleAttackAlwaysDeadType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetBattleAttackDamageZeroType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetBattleAttackDamageZeroType(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetBattleAttackDamageZeroType");

	Params::NicolaDebugSetting_SetBattleAttackDamageZeroType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetBattleDropItemRarity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   rarity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetBattleDropItemRarity(int32 rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetBattleDropItemRarity");

	Params::NicolaDebugSetting_SetBattleDropItemRarity Parms{};

	Parms.rarity = rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetBgmVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetBgmVolumeRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetBgmVolumeRate");

	Params::NicolaDebugSetting_SetBgmVolumeRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetCameraSpeedRateH
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetCameraSpeedRateH(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetCameraSpeedRateH");

	Params::NicolaDebugSetting_SetCameraSpeedRateH Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetCameraSpeedRateV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetCameraSpeedRateV(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetCameraSpeedRateV");

	Params::NicolaDebugSetting_SetCameraSpeedRateV Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetCursorBaseRotateByStickAxisDotMin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetCursorBaseRotateByStickAxisDotMin(const class UObject* WorldContextObject, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetCursorBaseRotateByStickAxisDotMin");

	Params::NicolaDebugSetting_SetCursorBaseRotateByStickAxisDotMin Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetCursorBaseRotateByStickAxisSizeMin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetCursorBaseRotateByStickAxisSizeMin(const class UObject* WorldContextObject, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetCursorBaseRotateByStickAxisSizeMin");

	Params::NicolaDebugSetting_SetCursorBaseRotateByStickAxisSizeMin Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugActionFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugActionFlags                       flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugActionFlag(EDebugActionFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugActionFlag");

	Params::NicolaDebugSetting_SetDebugActionFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugBattleActionId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             actionId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugBattleActionId(const class FName& actionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugBattleActionId");

	Params::NicolaDebugSetting_SetDebugBattleActionId Parms{};

	Parms.actionId = actionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugBattleActionPattern
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   pattern                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugBattleActionPattern(int32 pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugBattleActionPattern");

	Params::NicolaDebugSetting_SetDebugBattleActionPattern Parms{};

	Parms.pattern = pattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugBattleFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugBattleFlags                       flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugBattleFlag(EDebugBattleFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugBattleFlag");

	Params::NicolaDebugSetting_SetDebugBattleFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugBattlePlayAction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             actionId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugBattlePlayAction(const class FName& actionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugBattlePlayAction");

	Params::NicolaDebugSetting_SetDebugBattlePlayAction Parms{};

	Parms.actionId = actionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugBattleRandomAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugBattleRandomAction(int32 action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugBattleRandomAction");

	Params::NicolaDebugSetting_SetDebugBattleRandomAction Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugDrawFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugDrawFlags                         flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugDrawFlag(EDebugDrawFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugDrawFlag");

	Params::NicolaDebugSetting_SetDebugDrawFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugEtcFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugEtcFlags                          flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugEtcFlag(EDebugEtcFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugEtcFlag");

	Params::NicolaDebugSetting_SetDebugEtcFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugForcePersuade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugForcePersuade                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugForcePersuade(EDebugForcePersuade Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugForcePersuade");

	Params::NicolaDebugSetting_SetDebugForcePersuade Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugLogLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             logCategory                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   logVerbosity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugLogLevel(class FName logCategory, uint8 logVerbosity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugLogLevel");

	Params::NicolaDebugSetting_SetDebugLogLevel Parms{};

	Parms.logCategory = logCategory;
	Parms.logVerbosity = logVerbosity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugMapTimeProgressRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugMapTimeProgressRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugMapTimeProgressRate");

	Params::NicolaDebugSetting_SetDebugMapTimeProgressRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugMapTimeProgressSecondsPerHour
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   secondsPerHour                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugMapTimeProgressSecondsPerHour(float secondsPerHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugMapTimeProgressSecondsPerHour");

	Params::NicolaDebugSetting_SetDebugMapTimeProgressSecondsPerHour Parms{};

	Parms.secondsPerHour = secondsPerHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugMapTimeStart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   MapTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugMapTimeStart(float MapTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugMapTimeStart");

	Params::NicolaDebugSetting_SetDebugMapTimeStart Parms{};

	Parms.MapTime = MapTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugSkillFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugSkillFlags                        flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugSkillFlag(EDebugSkillFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugSkillFlag");

	Params::NicolaDebugSetting_SetDebugSkillFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugSkillTransformTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TARGET                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugSkillTransformTarget(int32 TARGET)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugSkillTransformTarget");

	Params::NicolaDebugSetting_SetDebugSkillTransformTarget Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugSoundFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugSoundFlags                        flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugSoundFlag(EDebugSoundFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugSoundFlag");

	Params::NicolaDebugSetting_SetDebugSoundFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugUnitPersonality
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TARGET                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugUnitPersonality(const class FName& TARGET)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugUnitPersonality");

	Params::NicolaDebugSetting_SetDebugUnitPersonality Parms{};

	Parms.TARGET = TARGET;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugVoteResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugVoteResult                        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugVoteResult(EDebugVoteResult Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugVoteResult");

	Params::NicolaDebugSetting_SetDebugVoteResult Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetDebugWorldMapFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDebugWorldMapFlags                     flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetDebugWorldMapFlag(EDebugWorldMapFlags flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetDebugWorldMapFlag");

	Params::NicolaDebugSetting_SetDebugWorldMapFlag Parms{};

	Parms.flag = flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetElapsedTimeBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   elapsedTimeBattle_0                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetElapsedTimeBattle(float elapsedTimeBattle_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetElapsedTimeBattle");

	Params::NicolaDebugSetting_SetElapsedTimeBattle Parms{};

	Parms.elapsedTimeBattle_0 = elapsedTimeBattle_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetElapsedTimeBattleType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   elapsedTimeBattleType_0                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetElapsedTimeBattleType(int32 elapsedTimeBattleType_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetElapsedTimeBattleType");

	Params::NicolaDebugSetting_SetElapsedTimeBattleType Parms{};

	Parms.elapsedTimeBattleType_0 = elapsedTimeBattleType_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetEnableCursorBaseRotateByStickCheck
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetEnableCursorBaseRotateByStickCheck(const class UObject* WorldContextObject, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetEnableCursorBaseRotateByStickCheck");

	Params::NicolaDebugSetting_SetEnableCursorBaseRotateByStickCheck Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetEnableForceFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetEnableForceFeedback(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetEnableForceFeedback");

	Params::NicolaDebugSetting_SetEnableForceFeedback Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetGameClearCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   gameClearCount_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetGameClearCount(int32 gameClearCount_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetGameClearCount");

	Params::NicolaDebugSetting_SetGameClearCount Parms{};

	Parms.gameClearCount_0 = gameClearCount_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetGameTypeVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   GameTypeVersion_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetGameTypeVersion(int32 GameTypeVersion_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetGameTypeVersion");

	Params::NicolaDebugSetting_SetGameTypeVersion Parms{};

	Parms.GameTypeVersion_0 = GameTypeVersion_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetPostProcessGainRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetPostProcessGainRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetPostProcessGainRate");

	Params::NicolaDebugSetting_SetPostProcessGainRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetPostProcessGammaRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetPostProcessGammaRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetPostProcessGammaRate");

	Params::NicolaDebugSetting_SetPostProcessGammaRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetQuickCameraRotation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetQuickCameraRotation(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetQuickCameraRotation");

	Params::NicolaDebugSetting_SetQuickCameraRotation Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetReverseCameraH
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Reverse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetReverseCameraH(bool Reverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetReverseCameraH");

	Params::NicolaDebugSetting_SetReverseCameraH Parms{};

	Parms.Reverse = Reverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetReverseCameraV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Reverse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetReverseCameraV(bool Reverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetReverseCameraV");

	Params::NicolaDebugSetting_SetReverseCameraV Parms{};

	Parms.Reverse = Reverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetSaveLoadErrorCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   saveLoadErrorCode_0                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetSaveLoadErrorCode(int32 saveLoadErrorCode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetSaveLoadErrorCode");

	Params::NicolaDebugSetting_SetSaveLoadErrorCode Parms{};

	Parms.saveLoadErrorCode_0 = saveLoadErrorCode_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetSeVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetSeVolumeRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetSeVolumeRate");

	Params::NicolaDebugSetting_SetSeVolumeRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaDebugSetting.SetVoiceVolumeRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaDebugSetting::SetVoiceVolumeRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaDebugSetting", "SetVoiceVolumeRate");

	Params::NicolaDebugSetting_SetVoiceVolumeRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.GetNpcRotatorForDirectionType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// ENpcDirectionType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANpcAIController::GetNpcRotatorForDirectionType(ENpcDirectionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAIController", "GetNpcRotatorForDirectionType");

	Params::NpcAIController_GetNpcRotatorForDirectionType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.ChangeMovePattern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENpcMovePattern                         NextState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   nextSpeedIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   nextWaitIdx                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::ChangeMovePattern(ENpcMovePattern NextState, int32 nextSpeedIdx, int32 nextWaitIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "ChangeMovePattern");

	Params::NpcAIController_ChangeMovePattern Parms{};

	Parms.NextState = NextState;
	Parms.nextSpeedIdx = nextSpeedIdx;
	Parms.nextWaitIdx = nextWaitIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InitializeScriptOnly
// (Final, Native, Public, BlueprintCallable)

void ANpcAIController::InitializeScriptOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InitializeScriptOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptAnimationBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimationType                          AnimType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLoop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAutoIdle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptAnimationBP(EAnimationType AnimType, bool IsLoop, bool IsAutoIdle, float AnimRate, bool IsOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptAnimationBP");

	Params::NpcAIController_InterruptScriptAnimationBP Parms{};

	Parms.AnimType = AnimType;
	Parms.IsLoop = IsLoop;
	Parms.IsAutoIdle = IsAutoIdle;
	Parms.AnimRate = AnimRate;
	Parms.IsOverride = IsOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptCommandAllAbort
// (Final, Native, Public, BlueprintCallable)

void ANpcAIController::InterruptScriptCommandAllAbort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptCommandAllAbort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptEnd
// (Final, Native, Public, BlueprintCallable)

void ANpcAIController::InterruptScriptEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InJumpHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InJumpSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InNoWaitJump                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptJump(float InJumpHeight, float InJumpSeconds, bool InNoWaitJump)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptJump");

	Params::NpcAIController_InterruptScriptJump Parms{};

	Parms.InJumpHeight = InJumpHeight;
	Parms.InJumpSeconds = InJumpSeconds;
	Parms.InNoWaitJump = InNoWaitJump;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptMove
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          targetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRelative                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENpcDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimationType                          AnimType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptMove(const struct FVector& targetLocation, float MoveSpeed, bool IsRelative, ENpcDirectionType DirectionType, EAnimationType AnimType, float AnimRate, int32 PlayType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptMove");

	Params::NpcAIController_InterruptScriptMove Parms{};

	Parms.targetLocation = std::move(targetLocation);
	Parms.MoveSpeed = MoveSpeed;
	Parms.IsRelative = IsRelative;
	Parms.DirectionType = DirectionType;
	Parms.AnimType = AnimType;
	Parms.AnimRate = AnimRate;
	Parms.PlayType = PlayType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptMovePhysicsJump
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMoveSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InJumpZVelocity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimationType                          InAnimationType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptMovePhysicsJump(const struct FVector& InLocation, float InMoveSpeed, float InJumpZVelocity, EAnimationType InAnimationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptMovePhysicsJump");

	Params::NpcAIController_InterruptScriptMovePhysicsJump Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InMoveSpeed = InMoveSpeed;
	Parms.InJumpZVelocity = InJumpZVelocity;
	Parms.InAnimationType = InAnimationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptMoveUpOrDownInterpolate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMoveUp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EaseFunc                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EaseExp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptMoveUpOrDownInterpolate(float Height, bool IsMoveUp, float Seconds, EEasingFunc EaseFunc, float EaseExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptMoveUpOrDownInterpolate");

	Params::NpcAIController_InterruptScriptMoveUpOrDownInterpolate Parms{};

	Parms.Height = Height;
	Parms.IsMoveUp = IsMoveUp;
	Parms.Seconds = Seconds;
	Parms.EaseFunc = EaseFunc;
	Parms.EaseExp = EaseExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptStart
// (Final, Native, Public, BlueprintCallable)

void ANpcAIController::InterruptScriptStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENpcDirectionType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptTurn(ENpcDirectionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptTurn");

	Params::NpcAIController_InterruptScriptTurn Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptTurnFromRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    InIsRelative                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptTurnFromRotation(const struct FRotator& Rotation, bool InIsRelative)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptTurnFromRotation");

	Params::NpcAIController_InterruptScriptTurnFromRotation Parms{};

	Parms.Rotation = std::move(Rotation);
	Parms.InIsRelative = InIsRelative;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.InterruptScriptWait
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWaitTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::InterruptScriptWait(float InWaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "InterruptScriptWait");

	Params::NpcAIController_InterruptScriptWait Parms{};

	Parms.InWaitTime = InWaitTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.OnCharacterMovementUpdated
// (Final, Native, Private, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcAIController::OnCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "OnCharacterMovementUpdated");

	Params::NpcAIController_OnCharacterMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANpcAIController::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "OnComponentHit");

	Params::NpcAIController_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.ResetOverrideAnimation
// (Final, Native, Public, BlueprintCallable)

void ANpcAIController::ResetOverrideAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "ResetOverrideAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcAIController.IsMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsMoveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsMoveState");

	Params::NpcAIController_IsMoveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsScriptAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsScriptAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsScriptAnimation");

	Params::NpcAIController_IsScriptAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsScriptControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsScriptControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsScriptControl");

	Params::NpcAIController_IsScriptControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsScriptJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsScriptJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsScriptJump");

	Params::NpcAIController_IsScriptJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsScriptMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsScriptMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsScriptMove");

	Params::NpcAIController_IsScriptMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsScriptMovePhysicsJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsScriptMovePhysicsJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsScriptMovePhysicsJump");

	Params::NpcAIController_IsScriptMovePhysicsJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsScriptTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsScriptTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsScriptTurn");

	Params::NpcAIController_IsScriptTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsTurnState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsTurnState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsTurnState");

	Params::NpcAIController_IsTurnState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsWaitCommand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsWaitCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsWaitCommand");

	Params::NpcAIController_IsWaitCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NpcAIController.IsWaitMoveUpOrDownInterpolate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANpcAIController::IsWaitMoveUpOrDownInterpolate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAIController", "IsWaitMoveUpOrDownInterpolate");

	Params::NpcAIController_IsWaitMoveUpOrDownInterpolate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.RockPuzzleGimmickActor.OnMoveRockOneSquare
// (Final, Native, Private)
// Parameters:
// class ARockGimmick*                     RockGimmick                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARockPuzzleGimmickActor::OnMoveRockOneSquare(class ARockGimmick* RockGimmick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RockPuzzleGimmickActor", "OnMoveRockOneSquare");

	Params::RockPuzzleGimmickActor_OnMoveRockOneSquare Parms{};

	Parms.RockGimmick = RockGimmick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEffectManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNicolaEffectManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaEffectManager* UNicolaEffectManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEffectManager", "GetInstance");

	Params::NicolaEffectManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEncountCalcActor.CalcEncountSec
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   min_time                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   max_time                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   offset_time                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaEncountCalcActor::CalcEncountSec(float min_time, float max_time, float offset_time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaEncountCalcActor", "CalcEncountSec");

	Params::NicolaEncountCalcActor_CalcEncountSec Parms{};

	Parms.min_time = min_time;
	Parms.max_time = max_time;
	Parms.offset_time = offset_time;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEndingManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNicolaEndingManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaEndingManager* UNicolaEndingManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEndingManager", "GetInstance");

	Params::NicolaEndingManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEndingManager.Begin
// (Final, Native, Public, BlueprintCallable)

void UNicolaEndingManager::Begin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaEndingManager", "Begin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEndingManager.StartDebugEndingEvent
// (Final, Native, Public, BlueprintCallable)

void UNicolaEndingManager::StartDebugEndingEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaEndingManager", "StartDebugEndingEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEndingManager.StartDebugEndingSave
// (Final, Native, Public, BlueprintCallable)

void UNicolaEndingManager::StartDebugEndingSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaEndingManager", "StartDebugEndingSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEndingManager.StartDebugEndingStaffroll
// (Final, Native, Public, BlueprintCallable)

void UNicolaEndingManager::StartDebugEndingStaffroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaEndingManager", "StartDebugEndingStaffroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ResearchSequenceCamera.DebugPlaySequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AResearchSequenceCamera::DebugPlaySequence(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResearchSequenceCamera", "DebugPlaySequence");

	Params::ResearchSequenceCamera_DebugPlaySequence Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ResearchSequenceCamera.OnPlaySequenceAfterFirstFrame
// (Final, Native, Protected)

void AResearchSequenceCamera::OnPlaySequenceAfterFirstFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResearchSequenceCamera", "OnPlaySequenceAfterFirstFrame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ResearchSequenceCamera.PlaySequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsInvisibleNpc                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bJumpToEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AResearchSequenceCamera::PlaySequence(int32 Index_0, bool bIsInvisibleNpc, bool bJumpToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResearchSequenceCamera", "PlaySequence");

	Params::ResearchSequenceCamera_PlaySequence Parms{};

	Parms.Index_0 = Index_0;
	Parms.bIsInvisibleNpc = bIsInvisibleNpc;
	Parms.bJumpToEnd = bJumpToEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWindowItemMovie.OnLoadedMovie
// (Final, Native, Protected)

void UUIWindowItemMovie::OnLoadedMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWindowItemMovie", "OnLoadedMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWindowItemMovieImage.OnLoadedImage
// (Final, Native, Protected)

void UUIWindowItemMovieImage::OnLoadedImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWindowItemMovieImage", "OnLoadedImage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.ApplyEventDebug
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventDebugId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       DebugTable                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ChangeMap                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::ApplyEventDebug(const class FName& EventDebugId, const class UDataTable* DebugTable, bool ChangeMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ApplyEventDebug");

	Params::NicolaEventFL_ApplyEventDebug Parms{};

	Parms.EventDebugId = EventDebugId;
	Parms.DebugTable = DebugTable;
	Parms.ChangeMap = ChangeMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.CheckEnableEchoFlute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::CheckEnableEchoFlute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "CheckEnableEchoFlute");

	Params::NicolaEventFL_CheckEnableEchoFlute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.CheckEnableRemirama
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::CheckEnableRemirama()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "CheckEnableRemirama");

	Params::NicolaEventFL_CheckEnableRemirama Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.CloseEventScreenShot
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::CloseEventScreenShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "CloseEventScreenShot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.DebugPlayEventScript
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EEventTriggerType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TriggerID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EventID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::DebugPlayEventScript(const EEventTriggerType Type, const class FName& TriggerID, const class FString& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "DebugPlayEventScript");

	Params::NicolaEventFL_DebugPlayEventScript Parms{};

	Parms.Type = Type;
	Parms.TriggerID = TriggerID;
	Parms.EventID = std::move(EventID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.DispelCurseGoldenClaws
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsPyramidUnderGround                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::DispelCurseGoldenClaws(bool IsPyramidUnderGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "DispelCurseGoldenClaws");

	Params::NicolaEventFL_DispelCurseGoldenClaws Parms{};

	Parms.IsPyramidUnderGround = IsPyramidUnderGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.ExistEventForTriggerType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEventTriggerType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::ExistEventForTriggerType(const EEventTriggerType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ExistEventForTriggerType");

	Params::NicolaEventFL_ExistEventForTriggerType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.GetEventDebugDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventDebugId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       DebugTable                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaEventFL::GetEventDebugDescription(const class FName& EventDebugId, const class UDataTable* DebugTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetEventDebugDescription");

	Params::NicolaEventFL_GetEventDebugDescription Parms{};

	Parms.EventDebugId = EventDebugId;
	Parms.DebugTable = DebugTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.GetEventIdList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EEventTriggerType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TriggerID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UNicolaEventFL::GetEventIdList(const EEventTriggerType Type, const class FName TriggerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetEventIdList");

	Params::NicolaEventFL_GetEventIdList Parms{};

	Parms.Type = Type;
	Parms.TriggerID = TriggerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.GetFlagIndexStartEnd
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EEventFlagType                          FlagType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Start                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   End                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::GetFlagIndexStartEnd(EEventFlagType FlagType, int32* Start, int32* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetFlagIndexStartEnd");

	Params::NicolaEventFL_GetFlagIndexStartEnd Parms{};

	Parms.FlagType = FlagType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Start != nullptr)
		*Start = Parms.Start;

	if (End != nullptr)
		*End = Parms.End;
}


// Function Nicola.NicolaEventFL.GetNumOfSearchObjContainItems
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IsCheckOnlyScreen                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaEventFL::GetNumOfSearchObjContainItems(bool IsCheckOnlyScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetNumOfSearchObjContainItems");

	Params::NicolaEventFL_GetNumOfSearchObjContainItems Parms{};

	Parms.IsCheckOnlyScreen = IsCheckOnlyScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.GetSaveFlagStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNicolaEventFL::GetSaveFlagStr(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetSaveFlagStr");

	Params::NicolaEventFL_GetSaveFlagStr Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.GetTriggerIdList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EEventTriggerType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNicolaEventFL::GetTriggerIdList(const EEventTriggerType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetTriggerIdList");

	Params::NicolaEventFL_GetTriggerIdList Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.GetUIManpuIDList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNicolaEventFL::GetUIManpuIDList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "GetUIManpuIDList");

	Params::NicolaEventFL_GetUIManpuIDList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.IsPlayEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::IsPlayEventScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "IsPlayEventScript");

	Params::NicolaEventFL_IsPlayEventScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.JudgeInpasuType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EInpasuType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInpasuType UNicolaEventFL::JudgeInpasuType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "JudgeInpasuType");

	Params::NicolaEventFL_JudgeInpasuType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.MakeEventConditionInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InEventId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InProgLower                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InProgUpper                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InFlagName1                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsTrueCondition1                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InFlagName2                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsTrueCondition2                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAndOperator                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InGopId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventConditionInfo              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventConditionInfo UNicolaEventFL::MakeEventConditionInfo(const class FString& InEventId, int32 InPriority, int32 InProgLower, int32 InProgUpper, class FName InFlagName1, bool InIsTrueCondition1, class FName InFlagName2, bool InIsTrueCondition2, bool IsAndOperator, class FName InGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "MakeEventConditionInfo");

	Params::NicolaEventFL_MakeEventConditionInfo Parms{};

	Parms.InEventId = std::move(InEventId);
	Parms.InPriority = InPriority;
	Parms.InProgLower = InProgLower;
	Parms.InProgUpper = InProgUpper;
	Parms.InFlagName1 = InFlagName1;
	Parms.InIsTrueCondition1 = InIsTrueCondition1;
	Parms.InFlagName2 = InFlagName2;
	Parms.InIsTrueCondition2 = InIsTrueCondition2;
	Parms.IsAndOperator = IsAndOperator;
	Parms.InGopId = InGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.MakeEventConditionInfoForGOPEventCommon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGOP_Event_CommonTable           EventTable                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventConditionInfo              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventConditionInfo UNicolaEventFL::MakeEventConditionInfoForGOPEventCommon(const struct FGOP_Event_CommonTable& EventTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "MakeEventConditionInfoForGOPEventCommon");

	Params::NicolaEventFL_MakeEventConditionInfoForGOPEventCommon Parms{};

	Parms.EventTable = std::move(EventTable);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.MakeScriptCommandTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           EventID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TriggerID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcTypeId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLookAtPlayerToTarget                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CollisionTag                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UNicolaEventFL::MakeScriptCommandTag(const class FString& EventID, const class FName& TriggerID, const class FName& GopId, const class FName& NpcTypeId, const bool IsLookAtPlayerToTarget, const class FName& CollisionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "MakeScriptCommandTag");

	Params::NicolaEventFL_MakeScriptCommandTag Parms{};

	Parms.EventID = std::move(EventID);
	Parms.TriggerID = TriggerID;
	Parms.GopId = GopId;
	Parms.NpcTypeId = NpcTypeId;
	Parms.IsLookAtPlayerToTarget = IsLookAtPlayerToTarget;
	Parms.CollisionTag = CollisionTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.PlayEffectEchoFlute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EffectId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayEffectTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::PlayEffectEchoFlute(const class FName& EffectId, float PlayEffectTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "PlayEffectEchoFlute");

	Params::NicolaEventFL_PlayEffectEchoFlute Parms{};

	Parms.EffectId = EffectId;
	Parms.PlayEffectTime = PlayEffectTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.PlayEffectInpasu
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::PlayEffectInpasu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "PlayEffectInpasu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.PlayEffectRemirama
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EffectId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayEffectTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::PlayEffectRemirama(const class FName& EffectId, float PlayEffectTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "PlayEffectRemirama");

	Params::NicolaEventFL_PlayEffectRemirama Parms{};

	Parms.EffectId = EffectId;
	Parms.PlayEffectTime = PlayEffectTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.PlayEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EEventTriggerType                       TriggerType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TriggerID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::PlayEventScript(const EEventTriggerType TriggerType, const class FName TriggerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "PlayEventScript");

	Params::NicolaEventFL_PlayEventScript Parms{};

	Parms.TriggerType = TriggerType;
	Parms.TriggerID = TriggerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.PlayEventScriptCommand
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           EventScriptId                                          (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     Tags                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     Args                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaEventFL::PlayEventScriptCommand(const class FString& EventScriptId, const TArray<class FName>& Tags, const TArray<class FName>& Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "PlayEventScriptCommand");

	Params::NicolaEventFL_PlayEventScriptCommand Parms{};

	Parms.EventScriptId = std::move(EventScriptId);
	Parms.Tags = std::move(Tags);
	Parms.Args = std::move(Args);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaEventFL.ReloadEventData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           ScriptPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       EventTable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       TalkTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       SearchTable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::ReloadEventData(const class FString& ScriptPath, const class FName& MapName, class UDataTable* EventTable, class UDataTable* TalkTable, class UDataTable* SearchTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ReloadEventData");

	Params::NicolaEventFL_ReloadEventData Parms{};

	Parms.ScriptPath = std::move(ScriptPath);
	Parms.MapName = MapName;
	Parms.EventTable = EventTable;
	Parms.TalkTable = TalkTable;
	Parms.SearchTable = SearchTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.RequestEventScreenShotTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InScreenShotGopId                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::RequestEventScreenShotTexture(const class FName& InScreenShotGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "RequestEventScreenShotTexture");

	Params::NicolaEventFL_RequestEventScreenShotTexture Parms{};

	Parms.InScreenShotGopId = InScreenShotGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.ResetEffectAndFlagsCurseGoldenClaws
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::ResetEffectAndFlagsCurseGoldenClaws()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ResetEffectAndFlagsCurseGoldenClaws");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.ResetFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EEventFlagType                          FlagType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::ResetFlag(EEventFlagType FlagType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ResetFlag");

	Params::NicolaEventFL_ResetFlag Parms{};

	Parms.FlagType = FlagType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.ResetTempSaveFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsResetDungeon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResetSuspend                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::ResetTempSaveFlag(bool IsResetDungeon, bool IsResetSuspend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ResetTempSaveFlag");

	Params::NicolaEventFL_ResetTempSaveFlag Parms{};

	Parms.IsResetDungeon = IsResetDungeon;
	Parms.IsResetSuspend = IsResetSuspend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.RetryRockPuzzleGimmick
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::RetryRockPuzzleGimmick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "RetryRockPuzzleGimmick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.SaveTemporaryEventDataInfo
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::SaveTemporaryEventDataInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "SaveTemporaryEventDataInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.ShowEventScreenShot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InScreenShotGopId                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaEventFL::ShowEventScreenShot(const class FName& InScreenShotGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "ShowEventScreenShot");

	Params::NicolaEventFL_ShowEventScreenShot Parms{};

	Parms.InScreenShotGopId = InScreenShotGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.StartEventScreenShotUI
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::StartEventScreenShotUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "StartEventScreenShotUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaEventFL.StopEffectInpasu
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaEventFL::StopEffectInpasu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaEventFL", "StopEffectInpasu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaFadingTriggerBase.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANicolaFadingTriggerBase::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaFadingTriggerBase", "OnOverlapBegin");

	Params::NicolaFadingTriggerBase_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaFadingTriggerBase.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaFadingTriggerBase::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaFadingTriggerBase", "OnOverlapEnd");

	Params::NicolaFadingTriggerBase_OnOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SearchObjectItem.MoveToPlayer
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchObjectItem::MoveToPlayer(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchObjectItem", "MoveToPlayer");

	Params::SearchObjectItem_MoveToPlayer Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SearchObjectItem.PlayItemGet
// (Event, Protected, BlueprintEvent)
// Parameters:
// EItemGetType                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchObjectItem::PlayItemGet(EItemGetType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchObjectItem", "PlayItemGet");

	Params::SearchObjectItem_PlayItemGet Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.SearchObjectItem.PlaySearchObjectGet
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESearchObjectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchObjectItem::PlaySearchObjectGet(ESearchObjectType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchObjectItem", "PlaySearchObjectGet");

	Params::SearchObjectItem_PlaySearchObjectGet Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.SearchObjectItem.SetLocationOffset
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchObjectItem::SetLocationOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchObjectItem", "SetLocationOffset");

	Params::SearchObjectItem_SetLocationOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SearchObjectItem.SetVisibilityItem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchObjectItem::SetVisibilityItem(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SearchObjectItem", "SetVisibilityItem");

	Params::SearchObjectItem_SetVisibilityItem Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ShineSearchEvent.OnStartShineSearchEventEffect
// (Event, Protected, BlueprintEvent)

void AShineSearchEvent::OnStartShineSearchEventEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShineSearchEvent", "OnStartShineSearchEventEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaFieldLevel.OnVisibleLevel
// (Event, Public, BlueprintEvent)

void ANicolaFieldLevel::OnVisibleLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaFieldLevel", "OnVisibleLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaResearchPlayerCameraManagerBase.RequestCameraFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaResearchPlayerCameraManagerBase::RequestCameraFadeIn(float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchPlayerCameraManagerBase", "RequestCameraFadeIn");

	Params::NicolaResearchPlayerCameraManagerBase_RequestCameraFadeIn Parms{};

	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchPlayerCameraManagerBase.RequestCameraFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   targetAlpha                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaResearchPlayerCameraManagerBase::RequestCameraFadeOut(float targetAlpha, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchPlayerCameraManagerBase", "RequestCameraFadeOut");

	Params::NicolaResearchPlayerCameraManagerBase_RequestCameraFadeOut Parms{};

	Parms.targetAlpha = targetAlpha;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchPlayerCameraManagerBase.RequestHideBattleCameraEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AssetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaResearchPlayerCameraManagerBase::RequestHideBattleCameraEffect(class FName AssetName, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchPlayerCameraManagerBase", "RequestHideBattleCameraEffect");

	Params::NicolaResearchPlayerCameraManagerBase_RequestHideBattleCameraEffect Parms{};

	Parms.AssetName = AssetName;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchPlayerCameraManagerBase.RequestHideCameraEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AssetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaResearchPlayerCameraManagerBase::RequestHideCameraEffect(class FName AssetName, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchPlayerCameraManagerBase", "RequestHideCameraEffect");

	Params::NicolaResearchPlayerCameraManagerBase_RequestHideCameraEffect Parms{};

	Parms.AssetName = AssetName;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchPlayerCameraManagerBase.RequestShowBattleCameraEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AssetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaResearchPlayerCameraManagerBase::RequestShowBattleCameraEffect(class FName AssetName, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchPlayerCameraManagerBase", "RequestShowBattleCameraEffect");

	Params::NicolaResearchPlayerCameraManagerBase_RequestShowBattleCameraEffect Parms{};

	Parms.AssetName = AssetName;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchPlayerCameraManagerBase.RequestShowCameraEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AssetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaResearchPlayerCameraManagerBase::RequestShowCameraEffect(class FName AssetName, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchPlayerCameraManagerBase", "RequestShowCameraEffect");

	Params::NicolaResearchPlayerCameraManagerBase_RequestShowCameraEffect Parms{};

	Parms.AssetName = AssetName;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.DemoEnding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaGameInstance::DemoEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "DemoEnding");

	Params::NicolaGameInstance_DemoEnding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.Ending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaGameInstance::Ending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "Ending");

	Params::NicolaGameInstance_Ending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.NewGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    titleSelectNewGame                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaGameInstance::NewGame(bool titleSelectNewGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "NewGame");

	Params::NicolaGameInstance_NewGame Parms{};

	Parms.titleSelectNewGame = titleSelectNewGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.onApplicationHasEnteredForeground
// (Final, Native, Private)

void UNicolaGameInstance::onApplicationHasEnteredForeground()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "onApplicationHasEnteredForeground");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.onApplicationWillEnterBackground
// (Final, Native, Private)

void UNicolaGameInstance::onApplicationWillEnterBackground()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "onApplicationWillEnterBackground");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.ProcessRequestReturnTitle
// (Final, Native, Public, BlueprintCallable)

void UNicolaGameInstance::ProcessRequestReturnTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "ProcessRequestReturnTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.RequestEnding
// (Final, Native, Public, BlueprintCallable)

void UNicolaGameInstance::RequestEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "RequestEnding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.ResetDebugSettings
// (Final, Native, Public, BlueprintCallable)

void UNicolaGameInstance::ResetDebugSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "ResetDebugSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.ReturnTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaGameInstance::ReturnTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "ReturnTitle");

	Params::NicolaGameInstance_ReturnTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.SendRequestReturnTitle
// (Final, Native, Public, BlueprintCallable)

void UNicolaGameInstance::SendRequestReturnTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "SendRequestReturnTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGameInstance.StartFromDevelopmentLauncher
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaGameInstance::StartFromDevelopmentLauncher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "StartFromDevelopmentLauncher");

	Params::NicolaGameInstance_StartFromDevelopmentLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetAchievementManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaAchievementManager*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaAchievementManager* UNicolaGameInstance::GetAchievementManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetAchievementManager");

	Params::NicolaGameInstance_GetAchievementManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetCompileVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UNicolaGameInstance::GetCompileVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetCompileVersion");

	Params::NicolaGameInstance_GetCompileVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetEffectManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaEffectManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaEffectManager* UNicolaGameInstance::GetEffectManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetEffectManager");

	Params::NicolaGameInstance_GetEffectManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetEndingManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaEndingManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaEndingManager* UNicolaGameInstance::GetEndingManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetEndingManager");

	Params::NicolaGameInstance_GetEndingManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetEventManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaEventManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaEventManager* UNicolaGameInstance::GetEventManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetEventManager");

	Params::NicolaGameInstance_GetEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetGuideIconManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaGuideIconManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaGuideIconManager* UNicolaGameInstance::GetGuideIconManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetGuideIconManager");

	Params::NicolaGameInstance_GetGuideIconManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetInGameManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaInGameManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaInGameManager* UNicolaGameInstance::GetInGameManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetInGameManager");

	Params::NicolaGameInstance_GetInGameManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetLuaScriptManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULuaScriptMgr*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULuaScriptMgr* UNicolaGameInstance::GetLuaScriptManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetLuaScriptManager");

	Params::NicolaGameInstance_GetLuaScriptManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetMapGuideManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaMapGuideManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaMapGuideManager* UNicolaGameInstance::GetMapGuideManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetMapGuideManager");

	Params::NicolaGameInstance_GetMapGuideManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetMapParameterCollectionManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapParameterCollectionManager*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapParameterCollectionManager* UNicolaGameInstance::GetMapParameterCollectionManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetMapParameterCollectionManager");

	Params::NicolaGameInstance_GetMapParameterCollectionManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetPS5ActivityManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPS5ActivityManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPS5ActivityManager* UNicolaGameInstance::GetPS5ActivityManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetPS5ActivityManager");

	Params::NicolaGameInstance_GetPS5ActivityManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetSaveGameManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaSaveGameManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaSaveGameManager* UNicolaGameInstance::GetSaveGameManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetSaveGameManager");

	Params::NicolaGameInstance_GetSaveGameManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetSkillManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaSkillManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaSkillManager* UNicolaGameInstance::GetSkillManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetSkillManager");

	Params::NicolaGameInstance_GetSkillManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameInstance.GetSoundManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNicolaSoundManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaSoundManager* UNicolaGameInstance::GetSoundManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameInstance", "GetSoundManager");

	Params::NicolaGameInstance_GetSoundManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaGameStateBase.GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANicolaPlayerControllerBase*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANicolaPlayerControllerBase* ANicolaGameStateBase::GetPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaGameStateBase", "GetPlayerController");

	Params::NicolaGameStateBase_GetPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatBaramos
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatBaramos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatBaramos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatBossTroll
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatBossTroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatBossTroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatDemonOfNile
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatDemonOfNile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatDemonOfNile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatGuardianOfHell
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatGuardianOfHell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatGuardianOfHell");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatOrochi
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatOrochi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatOrochi");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatRevnant
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatRevnant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatRevnant");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDefeatWarlock
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDefeatWarlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDefeatWarlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByDispelRubiss
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByDispelRubiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByDispelRubiss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerAchievement.RequestUnlockAchievementByUseRainbowDrop
// (Final, Native, Private, BlueprintCallable)

void AProduceSequencerAchievement::RequestUnlockAchievementByUseRainbowDrop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerAchievement", "RequestUnlockAchievementByUseRainbowDrop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGraphicSettingFL.ApplyPostProcessSetting_DOF
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaGraphicSettingFL::ApplyPostProcessSetting_DOF()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaGraphicSettingFL", "ApplyPostProcessSetting_DOF");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGraphicSettingFL.ApplyPostProcessSetting_Gamma
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaGraphicSettingFL::ApplyPostProcessSetting_Gamma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaGraphicSettingFL", "ApplyPostProcessSetting_Gamma");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaGraphicSettingFL.ApplyPostProcessSettings
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaGraphicSettingFL::ApplyPostProcessSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaGraphicSettingFL", "ApplyPostProcessSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaHighlightReceiverInterface.OnBeginHighlighting
// (Event, Public, BlueprintEvent)

void INicolaHighlightReceiverInterface::OnBeginHighlighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaHighlightReceiverInterface", "OnBeginHighlighting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaHighlightReceiverInterface.OnEndHighlighting
// (Event, Public, BlueprintEvent)

void INicolaHighlightReceiverInterface::OnEndHighlighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaHighlightReceiverInterface", "OnEndHighlighting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaSpriteManagerComponent.onFinishedPlaying
// (Final, Native, Private)

void UNicolaSpriteManagerComponent::onFinishedPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSpriteManagerComponent", "onFinishedPlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSpriteManagerComponent.SequencerRotationRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Degree                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSpriteManagerComponent::SequencerRotationRoll(float Degree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSpriteManagerComponent", "SequencerRotationRoll");

	Params::NicolaSpriteManagerComponent_SequencerRotationRoll Parms{};

	Parms.Degree = Degree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSpriteManagerComponent.SequencerSetEnableCharacterPrePass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSpriteManagerComponent::SequencerSetEnableCharacterPrePass(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSpriteManagerComponent", "SequencerSetEnableCharacterPrePass");

	Params::NicolaSpriteManagerComponent_SequencerSetEnableCharacterPrePass Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerTownNameUI.CloseTownNameWindow
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerTownNameUI::CloseTownNameWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerTownNameUI", "CloseTownNameWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerTownNameUI.PlayTownNameWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             textID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerTownNameUI::PlayTownNameWindow(class FName textID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerTownNameUI", "PlayTownNameWindow");

	Params::ProduceSequencerTownNameUI_PlayTownNameWindow Parms{};

	Parms.textID = textID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.AddItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   partyMemberNo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::AddItem(const class FName& ItemId, int32 Count, int32 partyMemberNo, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "AddItem");

	Params::NicolaItemDataFL_AddItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.partyMemberNo = partyMemberNo;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.AddItemNobody
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaItemDataFL::AddItemNobody(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "AddItemNobody");

	Params::NicolaItemDataFL_AddItemNobody Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.AdjustBag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyUnitIndex                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    checkTidy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::AdjustBag(const int32 partyUnitIndex, bool checkTidy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "AdjustBag");

	Params::NicolaItemDataFL_AdjustBag Parms{};

	Parms.partyUnitIndex = partyUnitIndex;
	Parms.checkTidy = checkTidy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.CanAddItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyMemberNo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   cnt                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::CanAddItem(int32 partyMemberNo, int32 cnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "CanAddItem");

	Params::NicolaItemDataFL_CanAddItem Parms{};

	Parms.partyMemberNo = partyMemberNo;
	Parms.cnt = cnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.DebugAddItem
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaItemDataFL::DebugAddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugAddItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.DebugAddItemAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaItemDataFL::DebugAddItemAll(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugAddItemAll");

	Params::NicolaItemDataFL_DebugAddItemAll Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.DebugAllItemDisplay
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaItemDataFL::DebugAllItemDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugAllItemDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.DebugEquipItem
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaItemDataFL::DebugEquipItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugEquipItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.DebugGetItemBagNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InGopId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaItemDataFL::DebugGetItemBagNum(const class FName& InGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugGetItemBagNum");

	Params::NicolaItemDataFL_DebugGetItemBagNum Parms{};

	Parms.InGopId = InGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.DebugGetItemNameID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InGopId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNicolaItemDataFL::DebugGetItemNameID(const class FName& InGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugGetItemNameID");

	Params::NicolaItemDataFL_DebugGetItemNameID Parms{};

	Parms.InGopId = InGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.DebugSetItemBagNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InGopId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaItemDataFL::DebugSetItemBagNum(const class FName& InGopId, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugSetItemBagNum");

	Params::NicolaItemDataFL_DebugSetItemBagNum Parms{};

	Parms.InGopId = InGopId;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.DebugTest
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaItemDataFL::DebugTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.DebugUseItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   targetNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBattle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnemy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RuraID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaItemDataFL::DebugUseItem(class FName ItemId, int32 targetNo, bool bBattle, bool bEnemy, class FName RuraID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "DebugUseItem");

	Params::NicolaItemDataFL_DebugUseItem Parms{};

	Parms.ItemId = ItemId;
	Parms.targetNo = targetNo;
	Parms.bBattle = bBattle;
	Parms.bEnemy = bEnemy;
	Parms.RuraID = RuraID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaItemDataFL.EquipItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::EquipItem(int32 partyIndex, const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "EquipItem");

	Params::NicolaItemDataFL_EquipItem Parms{};

	Parms.partyIndex = partyIndex;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.GetHaveItemNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    excludeRentalEquip                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    excludeUnitDataFromBelongStatusTemporary               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaItemDataFL::GetHaveItemNum(const class FName& ItemId, bool excludeRentalEquip, bool excludeUnitDataFromBelongStatusTemporary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "GetHaveItemNum");

	Params::NicolaItemDataFL_GetHaveItemNum Parms{};

	Parms.ItemId = ItemId;
	Parms.excludeRentalEquip = excludeRentalEquip;
	Parms.excludeUnitDataFromBelongStatusTemporary = excludeUnitDataFromBelongStatusTemporary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.GetItemGopList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaItemDataFL::GetItemGopList(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "GetItemGopList");

	Params::NicolaItemDataFL_GetItemGopList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaItemDataFL.GetItemGopListByCategory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EItemType                               InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutGopIdList                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaItemDataFL::GetItemGopListByCategory(EItemType InType, TArray<class FName>* OutGopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "GetItemGopListByCategory");

	Params::NicolaItemDataFL_GetItemGopListByCategory Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGopIdList != nullptr)
		*OutGopIdList = std::move(Parms.OutGopIdList);
}


// Function Nicola.NicolaItemDataFL.IsHaveItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    excludeRentalEquip                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    excludeUnitDataFromBelongStatusTemporary               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::IsHaveItem(const class FName& ItemId, bool excludeRentalEquip, bool excludeUnitDataFromBelongStatusTemporary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "IsHaveItem");

	Params::NicolaItemDataFL_IsHaveItem Parms{};

	Parms.ItemId = ItemId;
	Parms.excludeRentalEquip = excludeRentalEquip;
	Parms.excludeUnitDataFromBelongStatusTemporary = excludeUnitDataFromBelongStatusTemporary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.IsHaveItemEffectType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EItemEffectType                         EffectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    excludeUnitDataFromBelongStatusTemporary               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::IsHaveItemEffectType(EItemEffectType EffectType, bool excludeUnitDataFromBelongStatusTemporary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "IsHaveItemEffectType");

	Params::NicolaItemDataFL_IsHaveItemEffectType Parms{};

	Parms.EffectType = EffectType;
	Parms.excludeUnitDataFromBelongStatusTemporary = excludeUnitDataFromBelongStatusTemporary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.RemoveItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAllUnitData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    excludeUnitDataFromBelongStatusTemporary               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::RemoveItem(const class FName& ItemId, bool isAllUnitData, bool excludeUnitDataFromBelongStatusTemporary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "RemoveItem");

	Params::NicolaItemDataFL_RemoveItem Parms{};

	Parms.ItemId = ItemId;
	Parms.isAllUnitData = isAllUnitData;
	Parms.excludeUnitDataFromBelongStatusTemporary = excludeUnitDataFromBelongStatusTemporary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaItemDataFL.UseItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    isBag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   targetNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemUsableType                         usedTyming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RuraID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaItemDataFL::UseItem(bool isBag, int32 DataIndex, int32 ItemIndex, int32 targetNo, EItemUsableType usedTyming, class FName RuraID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaItemDataFL", "UseItem");

	Params::NicolaItemDataFL_UseItem Parms{};

	Parms.isBag = isBag;
	Parms.DataIndex = DataIndex;
	Parms.ItemIndex = ItemIndex;
	Parms.targetNo = targetNo;
	Parms.usedTyming = usedTyming;
	Parms.RuraID = RuraID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightDirRotator.GetCorrectionFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ANicolaLightDirRotator::GetCorrectionFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightDirRotator", "GetCorrectionFlag");

	Params::NicolaLightDirRotator_GetCorrectionFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightDirRotator.GetCorrectionLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ANicolaLightDirRotator::GetCorrectionLightColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightDirRotator", "GetCorrectionLightColor");

	Params::NicolaLightDirRotator_GetCorrectionLightColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightDirRotator.GetCorrectionLightIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaLightDirRotator::GetCorrectionLightIntensity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightDirRotator", "GetCorrectionLightIntensity");

	Params::NicolaLightDirRotator_GetCorrectionLightIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightDirRotator.GetCorrectionSkySphereOverallColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ANicolaLightDirRotator::GetCorrectionSkySphereOverallColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightDirRotator", "GetCorrectionSkySphereOverallColor");

	Params::NicolaLightDirRotator_GetCorrectionSkySphereOverallColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightDirRotator.SetVisibleActors
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaLightDirRotator::SetVisibleActors(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightDirRotator", "SetVisibleActors");

	Params::NicolaLightDirRotator_SetVisibleActors Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.NicolaLightDirRotator.GetCorrectionBlendRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaLightDirRotator::GetCorrectionBlendRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightDirRotator", "GetCorrectionBlendRate");

	Params::NicolaLightDirRotator_GetCorrectionBlendRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.CheckProgressFlagFromString
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANicolaLightingEnvMgrActor::CheckProgressFlagFromString(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "CheckProgressFlagFromString");

	Params::NicolaLightingEnvMgrActor_CheckProgressFlagFromString Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.GetCorrectionFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ANicolaLightingEnvMgrActor::GetCorrectionFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "GetCorrectionFlag");

	Params::NicolaLightingEnvMgrActor_GetCorrectionFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.GetCorrectionLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ANicolaLightingEnvMgrActor::GetCorrectionLightColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "GetCorrectionLightColor");

	Params::NicolaLightingEnvMgrActor_GetCorrectionLightColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.GetCorrectionLightIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaLightingEnvMgrActor::GetCorrectionLightIntensity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "GetCorrectionLightIntensity");

	Params::NicolaLightingEnvMgrActor_GetCorrectionLightIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.GetCorrectionSkySphereOverallColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ANicolaLightingEnvMgrActor::GetCorrectionSkySphereOverallColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "GetCorrectionSkySphereOverallColor");

	Params::NicolaLightingEnvMgrActor_GetCorrectionSkySphereOverallColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.OnReleaseActors
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANicolaLightingEnvMgrActor::OnReleaseActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "OnReleaseActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.NicolaLightingEnvMgrActor.SetVisibleActors
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaLightingEnvMgrActor::SetVisibleActors(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "SetVisibleActors");

	Params::NicolaLightingEnvMgrActor_SetVisibleActors Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.NicolaLightingEnvMgrActor.GetCorrectionBlendRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANicolaLightingEnvMgrActor::GetCorrectionBlendRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "GetCorrectionBlendRate");

	Params::NicolaLightingEnvMgrActor_GetCorrectionBlendRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingEnvMgrActor.UpdateSkyLightComponentSourceTypeByCubeMap
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkyLightComponent*               comp                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureCube*                     cubeMap                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANicolaLightingEnvMgrActor::UpdateSkyLightComponentSourceTypeByCubeMap(const class USkyLightComponent* comp, const class UTextureCube* cubeMap) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingEnvMgrActor", "UpdateSkyLightComponentSourceTypeByCubeMap");

	Params::NicolaLightingEnvMgrActor_UpdateSkyLightComponentSourceTypeByCubeMap Parms{};

	Parms.comp = comp;
	Parms.cubeMap = cubeMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.ApplyHeroInitStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::ApplyHeroInitStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "ApplyHeroInitStatus");

	Params::NicolaUnitDataFL_ApplyHeroInitStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.AutoHPMax
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAlmost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::AutoHPMax(bool bAlmost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "AutoHPMax");

	Params::NicolaUnitDataFL_AutoHPMax Parms{};

	Parms.bAlmost = bAlmost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.ChangePartyUnitParsonality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PersonalityId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::ChangePartyUnitParsonality(int32 partyNo, class FName PersonalityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "ChangePartyUnitParsonality");

	Params::NicolaUnitDataFL_ChangePartyUnitParsonality Parms{};

	Parms.partyNo = partyNo;
	Parms.PersonalityId = PersonalityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugAddExp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugAddExp(int32 partyNo, int32 Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugAddExp");

	Params::NicolaUnitDataFL_DebugAddExp Parms{};

	Parms.partyNo = partyNo;
	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugAddExpBeforeLevelUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugAddExpBeforeLevelUp(int32 partyNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugAddExpBeforeLevelUp");

	Params::NicolaUnitDataFL_DebugAddExpBeforeLevelUp Parms{};

	Parms.partyNo = partyNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugAddExpTargetLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   targetLv                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugAddExpTargetLevel(int32 partyNo, int32 targetLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugAddExpTargetLevel");

	Params::NicolaUnitDataFL_DebugAddExpTargetLevel Parms{};

	Parms.partyNo = partyNo;
	Parms.targetLv = targetLv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugCharaMake
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitClassType                          ClassType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitGenderType                         GenderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitVoicePattern                       VoicePattern                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   looksPattern                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   hairColorPattern                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusType                             Seed1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusType                             Seed2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusType                             Seed3                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusType                             seed4                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusType                             seed5                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusType                             seed6                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugCharaMake(class FName Name_0, EUnitClassType ClassType, EUnitGenderType GenderType, EUnitVoicePattern VoicePattern, int32 looksPattern, int32 hairColorPattern, EStatusType Seed1, EStatusType Seed2, EStatusType Seed3, EStatusType seed4, EStatusType seed5, EStatusType seed6)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugCharaMake");

	Params::NicolaUnitDataFL_DebugCharaMake Parms{};

	Parms.Name_0 = Name_0;
	Parms.ClassType = ClassType;
	Parms.GenderType = GenderType;
	Parms.VoicePattern = VoicePattern;
	Parms.looksPattern = looksPattern;
	Parms.hairColorPattern = hairColorPattern;
	Parms.Seed1 = Seed1;
	Parms.Seed2 = Seed2;
	Parms.Seed3 = Seed3;
	Parms.seed4 = seed4;
	Parms.seed5 = seed5;
	Parms.seed6 = seed6;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugCharaMakeForDebugMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUnitClassType                          ClassType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitGenderType                         GenderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   seedMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugCharaMakeForDebugMenu(EUnitClassType ClassType, EUnitGenderType GenderType, int32 seedMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugCharaMakeForDebugMenu");

	Params::NicolaUnitDataFL_DebugCharaMakeForDebugMenu Parms{};

	Parms.ClassType = ClassType;
	Parms.GenderType = GenderType;
	Parms.seedMode = seedMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugCreateAlphaParty
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaUnitDataFL::DebugCreateAlphaParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugCreateAlphaParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugCreateBattleParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCharaMakeInfo                   Party1                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCharaMakeInfo                   Party2                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCharaMakeInfo                   Party3                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCharaMakeInfo                   Party4                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   minLv                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugCreateBattleParty(const struct FCharaMakeInfo& Party1, const struct FCharaMakeInfo& Party2, const struct FCharaMakeInfo& Party3, const struct FCharaMakeInfo& Party4, int32 minLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugCreateBattleParty");

	Params::NicolaUnitDataFL_DebugCreateBattleParty Parms{};

	Parms.Party1 = std::move(Party1);
	Parms.Party2 = std::move(Party2);
	Parms.Party3 = std::move(Party3);
	Parms.Party4 = std::move(Party4);
	Parms.minLv = minLv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugCreateCharaMakeInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUnitClassType                          ClassType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitGenderType                         GenderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitVoicePattern                       VoicePattern                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   looksPattern                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   hairColorPattern                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDebugCharaMakeOption                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharaMakeInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCharaMakeInfo UNicolaUnitDataFL::DebugCreateCharaMakeInfo(EUnitClassType ClassType, EUnitGenderType GenderType, EUnitVoicePattern VoicePattern, int32 looksPattern, int32 hairColorPattern, EDebugCharaMakeOption Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugCreateCharaMakeInfo");

	Params::NicolaUnitDataFL_DebugCreateCharaMakeInfo Parms{};

	Parms.ClassType = ClassType;
	Parms.GenderType = GenderType;
	Parms.VoicePattern = VoicePattern;
	Parms.looksPattern = looksPattern;
	Parms.hairColorPattern = hairColorPattern;
	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.DebugDisplayAllMember
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    partyOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugDisplayAllMember(bool partyOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugDisplayAllMember");

	Params::NicolaUnitDataFL_DebugDisplayAllMember Parms{};

	Parms.partyOnly = partyOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugGetAllSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugGetAllSkill(int32 partyNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugGetAllSkill");

	Params::NicolaUnitDataFL_DebugGetAllSkill Parms{};

	Parms.partyNo = partyNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugMaxDoping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   sub                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugMaxDoping(int32 partyNo, int32 sub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugMaxDoping");

	Params::NicolaUnitDataFL_DebugMaxDoping Parms{};

	Parms.partyNo = partyNo;
	Parms.sub = sub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugModifyHp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   modifyValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccepDead                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugModifyHp(int32 partyIndex, int32 modifyValue, bool bAccepDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugModifyHp");

	Params::NicolaUnitDataFL_DebugModifyHp Parms{};

	Parms.partyIndex = partyIndex;
	Parms.modifyValue = modifyValue;
	Parms.bAccepDead = bAccepDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugModifyMp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   modifyValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAcceptEmpty                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugModifyMp(int32 partyNo, int32 modifyValue, bool bAcceptEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugModifyMp");

	Params::NicolaUnitDataFL_DebugModifyMp Parms{};

	Parms.partyNo = partyNo;
	Parms.modifyValue = modifyValue;
	Parms.bAcceptEmpty = bAcceptEmpty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DebugSetPartyUnitStatusEffectBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   statusEffectFlag                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   partyMemberIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   healRatio                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::DebugSetPartyUnitStatusEffectBP(int32 statusEffectFlag, bool bAdd, int32 partyMemberIndex, float healRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DebugSetPartyUnitStatusEffectBP");

	Params::NicolaUnitDataFL_DebugSetPartyUnitStatusEffectBP Parms{};

	Parms.statusEffectFlag = statusEffectFlag;
	Parms.bAdd = bAdd;
	Parms.partyMemberIndex = partyMemberIndex;
	Parms.healRatio = healRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.DeleteUnitDataFromStandby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   standbyIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::DeleteUnitDataFromStandby(int32 standbyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "DeleteUnitDataFromStandby");

	Params::NicolaUnitDataFL_DeleteUnitDataFromStandby Parms{};

	Parms.standbyIndex = standbyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.GetHairColorMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaUnitDataFL::GetHairColorMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "GetHairColorMax");

	Params::NicolaUnitDataFL_GetHairColorMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.GetPartyMemberNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaUnitDataFL::GetPartyMemberNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "GetPartyMemberNum");

	Params::NicolaUnitDataFL_GetPartyMemberNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.GetUnitDatasByBelongStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUnitResidentBelongStatus               belongStatus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, class FString>              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, class FString> UNicolaUnitDataFL::GetUnitDatasByBelongStatus(EUnitResidentBelongStatus belongStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "GetUnitDatasByBelongStatus");

	Params::NicolaUnitDataFL_GetUnitDatasByBelongStatus Parms{};

	Parms.belongStatus = belongStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.HealAllPartyMember
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bHealStatusEffect                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::HealAllPartyMember(bool bHealStatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "HealAllPartyMember");

	Params::NicolaUnitDataFL_HealAllPartyMember Parms{};

	Parms.bHealStatusEffect = bHealStatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.HealPartyUnitHP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::HealPartyUnitHP(int32 partyNo, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "HealPartyUnitHP");

	Params::NicolaUnitDataFL_HealPartyUnitHP Parms{};

	Parms.partyNo = partyNo;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.HealPartyUnitMP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::HealPartyUnitMP(int32 partyNo, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "HealPartyUnitMP");

	Params::NicolaUnitDataFL_HealPartyUnitMP Parms{};

	Parms.partyNo = partyNo;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.MoveUnitDataToParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   standbyIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::MoveUnitDataToParty(int32 standbyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "MoveUnitDataToParty");

	Params::NicolaUnitDataFL_MoveUnitDataToParty Parms{};

	Parms.standbyIndex = standbyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.MoveUnitDataToPartyFromTemporary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::MoveUnitDataToPartyFromTemporary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "MoveUnitDataToPartyFromTemporary");

	Params::NicolaUnitDataFL_MoveUnitDataToPartyFromTemporary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.MoveUnitDataToStandby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::MoveUnitDataToStandby(int32 partyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "MoveUnitDataToStandby");

	Params::NicolaUnitDataFL_MoveUnitDataToStandby Parms{};

	Parms.partyIndex = partyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.MoveUnitDataToTemporary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::MoveUnitDataToTemporary(int32 partyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "MoveUnitDataToTemporary");

	Params::NicolaUnitDataFL_MoveUnitDataToTemporary Parms{};

	Parms.partyIndex = partyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.ReducePartyUnitHP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::ReducePartyUnitHP(int32 partyNo, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "ReducePartyUnitHP");

	Params::NicolaUnitDataFL_ReducePartyUnitHP Parms{};

	Parms.partyNo = partyNo;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.ReducePartyUnitMP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::ReducePartyUnitMP(int32 partyNo, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "ReducePartyUnitMP");

	Params::NicolaUnitDataFL_ReducePartyUnitMP Parms{};

	Parms.partyNo = partyNo;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.SetUnitVoicePattern
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyUnitIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitVoicePattern                       VoicePattern                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::SetUnitVoicePattern(int32 partyUnitIndex, EUnitVoicePattern VoicePattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "SetUnitVoicePattern");

	Params::NicolaUnitDataFL_SetUnitVoicePattern Parms{};

	Parms.partyUnitIndex = partyUnitIndex;
	Parms.VoicePattern = VoicePattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.SortItemAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bSortABC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaUnitDataFL::SortItemAll(bool bSortABC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "SortItemAll");

	Params::NicolaUnitDataFL_SortItemAll Parms{};

	Parms.bSortABC = bSortABC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUnitDataFL.SwapUnitDataPosition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyIndex1                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   partyIndex2                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::SwapUnitDataPosition(int32 partyIndex1, int32 partyIndex2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "SwapUnitDataPosition");

	Params::NicolaUnitDataFL_SwapUnitDataPosition Parms{};

	Parms.partyIndex1 = partyIndex1;
	Parms.partyIndex2 = partyIndex2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.UseSkillBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnemy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   targetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::UseSkillBattle(bool bEnemy, int32 UserIndex, int32 targetIndex, class FName SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "UseSkillBattle");

	Params::NicolaUnitDataFL_UseSkillBattle Parms{};

	Parms.bEnemy = bEnemy;
	Parms.UserIndex = UserIndex;
	Parms.targetIndex = targetIndex;
	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaUnitDataFL.UseSkillNoBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   UserIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   targetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RuraID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaUnitDataFL::UseSkillNoBattle(int32 UserIndex, int32 targetIndex, class FName SkillId, class FName RuraID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUnitDataFL", "UseSkillNoBattle");

	Params::NicolaUnitDataFL_UseSkillNoBattle Parms{};

	Parms.UserIndex = UserIndex;
	Parms.targetIndex = targetIndex;
	Parms.SkillId = SkillId;
	Parms.RuraID = RuraID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIXenlonWish.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIXenlonWish::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIXenlonWish", "IsExecMenu");

	Params::UIXenlonWish_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIXenlonWish.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIXenlonWish::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIXenlonWish", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugCascadeDistributionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugCascadeDistributionExponent(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugCascadeDistributionExponent");

	Params::NicolaLightingMgr_SetDebugCascadeDistributionExponent Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugCascadeTransitionFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugCascadeTransitionFraction(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugCascadeTransitionFraction");

	Params::NicolaLightingMgr_SetDebugCascadeTransitionFraction Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugDynamicShadowCascades
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugDynamicShadowCascades(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugDynamicShadowCascades");

	Params::NicolaLightingMgr_SetDebugDynamicShadowCascades Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugDynamicShadowDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugDynamicShadowDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugDynamicShadowDistance");

	Params::NicolaLightingMgr_SetDebugDynamicShadowDistance Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugLightFunctionFadeDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugLightFunctionFadeDistance");

	Params::NicolaLightingMgr_SetDebugLightFunctionFadeDistance Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugShadowBias(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugShadowBias");

	Params::NicolaLightingMgr_SetDebugShadowBias Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetDebugShadowDistanceFadeoutFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetDebugShadowDistanceFadeoutFraction(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetDebugShadowDistanceFadeoutFraction");

	Params::NicolaLightingMgr_SetDebugShadowDistanceFadeoutFraction Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetLightDirRotatorActivated
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isActivated                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetLightDirRotatorActivated(bool isActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetLightDirRotatorActivated");

	Params::NicolaLightingMgr_SetLightDirRotatorActivated Parms{};

	Parms.isActivated = isActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.SetUseDebugDirectionalLightParameterFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaLightingMgr::SetUseDebugDirectionalLightParameterFlag(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "SetUseDebugDirectionalLightParameterFlag");

	Params::NicolaLightingMgr_SetUseDebugDirectionalLightParameterFlag Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaLightingMgr.GetDebugCascadeDistributionExponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaLightingMgr::GetDebugCascadeDistributionExponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugCascadeDistributionExponent");

	Params::NicolaLightingMgr_GetDebugCascadeDistributionExponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.GetDebugCascadeTransitionFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaLightingMgr::GetDebugCascadeTransitionFraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugCascadeTransitionFraction");

	Params::NicolaLightingMgr_GetDebugCascadeTransitionFraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.GetDebugDynamicShadowCascades
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaLightingMgr::GetDebugDynamicShadowCascades() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugDynamicShadowCascades");

	Params::NicolaLightingMgr_GetDebugDynamicShadowCascades Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.GetDebugDynamicShadowDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaLightingMgr::GetDebugDynamicShadowDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugDynamicShadowDistance");

	Params::NicolaLightingMgr_GetDebugDynamicShadowDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.GetDebugLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaLightingMgr::GetDebugLightFunctionFadeDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugLightFunctionFadeDistance");

	Params::NicolaLightingMgr_GetDebugLightFunctionFadeDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.GetDebugShadowBias
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaLightingMgr::GetDebugShadowBias() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugShadowBias");

	Params::NicolaLightingMgr_GetDebugShadowBias Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.GetDebugShadowDistanceFadeoutFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNicolaLightingMgr::GetDebugShadowDistanceFadeoutFraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "GetDebugShadowDistanceFadeoutFraction");

	Params::NicolaLightingMgr_GetDebugShadowDistanceFadeoutFraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.IsEnvironmentDirectionalLightEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaLightingMgr::IsEnvironmentDirectionalLightEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "IsEnvironmentDirectionalLightEnable");

	Params::NicolaLightingMgr_IsEnvironmentDirectionalLightEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.IsEnvironmentSkyLightEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaLightingMgr::IsEnvironmentSkyLightEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "IsEnvironmentSkyLightEnable");

	Params::NicolaLightingMgr_IsEnvironmentSkyLightEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.IsEnvironmentSkySphereEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaLightingMgr::IsEnvironmentSkySphereEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "IsEnvironmentSkySphereEnable");

	Params::NicolaLightingMgr_IsEnvironmentSkySphereEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaLightingMgr.IsLightDirRotatorActivated
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaLightingMgr::IsLightDirRotatorActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaLightingMgr", "IsLightDirRotatorActivated");

	Params::NicolaLightingMgr_IsLightDirRotatorActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIBar2Menu.DEBUG_PrepareForStart
// (Final, Native, Static, Public, BlueprintCallable)

void UUIBar2Menu::DEBUG_PrepareForStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBar2Menu", "DEBUG_PrepareForStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIBar2Menu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIBar2Menu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBar2Menu", "IsExecMenu");

	Params::UIBar2Menu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIBar2Menu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIBar2Menu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBar2Menu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessMgrBase.SetApertureRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessMgrBase::SetApertureRate(float Rate, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "SetApertureRate");

	Params::PostProcessMgrBase_SetApertureRate Parms{};

	Parms.Rate = Rate;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessMgrBase.SetFocalLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENicolaCameraParamType                  ParamType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FocalLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessMgrBase::SetFocalLength(ENicolaCameraParamType ParamType, float FocalLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "SetFocalLength");

	Params::PostProcessMgrBase_SetFocalLength Parms{};

	Parms.ParamType = ParamType;
	Parms.FocalLength = FocalLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessMgrBase.GetAperture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaCameraParamType                  ParamType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPostProcessMgrBase::GetAperture(ENicolaCameraParamType ParamType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "GetAperture");

	Params::PostProcessMgrBase_GetAperture Parms{};

	Parms.ParamType = ParamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessMgrBase.GetApertureRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPostProcessMgrBase::GetApertureRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "GetApertureRate");

	Params::PostProcessMgrBase_GetApertureRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessMgrBase.GetDiaphragmBladeCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaCameraParamType                  ParamType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPostProcessMgrBase::GetDiaphragmBladeCount(ENicolaCameraParamType ParamType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "GetDiaphragmBladeCount");

	Params::PostProcessMgrBase_GetDiaphragmBladeCount Parms{};

	Parms.ParamType = ParamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessMgrBase.GetDofDepthBlurAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaCameraParamType                  ParamType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPostProcessMgrBase::GetDofDepthBlurAmount(ENicolaCameraParamType ParamType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "GetDofDepthBlurAmount");

	Params::PostProcessMgrBase_GetDofDepthBlurAmount Parms{};

	Parms.ParamType = ParamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessMgrBase.GetDofDepthBlurRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaCameraParamType                  ParamType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPostProcessMgrBase::GetDofDepthBlurRadius(ENicolaCameraParamType ParamType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "GetDofDepthBlurRadius");

	Params::PostProcessMgrBase_GetDofDepthBlurRadius Parms{};

	Parms.ParamType = ParamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessMgrBase.GetFocalLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaCameraParamType                  ParamType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPostProcessMgrBase::GetFocalLength(ENicolaCameraParamType ParamType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessMgrBase", "GetFocalLength");

	Params::PostProcessMgrBase_GetFocalLength Parms{};

	Parms.ParamType = ParamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaResearchCommandComponent.OnEventOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNicolaResearchCommandComponent::OnEventOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchCommandComponent", "OnEventOverlapBegin");

	Params::NicolaResearchCommandComponent_OnEventOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaResearchCommandComponent.OnEventOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaResearchCommandComponent::OnEventOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaResearchCommandComponent", "OnEventOverlapEnd");

	Params::NicolaResearchCommandComponent_OnEventOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ShineSearchEventForField.OnFadeCollisionOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AShineSearchEventForField::OnFadeCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShineSearchEventForField", "OnFadeCollisionOverlapBegin");

	Params::ShineSearchEventForField_OnFadeCollisionOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ShineSearchEventForField.OnFadeCollisionOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShineSearchEventForField::OnFadeCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShineSearchEventForField", "OnFadeCollisionOverlapEnd");

	Params::ShineSearchEventForField_OnFadeCollisionOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SpawnManagementActor.DebugSpawn
// (Final, Native, Static, Public, BlueprintCallable)

void ASpawnManagementActor::DebugSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnManagementActor", "DebugSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UITutorial.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUITutorial::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITutorial", "IsExecMenu");

	Params::UITutorial_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UITutorial.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InGopId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITutorial::OpenMenu(class FName InGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITutorial", "OpenMenu");

	Params::UITutorial_OpenMenu Parms{};

	Parms.InGopId = InGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.AsyncLoadGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    loadForConfig                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::AsyncLoadGameData(int32 DataIndex, bool loadForConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "AsyncLoadGameData");

	Params::NicolaSaveGameManager_AsyncLoadGameData Parms{};

	Parms.DataIndex = DataIndex;
	Parms.loadForConfig = loadForConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.AsyncSaveGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    gameClear                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             saveChurchID                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::AsyncSaveGameData(const class UObject* WorldContext, int32 DataIndex, bool gameClear, const class FName saveChurchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "AsyncSaveGameData");

	Params::NicolaSaveGameManager_AsyncSaveGameData Parms{};

	Parms.WorldContext = WorldContext;
	Parms.DataIndex = DataIndex;
	Parms.gameClear = gameClear;
	Parms.saveChurchID = saveChurchID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.DEBUG_ResetSystemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::DEBUG_ResetSystemData(int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "DEBUG_ResetSystemData");

	Params::NicolaSaveGameManager_DEBUG_ResetSystemData Parms{};

	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.DebugMakeClearData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::DebugMakeClearData(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "DebugMakeClearData");

	Params::NicolaSaveGameManager_DebugMakeClearData Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.DeleteSaveGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::DeleteSaveGameData(int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "DeleteSaveGameData");

	Params::NicolaSaveGameManager_DeleteSaveGameData Parms{};

	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.DoesSaveGameExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::DoesSaveGameExist(int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "DoesSaveGameExist");

	Params::NicolaSaveGameManager_DoesSaveGameExist Parms{};

	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.LoadGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::LoadGameData(int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "LoadGameData");

	Params::NicolaSaveGameManager_LoadGameData Parms{};

	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.MakeBrokenGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   randSeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::MakeBrokenGameData(int32 DataIndex, int32 randSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "MakeBrokenGameData");

	Params::NicolaSaveGameManager_MakeBrokenGameData Parms{};

	Parms.DataIndex = DataIndex;
	Parms.randSeed = randSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.MakeCrackedGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   randSeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::MakeCrackedGameData(int32 DataIndex, int32 randSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "MakeCrackedGameData");

	Params::NicolaSaveGameManager_MakeCrackedGameData Parms{};

	Parms.DataIndex = DataIndex;
	Parms.randSeed = randSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.MakeDifferentVersionGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Version                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::MakeDifferentVersionGameData(int32 DataIndex, int32 Version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "MakeDifferentVersionGameData");

	Params::NicolaSaveGameManager_MakeDifferentVersionGameData Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Version = Version;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.MakeDifferentVersionSystemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Version                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::MakeDifferentVersionSystemData(int32 DataIndex, int32 Version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "MakeDifferentVersionSystemData");

	Params::NicolaSaveGameManager_MakeDifferentVersionSystemData Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Version = Version;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.MakeInvertedGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::MakeInvertedGameData(int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "MakeInvertedGameData");

	Params::NicolaSaveGameManager_MakeInvertedGameData Parms{};

	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.MakeInvertedSystemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSaveGameManager::MakeInvertedSystemData(int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "MakeInvertedSystemData");

	Params::NicolaSaveGameManager_MakeInvertedSystemData Parms{};

	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSaveGameManager.SaveGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    gameClear                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             saveChurchID                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::SaveGameData(const class UObject* WorldContext, int32 DataIndex, bool gameClear, const class FName saveChurchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "SaveGameData");

	Params::NicolaSaveGameManager_SaveGameData Parms{};

	Parms.WorldContext = WorldContext;
	Parms.DataIndex = DataIndex;
	Parms.gameClear = gameClear;
	Parms.saveChurchID = saveChurchID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.IsExistingAutoSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::IsExistingAutoSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "IsExistingAutoSaveData");

	Params::NicolaSaveGameManager_IsExistingAutoSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.IsExistingContinueSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::IsExistingContinueSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "IsExistingContinueSaveData");

	Params::NicolaSaveGameManager_IsExistingContinueSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSaveGameManager.IsExistingNormalSaveData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSaveGameManager::IsExistingNormalSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSaveGameManager", "IsExistingNormalSaveData");

	Params::NicolaSaveGameManager_IsExistingNormalSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSkillFL.DebugUseSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             gopMagicId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   targetNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBattle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnemy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RuraID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSkillFL::DebugUseSkill(class FName gopMagicId, int32 targetNo, bool bBattle, bool bEnemy, class FName RuraID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "DebugUseSkill");

	Params::NicolaSkillFL_DebugUseSkill Parms{};

	Parms.gopMagicId = gopMagicId;
	Parms.targetNo = targetNo;
	Parms.bBattle = bBattle;
	Parms.bEnemy = bEnemy;
	Parms.RuraID = RuraID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSkillFL.GetRuraList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSkillFL::GetRuraList(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "GetRuraList");

	Params::NicolaSkillFL_GetRuraList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSkillFL.GetScriptArgs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   scriptId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class FString, class FString>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const TMap<class FString, class FString> UNicolaSkillFL::GetScriptArgs(int32 scriptId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "GetScriptArgs");

	Params::NicolaSkillFL_GetScriptArgs Parms{};

	Parms.scriptId = scriptId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSkillFL.GetSkillGopList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     GopIdList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNicolaSkillFL::GetSkillGopList(TArray<class FName>* GopIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "GetSkillGopList");

	Params::NicolaSkillFL_GetSkillGopList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GopIdList != nullptr)
		*GopIdList = std::move(Parms.GopIdList);
}


// Function Nicola.NicolaSkillFL.OnChangeAreaSkill
// (Final, Native, Static, Public, BlueprintCallable)

void UNicolaSkillFL::OnChangeAreaSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "OnChangeAreaSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSkillFL.OnWalkStep
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    isInTown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isField                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FastWalkRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   subRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSkillFL::OnWalkStep(bool isInTown, bool isField, float FastWalkRate, float subRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "OnWalkStep");

	Params::NicolaSkillFL_OnWalkStep Parms{};

	Parms.isInTown = isInTown;
	Parms.isField = isField;
	Parms.FastWalkRate = FastWalkRate;
	Parms.subRate = subRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSkillFL.RemoveScriptArgs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   scriptId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSkillFL::RemoveScriptArgs(int32 scriptId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaSkillFL", "RemoveScriptArgs");

	Params::NicolaSkillFL_RemoveScriptArgs Parms{};

	Parms.scriptId = scriptId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.OutputFontSizeSubsytem.OutputFontSize
// (Final, Native, Public, BlueprintCallable)

void UOutputFontSizeSubsytem::OutputFontSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutputFontSizeSubsytem", "OutputFontSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.OutputFontSizeSubsytem.SetFontPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InFontPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOutputFontSizeSubsytem::SetFontPath(const class FString& InFontPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutputFontSizeSubsytem", "SetFontPath");

	Params::OutputFontSizeSubsytem_SetFontPath Parms{};

	Parms.InFontPath = std::move(InFontPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.OutputFontSizeSubsytem.SetFontSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InFontSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOutputFontSizeSubsytem::SetFontSize(int32 InFontSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutputFontSizeSubsytem", "SetFontSize");

	Params::OutputFontSizeSubsytem_SetFontSize Parms{};

	Parms.InFontSize = InFontSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.OutputFontSizeSubsytem.GetFontSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOutputFontSizeSubsytem::GetFontSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutputFontSizeSubsytem", "GetFontSize");

	Params::OutputFontSizeSubsytem_GetFontSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.SequenceCameraFL.DebugPlayEventSequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequenceCameraFL::DebugPlayEventSequence(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequenceCameraFL", "DebugPlayEventSequence");

	Params::SequenceCameraFL_DebugPlayEventSequence Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SequenceCameraFL.SequencerSetEnableCharacterForegroundPrePass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              TARGET                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequenceCameraFL::SequencerSetEnableCharacterForegroundPrePass(class UPrimitiveComponent* TARGET, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequenceCameraFL", "SequencerSetEnableCharacterForegroundPrePass");

	Params::SequenceCameraFL_SequencerSetEnableCharacterForegroundPrePass Parms{};

	Parms.TARGET = TARGET;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.DebugCatchPostProcessVolume
// (Final, Native, Static, Public, BlueprintCallable)

void UPostProcessFL::DebugCatchPostProcessVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "DebugCatchPostProcessVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.EndPostProcessRecollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::EndPostProcessRecollection(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "EndPostProcessRecollection");

	Params::PostProcessFL_EndPostProcessRecollection Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.EndPostProcessSepia
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::EndPostProcessSepia(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "EndPostProcessSepia");

	Params::PostProcessFL_EndPostProcessSepia Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.EndSettingPostProcessColorByEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::EndSettingPostProcessColorByEventScript(float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "EndSettingPostProcessColorByEventScript");

	Params::PostProcessFL_EndSettingPostProcessColorByEventScript Parms{};

	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.EndSettingPostProcessGainByEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::EndSettingPostProcessGainByEventScript(float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "EndSettingPostProcessGainByEventScript");

	Params::PostProcessFL_EndSettingPostProcessGainByEventScript Parms{};

	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.EndSettingPostProcessVignetteByEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::EndSettingPostProcessVignetteByEventScript(float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "EndSettingPostProcessVignetteByEventScript");

	Params::PostProcessFL_EndSettingPostProcessVignetteByEventScript Parms{};

	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.IsCatchingPostProcessVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPostProcessFL::IsCatchingPostProcessVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "IsCatchingPostProcessVolume");

	Params::PostProcessFL_IsCatchingPostProcessVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessFL.IsPlayingPostProcessRecollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPostProcessFL::IsPlayingPostProcessRecollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "IsPlayingPostProcessRecollection");

	Params::PostProcessFL_IsPlayingPostProcessRecollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessFL.IsPlayingPostProcessSepia
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPostProcessFL::IsPlayingPostProcessSepia()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "IsPlayingPostProcessSepia");

	Params::PostProcessFL_IsPlayingPostProcessSepia Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PostProcessFL.ReleasePostProcessVolume
// (Final, Native, Static, Public, BlueprintCallable)

void UPostProcessFL::ReleasePostProcessVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "ReleasePostProcessVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.SetPostProcessVolumeInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MapId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapTimeFrame                           MapTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             subLevelId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::SetPostProcessVolumeInfo(class FName MapId, EMapTimeFrame MapTime, class FName subLevelId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "SetPostProcessVolumeInfo");

	Params::PostProcessFL_SetPostProcessVolumeInfo Parms{};

	Parms.MapId = MapId;
	Parms.MapTime = MapTime;
	Parms.subLevelId = subLevelId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.StartPostProcessRecollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::StartPostProcessRecollection(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "StartPostProcessRecollection");

	Params::PostProcessFL_StartPostProcessRecollection Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.StartPostProcessSepia
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::StartPostProcessSepia(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "StartPostProcessSepia");

	Params::PostProcessFL_StartPostProcessSepia Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.StartSettingPostProcessColorByEventScript
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          rgbVec                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::StartSettingPostProcessColorByEventScript(const struct FVector& rgbVec, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "StartSettingPostProcessColorByEventScript");

	Params::PostProcessFL_StartSettingPostProcessColorByEventScript Parms{};

	Parms.rgbVec = std::move(rgbVec);
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.StartSettingPostProcessGainByEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   gainRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::StartSettingPostProcessGainByEventScript(float gainRate, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "StartSettingPostProcessGainByEventScript");

	Params::PostProcessFL_StartSettingPostProcessGainByEventScript Parms{};

	Parms.gainRate = gainRate;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PostProcessFL.StartSettingPostProcessVignetteByEventScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessFL::StartSettingPostProcessVignetteByEventScript(float Intensity, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PostProcessFL", "StartSettingPostProcessVignetteByEventScript");

	Params::PostProcessFL_StartSettingPostProcessVignetteByEventScript Parms{};

	Parms.Intensity = Intensity;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.FadeInCategoryVolumeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::FadeInCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "FadeInCategoryVolumeRate");

	Params::NicolaSoundManager_FadeInCategoryVolumeRate Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.FadeOutCategoryVolumeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoStop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::FadeOutCategoryVolumeRate(const ENicolaSoundCategory SoundCategory, float DurationSec, bool bAutoStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "FadeOutCategoryVolumeRate");

	Params::NicolaSoundManager_FadeOutCategoryVolumeRate Parms{};

	Parms.SoundCategory = SoundCategory;
	Parms.DurationSec = DurationSec;
	Parms.bAutoStop = bAutoStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.PlaySE
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Owner                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ENicolaSoundCategory>            AdditionalSoundCategory                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ENicolaSoundPlayOptionFlags             NicolaSoundPlayOptionFlags                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaSoundManager::PlaySE(const class FName& GopId, const struct FVector& Location, const class UObject* Owner, const TArray<ENicolaSoundCategory>& AdditionalSoundCategory, ENicolaSoundPlayOptionFlags NicolaSoundPlayOptionFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "PlaySE");

	Params::NicolaSoundManager_PlaySE Parms{};

	Parms.GopId = GopId;
	Parms.Location = std::move(Location);
	Parms.Owner = Owner;
	Parms.AdditionalSoundCategory = std::move(AdditionalSoundCategory);
	Parms.NicolaSoundPlayOptionFlags = NicolaSoundPlayOptionFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaSoundManager.SetBgmVolumeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::SetBgmVolumeRate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "SetBgmVolumeRate");

	Params::NicolaSoundManager_SetBgmVolumeRate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.SetSeVolumeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::SetSeVolumeRate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "SetSeVolumeRate");

	Params::NicolaSoundManager_SetSeVolumeRate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.SetVoiceVolumeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::SetVoiceVolumeRate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "SetVoiceVolumeRate");

	Params::NicolaSoundManager_SetVoiceVolumeRate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.StopByCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    SoundCategory                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::StopByCategory(const ENicolaSoundCategory SoundCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "StopByCategory");

	Params::NicolaSoundManager_StopByCategory Parms{};

	Parms.SoundCategory = SoundCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.TransitionCategoryVolumeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENicolaSoundCategory                    Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaSoundManager::TransitionCategoryVolumeRate(ENicolaSoundCategory Category, float Rate, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "TransitionCategoryVolumeRate");

	Params::NicolaSoundManager_TransitionCategoryVolumeRate Parms{};

	Parms.Category = Category;
	Parms.Rate = Rate;
	Parms.DurationSec = DurationSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaSoundManager.IsLoopByGopId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENicolaSoundDataTableType               DataTableType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GopId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNicolaSoundManager::IsLoopByGopId(const ENicolaSoundDataTableType DataTableType, const class FName& GopId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaSoundManager", "IsLoopByGopId");

	Params::NicolaSoundManager_IsLoopByGopId Parms{};

	Parms.DataTableType = DataTableType;
	Parms.GopId = GopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaTitleManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ANicolaTitleManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANicolaTitleManager* ANicolaTitleManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaTitleManager", "GetInstance");

	Params::NicolaTitleManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaTitleManager.OpenTitleDemo
// (Final, Native, Public, BlueprintCallable)

void ANicolaTitleManager::OpenTitleDemo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaTitleManager", "OpenTitleDemo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaTitleManager.OpenTitleMenu
// (Final, Native, Public, BlueprintCallable)

void ANicolaTitleManager::OpenTitleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NicolaTitleManager", "OpenTitleMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaUIManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWCO                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNicolaUIManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNicolaUIManager* UNicolaUIManager::GetInstance(const class UObject* InWCO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaUIManager", "GetInstance");

	Params::NicolaUIManager_GetInstance Parms{};

	Parms.InWCO = InWCO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaVoiceFL.DebugChangeUnitVoicePattern
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyUnitIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   voicePatternNo                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNicolaVoiceFL::DebugChangeUnitVoicePattern(int32 partyUnitIndex, int32 voicePatternNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaVoiceFL", "DebugChangeUnitVoicePattern");

	Params::NicolaVoiceFL_DebugChangeUnitVoicePattern Parms{};

	Parms.partyUnitIndex = partyUnitIndex;
	Parms.voicePatternNo = voicePatternNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NicolaVoiceFL.DebugGetUnitVoicePattern
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyUnitIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNicolaVoiceFL::DebugGetUnitVoicePattern(int32 partyUnitIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaVoiceFL", "DebugGetUnitVoicePattern");

	Params::NicolaVoiceFL_DebugGetUnitVoicePattern Parms{};

	Parms.partyUnitIndex = partyUnitIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NicolaVoiceFL.PlayVoiceBattle2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GopVoiceBattleId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnitVoicePattern                       VoicePattern                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FADSoundPlaybackId               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FADSoundPlaybackId UNicolaVoiceFL::PlayVoiceBattle2D(const class FName& GopVoiceBattleId, EUnitVoicePattern VoicePattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NicolaVoiceFL", "PlayVoiceBattle2D");

	Params::NicolaVoiceFL_PlayVoiceBattle2D Parms{};

	Parms.GopVoiceBattleId = GopVoiceBattleId;
	Parms.VoicePattern = VoicePattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.NotifyChangeVisibleInterface.NotifyChangeVisibleActor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsVisible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INotifyChangeVisibleInterface::NotifyChangeVisibleActor(bool NewIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotifyChangeVisibleInterface", "NotifyChangeVisibleActor");

	Params::NotifyChangeVisibleInterface_NotifyChangeVisibleActor Parms{};

	Parms.NewIsVisible = NewIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.NpcTestAIController.InitNpcController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    PatrolVolumeComp                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NpcActor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NpcWaitTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcTestAIController::InitNpcController(const class UBoxComponent* PatrolVolumeComp, const class AActor* NpcActor, float NpcWaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTestAIController", "InitNpcController");

	Params::NpcTestAIController_InitNpcController Parms{};

	Parms.PatrolVolumeComp = PatrolVolumeComp;
	Parms.NpcActor = NpcActor;
	Parms.NpcWaitTime = NpcWaitTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerFollowNpcAIController.NotifyHitOtherCharacter
// (Final, Native, Public, BlueprintCallable)

void APlayerFollowNpcAIController::NotifyHitOtherCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerFollowNpcAIController", "NotifyHitOtherCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerFollowNpcAIController.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APlayerFollowNpcAIController::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerFollowNpcAIController", "OnComponentHit");

	Params::PlayerFollowNpcAIController_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerFollowNpcAIController.ScriptMove
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          targetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerFollowNpcAIController::ScriptMove(const struct FVector& targetLocation, float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerFollowNpcAIController", "ScriptMove");

	Params::PlayerFollowNpcAIController_ScriptMove Parms{};

	Parms.targetLocation = std::move(targetLocation);
	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PlayerFollowNpcAIController.IsMoveState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerFollowNpcAIController::IsMoveState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerFollowNpcAIController", "IsMoveState");

	Params::PlayerFollowNpcAIController_IsMoveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PlayerLamia.GetHeightRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerLamia::GetHeightRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLamia", "GetHeightRate");

	Params::PlayerLamia_GetHeightRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PlayerShip.GetTopSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerShip::GetTopSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerShip", "GetTopSpeed");

	Params::PlayerShip_GetTopSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PlayerShip.GetTopSpeedDash
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerShip::GetTopSpeedDash() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerShip", "GetTopSpeedDash");

	Params::PlayerShip_GetTopSpeedDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.ProduceSequencerBGM.PlayBattleBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GopBattleBgmId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerBGM::PlayBattleBGM(class FName GopBattleBgmId, float FadeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerBGM", "PlayBattleBGM");

	Params::ProduceSequencerBGM_PlayBattleBGM Parms{};

	Parms.GopBattleBgmId = GopBattleBgmId;
	Parms.FadeSec = FadeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerBGM.PlayBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GopBgmId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerBGM::PlayBGM(class FName GopBgmId, float FadeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerBGM", "PlayBGM");

	Params::ProduceSequencerBGM_PlayBGM Parms{};

	Parms.GopBgmId = GopBgmId;
	Parms.FadeSec = FadeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerBGM.StopBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   fadeOutSec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerBGM::StopBGM(float fadeOutSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerBGM", "StopBGM");

	Params::ProduceSequencerBGM_StopBGM Parms{};

	Parms.fadeOutSec = fadeOutSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerScreenShot.CloseEventScreenShot
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerScreenShot::CloseEventScreenShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerScreenShot", "CloseEventScreenShot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerScreenShot.ShowEventScreenShot
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerScreenShot::ShowEventScreenShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerScreenShot", "ShowEventScreenShot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerSe.PlaySE
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GopSeID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProduceSequencerSe::PlaySE(const class FString& GopSeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerSe", "PlaySE");

	Params::ProduceSequencerSe_PlaySE Parms{};

	Parms.GopSeID = std::move(GopSeID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ProduceSequencerSe.StopSE
// (Final, Native, Public, BlueprintCallable)

void AProduceSequencerSe::StopSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProduceSequencerSe", "StopSE");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PS5ActivityManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPS5ActivityManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPS5ActivityManager* UPS5ActivityManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PS5ActivityManager", "GetInstance");

	Params::PS5ActivityManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PS5ActivityManager.ChangeActivityAvailability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ActivityId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAvailable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5ActivityManager::ChangeActivityAvailability(const class FString& ActivityId, bool IsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "ChangeActivityAvailability");

	Params::PS5ActivityManager_ChangeActivityAvailability Parms{};

	Parms.ActivityId = std::move(ActivityId);
	Parms.IsAvailable = IsAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PS5ActivityManager.DebugGetAllActivityIds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UPS5ActivityManager::DebugGetAllActivityIds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "DebugGetAllActivityIds");

	Params::PS5ActivityManager_DebugGetAllActivityIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.PS5ActivityManager.EndActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ActivityId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPS5ActivityOutcome                     ActivityOutcome                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5ActivityManager::EndActivity(const class FString& ActivityId, EPS5ActivityOutcome ActivityOutcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "EndActivity");

	Params::PS5ActivityManager_EndActivity Parms{};

	Parms.ActivityId = std::move(ActivityId);
	Parms.ActivityOutcome = ActivityOutcome;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PS5ActivityManager.StartActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ActivityId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5ActivityManager::StartActivity(const class FString& ActivityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "StartActivity");

	Params::PS5ActivityManager_StartActivity Parms{};

	Parms.ActivityId = std::move(ActivityId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.PS5ActivityManager.TerminateActivity
// (Final, Native, Public, BlueprintCallable)

void UPS5ActivityManager::TerminateActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "TerminateActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.RecollectionDataFL.ImprintRecollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecollectionDataFL::ImprintRecollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RecollectionDataFL", "ImprintRecollection");

	Params::RecollectionDataFL_ImprintRecollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.RockPuzzleGoalFloor.OnRockCheckCollisionOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARockPuzzleGoalFloor::OnRockCheckCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RockPuzzleGoalFloor", "OnRockCheckCollisionOverlapBegin");

	Params::RockPuzzleGoalFloor_OnRockCheckCollisionOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.RockPuzzleGoalFloor.OnRockCheckCollisionOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARockPuzzleGoalFloor::OnRockCheckCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RockPuzzleGoalFloor", "OnRockCheckCollisionOverlapEnd");

	Params::RockPuzzleGoalFloor_OnRockCheckCollisionOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SequenceBattleCameraManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASequenceBattleCameraManager*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASequenceBattleCameraManager* ASequenceBattleCameraManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequenceBattleCameraManager", "GetInstance");

	Params::SequenceBattleCameraManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.SequenceBattleCameraManager.PlaySequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bJumpToEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceBattleCameraManager::PlaySequence(int32 Index_0, bool bJumpToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceBattleCameraManager", "PlaySequence");

	Params::SequenceBattleCameraManager_PlaySequence Parms{};

	Parms.Index_0 = Index_0;
	Parms.bJumpToEnd = bJumpToEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SequenceBattleCameraManager.PlaySequenceBackToFront
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bJumpToEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceBattleCameraManager::PlaySequenceBackToFront(bool bJumpToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceBattleCameraManager", "PlaySequenceBackToFront");

	Params::SequenceBattleCameraManager_PlaySequenceBackToFront Parms{};

	Parms.bJumpToEnd = bJumpToEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.SequenceBattleCameraManager.PlaySequenceFrontToBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bJumpToEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceBattleCameraManager::PlaySequenceFrontToBack(bool bJumpToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceBattleCameraManager", "PlaySequenceFrontToBack");

	Params::SequenceBattleCameraManager_PlaySequenceFrontToBack Parms{};

	Parms.bJumpToEnd = bJumpToEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.ShineChildActorBase.OnStartShineChildActorEffect
// (Event, Public, BlueprintEvent)

void AShineChildActorBase::OnStartShineChildActorEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShineChildActorBase", "OnStartShineChildActorEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.Ship.GetShipSpeedTypeEnum
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EShipSpeedType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EShipSpeedType AShip::GetShipSpeedTypeEnum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ship", "GetShipSpeedTypeEnum");

	Params::Ship_GetShipSpeedTypeEnum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.Ship.GetShipSpeedTypeInt
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AShip::GetShipSpeedTypeInt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ship", "GetShipSpeedTypeInt");

	Params::Ship_GetShipSpeedTypeInt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.Ship.IsSpeedTypeFast
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AShip::IsSpeedTypeFast() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ship", "IsSpeedTypeFast");

	Params::Ship_IsSpeedTypeFast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.Ship.IsSpeedTypeSlow
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AShip::IsSpeedTypeSlow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ship", "IsSpeedTypeSlow");

	Params::Ship_IsSpeedTypeSlow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.Ship.IsSpeedTypeStop
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AShip::IsSpeedTypeStop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ship", "IsSpeedTypeStop");

	Params::Ship_IsSpeedTypeStop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestLamia.EnableGravity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::EnableGravity(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "EnableGravity");

	Params::TestLamia_EnableGravity Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.GetDashPerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATestLamia::GetDashPerSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "GetDashPerSec");

	Params::TestLamia_GetDashPerSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestLamia.GetMovePerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATestLamia::GetMovePerSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "GetMovePerSec");

	Params::TestLamia_GetMovePerSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestLamia.GetMovePerStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATestLamia::GetMovePerStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "GetMovePerStep");

	Params::TestLamia_GetMovePerStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestLamia.GetSpriteScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATestLamia::GetSpriteScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "GetSpriteScale");

	Params::TestLamia_GetSpriteScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestLamia.GetTraceLandscapeFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATestLamia::GetTraceLandscapeFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "GetTraceLandscapeFlag");

	Params::TestLamia_GetTraceLandscapeFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestLamia.onChangedMovementMode
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           prevMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PrevCustomMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::onChangedMovementMode(class ACharacter* Character, EMovementMode prevMode, uint8 PrevCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "onChangedMovementMode");

	Params::TestLamia_onChangedMovementMode Parms{};

	Parms.Character = Character;
	Parms.prevMode = prevMode;
	Parms.PrevCustomMode = PrevCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.onUpdateMovement
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::onUpdateMovement(float Delta, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "onUpdateMovement");

	Params::TestLamia_onUpdateMovement Parms{};

	Parms.Delta = Delta;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.SetDashPerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::SetDashPerSec(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "SetDashPerSec");

	Params::TestLamia_SetDashPerSec Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.SetMovePerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::SetMovePerSec(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "SetMovePerSec");

	Params::TestLamia_SetMovePerSec Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.SetPosAndAlignment
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionOnMap                         dirAlignment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionOnMap                         dirLeader                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::SetPosAndAlignment(const struct FVector& Pos, EDirectionOnMap dirAlignment, EDirectionOnMap dirLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "SetPosAndAlignment");

	Params::TestLamia_SetPosAndAlignment Parms{};

	Parms.Pos = std::move(Pos);
	Parms.dirAlignment = dirAlignment;
	Parms.dirLeader = dirLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.SetTraceLandscapeFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::SetTraceLandscapeFlag(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "SetTraceLandscapeFlag");

	Params::TestLamia_SetTraceLandscapeFlag Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestLamia.Together
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestLamia::Together(const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestLamia", "Together");

	Params::TestLamia_Together Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestShip.GetDashPerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATestShip::GetDashPerSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "GetDashPerSec");

	Params::TestShip_GetDashPerSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestShip.GetMovePerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATestShip::GetMovePerSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "GetMovePerSec");

	Params::TestShip_GetMovePerSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestShip.IsEnableWalkingByPhysicalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATestShip::IsEnableWalkingByPhysicalMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "IsEnableWalkingByPhysicalMaterial");

	Params::TestShip_IsEnableWalkingByPhysicalMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TestShip.SetDashPerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestShip::SetDashPerSec(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "SetDashPerSec");

	Params::TestShip_SetDashPerSec Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestShip.SetEnableWalkingByPhysicalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestShip::SetEnableWalkingByPhysicalMaterial(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "SetEnableWalkingByPhysicalMaterial");

	Params::TestShip_SetEnableWalkingByPhysicalMaterial Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestShip.SetMovePerSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestShip::SetMovePerSec(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "SetMovePerSec");

	Params::TestShip_SetMovePerSec Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TestShip.GetMeshDir
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector ATestShip::GetMeshDir() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestShip", "GetMeshDir");

	Params::TestShip_GetMeshDir Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.TriggerVolumeActorByOneFrame.SpawnOneFrameVolumeActorAndApplyParameterFromTriggerVolume
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATriggerVolumeActor*              SourceVolume                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ATriggerVolumeActorByOneFrame>OneFrameVolumeClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATriggerVolumeActorByOneFrame*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATriggerVolumeActorByOneFrame* ATriggerVolumeActorByOneFrame::SpawnOneFrameVolumeActorAndApplyParameterFromTriggerVolume(class UObject* WorldContext, class ATriggerVolumeActor* SourceVolume, TSubclassOf<class ATriggerVolumeActorByOneFrame> OneFrameVolumeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TriggerVolumeActorByOneFrame", "SpawnOneFrameVolumeActorAndApplyParameterFromTriggerVolume");

	Params::TriggerVolumeActorByOneFrame_SpawnOneFrameVolumeActorAndApplyParameterFromTriggerVolume Parms{};

	Parms.WorldContext = WorldContext;
	Parms.SourceVolume = SourceVolume;
	Parms.OneFrameVolumeClass = OneFrameVolumeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.RockTriggerVolumeActor.OnRockCollisionOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARockTriggerVolumeActor::OnRockCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RockTriggerVolumeActor", "OnRockCollisionOverlapBegin");

	Params::RockTriggerVolumeActor_OnRockCollisionOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.TurnGimmick.PlayEnterAnimation
// (Event, Protected, BlueprintEvent)

void ATurnGimmick::PlayEnterAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurnGimmick", "PlayEnterAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.TurnGimmick.PlayEscapeAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAxis2Direction                         Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATurnGimmick::PlayEscapeAnimation(EAxis2Direction Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurnGimmick", "PlayEscapeAnimation");

	Params::TurnGimmick_PlayEscapeAnimation Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Nicola.TurnGimmick.PlayWaitAnimation
// (Event, Protected, BlueprintEvent)

void ATurnGimmick::PlayWaitAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurnGimmick", "PlayWaitAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Nicola.UIBattleManager.DEBUG_CreatePartyMembers
// (Final, Native, Static, Public, BlueprintCallable)

void UUIBattleManager::DEBUG_CreatePartyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleManager", "DEBUG_CreatePartyMembers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIBattleManager.DEBUG_StartMBRBattle
// (Final, Native, Static, Public, BlueprintCallable)

void UUIBattleManager::DEBUG_StartMBRBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleManager", "DEBUG_StartMBRBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIBattleManager.DEBUG_StartMBRBattle2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             encountId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             playerId1                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             playerId2                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             playerId3                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MapId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIBattleManager::DEBUG_StartMBRBattle2(const class FName& encountId, const class FName& playerId1, const class FName& playerId2, const class FName& playerId3, const class FName& MapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleManager", "DEBUG_StartMBRBattle2");

	Params::UIBattleManager_DEBUG_StartMBRBattle2 Parms{};

	Parms.encountId = encountId;
	Parms.playerId1 = playerId1;
	Parms.playerId2 = playerId2;
	Parms.playerId3 = playerId3;
	Parms.MapId = MapId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIBattleManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InWCO                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIBattleManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIBattleManager* UUIBattleManager::GetInstance(const class UObject* InWCO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleManager", "GetInstance");

	Params::UIBattleManager_GetInstance Parms{};

	Parms.InWCO = InWCO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIBattleManager.DEBUG_StartResultMenu
// (Final, Native, Public, BlueprintCallable)

void UUIBattleManager::DEBUG_StartResultMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBattleManager", "DEBUG_StartResultMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIBattleMonsterName.DEBUG_GetDispRangeFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIBattleMonsterName::DEBUG_GetDispRangeFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleMonsterName", "DEBUG_GetDispRangeFlag");

	Params::UIBattleMonsterName_DEBUG_GetDispRangeFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIBattleMonsterName.DEBUG_SetDispRangeFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIBattleMonsterName::DEBUG_SetDispRangeFlag(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIBattleMonsterName", "DEBUG_SetDispRangeFlag");

	Params::UIBattleMonsterName_DEBUG_SetDispRangeFlag Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UICommonMenuCheck.DEBUG_GetForceOpenFieldMenuFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUICommonMenuCheck::DEBUG_GetForceOpenFieldMenuFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UICommonMenuCheck", "DEBUG_GetForceOpenFieldMenuFlag");

	Params::UICommonMenuCheck_DEBUG_GetForceOpenFieldMenuFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UICommonMenuCheck.DEBUG_SetForceOpenFieldMenuFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICommonMenuCheck::DEBUG_SetForceOpenFieldMenuFlag(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UICommonMenuCheck", "DEBUG_SetForceOpenFieldMenuFlag");

	Params::UICommonMenuCheck_DEBUG_SetForceOpenFieldMenuFlag Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIEndingSaveMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIEndingSaveMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEndingSaveMenu", "IsExecMenu");

	Params::UIEndingSaveMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIEndingSaveMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIEndingSaveMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEndingSaveMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIEndingStaffRollMenu.IsDebugInfoVisible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIEndingStaffRollMenu::IsDebugInfoVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEndingStaffRollMenu", "IsDebugInfoVisible");

	Params::UIEndingStaffRollMenu_IsDebugInfoVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIEndingStaffRollMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIEndingStaffRollMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEndingStaffRollMenu", "IsExecMenu");

	Params::UIEndingStaffRollMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIEndingStaffRollMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIEndingStaffRollMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEndingStaffRollMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIEndingStaffRollMenu.ToggleDebugInfoVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIEndingStaffRollMenu::ToggleDebugInfoVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEndingStaffRollMenu", "ToggleDebugInfoVisibility");

	Params::UIEndingStaffRollMenu_ToggleDebugInfoVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIEventMovieControl.BPPlayEventControlUI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsSkip                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIEventMovieControl::BPPlayEventControlUI(bool bIsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIEventMovieControl", "BPPlayEventControlUI");

	Params::UIEventMovieControl_BPPlayEventControlUI Parms{};

	Parms.bIsSkip = bIsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.DEBUG_ManpuAddItemId
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::DEBUG_ManpuAddItemId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "DEBUG_ManpuAddItemId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.DEBUG_ManpuPlayIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::DEBUG_ManpuPlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "DEBUG_ManpuPlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.DEBUG_ManpuPlayOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::DEBUG_ManpuPlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "DEBUG_ManpuPlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.DEBUG_ManpuSetPosition
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::DEBUG_ManpuSetPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "DEBUG_ManpuSetPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.GuideForceOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::GuideForceOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuideForceOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.GuideHide
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::GuideHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuideHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.GuideIsPlaying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFieldEfxMenu::GuideIsPlaying(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuideIsPlaying");

	Params::UIFieldEfxMenu_GuideIsPlaying Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.GuidePlayDecide
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldEfxMenu::GuidePlayDecide(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuidePlayDecide");

	Params::UIFieldEfxMenu_GuidePlayDecide Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.GuidePlayIn
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InPos                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFieldEfxMenu::GuidePlayIn(class FName InName, const struct FVector2D& InPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuidePlayIn");

	Params::UIFieldEfxMenu_GuidePlayIn Parms{};

	Parms.InName = InName;
	Parms.InPos = std::move(InPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.GuidePlayOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldEfxMenu::GuidePlayOut(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuidePlayOut");

	Params::UIFieldEfxMenu_GuidePlayOut Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.GuideSetPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InPos                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFieldEfxMenu::GuideSetPosition(int32 InHandle, const struct FVector2D& InPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuideSetPosition");

	Params::UIFieldEfxMenu_GuideSetPosition Parms{};

	Parms.InHandle = InHandle;
	Parms.InPos = std::move(InPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.GuideShow
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::GuideShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "GuideShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.ManpuHide
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::ManpuHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.ManpuIsPlaying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFieldEfxMenu::ManpuIsPlaying(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuIsPlaying");

	Params::UIFieldEfxMenu_ManpuIsPlaying Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.ManpuPlayIn
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InPos                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFieldEfxMenu::ManpuPlayIn(class FName InName, const struct FVector2D& InPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuPlayIn");

	Params::UIFieldEfxMenu_ManpuPlayIn Parms{};

	Parms.InName = InName;
	Parms.InPos = std::move(InPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.ManpuPlayOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldEfxMenu::ManpuPlayOut(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuPlayOut");

	Params::UIFieldEfxMenu_ManpuPlayOut Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.ManpuSetPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InPos                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFieldEfxMenu::ManpuSetPosition(int32 InHandle, const struct FVector2D& InPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuSetPosition");

	Params::UIFieldEfxMenu_ManpuSetPosition Parms{};

	Parms.InHandle = InHandle;
	Parms.InPos = std::move(InPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.ManpuSetScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFieldEfxMenu::ManpuSetScale(int32 InHandle, float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuSetScale");

	Params::UIFieldEfxMenu_ManpuSetScale Parms{};

	Parms.InHandle = InHandle;
	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldEfxMenu.ManpuShow
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::ManpuShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "ManpuShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.RetryGuidePlayIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::RetryGuidePlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "RetryGuidePlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.RetryGuidePlayOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::RetryGuidePlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "RetryGuidePlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.VehicleGuidePlayIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::VehicleGuidePlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "VehicleGuidePlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldEfxMenu.VehicleGuidePlayOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIFieldEfxMenu::VehicleGuidePlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldEfxMenu", "VehicleGuidePlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIFieldTacticsRecordMenuWindowTop.GetDebugRecordCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDEBUG_RecordCategory                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFieldTacticsRecordMenuWindowTop::GetDebugRecordCount(EDEBUG_RecordCategory Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldTacticsRecordMenuWindowTop", "GetDebugRecordCount");

	Params::UIFieldTacticsRecordMenuWindowTop_GetDebugRecordCount Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIFieldTacticsRecordMenuWindowTop.SetDebugRecordCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDEBUG_RecordCategory                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldTacticsRecordMenuWindowTop::SetDebugRecordCount(EDEBUG_RecordCategory Index_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFieldTacticsRecordMenuWindowTop", "SetDebugRecordCount");

	Params::UIFieldTacticsRecordMenuWindowTop_SetDebugRecordCount Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIJobChangeMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIJobChangeMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIJobChangeMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIKeyboardNameMenuKeyboardListTop.OnChangeText
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIKeyboardNameMenuKeyboardListTop::OnChangeText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIKeyboardNameMenuKeyboardListTop", "OnChangeText");

	Params::UIKeyboardNameMenuKeyboardListTop_OnChangeText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIKeyboardNameMenuKeyboardListTop.OnCommitText
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIKeyboardNameMenuKeyboardListTop::OnCommitText(const class FText& InText, ETextCommit InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIKeyboardNameMenuKeyboardListTop", "OnCommitText");

	Params::UIKeyboardNameMenuKeyboardListTop_OnCommitText Parms{};

	Parms.InText = std::move(InText);
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_AddUnscoutedSpecies
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_AddUnscoutedSpecies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_AddUnscoutedSpecies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_ClearBattleRoadRank
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_ClearBattleRoadRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_ClearBattleRoadRank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_PrepareForEntry
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_PrepareForEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_PrepareForEntry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_PrepareForInfo
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_PrepareForInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_PrepareForInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_PrepareForZoo
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_PrepareForZoo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_PrepareForZoo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_ScoutAllMonsters
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_ScoutAllMonsters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_ScoutAllMonsters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_SetBattleRoadData
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_SetBattleRoadData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_SetBattleRoadData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_SetupForEntry
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRDebugFL::DEBUG_SetupForEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_SetupForEntry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRDebugFL.DEBUG_SetupForResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InWin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMBRDebugFL::DEBUG_SetupForResult(bool InWin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRDebugFL", "DEBUG_SetupForResult");

	Params::UIMBRDebugFL_DEBUG_SetupForResult Parms{};

	Parms.InWin = InWin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBREntryMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMBREntryMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBREntryMenu", "IsExecMenu");

	Params::UIMBREntryMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIMBREntryMenu.OpenMenuForEntry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMBREntryMenu::OpenMenuForEntry(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBREntryMenu", "OpenMenuForEntry");

	Params::UIMBREntryMenu_OpenMenuForEntry Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBREntryMenu.OpenMenuForResult
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBREntryMenu::OpenMenuForResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBREntryMenu", "OpenMenuForResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRInfoMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMBRInfoMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRInfoMenu", "IsExecMenu");

	Params::UIMBRInfoMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIMBRInfoMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRInfoMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRInfoMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRRecruitMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RecruitMonsterSpeciesID                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMBRRecruitMenu::OpenMenu(class FName RecruitMonsterSpeciesID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRRecruitMenu", "OpenMenu");

	Params::UIMBRRecruitMenu_OpenMenu Parms{};

	Parms.RecruitMonsterSpeciesID = RecruitMonsterSpeciesID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMBRZooMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMBRZooMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRZooMenu", "IsExecMenu");

	Params::UIMBRZooMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIMBRZooMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIMBRZooMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMBRZooMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMedalTradeMenu.SetupDebugMedalCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TotalNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DepositeNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMedalTradeMenu::SetupDebugMedalCount(int32 TotalNum, int32 DepositeNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMedalTradeMenu", "SetupDebugMedalCount");

	Params::UIMedalTradeMenu_SetupDebugMedalCount Parms{};

	Parms.TotalNum = TotalNum;
	Parms.DepositeNum = DepositeNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIMouseClickData.DEBUG_GetDispRangeFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMouseClickData::DEBUG_GetDispRangeFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMouseClickData", "DEBUG_GetDispRangeFlag");

	Params::UIMouseClickData_DEBUG_GetDispRangeFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIMouseClickData.DEBUG_SetDispRangeFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMouseClickData::DEBUG_SetDispRangeFlag(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIMouseClickData", "DEBUG_SetDispRangeFlag");

	Params::UIMouseClickData_DEBUG_SetDispRangeFlag Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIVisualChangeMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUIVisualChangeMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIVisualChangeMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIShopMenu.ShopUIDebugPreparation
// (Final, Native, Static, Public, BlueprintCallable)

void UUIShopMenu::ShopUIDebugPreparation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIShopMenu", "ShopUIDebugPreparation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UITestScrollMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUITestScrollMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITestScrollMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UITitle2Menu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUITitle2Menu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITitle2Menu", "IsExecMenu");

	Params::UITitle2Menu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UITitle2Menu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUITitle2Menu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITitle2Menu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UITitleDemoMenu.IsExecMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUITitleDemoMenu::IsExecMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITitleDemoMenu", "IsExecMenu");

	Params::UITitleDemoMenu_IsExecMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UITitleDemoMenu.OpenMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UUITitleDemoMenu::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITitleDemoMenu", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUIWidgetManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIWidgetManager* UUIWidgetManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIWidgetManager", "GetInstance");

	Params::UIWidgetManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIWidgetManager.ClearTitleMenuStorage
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::ClearTitleMenuStorage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "ClearTitleMenuStorage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.DEBUG_GetHideUI_MV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIWidgetManager::DEBUG_GetHideUI_MV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "DEBUG_GetHideUI_MV");

	Params::UIWidgetManager_DEBUG_GetHideUI_MV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIWidgetManager.DEBUG_GetHideUI_SS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIWidgetManager::DEBUG_GetHideUI_SS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "DEBUG_GetHideUI_SS");

	Params::UIWidgetManager_DEBUG_GetHideUI_SS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIWidgetManager.DEBUG_SetHideUI_MV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIWidgetManager::DEBUG_SetHideUI_MV(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "DEBUG_SetHideUI_MV");

	Params::UIWidgetManager_DEBUG_SetHideUI_MV Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.DEBUG_SetHideUI_SS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIWidgetManager::DEBUG_SetHideUI_SS(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "DEBUG_SetHideUI_SS");

	Params::UIWidgetManager_DEBUG_SetHideUI_SS Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.DebugShowMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InMessage                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIWidgetManager::DebugShowMessage(const class FString& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "DebugShowMessage");

	Params::UIWidgetManager_DebugShowMessage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.GetTitleMenuMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETitleMenuMessage                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETitleMenuMessage UUIWidgetManager::GetTitleMenuMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "GetTitleMenuMessage");

	Params::UIWidgetManager_GetTitleMenuMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIWidgetManager.GetTitleMenuSelectedSaveSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIWidgetManager::GetTitleMenuSelectedSaveSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "GetTitleMenuSelectedSaveSlotIndex");

	Params::UIWidgetManager_GetTitleMenuSelectedSaveSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIWidgetManager.IsTitleMenuEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIWidgetManager::IsTitleMenuEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "IsTitleMenuEnd");

	Params::UIWidgetManager_IsTitleMenuEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.UIWidgetManager.OpenBankMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenBankMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenBankMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenBarMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenBarMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenBarMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenFieldMenuTop
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenFieldMenuTop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenFieldMenuTop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenFieldPopup
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenFieldPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenFieldPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenInnMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InInnId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCallMemberIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDoChangeMap                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIWidgetManager::OpenInnMenu(class FName InInnId, int32 InCallMemberIndex, bool InDoChangeMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenInnMenu");

	Params::UIWidgetManager_OpenInnMenu Parms{};

	Parms.InInnId = InInnId;
	Parms.InCallMemberIndex = InCallMemberIndex;
	Parms.InDoChangeMap = InDoChangeMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenMedalRewardMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenMedalRewardMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenMedalRewardMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenMedalTradeMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenMedalTradeMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenMedalTradeMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenMemberCreateMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenMemberCreateMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenMemberCreateMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenShopMenuTest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InShopId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIWidgetManager::OpenShopMenuTest(class FName InShopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenShopMenuTest");

	Params::UIWidgetManager_OpenShopMenuTest Parms{};

	Parms.InShopId = InShopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenTestWidget
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenTestWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenTestWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenTitleMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenTitleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenTitleMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenTutorialTest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InGopId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIWidgetManager::OpenTutorialTest(class FName InGopId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenTutorialTest");

	Params::UIWidgetManager_OpenTutorialTest Parms{};

	Parms.InGopId = InGopId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.OpenXenlonWishMenu
// (Final, Native, Public, BlueprintCallable)

void UUIWidgetManager::OpenXenlonWishMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "OpenXenlonWishMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Nicola.UIWidgetManager.StartMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIWidgetId                             InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIWidgetManager::StartMenu(EUIWidgetId InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIWidgetManager", "StartMenu");

	Params::UIWidgetManager_StartMenu Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Nicola.VehicleEventTrigger.OnDestroyedParent
// (Final, Native, Public)

void UVehicleEventTrigger::OnDestroyedParent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleEventTrigger", "OnDestroyedParent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

