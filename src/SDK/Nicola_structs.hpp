#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Nicola

#include "Basic.hpp"

#include "Paper2D_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "ADSound_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "MovieScene_structs.hpp"


namespace SDK
{

// Enum Nicola.EAchievement
// NumValues: 0x002F
enum class EAchievement : uint8
{
	PLATINUM                                 = 0,
	ACHIEVEMENT_FIELD_Aliahan                = 1,
	ACHIEVEMENT_FIELD_IzanaiShrine           = 2,
	ACHIEVEMENT_DEFEAT_Kandata1              = 3,
	ACHIEVEMENT_DEFEAT_DemonOfNile           = 4,
	ACHIEVEMENT_DEFEAT_Kandata2              = 5,
	ACHIEVEMENT_GET_Ship                     = 6,
	ACHIEVEMENT_DEFEAT_Orochi                = 7,
	ACHIEVEMENT_DEFEAT_Warlock               = 8,
	ACHIEVEMENT_DEFEAT_GuardianOfHell        = 9,
	ACHIEVEMENT_DEFEAT_BossTroll             = 10,
	ACHIEVEMENT_DEFEAT_Revnant               = 11,
	ACHIEVEMENT_GET_Lamia                    = 12,
	ACHIEVEMENT_DEFEAT_Baramos               = 13,
	ACHIEVEMENT_FIELD_Alefgard               = 14,
	ACHIEVEMENT_DISPEL_Rubiss                = 15,
	ACHIEVEMENT_USE_RainbowDrop              = 16,
	ACHIEVEMENT_ENDING                       = 17,
	ACHIEVEMENT_COUNT_Monster                = 18,
	ACHIEVEMENT_COUNT_Item                   = 19,
	ACHIEVEMENT_COUNT_Skill                  = 20,
	ACHIEVEMENT_GET_GoldenMedal              = 21,
	ACHIEVEMENT_Xenlon                       = 22,
	ACHIEVEMENT_COUNT_Scout                  = 23,
	ACHIEVEMENT_SmallMedal                   = 24,
	ACHIEVEMENT_MBR_Victory                  = 25,
	ACHIEVEMENT_COUNT_Win                    = 26,
	ACHIEVEMENT_COUNT_Shine                  = 27,
	ACHIEVEMENT_COUNT_TotalMoney             = 28,
	ACHIEVEMENT_COUNT_Treasure               = 29,
	ACHIEVEMENT_DEFEAT_MetalSlime            = 30,
	ACHIEVEMENT_JOBCHANGE_Any                = 31,
	ACHIEVEMENT_DISPEL_Noaniel               = 32,
	ACHIEVEMENT_GET_LightHelm                = 33,
	ACHIEVEMENT_GET_SwordOfKings             = 34,
	ACHIEVEMENT_SHOP_Ripoff                  = 35,
	ACHIEVEMENT_SHOP_PiffPuff                = 36,
	ACHIEVEMENT_JOBCHANGE_Sage               = 37,
	ACHIEVEMENT_BAR_PartyMem                 = 38,
	ACHIEVEMENT_ROMARIA_BraveKing            = 39,
	ACHIEVEMENT_CHURCH_Defeated              = 40,
	ACHIEVEMENT_GoldenClaws                  = 41,
	COUNT                                    = 42,
	NONE                                     = 43,
	VERIFY                                   = 44,
	REMOVE                                   = 255,
	EAchievement_MAX                         = 256,
};

// Enum Nicola.EActorType
// NumValues: 0x001E
enum class EActorType : uint8
{
	ACTOR_TYPE_NONE                          = 0,
	ACTOR_TYPE_PLAYER                        = 1,
	ACTOR_TYPE_NPC                           = 2,
	ACTOR_TYPE_SEQUENCER                     = 3,
	ACTOR_TYPE_LUA_SPAWNED                   = 4,
	ACTOR_TYPE_MAP_OBJECT                    = 5,
	ACTOR_TYPE_MESH_DEPEND_CAMERA            = 6,
	ACTOR_TYPE_COMMAND_COLLISION             = 7,
	ACTOR_TYPE_MAP_SOUND_SOURCE              = 8,
	ACTOR_TYPE_SCREEN_SHOT                   = 9,
	ACTOR_TYPE_EFFECT_BASE                   = 10,
	ACTOR_TYPE_BATTLE_PLAYER                 = 11,
	ACTOR_TYPE_BATTLE_ENEMY                  = 12,
	ACTOR_TYPE_BATTLE_OBJECT                 = 13,
	ACTOR_TYPE_FIELD_SYMBOL                  = 14,
	ACTOR_TYPE_FIELD_EFFECT                  = 15,
	ACTOR_TYPE_FIELD_TRIGGER                 = 16,
	ACTOR_TYPE_FIELD_SPOT                    = 17,
	ACTOR_TYPE_FIELD_SYMBOL_WORLDMAP_LOCATION = 18,
	ACTOR_TYPE_FIELD_PLAYER_START            = 19,
	ACTOR_TYPE_MAP_TRANSITION                = 20,
	ACTOR_TYPE_EVENT                         = 21,
	ACTOR_TYPE_FADING_ACTOR                  = 22,
	ACTOR_TYPE_FADING_TRIGGER                = 23,
	ACTOR_TYPE_GHOSTSHIP_DRIVER              = 24,
	ACTOR_TYPE_SPAWN_MANAGEMENT_ACTOR        = 25,
	ACTOR_TYPE_SPAWN_MANAGEMENT_ACTOR_FIELD  = 26,
	ACTOR_TYPE_TOWN_SHIP_LOCATOR             = 27,
	ACTOR_TYPE_TEMP                          = 28,
	ACTOR_TYPE_MAX                           = 29,
};

// Enum Nicola.EBattleActionParamFlag
// NumValues: 0x0025
enum class EBattleActionParamFlag : uint8
{
	IsSureHit                                = 0,
	IsConfusedUse                            = 1,
	IsConfusedUse_Single                     = 2,
	IsCounterDamage                          = 3,
	IsNageki                                 = 4,
	IsCopOut                                 = 5,
	IsCoverUp                                = 6,
	IsHealSleep                              = 7,
	IsMahoton                                = 8,
	IsMahokanta                              = 9,
	IsBreath                                 = 10,
	IsManusa                                 = 11,
	IsBaikiruto                              = 12,
	IsPowerCharge                            = 13,
	IsMagicAwake                             = 14,
	IsOrder                                  = 15,
	IsKaishin                                = 16,
	IsExp                                    = 17,
	IsGold                                   = 18,
	IsItem                                   = 19,
	IsConcentration                          = 20,
	IsNormalAttack                           = 21,
	IsAsutoron                               = 22,
	IsCurse                                  = 23,
	IsRace                                   = 24,
	IsMultiAttack                            = 25,
	IsMultiMagic                             = 26,
	IsDokubari_Dead                          = 27,
	IsDokubari_1                             = 28,
	IsPhysical                               = 29,
	IsMagic                                  = 30,
	IsMPAbsorb                               = 31,
	IsChangeTarget                           = 32,
	IsExcludeRental                          = 33,
	IsCanNotTargetSelf                       = 34,
	IsMultiAction                            = 35,
	EBattleActionParamFlag_MAX               = 36,
};

// Enum Nicola.EAttachEventGetType
// NumValues: 0x000D
enum class EAttachEventGetType : uint8
{
	MAX                                      = 0,
	MIN                                      = 1,
	SUM                                      = 2,
	MULTIPLE_RATE                            = 3,
	MULTIPLE_PERCENT_RATE                    = 4,
	BOOL_ANY                                 = 5,
	LAST_NAME                                = 6,
	EXEC_ALL                                 = 7,
	EXEC_UNTIL_SUCCESS                       = 8,
	EXEC_UNTIL_FAILED                        = 9,
	GET_ALL                                  = 10,
	INT_PLUS                                 = 11,
	INT_MINUS                                = 12,
};

// Enum Nicola.EAttachEventType
// NumValues: 0x0057
enum class EAttachEventType : uint8
{
	NONE                                     = 0,
	GET_ADD_OFFENSE                          = 1,
	GET_ADD_DEFENSE                          = 2,
	GET_ADD_SPEED                            = 3,
	GET_OFFENSE_EFFECT_VALUE                 = 4,
	GET_DEFFENSE_EFFECT_VALUE                = 5,
	GET_SPEED_EFFECT_VALUE                   = 6,
	GET_ADD_AVOID                            = 7,
	GET_BAIKIRUTO_DAMAGE_PERCENT_RATE        = 8,
	GET_POWER_CHARGE_DAMAGE_PERCENT_RATE     = 9,
	GET_POWER_DOWN_PERCENT_RATE              = 10,
	GET_SPELL_ATTACK_UP_PERCENT_RATE         = 11,
	GET_SPELL_WEAKNESS_PERCENT_RATE          = 12,
	GET_DESPERATE_DAMAGE_RATE                = 13,
	EXEC_COVER_REGISTER                      = 14,
	EXEC_COVER_UNREGISTER                    = 15,
	EXEC_ASOBI_REGISTER                      = 16,
	EXEC_ASOBI_UNREGISTER                    = 17,
	MANUSA_MISS_PERCENT                      = 18,
	GET_NO_DAMAGE_PERCENT                    = 19,
	GET_DAMAGE_PERCENT_RATE                  = 20,
	GET_PARRY_ENEMY_PERCENT                  = 21,
	GET_PARRY_PARTY_PERCENT                  = 22,
	GET_COVER_TARGET                         = 23,
	GET_ASOBI_TARGET                         = 24,
	IS_ALL_COVER                             = 25,
	GET_ALL_COVER_PRIORITY                   = 26,
	GET_DAMAGE_DOWN                          = 27,
	GET_ADD_ACTION_COUNT                     = 28,
	GET_USE_ACTION_COUNT                     = 29,
	EXEC_ACTION_COUNT_INCREMENT              = 30,
	BASE_DAMAGE_1                            = 31,
	GET_KILL_PERCENT_RATE                    = 32,
	GET_MAGIC_ATTACK_PERCENT_RATE            = 33,
	GET_MAGIC_DAMAGE_PERCENT_RATE            = 34,
	GET_RESIST_PERCENT_RATE                  = 35,
	GET_RESIST_DAMAGE_PERCENT_EQUIP          = 36,
	GET_RESIST_DAMAGE_PERCENT_RATE           = 37,
	GET_ADD_ATTACK_COUNT                     = 38,
	GET_ADD_MAGIC_COUNT                      = 39,
	GET_USE_MAGIC_COUNT                      = 40,
	EXEC_MAGIC_COUNT_INCREMENT               = 41,
	EXEC_MAGIC_COUNT_RESET                   = 42,
	EXEC_MAGIC_COUNT_FULL                    = 43,
	GET_NORMAL_ATTACK_ID                     = 44,
	GET_MULTI_ATTACK_DAMAGE_RATE             = 45,
	GET_ADD_REGENATION_BASE                  = 46,
	GET_ADD_REGENATION_RANGE                 = 47,
	GET_ADD_MP_REGENATION_BASE               = 48,
	GET_ADD_MP_REGENATION_RANGE              = 49,
	GET_COST_MP_SAVING_PERCENT_RATE          = 50,
	GET_ATTACK_MP_DOWN                       = 51,
	GET_ATTACK_MP_UP                         = 52,
	GET_DRAGON_KILLER_DAMAGE_RATE            = 53,
	GET_ZOMBIE_KILLER_DAMAGE_RATE            = 54,
	GET_BEAST_KILLER_DAMAGE_RATE             = 55,
	GET_KAIJIN_KILLER_DAMAGE_RATE            = 56,
	GET_INSECT_KILLER_DAMAGE_RATE            = 57,
	GET_DRAGON_KILLER_DAMAGE_ADD             = 58,
	GET_ZOMBIE_KILLER_DAMAGE_ADD             = 59,
	GET_BEAST_KILLER_DAMAGE_ADD              = 60,
	GET_KAIJIN_KILLER_DAMAGE_ADD             = 61,
	GET_INSECT_KILLER_DAMAGE_ADD             = 62,
	GET_METAL_KILLER_ACCURACY                = 63,
	GET_METAL_KILLER_CRITICAL_RATE           = 64,
	GET_CRITICAL_PERCENT_RATE                = 65,
	IS_DODGE_DEATH                           = 66,
	EXEC_DODGE_DEATH_CONSUME                 = 67,
	GET_ATTACH_ATTRIBUTE                     = 68,
	GET_ACCURACY_DOWN_PERCENT_RATE           = 69,
	GET_REFLECTION_MAGIC_PERCENT_RATE        = 70,
	GET_REFLECTION_DAMAGE_ENEMY_PERCENT_RATE = 71,
	GET_CURSE_PAIN_SPLIT_PERCENT_RATE        = 72,
	GET_DOUBLE_EDGE_DAMAGE_PERCENT_RATE      = 73,
	GET_CURSE_BIND_PERCENT_RATE              = 74,
	IS_CURSE_CONFUSION                       = 75,
	IS_CURSE_UNLUCK                          = 76,
	EXEC_CHECK_PLAY_ACTION                   = 77,
	EXEC_SET_PLAY_ACTION                     = 78,
	IS_SET_PLAY_ACTION                       = 79,
	GET_PLAY_RATE                            = 80,
	GET_MERCHANT_GOLD_PERCENT_RATE           = 81,
	GET_MERCHANT_ADD_GOLD_RATE               = 82,
	GET_STEAL_RATE                           = 83,
	GET_ORDEAL_ATTACK_DAMAGE_RATE            = 84,
	GET_ORDEAL_DEFENSE_DAMAGE_RATE           = 85,
	MAX                                      = 86,
};

// Enum Nicola.EBattleCameraSettingType
// NumValues: 0x0003
enum class EBattleCameraSettingType : uint8
{
	Back                                     = 0,
	Front                                    = 1,
	EBattleCameraSettingType_MAX             = 2,
};

// Enum Nicola.EBattleTargetMaskType
// NumValues: 0x000C
enum class EBattleTargetMaskType : uint8
{
	SINGLE                                   = 0,
	GROUP                                    = 32,
	NONE                                     = 64,
	MONSTER_ALL                              = 65,
	PLAYER_ALL                               = 66,
	ALL                                      = 67,
	ENEMY_ALL                                = 68,
	FRIEND_ALL                               = 72,
	EXCEPT_USER_ALL                          = 80,
	EXCEPT_USER_PARTY                        = 96,
	EXCEPT_USER_ENEMY                        = 112,
	EBattleTargetMaskType_MAX                = 113,
};

// Enum Nicola.EBattleAISelectActionOption
// NumValues: 0x0004
enum class EBattleAISelectActionOption : uint8
{
	NONE                                     = 0,
	SUPPORT                                  = 1,
	DAMAGE                                   = 2,
	EBattleAISelectActionOption_MAX          = 3,
};

// Enum Nicola.EBattleMonsterRace
// NumValues: 0x0009
enum class EBattleMonsterRace : uint8
{
	NONE                                     = 0,
	DRAGON                                   = 1,
	ZOMBIE                                   = 2,
	KAIJIN                                   = 3,
	BEAST                                    = 4,
	INSECT                                   = 5,
	METAL                                    = 6,
	FLY                                      = 7,
	EBattleMonsterRace_MAX                   = 8,
};

// Enum Nicola.EBattleActionParamType
// NumValues: 0x0006
enum class EBattleActionParamType : uint8
{
	NONE                                     = 0,
	MAGIC                                    = 1,
	ITEM                                     = 2,
	MONSTER_ACTION                           = 3,
	OTHER                                    = 4,
	EBattleActionParamType_MAX               = 5,
};

// Enum Nicola.EBattleActionSpecialTargetType
// NumValues: 0x0003
enum class EBattleActionSpecialTargetType : uint8
{
	NONE                                     = 0,
	MOST_LOW_HP_PLAYER                       = 1,
	EBattleActionSpecialTargetType_MAX       = 2,
};

// Enum Nicola.EBattlePlayEventScriptType
// NumValues: 0x0004
enum class EBattlePlayEventScriptType : uint8
{
	DEFAULT                                  = 0,
	EXCLUSION                                = 1,
	MERGE                                    = 2,
	EBattlePlayEventScriptType_MAX           = 3,
};

// Enum Nicola.EBattleCriticalType
// NumValues: 0x0005
enum class EBattleCriticalType : uint8
{
	DEFAULT                                  = 0,
	KAISHIN_ALL                              = 1,
	KAISHIN_SKILL                            = 2,
	NONE                                     = 3,
	EBattleCriticalType_MAX                  = 4,
};

// Enum Nicola.EBattleActionRegistlType
// NumValues: 0x0004
enum class EBattleActionRegistlType : uint8
{
	DEFAULT                                  = 0,
	REGIST                                   = 1,
	WEAK                                     = 2,
	EBattleActionRegistlType_MAX             = 3,
};

// Enum Nicola.EBattleMessageWaitMode
// NumValues: 0x0005
enum class EBattleMessageWaitMode : uint8
{
	AUTO_CLOSE                               = 0,
	WAIT_CLOSE                               = 1,
	WAIT_TIME                                = 2,
	WAIT_NOTIFY                              = 3,
	EBattleMessageWaitMode_MAX               = 4,
};

// Enum Nicola.EBattleCounterType
// NumValues: 0x000A
enum class EBattleCounterType : uint8
{
	NONE                                     = 0,
	MAHOKANTA                                = 1,
	COUNTER_BREATH                           = 2,
	DOUBLE_EDGE                              = 3,
	COUNTER_ATTACK                           = 4,
	PARRY                                    = 5,
	COVER_UP                                 = 6,
	ALL_COVER                                = 7,
	ABSORB_MP                                = 8,
	EBattleCounterType_MAX                   = 9,
};

// Enum Nicola.EBattleActionResultType
// NumValues: 0x0025
enum class EBattleActionResultType : uint8
{
	NONE                                     = 0,
	DEFAULT                                  = 1,
	YOKE                                     = 2,
	ASUTORON                                 = 3,
	NODAMAGE                                 = 4,
	NODAMAGE_PHYSICS                         = 5,
	MISS                                     = 6,
	KAISHIN                                  = 7,
	DOKUBARI                                 = 8,
	MAHOKANTA                                = 9,
	COUNTER_BREATH                           = 10,
	DOUBLE_EDGE                              = 11,
	PARRY_ENEMY                              = 12,
	PARRY_PARTY                              = 13,
	COVER_UP                                 = 14,
	ALL_COVER                                = 15,
	CURSE_BIND                               = 16,
	LINK_MISS                                = 17,
	ATTACK_SLEEP_OFF                         = 18,
	ATTACK_CONFUSION_OFF                     = 19,
	DODGE_DEATH                              = 20,
	SUCCESS                                  = 21,
	FAILURE                                  = 22,
	FAILURE_2                                = 23,
	FAILURE_BEFORE_DAMAGE                    = 24,
	FAILURE_COMBINATION                      = 25,
	FAILURE_PERFECT_RESIST                   = 26,
	DEPLICATE_SUCCESS                        = 27,
	DEPLICATE_FAILED                         = 28,
	SPECIAL                                  = 29,
	SELF_DESTRUCT                            = 30,
	SUCCESS_MP_DRAIN                         = 31,
	FAILURE_MP_DRAIN                         = 32,
	SUCCESS_MP_DRAIN_USER                    = 33,
	FAILURE_MP_DRAIN_USER                    = 34,
	OUT_OF_EFFECT                            = 35,
	EBattleActionResultType_MAX              = 36,
};

// Enum Nicola.EBattleDamageFactor
// NumValues: 0x0025
enum class EBattleDamageFactor : uint8
{
	NONE                                     = 0,
	ATTACK                                   = 1,
	DEFENSE                                  = 2,
	ATTACKER_LUCK                            = 3,
	ATTACKER_BASE_LUCK                       = 4,
	TARGET_NUM                               = 5,
	TARGET_RANGE                             = 6,
	ATTACK_DAMAGE_RATE                       = 7,
	DEFENSE_DAMAGE_RATE                      = 8,
	MULTI_ATTACK_DAMAGE_RATE                 = 9,
	ATTACK_RACE_DAMAGE_RATE                  = 10,
	ATTACK_RACE_DAMAGE_ADD                   = 11,
	ATTACK_RACE_DAMAGE_MIN                   = 12,
	ATTRIBUTE_DAMAGE_RATE                    = 13,
	SKILL_DEFENSE_DAMAGE_RATE                = 14,
	EQUIP_DAMAGE_RATE                        = 15,
	OVERRIDE_DAMAGE                          = 16,
	SKILL_SPECIAL_OVERRIDE_DAMAGE            = 17,
	SKILL_ATTACK_DAMAGE_RATE                 = 18,
	SKILL_ATTACK_DAMAGE_ADD                  = 19,
	SKILL_ATTACK_DAMAGE_MIN                  = 20,
	IS_SKILL_ATTACK_RANDOM                   = 21,
	SKILL_RACE_DAMAGE_RATE                   = 22,
	SPELL_BASE_DAMAGE                        = 23,
	DEFENSE_RESIST_DAMAGE_RATE               = 24,
	ATTACKER_INT                             = 25,
	ATTACKER_BASE_INT                        = 26,
	MULTI_SPELL_DAMAGE_RATE                  = 27,
	SPELL_ATTACK_DAMAGE_RATE                 = 28,
	SPELL_DEFENSE_DAMAGE_RATE                = 29,
	SPELL_EQUIP_ATTACK_DAMAGE_RATE           = 30,
	SPELL_EQUIP_DAMAGE_RATE                  = 31,
	SPELL_METAL_DAMAGE_RATE                  = 32,
	ORDEAL_ATTACK_DAMAGE_RATE                = 33,
	ORDEAL_DEFENSE_DAMAGE_RATE               = 34,
	IS_CRITICAL                              = 35,
	MAX                                      = 36,
};

// Enum Nicola.EBattleDamageCalcType
// NumValues: 0x0007
enum class EBattleDamageCalcType : uint8
{
	NONE                                     = 0,
	NORMAL                                   = 1,
	SPELL                                    = 2,
	BREATH                                   = 3,
	SKILL_NORMAL                             = 4,
	SKILL_RANGE                              = 5,
	EBattleDamageCalcType_MAX                = 6,
};

// Enum Nicola.EBattleSpeed
// NumValues: 0x0004
enum class EBattleSpeed : uint8
{
	NORMAL                                   = 0,
	FAST                                     = 1,
	VERY_FAST                                = 2,
	EBattleSpeed_MAX                         = 3,
};

// Enum Nicola.EBattleUnitCommand
// NumValues: 0x0007
enum class EBattleUnitCommand : uint8
{
	NONE                                     = 0,
	ATTACK                                   = 1,
	ITEM                                     = 2,
	SPELL                                    = 3,
	SKILL                                    = 4,
	GUARD                                    = 5,
	EBattleUnitCommand_MAX                   = 6,
};

// Enum Nicola.EBattlePartyCommand
// NumValues: 0x0006
enum class EBattlePartyCommand : uint8
{
	NONE                                     = 0,
	BATTLE                                   = 1,
	RUN                                      = 2,
	TACTICS                                  = 3,
	SPHERE_OF_LIGHT                          = 4,
	EBattlePartyCommand_MAX                  = 5,
};

// Enum Nicola.EBattleUnitType
// NumValues: 0x0003
enum class EBattleUnitType : uint8
{
	PLAYER                                   = 0,
	ENEMY                                    = 1,
	EBattleUnitType_MAX                      = 2,
};

// Enum Nicola.EBattleLoseType
// NumValues: 0x0003
enum class EBattleLoseType : uint8
{
	DEFAULT                                  = 0,
	TURN                                     = 1,
	EBattleLoseType_MAX                      = 2,
};

// Enum Nicola.EBattleWinType
// NumValues: 0x0006
enum class EBattleWinType : uint8
{
	NO_EXIST                                 = 0,
	GONE                                     = 1,
	VANISH                                   = 2,
	GONE_GOLD_ITEM                           = 3,
	DEFAULT                                  = 4,
	EBattleWinType_MAX                       = 5,
};

// Enum Nicola.EBattleEndType
// NumValues: 0x0006
enum class EBattleEndType : uint8
{
	NONE                                     = 0,
	WIN                                      = 1,
	LOSE                                     = 2,
	RUN                                      = 3,
	RURA                                     = 8,
	EBattleEndType_MAX                       = 9,
};

// Enum Nicola.EBattleAIUnitParam
// NumValues: 0x0019
enum class EBattleAIUnitParam : uint8
{
	NONE                                     = 0,
	HP                                       = 1,
	MAX_HP                                   = 2,
	MP                                       = 3,
	MAX_MP                                   = 4,
	BASE_OFFENSE                             = 5,
	BASE_DEFENSE                             = 6,
	BASE_SPEED                               = 7,
	OFFENSE                                  = 8,
	DEFENSE                                  = 9,
	SPEED                                    = 10,
	USE_SPELL                                = 11,
	USE_ATTACK_SPELL                         = 12,
	USE_SKILL                                = 13,
	USE_MAHOTON_ACTION                       = 14,
	USE_BREATH                               = 15,
	USE_ATTACK_CRITICAL                      = 16,
	UNIT_CLASS                               = 17,
	GENDER                                   = 18,
	OFFENSE_EFFECT_VALUE                     = 19,
	DEFFENSE_EFFECT_VALUE                    = 20,
	SPEED_EFFECT_VALUE                       = 21,
	GROUP                                    = 22,
	METAL                                    = 23,
	MAX                                      = 24,
};

// Enum Nicola.EBattleInitiative
// NumValues: 0x0005
enum class EBattleInitiative : uint8
{
	INITIATIVE_NONE                          = 0,
	INITIATIVE_PLAYER                        = 1,
	INITIATIVE_MONSTER                       = 2,
	INITIATIVE_RUN_MONSTER                   = 3,
	INITIATIVE_MAX                           = 4,
};

// Enum Nicola.EBattleCondition
// NumValues: 0x003D
enum class EBattleCondition : uint8
{
	ALIVE                                    = 0,
	COMP_GROUP                               = 1,
	FEMALE                                   = 2,
	MONSTER                                  = 3,
	PLAYER                                   = 4,
	MANUSA                                   = 5,
	MAHOTON                                  = 6,
	MAHOKANTA                                = 7,
	SPD                                      = 8,
	BAIKIRUTO                                = 9,
	CONFUSE                                  = 10,
	ASUTORON                                 = 11,
	SLEEP                                    = 12,
	MP                                       = 13,
	DEFENCE                                  = 14,
	DEFENCE_MAX                              = 15,
	ASOBI                                    = 16,
	FUBAHA                                   = 17,
	HP_HALF                                  = 18,
	POISON                                   = 19,
	PARALYZE                                 = 20,
	STUN                                     = 21,
	TIME_STOP                                = 22,
	HP_3                                     = 23,
	COMP_DEFENCE                             = 24,
	COMP_MONSTER_ID                          = 25,
	COMP_MONSTER_MASTER_ID                   = 26,
	COMP_MONSTER_TEXT_ID                     = 27,
	MONSTER_PARAM                            = 28,
	ALL                                      = 29,
	MONSTER_SPACE                            = 30,
	COMP_HP                                  = 31,
	DORAGORAMU                               = 32,
	HERO                                     = 33,
	HAS_ITETSUKU_EFFECT                      = 34,
	HAS_RESIST_ATTRIBUTE                     = 35,
	ATTACKER                                 = 36,
	HEALER                                   = 37,
	SUPPORTER                                = 38,
	BOSS                                     = 39,
	HAS_STATUS_CHANGE                        = 40,
	CAN_ADD_STATUS_CHANGE                    = 41,
	LOWER_EFFECT_VALUE                       = 42,
	ORDER_AFTER                              = 43,
	PLAY_ACTION                              = 44,
	COMP_CAN_USE_ACTION_ID                   = 45,
	COMP_HAS_ACTION_ID                       = 46,
	COMP_RESERVED_ACTION_ID                  = 47,
	COMP_EQUIP                               = 48,
	COMP_HAS_ITEM                            = 49,
	METAL                                    = 50,
	PARTY                                    = 51,
	ENEMY                                    = 52,
	USE_SPELL                                = 53,
	USE_ATTACK_SPELL                         = 54,
	USE_SKILL                                = 55,
	USE_MAHOTON_ACTION                       = 56,
	USE_BREATH                               = 57,
	COMMAND                                  = 58,
	RENTAL                                   = 59,
	EBattleCondition_MAX                     = 60,
};

// Enum Nicola.EBattleState
// NumValues: 0x0014
enum class EBattleState : uint8
{
	NONE                                     = 0,
	OPENLEVEL                                = 1,
	ENCOUNT                                  = 2,
	START                                    = 3,
	INIT                                     = 4,
	WAIT_MENU                                = 5,
	TURN_START                               = 6,
	TURN_END                                 = 7,
	ACTION_START                             = 8,
	ACTION_END                               = 9,
	ACTION_EFFECT                            = 10,
	ACTION_MESSAGE                           = 11,
	ACTION_SCRIPT                            = 12,
	ATTACK                                   = 13,
	SCRIPT                                   = 14,
	WIN                                      = 15,
	LOSE                                     = 16,
	RUN                                      = 17,
	END                                      = 18,
	EBattleState_MAX                         = 19,
};

// Enum Nicola.EBattleLuaValueType
// NumValues: 0x0006
enum class EBattleLuaValueType : uint8
{
	NONE                                     = 0,
	INT                                      = 1,
	DOUBLE                                   = 2,
	BOOL                                     = 3,
	STRING                                   = 4,
	EBattleLuaValueType_MAX                  = 5,
};

// Enum Nicola.EBattleTestActorMode
// NumValues: 0x0003
enum class EBattleTestActorMode : uint8
{
	LOCAL                                    = 0,
	GOP_LOOKS                                = 1,
	EBattleTestActorMode_MAX                 = 2,
};

// Enum Nicola.EBattleBuffDebuffFlag
// NumValues: 0x000F
enum class EBattleBuffDebuffFlag : uint64
{
	NONE                                     = 0,
	OFFENSE_UP                               = 1,
	OFFENSE_DOWN                             = 2,
	DEFENSE_UP                               = 4,
	DEFENSE_DOWN                             = 8,
	SPEED_UP                                 = 16,
	SPEED_DOWN                               = 32,
	AVOID_UP                                 = 64,
	AVOID_DOWN                               = 128,
	POWER_DOWN                               = 256,
	SPELL_ATTACK_UP                          = 512,
	SPELL_DAMAGE_DOWN                        = 1024,
	SPELL_WEAKNESS                           = 2048,
	ALL                                      = 18446744073709551615,
	EBattleBuffDebuffFlag_MAX                = 2049,
};

// Enum Nicola.EBattleParamFlag
// NumValues: 0x0012
enum class EBattleParamFlag : uint64
{
	NONE                                     = 0,
	GUARD                                    = 1,
	CONFUSE_OFF                              = 2,
	SLEEP_OFF                                = 4,
	LOW_MP                                   = 8,
	ASOBI                                    = 16,
	DEFENCE_MAX                              = 32,
	DROP_ITEM                                = 64,
	USE_ITEM                                 = 128,
	TURN_SKIP                                = 256,
	DESPERATE                                = 512,
	TIME_STOP_USER                           = 1024,
	COVER_USER                               = 2048,
	ASOBI_USER                               = 4096,
	REVIVE_TURN                              = 8192,
	REMOVE                                   = 6967,
	ALL                                      = 18446744073709551615,
	EBattleParamFlag_MAX                     = 8193,
};

// Enum Nicola.EBgmPlayerDelayCallOptionFlag
// NumValues: 0x0005
enum class EBgmPlayerDelayCallOptionFlag : uint8
{
	NONE                                     = 0,
	STOP                                     = 1,
	PAUSE                                    = 2,
	ALL                                      = 255,
	EBgmPlayerDelayCallOptionFlag_MAX        = 256,
};

// Enum Nicola.EBgmPlayerState
// NumValues: 0x0006
enum class EBgmPlayerState : uint8
{
	NOP                                      = 0,
	IDLE                                     = 1,
	PAUSE                                    = 2,
	PLAYING                                  = 3,
	FADE_OUT                                 = 4,
	EBgmPlayerState_MAX                      = 5,
};

// Enum Nicola.EBgmType
// NumValues: 0x0005
enum class EBgmType : uint8
{
	INVALID                                  = 0,
	MAIN                                     = 1,
	JINGLE                                   = 2,
	BATTLE                                   = 3,
	EBgmType_MAX                             = 4,
};

// Enum Nicola.EPartyAlignmentMoveType
// NumValues: 0x0008
enum class EPartyAlignmentMoveType : uint8
{
	Walk                                     = 0,
	Dash                                     = 1,
	Warp                                     = 2,
	Owner                                    = 3,
	Constant                                 = 4,
	Flexible                                 = 5,
	Num                                      = 6,
	EPartyAlignmentMoveType_MAX              = 7,
};

// Enum Nicola.EPartyAlignmentType
// NumValues: 0x000A
enum class EPartyAlignmentType : uint8
{
	Together                                 = 0,
	Straight                                 = 1,
	Together_Old                             = 2,
	Straight_Old                             = 3,
	Num                                      = 4,
	Idle                                     = 5,
	Uninit                                   = 6,
	Landing                                  = 7,
	Ladder                                   = 8,
	EPartyAlignmentType_MAX                  = 9,
};

// Enum Nicola.EOrientationType
// NumValues: 0x0007
enum class EOrientationType : uint8
{
	Current                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	PlayerStart                              = 5,
	EOrientationType_MAX                     = 6,
};

// Enum Nicola.ENicolaCameraKeepOutDirection
// NumValues: 0x0004
enum class ENicolaCameraKeepOutDirection : uint8
{
	BothDirections                           = 0,
	XPosDirectionOnly                        = 1,
	XNegDirectionOnly                        = 2,
	ENicolaCameraKeepOutDirection_MAX        = 3,
};

// Enum Nicola.ENicolaCameraCollisionInterpolationType
// NumValues: 0x0004
enum class ENicolaCameraCollisionInterpolationType : uint8
{
	ByPlayerMoving                           = 0,
	ByTimeElapsing                           = 1,
	NoInterpolation                          = 2,
	ENicolaCameraCollisionInterpolationType_MAX = 3,
};

// Enum Nicola.ENicolaCameraCollisionType
// NumValues: 0x0007
enum class ENicolaCameraCollisionType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	KeepOut                                  = 2,
	Cancel                                   = 3,
	ForCorrectingOnly_Normal                 = 4,
	ForCorrectingOnly_KeepOut                = 5,
	ENicolaCameraCollisionType_MAX           = 6,
};

// Enum Nicola.ECaptureState
// NumValues: 0x0006
enum class ECaptureState : uint8
{
	NONE                                     = 0,
	CAPTURE                                  = 1,
	CREATE_TEXTURE                           = 2,
	SAVE_WAIT                                = 3,
	SAVE                                     = 4,
	ECaptureState_MAX                        = 5,
};

// Enum Nicola.EDebugMenuCustomItemType
// NumValues: 0x0005
enum class EDebugMenuCustomItemType : uint8
{
	BUTTON                                   = 0,
	TOGGLE                                   = 1,
	SLIDER                                   = 2,
	SELECT                                   = 3,
	EDebugMenuCustomItemType_MAX             = 4,
};

// Enum Nicola.EUnitResidentBelongStatus
// NumValues: 0x0007
enum class EUnitResidentBelongStatus : uint8
{
	INVALID                                  = 0,
	PARTY                                    = 1,
	STANDBY                                  = 2,
	LEAVE                                    = 3,
	ITEM_BAG                                 = 4,
	TEMPORARY                                = 5,
	EUnitResidentBelongStatus_MAX            = 6,
};

// Enum Nicola.ECloneUnitLooksType
// NumValues: 0x0006
enum class ECloneUnitLooksType : uint8
{
	Default                                  = 0,
	DisableSkill                             = 1,
	DisableCostume                           = 2,
	DisableCoffin                            = 4,
	DisableAll                               = 255,
	ECloneUnitLooksType_MAX                  = 256,
};

// Enum Nicola.ENicolaUnitDataTypeFlag
// NumValues: 0x0008
enum class ENicolaUnitDataTypeFlag : uint16
{
	NONE                                     = 0,
	NPC                                      = 1,
	FRIEND                                   = 2,
	ENEMY                                    = 4,
	BATTLER                                  = 8,
	FLIPBOOK                                 = 16,
	ALL                                      = 65535,
	ENicolaUnitDataTypeFlag_MAX              = 65536,
};

// Enum Nicola.EDoorLightType
// NumValues: 0x0003
enum class EDoorLightType : uint8
{
	NightOnly                                = 0,
	Always                                   = 1,
	EDoorLightType_MAX                       = 2,
};

// Enum Nicola.EDoorSeType
// NumValues: 0x0006
enum class EDoorSeType : uint8
{
	Normal                                   = 0,
	Jail                                     = 1,
	Large                                    = 2,
	Castle                                   = 3,
	Custom                                   = 4,
	EDoorSeType_MAX                          = 5,
};

// Enum Nicola.ELockType
// NumValues: 0x0008
enum class ELockType : uint8
{
	Normal                                   = 0,
	Thief                                    = 1,
	Magic                                    = 2,
	Last                                     = 3,
	Special                                  = 4,
	NotOpen                                  = 5,
	Unused                                   = 6,
	ELockType_MAX                            = 7,
};

// Enum Nicola.EMBRScoutResult
// NumValues: 0x0008
enum class EMBRScoutResult : uint8
{
	Success                                  = 0,
	SuccessDisguiseHuman                     = 1,
	FailedDisguiseHuman                      = 2,
	FailedEscapeLook                         = 3,
	FailedEscapeSound                        = 4,
	FailedEscapeSmell                        = 5,
	Failed                                   = 6,
	EMBRScoutResult_MAX                      = 7,
};

// Enum Nicola.EInpasuType
// NumValues: 0x0006
enum class EInpasuType : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	Blue                                     = 2,
	Red                                      = 3,
	Yellow                                   = 4,
	EInpasuType_MAX                          = 5,
};

// Enum Nicola.EFlagOperator
// NumValues: 0x0003
enum class EFlagOperator : uint8
{
	Or                                       = 0,
	And                                      = 1,
	EFlagOperator_MAX                        = 2,
};

// Enum Nicola.EFlagEnableType
// NumValues: 0x0003
enum class EFlagEnableType : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	EFlagEnableType_MAX                      = 2,
};

// Enum Nicola.EEventActorType
// NumValues: 0x0007
enum class EEventActorType : uint8
{
	Npc                                      = 0,
	NpcFixedRange                            = 1,
	Object                                   = 2,
	ObjectCheckForward                       = 3,
	ObjectInsideVolume                       = 4,
	Volume                                   = 5,
	EEventActorType_MAX                      = 6,
};

// Enum Nicola.EShowGuideFlag
// NumValues: 0x0005
enum class EShowGuideFlag : uint8
{
	None                                     = 0,
	Main                                     = 1,
	Sub                                      = 2,
	All                                      = 255,
	EShowGuideFlag_MAX                       = 256,
};

// Enum Nicola.EMangaIconType
// NumValues: 0x0005
enum class EMangaIconType : uint8
{
	NONE                                     = 0,
	UI                                       = 1,
	GuideUI                                  = 2,
	EFFECT                                   = 3,
	EMangaIconType_MAX                       = 4,
};

// Enum Nicola.EFadingPriority
// NumValues: 0x0006
enum class EFadingPriority : uint8
{
	TopMost                                  = 0,
	UIBackGround                             = 1,
	EventSkip                                = 2,
	WhiteTopMost                             = 3,
	EventUIBackGround                        = 4,
	Max                                      = 5,
};

// Enum Nicola.EAfterFadeOut
// NumValues: 0x0003
enum class EAfterFadeOut : uint8
{
	None                                     = 0,
	Loading                                  = 1,
	EAfterFadeOut_MAX                        = 2,
};

// Enum Nicola.ENicolaFlipbookWidgetLayoutType
// NumValues: 0x0003
enum class ENicolaFlipbookWidgetLayoutType : uint8
{
	CENTER                                   = 0,
	CUSTOM_PIVOT                             = 1,
	ENicolaFlipbookWidgetLayoutType_MAX      = 2,
};

// Enum Nicola.ENicolaFlipbookWidgetBitFlag
// NumValues: 0x0007
enum class ENicolaFlipbookWidgetBitFlag : uint8
{
	NONE                                     = 0,
	UPDATABLE                                = 1,
	LOOP                                     = 2,
	PAUSED                                   = 4,
	IDLE                                     = 8,
	ALL                                      = 255,
	ENicolaFlipbookWidgetBitFlag_MAX         = 256,
};

// Enum Nicola.ENicolaFlipbookWidgetChangeSpriteDataBitFlag
// NumValues: 0x0006
enum class ENicolaFlipbookWidgetChangeSpriteDataBitFlag : uint8
{
	NONE                                     = 0,
	START_WITH_PAUSED                        = 1,
	ONE_SHOT_PLAYING                         = 2,
	WHEN_FINISHED_IDLE_MOTION                = 4,
	ALL                                      = 255,
	ENicolaFlipbookWidgetChangeSpriteDataBitFlag_MAX = 256,
};

// Enum Nicola.EDebugGOPFlagType
// NumValues: 0x0004
enum class EDebugGOPFlagType : uint8
{
	FLAG_PROGRESS                            = 0,
	FLAG_MBR                                 = 1,
	FLAG_SEARCH                              = 2,
	FLAG_MAX                                 = 3,
};

// Enum Nicola.EGameMode
// NumValues: 0x0006
enum class EGameMode : uint8
{
	INVALID                                  = 0,
	RESEARCH                                 = 1,
	BATTLE                                   = 2,
	ETC                                      = 3,
	TITLE                                    = 4,
	EGameMode_MAX                            = 5,
};

// Enum Nicola.ERecollectionResult
// NumValues: 0x0007
enum class ERecollectionResult : uint8
{
	NONE                                     = 0,
	SUCCESS                                  = 1,
	SUCCESS_MAX                              = 2,
	FAILED                                   = 3,
	FAILED_MAX                               = 4,
	FAILED_ALEADY                            = 5,
	ERecollectionResult_MAX                  = 6,
};

// Enum Nicola.ETownGimmickState
// NumValues: 0x0004
enum class ETownGimmickState : uint8
{
	Default                                  = 0,
	Rope                                     = 1,
	Ladder                                   = 2,
	Max                                      = 3,
};

// Enum Nicola.ELangType
// NumValues: 0x000C
enum class ELangType : uint8
{
	LANG_JP                                  = 0,
	LANG_JP_HI                               = 1,
	LANG_TW                                  = 2,
	LANG_CN                                  = 3,
	LANG_KO                                  = 4,
	LANG_EN                                  = 5,
	LANG_FR                                  = 6,
	LANG_IT                                  = 7,
	LANG_DE                                  = 8,
	LANG_ES                                  = 9,
	LANG_ES_419                              = 10,
	LANG_MAX                                 = 11,
};

// Enum Nicola.EEventTableType
// NumValues: 0x0004
enum class EEventTableType : uint8
{
	EVENT_TYPE_EVENT                         = 0,
	EVENT_TYPE_TALK                          = 1,
	EVENT_TYPE_SEARCH                        = 2,
	EVENT_TYPE_MAX                           = 3,
};

// Enum Nicola.EGopEventType
// NumValues: 0x005B
enum class EGopEventType : uint8
{
	GOP_EVENT_COMMON                         = 0,
	GOP_EVENT_ALIAHAN                        = 1,
	GOP_EVENT_ROMARIA                        = 2,
	GOP_EVENT_ISIS                           = 3,
	GOP_EVENT_PORTOGA                        = 4,
	GOP_EVENT_DHARMA                         = 5,
	GOP_EVENT_JIPANG                         = 6,
	GOP_EVENT_EDINBEAR                       = 7,
	GOP_EVENT_SAMANOSA                       = 8,
	GOP_EVENT_DRAGON_QUEEN                   = 9,
	GOP_EVENT_LUDATORM                       = 10,
	GOP_EVENT_MERCADO                        = 11,
	GOP_EVENT_ZENIS                          = 12,
	GOP_EVENT_MISAKI_CAVE                    = 13,
	GOP_EVENT_NAJIMI_TOWER                   = 14,
	GOP_EVENT_IZANAI_CAVE                    = 15,
	GOP_EVENT_SHAMPANE_TOWER                 = 16,
	GOP_EVENT_UNDERGROUND_LAKE               = 17,
	GOP_EVENT_PYRAMID                        = 18,
	GOP_EVENT_BAHARATA_EAST_CAVE             = 19,
	GOP_EVENT_GARUNA_TOWER                   = 20,
	GOP_EVENT_GAIA_NAVEL                     = 21,
	GOP_EVENT_JIPANG_CAVE                    = 22,
	GOP_EVENT_ARP_TOWER                      = 23,
	GOP_EVENT_RA_CAVE                        = 24,
	GOP_EVENT_GHOST_SHIP                     = 25,
	GOP_EVENT_NECROGOND_CAVE                 = 26,
	GOP_EVENT_BARAMOS_CASTLE                 = 27,
	GOP_EVENT_HERO_CAVE                      = 28,
	GOP_EVENT_ROCK_MT_CAVE                   = 29,
	GOP_EVENT_RUBISS_TOWER                   = 30,
	GOP_EVENT_ZOMA_CASTLE                    = 31,
	GOP_EVENT_SECRET_CAVE                    = 32,
	GOP_EVENT_SECRET_TOWER                   = 33,
	GOP_EVENT_GRAN_DRAGON                    = 34,
	GOP_EVENT_SMALL_SHRINE                   = 35,
	GOP_EVENT_REEVE_SOUTH                    = 36,
	GOP_EVENT_IZANAI_SHRINE                  = 37,
	GOP_EVENT_ROMARIA_BARRIER                = 38,
	GOP_EVENT_PORTOGA_LIGHT                  = 39,
	GOP_EVENT_DESERT_SHRINE                  = 40,
	GOP_EVENT_NORUD_CAVE                     = 41,
	GOP_EVENT_TRAVELERS_SHRINE               = 42,
	GOP_EVENT_TRAVELERS_HOTEL                = 43,
	GOP_EVENT_TRAVELERS_CHURCH               = 44,
	GOP_EVENT_TRAVEL_DOOR_SHRINE             = 45,
	GOP_EVENT_SHALLOW_SHRINE                 = 46,
	GOP_EVENT_HOBBIT_SHRINE                  = 47,
	GOP_EVENT_OLIVIA_MISAKI                  = 48,
	GOP_EVENT_SHRINE_PRISON                  = 49,
	GOP_EVENT_REIAMULAND                     = 50,
	GOP_EVENT_GREENLAD                       = 51,
	GOP_EVENT_NECROGOND_SHRINE               = 52,
	GOP_EVENT_SPIRIT_SPRING                  = 53,
	GOP_EVENT_GIAGA_PIT                      = 54,
	GOP_EVENT_WEST_PORT                      = 55,
	GOP_EVENT_GARAI_HOUSE                    = 56,
	GOP_EVENT_SWAMP_CAVE                     = 57,
	GOP_EVENT_SPIRIT_SHRINE                  = 58,
	GOP_EVENT_HOLY_SHRINE                    = 59,
	GOP_EVENT_VOLCANO                        = 60,
	GOP_EVENT_ROMARIA_HIGHROAD               = 61,
	GOP_EVENT_DEVILS_ISLAND                  = 62,
	GOP_EVENT_REEVE                          = 63,
	GOP_EVENT_KAZAVE                         = 64,
	GOP_EVENT_NOANIEL                        = 65,
	GOP_EVENT_ASHALAM                        = 66,
	GOP_EVENT_BAHARATA                       = 67,
	GOP_EVENT_LANCEL                         = 68,
	GOP_EVENT_SOO                            = 69,
	GOP_EVENT_DOMDORA                        = 70,
	GOP_EVENT_MYRA                           = 71,
	GOP_EVENT_RIMULDAR                       = 72,
	GOP_EVENT_ELF_VILLAGE                    = 73,
	GOP_EVENT_MUOR                           = 74,
	GOP_EVENT_TEDON                          = 75,
	GOP_EVENT_LUZAMI                         = 76,
	GOP_EVENT_BURG                           = 77,
	GOP_EVENT_PIRATES_BASE                   = 78,
	GOP_EVENT_DREAM_CAVE                     = 79,
	GOP_EVENT_DREAM_TOWER                    = 80,
	GOP_EVENT_DREAM_TOWN                     = 81,
	GOP_EVENT_DREAM_VILLAGE                  = 82,
	GOP_EVENT_DREAM_FOREST                   = 83,
	GOP_EVENT_DREAM_CASTLE                   = 84,
	GOP_EVENT_DREAM_DESERT                   = 85,
	GOP_EVENT_DREAM_THEATER                  = 86,
	GOP_EVENT_DREAM_WATER_FALL               = 87,
	GOP_EVENT_BATTLE_ROAD                    = 88,
	GOP_EVENT_COUNT                          = 89,
	GOP_EVENT_MAX                            = 90,
};

// Enum Nicola.EGopTextType
// NumValues: 0x001C
enum class EGopTextType : uint8
{
	GOP_TEXT_COMMON                          = 0,
	GOP_TEXT_FIELDMENU                       = 1,
	GOP_TEXT_BATTLEMENU                      = 2,
	GOP_TEXT_BATTLEROADMENU                  = 3,
	GOP_TEXT_ITEM                            = 4,
	GOP_TEXT_NPC_NAME                        = 5,
	GOP_TEXT_SHOP                            = 6,
	GOP_TEXT_CHURCH                          = 7,
	GOP_TEXT_MONSTER                         = 8,
	GOP_TEXT_MAGIC                           = 9,
	GOP_TEXT_INN                             = 10,
	GOP_TEXT_INFORMATION                     = 11,
	GOP_TEXT_MAP                             = 12,
	GOP_TEXT_BANK                            = 13,
	GOP_TEXT_MEDAL                           = 14,
	GOP_TEXT_BAR                             = 15,
	GOP_TEXT_STATUS                          = 16,
	GOP_TEXT_REGISTRATION                    = 17,
	GOP_TEXT_RENAME                          = 18,
	GOP_TEXT_JOB_CHANGE                      = 19,
	GOP_TEXT_APPEARANCE_CHANGE               = 20,
	GOP_TEXT_MEMBER_INIT                     = 21,
	GOP_TEXT_OPERATIONGUIDE                  = 22,
	GOP_TEXT_STAFFROLL                       = 23,
	GOP_TEXT_DEBUGMENU                       = 24,
	GOP_TEXT_DLC                             = 25,
	GOP_TEXT_COUNT                           = 26,
	GOP_TEXT_MAX                             = 27,
};

// Enum Nicola.EGopDataType
// NumValues: 0x0083
enum class EGopDataType : uint8
{
	GOP_CONFIG_BUTTON_INFO                   = 0,
	GOP_CONFIG_ACTION_INFO                   = 1,
	GOP_FORCE_FEEDBACK_ASSET                 = 2,
	GOP_CAMERA_SHAKE_ASSET                   = 3,
	GOP_ITEM                                 = 4,
	GOP_ITEM_SPEC                            = 5,
	GOP_TOWN_DUNGEON_SUBLEVEL                = 6,
	GOP_MAP_LIST                             = 7,
	GOP_MAP_LIST_BATTLE_SUBLEVEL             = 8,
	GOP_MAP_LIST_BATTLE                      = 9,
	GOP_MAP_CAMERA                           = 10,
	GOP_MAP_SPOTICON                         = 11,
	GOP_UNIT_COMMON                          = 12,
	GOP_UNIT_ITEMBAG                         = 13,
	GOP_UNIT_LOOKS                           = 14,
	GOP_UNIT_MASTER                          = 15,
	GOP_UNIT_RESIDENT                        = 16,
	GOP_UNIT_NPCTYPE                         = 17,
	GOP_UNIT_COLOR                           = 18,
	GOP_EFFECT_ASSET                         = 19,
	GOP_SEQUENCE_BATTLE_ASSET                = 20,
	GOP_EFFECT_BATTLE                        = 21,
	GOP_EVENT_OBJECT                         = 22,
	GOP_HOUR                                 = 23,
	GOP_ENCOUNTER_TERRAIN                    = 24,
	GOP_ENCOUNTER_MONSTER                    = 25,
	GOP_ENCOUNTER_COMMON                     = 26,
	GOP_ENCOUNTER_AREA                       = 27,
	GOP_ENCOUNTER_AREA_SUB                   = 28,
	GOP_ENCOUNTER_AREA_GRID                  = 29,
	GOP_BATTLE_BUFFDEBUFF                    = 30,
	GOP_BATTLE_CAMERA                        = 31,
	GOP_BATTLE_CAMERASHAKE                   = 32,
	GOP_BATTLE_FORMATION                     = 33,
	GOP_BATTLE_WEAPON_STYLE                  = 34,
	GOP_BATTLE_MONSTER_ACTION                = 35,
	GOP_BATTLE_MONSTER_ACTION_LIST           = 36,
	GOP_BATTLE_PC_ACTION                     = 37,
	GOP_BATTLE_RESIST                        = 38,
	GOP_BATTLE_STATUS_EFFECT                 = 39,
	GOP_BATTLE_EVENT                         = 40,
	GOP_BATTLE_TEXT_SET                      = 41,
	GOP_MAP_ATTRIBUTE                        = 42,
	GOP_SE_FIELD                             = 43,
	GOP_SE_SYSTEM                            = 44,
	GOP_SE_WEAPON                            = 45,
	GOP_SE_MAGIC                             = 46,
	GOP_SE_PROGRESS_AMBIENT                  = 47,
	GOP_SE_ACTION_MONSTER                    = 48,
	GOP_SE_EVENT                             = 49,
	GOP_VOICE_BATTLE                         = 50,
	GOP_VOICE_SCENARIO                       = 51,
	GOP_VOICE_REGISTRATION                   = 52,
	GOP_LEVELUPEXP                           = 53,
	GOP_LEARNING                             = 54,
	GOP_PERSONALITY                          = 55,
	GOP_PERSONALITY_CANDIDATE                = 56,
	GOP_STATUSUP                             = 57,
	GOP_POSTPROCESS_BATTLE                   = 58,
	GOP_SHOP                                 = 59,
	GOP_CHURCH                               = 60,
	GOP_MAGIC_SPEC                           = 61,
	GOP_MAGIC                                = 62,
	GOP_MAGIC_RANDOM                         = 63,
	GOP_MAGIC_TEXT_SET                       = 64,
	GOP_INN                                  = 65,
	GOP_INFORMATION                          = 66,
	GOP_IMAGE_INFORMATION                    = 67,
	GOP_BANK                                 = 68,
	GOP_MEDAL                                = 69,
	GOP_RURA_RIREMITO                        = 70,
	GOP_UI_CONSTPARAM                        = 71,
	GOP_MONSTER                              = 72,
	GOP_JOB                                  = 73,
	GOP_JOBCHANGE                            = 74,
	GOP_JOB_ABILITY_LV                       = 75,
	GOP_JOB_PLAY                             = 76,
	GOP_MEMBER_INIT                          = 77,
	GOP_BATTLEROAD_MONSTER                   = 78,
	GOP_BATTLEROAD_MONSTER_SPECIES           = 79,
	GOP_BATTLEROAD_RANK                      = 80,
	GOP_BATTLEROAD_REWARD                    = 81,
	GOP_BATTLEROAD_INFORMATION               = 82,
	GOP_BATTLEROAD_ENTRY                     = 83,
	GOP_BATTLEROAD_SCOUT                     = 84,
	GOP_TEXT_NOUN_CHINESE                    = 85,
	GOP_TEXT_NOUN_ENGLISH                    = 86,
	GOP_TEXT_NOUN_FRENCH                     = 87,
	GOP_TEXT_NOUN_GERMAN                     = 88,
	GOP_TEXT_NOUN_ITALIAN                    = 89,
	GOP_TEXT_NOUN_JAPANESE                   = 90,
	GOP_TEXT_NOUN_JAPANESE_HI                = 91,
	GOP_TEXT_NOUN_KOREAN                     = 92,
	GOP_TEXT_NOUN_NEUTRALSPANISH             = 93,
	GOP_TEXT_NOUN_SPANISH                    = 94,
	GOP_TEXT_NOUN_TAIWAN                     = 95,
	GOP_TOWNDUNGEON_MAP_PARAMETER            = 96,
	GOP_DIRECTIONALLIGHT_PARAMETER           = 97,
	GOP_DIRECTIONALLIGHT_PARAMETER_CUTSCENE  = 98,
	GOP_MAPGUIDEDATA                         = 99,
	GOP_MAPGUIDE                             = 100,
	GOP_FIELD_EFX2D                          = 101,
	GOP_MONSTER_LIBRARY                      = 102,
	GOP_ECHO_FLUTE                           = 103,
	GOP_SHINE_SEARCHOBJECT                   = 104,
	GOP_TEXT_NOUN_GERMAN_MARCO_NOUN          = 105,
	GOP_TEXT_NOUN_GERMAN_MARCO_ARTICLE       = 106,
	GOP_OPERATIONGUIDE                       = 107,
	GOP_MAPGUIDEMARKER                       = 108,
	GOP_RIREMITODATA                         = 109,
	GOP_FIELDSYMBOLLIST                      = 110,
	GOP_INITIAL_LOGO                         = 111,
	GOP_TITLEDEMO                            = 112,
	GOP_MAPIMAGEOVERLAY                      = 113,
	GOP_GUIDEICON                            = 114,
	GOP_MAPCHANGEGROUP                       = 115,
	GOP_EVENTSCREENSHOT                      = 116,
	GOP_STAFFROLL                            = 117,
	GOP_STAFFROLL_IMAGE                      = 118,
	GOP_DOOR_LIST                            = 119,
	GOP_CHARACTER_MATERIAL                   = 120,
	GOP_SEQUENCE_BATTLE                      = 121,
	GOP_NG_NAMELIST                          = 122,
	GOP_FONTSIZEDATA                         = 123,
	GOP_LANTERN                              = 124,
	GOP_MAP_PERFORMANCE                      = 125,
	GOP_DLC                                  = 126,
	GOP_PS5_ACTIVITY                         = 127,
	GOP_MEMORY                               = 128,
	GOP_DATA_COUNT                           = 129,
	GOP_MAX                                  = 130,
};

// Enum Nicola.EGopLoadFlag
// NumValues: 0x0008
enum class EGopLoadFlag : uint8
{
	NONE                                     = 0,
	PRIMARY                                  = 1,
	TEXT                                     = 2,
	VOICE                                    = 4,
	EVENT                                    = 8,
	UNLOCALIZED                              = 1,
	ALL                                      = 255,
	EGopLoadFlag_MAX                         = 256,
};

// Enum Nicola.EGopTextBlockContainMode
// NumValues: 0x0004
enum class EGopTextBlockContainMode : uint8
{
	NONE                                     = 0,
	SCALE                                    = 1,
	SCROLL                                   = 2,
	EGopTextBlockContainMode_MAX             = 3,
};

// Enum Nicola.ENicolaButtonOp
// NumValues: 0x0004
enum class ENicolaButtonOp : uint8
{
	None                                     = 0,
	OR                                       = 1,
	AND                                      = 2,
	ENicolaButtonOp_MAX                      = 3,
};

// Enum Nicola.ETransitionStatus
// NumValues: 0x0004
enum class ETransitionStatus : uint8
{
	IDLE                                     = 0,
	RUNNING                                  = 1,
	SUSPEND                                  = 2,
	ETransitionStatus_MAX                    = 3,
};

// Enum Nicola.ELuaFlag
// NumValues: 0x023D
enum class ELuaFlag : uint16
{
	DummyFlag                                = 0,
	FLAG_DUMMY                               = 1,
	FD8                                      = 2,
	FD9                                      = 3,
	FD10                                     = 4,
	FD11                                     = 5,
	FD12                                     = 6,
	FD13                                     = 7,
	FD14                                     = 8,
	FD15                                     = 9,
	FD16                                     = 10,
	FD17                                     = 11,
	FD18                                     = 12,
	FD19                                     = 13,
	FD20                                     = 14,
	FD21                                     = 15,
	FD22                                     = 16,
	FD23                                     = 17,
	FD24                                     = 18,
	FD25                                     = 19,
	FD26                                     = 20,
	FD27                                     = 21,
	FD28                                     = 22,
	FD29                                     = 23,
	FD30                                     = 24,
	FD31                                     = 25,
	FD32                                     = 26,
	FD33                                     = 27,
	FD34                                     = 28,
	FD35                                     = 29,
	FD36                                     = 30,
	FD37                                     = 31,
	FD38                                     = 32,
	FD39                                     = 33,
	FD40                                     = 34,
	FD41                                     = 35,
	FD42                                     = 36,
	FD43                                     = 37,
	FD44                                     = 38,
	FLAG_DUNGEON_MAX                         = 39,
	FF0                                      = 40,
	FF1                                      = 41,
	FF2                                      = 42,
	FF3                                      = 43,
	FF4                                      = 44,
	FF5                                      = 45,
	FF6                                      = 46,
	FF7                                      = 47,
	FF8                                      = 48,
	FF9                                      = 49,
	FF10                                     = 50,
	FLAG_FLOOR_MAX                           = 51,
	FS0                                      = 52,
	FS1                                      = 53,
	FS2                                      = 54,
	FS3                                      = 55,
	FS4                                      = 56,
	FS5                                      = 57,
	FLAG_SUSPEND_MAX                         = 58,
	FE8                                      = 59,
	FE10                                     = 60,
	FE12                                     = 61,
	FE13                                     = 62,
	FE14                                     = 63,
	FE18                                     = 64,
	FE19                                     = 65,
	FE20                                     = 66,
	FE21                                     = 67,
	FE26                                     = 68,
	FE27                                     = 69,
	FE28                                     = 70,
	FE29                                     = 71,
	FE30                                     = 72,
	FE31                                     = 73,
	FE34                                     = 74,
	FE35                                     = 75,
	FE36                                     = 76,
	FE37                                     = 77,
	FE40                                     = 78,
	FE41                                     = 79,
	FE42                                     = 80,
	FE43                                     = 81,
	FE54                                     = 82,
	FE55                                     = 83,
	FE56                                     = 84,
	FE57                                     = 85,
	FE58                                     = 86,
	FE59                                     = 87,
	FE60                                     = 88,
	FE61                                     = 89,
	FE62                                     = 90,
	FE63                                     = 91,
	FE64                                     = 92,
	FE65                                     = 93,
	FE66                                     = 94,
	FE67                                     = 95,
	FE68                                     = 96,
	FE69                                     = 97,
	FE70                                     = 98,
	FE71                                     = 99,
	FE72                                     = 100,
	FE73                                     = 101,
	FE74                                     = 102,
	FE75                                     = 103,
	FE76                                     = 104,
	FE77                                     = 105,
	FE78                                     = 106,
	FE79                                     = 107,
	FE80                                     = 108,
	FE81                                     = 109,
	FE82                                     = 110,
	FE83                                     = 111,
	FE84                                     = 112,
	FE85                                     = 113,
	FE86                                     = 114,
	FE87                                     = 115,
	FE88                                     = 116,
	FE89                                     = 117,
	FE90                                     = 118,
	FE91                                     = 119,
	FE92                                     = 120,
	FE93                                     = 121,
	FE94                                     = 122,
	FE95                                     = 123,
	FE96                                     = 124,
	FE97                                     = 125,
	FE98                                     = 126,
	FE99                                     = 127,
	FE100                                    = 128,
	FE101                                    = 129,
	FE102                                    = 130,
	FE103                                    = 131,
	FE104                                    = 132,
	FE105                                    = 133,
	FE106                                    = 134,
	FE107                                    = 135,
	FE108                                    = 136,
	FE109                                    = 137,
	FE110                                    = 138,
	FE111                                    = 139,
	FE112                                    = 140,
	FE113                                    = 141,
	FE114                                    = 142,
	FE115                                    = 143,
	FE116                                    = 144,
	FE117                                    = 145,
	FE118                                    = 146,
	FE119                                    = 147,
	FE120                                    = 148,
	FE121                                    = 149,
	FE122                                    = 150,
	FE123                                    = 151,
	FE124                                    = 152,
	FE125                                    = 153,
	FE126                                    = 154,
	FE127                                    = 155,
	FE128                                    = 156,
	FE129                                    = 157,
	FE130                                    = 158,
	FE131                                    = 159,
	FE132                                    = 160,
	FE133                                    = 161,
	FE134                                    = 162,
	FE135                                    = 163,
	FE136                                    = 164,
	FE137                                    = 165,
	FE138                                    = 166,
	FE140                                    = 167,
	FE141                                    = 168,
	FE142                                    = 169,
	FE143                                    = 170,
	FE144                                    = 171,
	FE145                                    = 172,
	FE146                                    = 173,
	FE147                                    = 174,
	FE148                                    = 175,
	FE149                                    = 176,
	FE150                                    = 177,
	FE151                                    = 178,
	FE152                                    = 179,
	FE153                                    = 180,
	FE154                                    = 181,
	FE155                                    = 182,
	FE156                                    = 183,
	FE157                                    = 184,
	FE158                                    = 185,
	FE159                                    = 186,
	FE160                                    = 187,
	FE161                                    = 188,
	FE162                                    = 189,
	FE163                                    = 190,
	FE164                                    = 191,
	FE165                                    = 192,
	FE166                                    = 193,
	FE167                                    = 194,
	FE168                                    = 195,
	FE169                                    = 196,
	FE170                                    = 197,
	FE171                                    = 198,
	FE172                                    = 199,
	FE173                                    = 200,
	FE174                                    = 201,
	FE175                                    = 202,
	FE176                                    = 203,
	FE177                                    = 204,
	FE178                                    = 205,
	FE179                                    = 206,
	FE180                                    = 207,
	FE181                                    = 208,
	FE182                                    = 209,
	FE183                                    = 210,
	FE184                                    = 211,
	FE185                                    = 212,
	FE186                                    = 213,
	FE187                                    = 214,
	FE188                                    = 215,
	FE189                                    = 216,
	FE190                                    = 217,
	FE191                                    = 218,
	FE192                                    = 219,
	FE193                                    = 220,
	FE194                                    = 221,
	FE195                                    = 222,
	FE196                                    = 223,
	FE197                                    = 224,
	FE198                                    = 225,
	FE199                                    = 226,
	FE200                                    = 227,
	FE201                                    = 228,
	FE202                                    = 229,
	FE203                                    = 230,
	FE204                                    = 231,
	FE205                                    = 232,
	FE206                                    = 233,
	FE207                                    = 234,
	FE208                                    = 235,
	FE209                                    = 236,
	FE210                                    = 237,
	FE211                                    = 238,
	FE212                                    = 239,
	FE213                                    = 240,
	FE214                                    = 241,
	FE215                                    = 242,
	FE216                                    = 243,
	FE217                                    = 244,
	FE218                                    = 245,
	FE219                                    = 246,
	FE220                                    = 247,
	FE222                                    = 248,
	FE223                                    = 249,
	FE224                                    = 250,
	FE225                                    = 251,
	FE226                                    = 252,
	FE227                                    = 253,
	FE228                                    = 254,
	FE229                                    = 255,
	FE230                                    = 256,
	FE231                                    = 257,
	FE232                                    = 258,
	FE233                                    = 259,
	FE234                                    = 260,
	FE235                                    = 261,
	FE236                                    = 262,
	FE237                                    = 263,
	FE238                                    = 264,
	FE239                                    = 265,
	FE240                                    = 266,
	FE241                                    = 267,
	FE242                                    = 268,
	FE243                                    = 269,
	FE244                                    = 270,
	FE245                                    = 271,
	FE246                                    = 272,
	FE247                                    = 273,
	FE248                                    = 274,
	FE249                                    = 275,
	FE251                                    = 276,
	FE265                                    = 277,
	FE266                                    = 278,
	FE300                                    = 279,
	FE327                                    = 280,
	FE341                                    = 281,
	FE342                                    = 282,
	FE343                                    = 283,
	FE344                                    = 284,
	FE345                                    = 285,
	FE381                                    = 286,
	FE382                                    = 287,
	FE383                                    = 288,
	FE384                                    = 289,
	FE385                                    = 290,
	FE386                                    = 291,
	FE448                                    = 292,
	FE449                                    = 293,
	FE450                                    = 294,
	FE465                                    = 295,
	FE466                                    = 296,
	FE540                                    = 297,
	FE547                                    = 298,
	FE578                                    = 299,
	FE609                                    = 300,
	FE613                                    = 301,
	FE614                                    = 302,
	FE615                                    = 303,
	FE622                                    = 304,
	FE632                                    = 305,
	FE633                                    = 306,
	FE634                                    = 307,
	FE635                                    = 308,
	FE636                                    = 309,
	FE637                                    = 310,
	FE638                                    = 311,
	FE639                                    = 312,
	FE640                                    = 313,
	FE641                                    = 314,
	FE642                                    = 315,
	FE643                                    = 316,
	FE645                                    = 317,
	FE646                                    = 318,
	FE647                                    = 319,
	FE648                                    = 320,
	FE649                                    = 321,
	FE650                                    = 322,
	FE675                                    = 323,
	FE677                                    = 324,
	FE688                                    = 325,
	FE698                                    = 326,
	FE700                                    = 327,
	FE701                                    = 328,
	FE702                                    = 329,
	FE703                                    = 330,
	FE704                                    = 331,
	FE705                                    = 332,
	FE706                                    = 333,
	FE707                                    = 334,
	FE708                                    = 335,
	FE709                                    = 336,
	FE710                                    = 337,
	FE711                                    = 338,
	FE712                                    = 339,
	FE713                                    = 340,
	FE714                                    = 341,
	FE715                                    = 342,
	FE716                                    = 343,
	FE717                                    = 344,
	FE718                                    = 345,
	FE719                                    = 346,
	FE720                                    = 347,
	FE721                                    = 348,
	FE722                                    = 349,
	FE723                                    = 350,
	FE724                                    = 351,
	FE725                                    = 352,
	FE726                                    = 353,
	FE727                                    = 354,
	FE728                                    = 355,
	FE729                                    = 356,
	FE730                                    = 357,
	FE731                                    = 358,
	FE732                                    = 359,
	FE733                                    = 360,
	FE734                                    = 361,
	FE735                                    = 362,
	FE736                                    = 363,
	FE737                                    = 364,
	FE738                                    = 365,
	FE739                                    = 366,
	FE740                                    = 367,
	FE741                                    = 368,
	FE742                                    = 369,
	FE743                                    = 370,
	FE744                                    = 371,
	FE745                                    = 372,
	FE746                                    = 373,
	FE747                                    = 374,
	FE748                                    = 375,
	FE749                                    = 376,
	FE750                                    = 377,
	FE751                                    = 378,
	FE752                                    = 379,
	FE753                                    = 380,
	FE754                                    = 381,
	FE755                                    = 382,
	FE756                                    = 383,
	FE757                                    = 384,
	FE758                                    = 385,
	FE759                                    = 386,
	FE760                                    = 387,
	FE761                                    = 388,
	FE762                                    = 389,
	FE763                                    = 390,
	FE764                                    = 391,
	FE765                                    = 392,
	FE766                                    = 393,
	FE767                                    = 394,
	FE768                                    = 395,
	FE769                                    = 396,
	FE770                                    = 397,
	FE771                                    = 398,
	FE772                                    = 399,
	FE773                                    = 400,
	FE774                                    = 401,
	FE775                                    = 402,
	FE776                                    = 403,
	FE777                                    = 404,
	FE778                                    = 405,
	FE779                                    = 406,
	FE780                                    = 407,
	FE800                                    = 408,
	FE801                                    = 409,
	FE802                                    = 410,
	FE803                                    = 411,
	FE804                                    = 412,
	FE805                                    = 413,
	FE806                                    = 414,
	FE807                                    = 415,
	FE808                                    = 416,
	FE809                                    = 417,
	FE810                                    = 418,
	FE811                                    = 419,
	FE812                                    = 420,
	FE813                                    = 421,
	FE814                                    = 422,
	FE815                                    = 423,
	FE816                                    = 424,
	FE817                                    = 425,
	FE818                                    = 426,
	FE819                                    = 427,
	FE820                                    = 428,
	FE821                                    = 429,
	FE822                                    = 430,
	FE823                                    = 431,
	FE824                                    = 432,
	FE825                                    = 433,
	FE826                                    = 434,
	FE827                                    = 435,
	FE828                                    = 436,
	FE829                                    = 437,
	FE830                                    = 438,
	FE831                                    = 439,
	FE832                                    = 440,
	FE833                                    = 441,
	FE834                                    = 442,
	FE835                                    = 443,
	FE836                                    = 444,
	FE837                                    = 445,
	FE838                                    = 446,
	FE839                                    = 447,
	FE840                                    = 448,
	FE841                                    = 449,
	FE842                                    = 450,
	FE843                                    = 451,
	FE844                                    = 452,
	FE845                                    = 453,
	FE846                                    = 454,
	FE847                                    = 455,
	FE848                                    = 456,
	FE849                                    = 457,
	FE850                                    = 458,
	FE851                                    = 459,
	FE852                                    = 460,
	FE853                                    = 461,
	FE854                                    = 462,
	FE855                                    = 463,
	FE856                                    = 464,
	FE857                                    = 465,
	FE858                                    = 466,
	FE859                                    = 467,
	FE860                                    = 468,
	FE861                                    = 469,
	FE862                                    = 470,
	FE863                                    = 471,
	FE864                                    = 472,
	FE865                                    = 473,
	FE866                                    = 474,
	FE867                                    = 475,
	FE868                                    = 476,
	FE869                                    = 477,
	FE870                                    = 478,
	FE871                                    = 479,
	FE872                                    = 480,
	FE873                                    = 481,
	FE874                                    = 482,
	FE875                                    = 483,
	FE876                                    = 484,
	FE877                                    = 485,
	FE878                                    = 486,
	FE879                                    = 487,
	FE880                                    = 488,
	FE881                                    = 489,
	FE882                                    = 490,
	FE883                                    = 491,
	FE884                                    = 492,
	FE885                                    = 493,
	FE886                                    = 494,
	FE887                                    = 495,
	FE888                                    = 496,
	FE889                                    = 497,
	FE890                                    = 498,
	FE891                                    = 499,
	FE892                                    = 500,
	FE893                                    = 501,
	FE894                                    = 502,
	FE895                                    = 503,
	FE896                                    = 504,
	FE897                                    = 505,
	FE898                                    = 506,
	FE899                                    = 507,
	FE900                                    = 508,
	FE901                                    = 509,
	FE902                                    = 510,
	FE903                                    = 511,
	FE904                                    = 512,
	FE905                                    = 513,
	FE906                                    = 514,
	FE907                                    = 515,
	FE908                                    = 516,
	FE909                                    = 517,
	FE910                                    = 518,
	FE911                                    = 519,
	FE912                                    = 520,
	FE913                                    = 521,
	FE914                                    = 522,
	FE915                                    = 523,
	FE916                                    = 524,
	FE917                                    = 525,
	FE918                                    = 526,
	FE919                                    = 527,
	FE920                                    = 528,
	FE921                                    = 529,
	FE922                                    = 530,
	FE923                                    = 531,
	FE924                                    = 532,
	FE925                                    = 533,
	FE926                                    = 534,
	FE927                                    = 535,
	FE928                                    = 536,
	FE929                                    = 537,
	FE930                                    = 538,
	FE931                                    = 539,
	FE932                                    = 540,
	FE933                                    = 541,
	FE934                                    = 542,
	FE935                                    = 543,
	FE936                                    = 544,
	FE937                                    = 545,
	FE938                                    = 546,
	FE939                                    = 547,
	FE940                                    = 548,
	FE950                                    = 549,
	FE951                                    = 550,
	FE952                                    = 551,
	FE953                                    = 552,
	FE954                                    = 553,
	FE955                                    = 554,
	FE956                                    = 555,
	FE957                                    = 556,
	FE958                                    = 557,
	FE959                                    = 558,
	FE960                                    = 559,
	FE961                                    = 560,
	FE962                                    = 561,
	FE963                                    = 562,
	FE964                                    = 563,
	FE965                                    = 564,
	FE966                                    = 565,
	FE967                                    = 566,
	FE968                                    = 567,
	FE969                                    = 568,
	BAR01                                    = 569,
	FLAG_EVENT_MAX                           = 570,
	FLAG_MAX                                 = 571,
	ELuaFlag_MAX                             = 572,
};

// Enum Nicola.ELuaGameInfo
// NumValues: 0x000B
enum class ELuaGameInfo : uint8
{
	DummyGameInfo                            = 0,
	TEST_GAMEINFO_0                          = 1,
	TEST_GAMEINFO_1                          = 2,
	TEST_GAMEINFO_2                          = 3,
	TEST_GAMEINFO_3                          = 4,
	TEST_GAMEINFO_4                          = 5,
	TEST_GAMEINFO_5                          = 6,
	TEST_GAMEINFO_6                          = 7,
	TEST_GAMEINFO_7                          = 8,
	TEST_GAMEINFO_8                          = 9,
	ELuaGameInfo_MAX                         = 10,
};

// Enum Nicola.ELuaSysInfo
// NumValues: 0x0031
enum class ELuaSysInfo : uint8
{
	DummySysInfo                             = 0,
	BOOL_LEVEL_START                         = 1,
	BOOL_LEVEL_END                           = 2,
	BOOL_SUB_LEVEL_START                     = 3,
	BOOL_SUB_LEVEL_END                       = 4,
	STAGE_CAMERA_DEFAULT_DISTANCE            = 5,
	RESEARCH_START                           = 6,
	RESEARCH_RESUME                          = 7,
	RESEARCH_END                             = 8,
	RESEARCH_ACTION_START                    = 9,
	MAP_CHANGE_DETECT                        = 10,
	TALK_REPEAT_STOP                         = 11,
	PLAY_GAME_MODE                           = 12,
	IS_RUNNING_RESEARCH_GIMMICK              = 13,
	BATTLE_START                             = 14,
	BATTLE_END                               = 15,
	BATTLE_STATE                             = 16,
	IS_CHANGE_BATTLE_STATE                   = 17,
	IS_RUNNING_MAIN                          = 18,
	SYS_GAME_EDITION                         = 19,
	SYS_NEW_GAME_START                       = 20,
	TRANSITION_INN_START_FLAG                = 21,
	TRANSITION_INN_ENVIRONMENT_LIGHT_FLAG    = 22,
	VE0                                      = 23,
	VE5                                      = 24,
	VF0                                      = 25,
	VA0                                      = 26,
	VALUE_EVENT_MAX                          = 27,
	TRANSITION_AMBIENT_CANCEL                = 28,
	EVENT_NAME                               = 18446744073709551615,
	NEXT_LEVEL_NAME                          = 18446744073709551614,
	NEXT_LEVEL_PATH                          = 18446744073709551613,
	NEXT_LEVELSCRIPT_PATH                    = 18446744073709551612,
	CURRENT_LEVEL_NAME                       = 18446744073709551611,
	BATTLE_SCRIPT                            = 18446744073709551610,
	BATTLE_SCRIPT_ARGS                       = 18446744073709551609,
	MESSAGE_ACTORNAME                        = 18446744073709551608,
	MESSAGE_COMMAND                          = 18446744073709551607,
	MESSAGE_COMMAND_TAGNAME                  = 18446744073709551606,
	MESSAGE_COMMAND_ARGMENT                  = 18446744073709551605,
	LEVEL_NAME                               = 18446744073709551604,
	SUB_LEVEL_NAME_START                     = 18446744073709551603,
	SUB_LEVEL_NAME_END                       = 18446744073709551602,
	GAME_PROGRESS                            = 18446744073709551601,
	EVENT_TRIGGER_UNIT                       = 18446744073709551600,
	PICK_UP_OBJECTNAME                       = 18446744073709551599,
	TRANSITION_INN_MAP_ID                    = 18446744073709551598,
	TRANSITION_INN_START_POINT_NAME          = 18446744073709551597,
	ELuaSysInfo_MAX                          = 29,
};

// Enum Nicola.ELuaSysGlobal
// NumValues: 0x0016
enum class ELuaSysGlobal : uint8
{
	DummySysGlobal                           = 0,
	TRANSITION_LEVEL_RECORD                  = 1,
	TRANSITION_LEVEL_MAP_TIME                = 2,
	progress                                 = 3,
	VD0                                      = 4,
	VD1                                      = 5,
	VD2                                      = 6,
	VD3                                      = 7,
	VD4                                      = 8,
	VD5                                      = 9,
	VD6                                      = 10,
	VD7                                      = 11,
	ORB0                                     = 12,
	ORB1                                     = 13,
	ORB2                                     = 14,
	ORB3                                     = 15,
	ORB4                                     = 16,
	ORB5                                     = 17,
	PERSONALITY_CHECK_RESULT                 = 18,
	PERSONALITY_CHECK_FLOOR                  = 19,
	BAR01                                    = 20,
	ELuaSysGlobal_MAX                        = 21,
};

// Enum Nicola.ELuaSysLocal
// NumValues: 0x0002
enum class ELuaSysLocal : uint8
{
	DummySysLocal                            = 0,
	ELuaSysLocal_MAX                         = 1,
};

// Enum Nicola.EDirectionOnMap
// NumValues: 0x0009
enum class EDirectionOnMap : uint8
{
	X_PLUS                                   = 0,
	X_MINUS                                  = 1,
	Y_PLUS                                   = 2,
	Y_MINUS                                  = 3,
	X_PLUS_Y_PLUS                            = 4,
	X_MINUS_Y_PLUS                           = 5,
	X_MINUS_Y_MINUS                          = 6,
	X_PLUS_Y_MINUS                           = 7,
	MAX                                      = 8,
};

// Enum Nicola.EMapMode
// NumValues: 0x0005
enum class EMapMode : uint8
{
	NONE                                     = 0,
	RESEARCH                                 = 1,
	BATTLE                                   = 2,
	FIELD                                    = 3,
	EMapMode_MAX                             = 4,
};

// Enum Nicola.EActionType
// NumValues: 0x000A
enum class EActionType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	BattleIdle                               = 2,
	Talk                                     = 3,
	Walk                                     = 4,
	Run                                      = 5,
	Ladder                                   = 6,
	Rope                                     = 7,
	CustomAnimation                          = 8,
	Max                                      = 9,
};

// Enum Nicola.ECameraDistance
// NumValues: 0x0004
enum class ECameraDistance : uint8
{
	CameraDistanceNear                       = 0,
	CameraDistanceNormal                     = 1,
	CameraDistanceFar                        = 2,
	ECameraDistance_MAX                      = 3,
};

// Enum Nicola.ENicolaCameraInputZoomChange
// NumValues: 0x0003
enum class ENicolaCameraInputZoomChange : uint8
{
	ZOOM_IN                                  = 0,
	ZOOM_OUT                                 = 1,
	ZOOM_MAX                                 = 2,
};

// Enum Nicola.ENicolaCameraTriggerCurveType
// NumValues: 0x0009
enum class ENicolaCameraTriggerCurveType : uint8
{
	None                                     = 0,
	Field_00                                 = 1,
	Field_01                                 = 2,
	Field_02                                 = 3,
	TownDungeon_00                           = 4,
	TownDungeon_01                           = 5,
	TownDungeon_02                           = 6,
	Num                                      = 7,
	ENicolaCameraTriggerCurveType_MAX        = 8,
};

// Enum Nicola.EEffectSocketType
// NumValues: 0x0003
enum class EEffectSocketType : uint8
{
	INVALID                                  = 0,
	DEFAULT                                  = 1,
	EEffectSocketType_MAX                    = 2,
};

// Enum Nicola.ECharacterSocketType
// NumValues: 0x000D
enum class ECharacterSocketType : uint8
{
	HEAD                                     = 0,
	TOP                                      = 1,
	CENTER                                   = 2,
	HIT                                      = 3,
	BREATH                                   = 4,
	DEAD                                     = 5,
	BULLET_START                             = 6,
	NAME_PLATE                               = 7,
	DAMAGE                                   = 8,
	DAMAGE2                                  = 9,
	DAMAGE3                                  = 10,
	DAMAGE4                                  = 11,
	ECharacterSocketType_MAX                 = 12,
};

// Enum Nicola.ECharacterMaterialType
// NumValues: 0x000A
enum class ECharacterMaterialType : uint8
{
	Default                                  = 0,
	Kaclang                                  = 1,
	Invisible                                = 2,
	Event                                    = 3,
	Zoma_Shadow                              = 4,
	Ortega                                   = 5,
	DarkArmor                                = 6,
	DragonQueen                              = 7,
	Num                                      = 8,
	ECharacterMaterialType_MAX               = 9,
};

// Enum Nicola.EBattleMoveType
// NumValues: 0x0005
enum class EBattleMoveType : uint64
{
	NONE                                     = 18446744073709551615,
	POOF                                     = 0,
	BLASTO                                   = 1,
	NAKAMA                                   = 2,
	EBattleMoveType_MAX                      = 3,
};

// Enum Nicola.EDebugSkillFlags
// NumValues: 0x0009
enum class EDebugSkillFlags : uint8
{
	DIG_A_HOLE_ITEM_DROP                     = 0,
	DIG_A_HOLE_ITEM_DROP_ABSOLUTE            = 1,
	DIG_A_HOLE_GOLD                          = 2,
	DIG_A_HOLE_GOLD_JACKPOT                  = 3,
	DIG_A_HOLE_MISS                          = 4,
	DIG_A_HOLE_SIMULATE                      = 5,
	DIG_A_HOLE_INFINITY                      = 6,
	End                                      = 7,
	EDebugSkillFlags_MAX                     = 8,
};

// Enum Nicola.EDebugVoteResult
// NumValues: 0x000A
enum class EDebugVoteResult : uint8
{
	NONE                                     = 0,
	FREEDOM                                  = 1,
	BENEFIT                                  = 2,
	MORAL                                    = 3,
	SAME                                     = 4,
	SAME_FREEDOM_BENEFIT                     = 5,
	SAME_FREEDOM_MORAL                       = 6,
	SAME_BENEFIT_MORAL                       = 7,
	End                                      = 8,
	EDebugVoteResult_MAX                     = 9,
};

// Enum Nicola.EDebugForcePersuade
// NumValues: 0x0005
enum class EDebugForcePersuade : uint8
{
	NONE                                     = 0,
	SUCCESS                                  = 1,
	FAIL                                     = 2,
	End                                      = 3,
	EDebugForcePersuade_MAX                  = 4,
};

// Enum Nicola.EDebugBattleFlags
// NumValues: 0x0038
enum class EDebugBattleFlags : uint8
{
	ABSOLUTE_RUN                             = 0,
	ABSOLUTE_HIT_PLAYER                      = 1,
	ABSOLUTE_HIT_ENEMY                       = 2,
	ABSOLUTE_YOKE_PLAYER                     = 3,
	ABSOLUTE_YOKE_ENEMY                      = 4,
	ABSOLUTE_MISS_PLAYER                     = 5,
	ABSOLUTE_MISS_ENEMY                      = 6,
	ABSOLUTE_CRITICAL_PLAYER                 = 7,
	ABSOLUTE_CRITICAL_ENEMY                  = 8,
	DAMAGE_ZERO_PLAYER                       = 9,
	DAMAGE_ZERO_ENEMY                        = 10,
	ABSOLUTE_ITEM_DROP                       = 11,
	USE_MP_ZERO                              = 12,
	ALL_SKILL                                = 13,
	ABSOLUTE_INITIATIVE_PLAYER               = 14,
	ABSOLUTE_INITIATIVE_ENEMY                = 15,
	FULL_RECOVERY                            = 16,
	DAMAGE_GUTS_PLAYER                       = 17,
	DAMAGE_GUTS_ENEMY                        = 18,
	ATTACK_DAMAGE_MAX_PLAYER                 = 19,
	ATTACK_DAMAGE_MAX_ENEMY                  = 20,
	IDATEN_PLAYER                            = 21,
	DEBUG_ACTION                             = 22,
	USE_MP_MAX                               = 23,
	ABSOLUTE_SHIEF_STEAL                     = 24,
	ABSOLUTE_MERCHANT_GOLD                   = 25,
	ABSOLUTE_GADABOUT_PLAY                   = 26,
	PERMANENT_DRAGORAM                       = 27,
	EXP_MAX                                  = 28,
	GOLD_MAX                                 = 29,
	OTHER_RENATL                             = 30,
	PERMANENT_CONFUSE                        = 31,
	DEBUG_MONSTER_ACTION_LIST                = 32,
	DISABLE_PARRY_ENEMY                      = 33,
	DISABLE_PARRY_PARTY                      = 34,
	DISABLE_PARRY_FAILURE                    = 35,
	STATUS_EFFECT_PLUS                       = 36,
	ENABLE_ORDEAL_A                          = 37,
	ENABLE_ORDEAL_B                          = 38,
	DEBUG_EXPORT_LOG                         = 39,
	DEBUG_ACTION_PLAY                        = 40,
	ABSOLUTE_AVOID_ATTRIBUTE_PLAYER          = 41,
	ABSOLUTE_AVOID_ATTRIBUTE_ENEMY           = 42,
	USE_MP_MAX_ENEMY                         = 43,
	ABSOLUTE_HIT_ONE_SHOT_KILL               = 44,
	DAMAGE_RAND_MIN                          = 45,
	DAMAGE_RAND_MAX                          = 46,
	DEBUG_SHADOW_METAMORPHOSE_MONSTER        = 47,
	DEBUG_DISABLE_SHOW_BATTLE_MESSAGE        = 48,
	DEBUG_DISABLE_SHOW_BATTLE_DAMAGE         = 49,
	DEBUG_DISABLE_OPEN_BATTLE_MESSAGE        = 50,
	DEBUG_DISABLE_CLOSE_BATTLE_MESSAGE       = 51,
	ENABLE_PRODUCT_UI                        = 60,
	ENABLE_DEBUG_UI                          = 61,
	DebugEnd                                 = 62,
	EDebugBattleFlags_MAX                    = 63,
};

// Enum Nicola.EDebugWorldMapFlags
// NumValues: 0x0007
enum class EDebugWorldMapFlags : uint8
{
	DRAW_AREA_EVENTMARK                      = 0,
	DRAW_AREA_CAMERAMOVE_START               = 1,
	DRAW_AREA_CAMERAMOVE_CONTINUE            = 2,
	FORCE_POP_ALL_EVENTMARK                  = 3,
	USE_LOCAL_CAMERA_PARAMETER               = 4,
	DebugEnd                                 = 5,
	EDebugWorldMapFlags_MAX                  = 6,
};

// Enum Nicola.EDebugEtcFlags
// NumValues: 0x000D
enum class EDebugEtcFlags : uint8
{
	DebugEtcDontDeleteContinueData           = 0,
	DebugEtcAlwaysFailSavingGameData         = 1,
	DebugEtcAlwaysFailLoadingGameData        = 2,
	DebugEtcAlwaysFailSavingSystemData       = 3,
	DebugEtcAlwaysFailLoadingSystemData      = 4,
	EnableInputMouse                         = 5,
	DisableLevelPreload                      = 6,
	DeleteSystemDataOnInitialLevel           = 7,
	DebugEtcAlwaysFailSavingAutoSave         = 8,
	DebugIgnoreXR                            = 9,
	DebugShowMouseCursorAlways               = 10,
	DebugEtcEnd                              = 11,
	EDebugEtcFlags_MAX                       = 12,
};

// Enum Nicola.EDebugSoundFlags
// NumValues: 0x0008
enum class EDebugSoundFlags : uint8
{
	MUTE_BGM                                 = 0,
	MUTE_SE                                  = 1,
	MUTE_VOICE                               = 2,
	MUTE_AMBIENT                             = 3,
	FORCE_SUPERVISION_VOLUMERATE             = 4,
	NOT_PLAY_SOUND_BY_EVENT_SEQUENCER        = 5,
	DebugSoundEnd                            = 6,
	EDebugSoundFlags_MAX                     = 7,
};

// Enum Nicola.EDebugDrawFlags
// NumValues: 0x0030
enum class EDebugDrawFlags : uint8
{
	DrawMapTime                              = 0,
	CharaStatus                              = 1,
	HideUMG                                  = 2,
	GameStatus                               = 3,
	LuaStatus                                = 4,
	LuaTrigger                               = 5,
	LuaSysGlobal                             = 6,
	LuaSysFlag                               = 7,
	LuaGameInfo                              = 8,
	LuaSysInfo                               = 9,
	LuaSysShortNameDisp                      = 10,
	UEOutput                                 = 11,
	MessageLog                               = 12,
	DrawScreenMessageEnable                  = 13,
	DisableDofFlag                           = 14,
	DrawFocusPoint                           = 15,
	DrawActorHiddenInGame                    = 16,
	DrawAnalogInput                          = 17,
	ForceHideUMG                             = 18,
	Hide3DUI                                 = 19,
	TownDungeonMapLoadingInfo                = 20,
	DebugDrawPhysicalMaterial                = 21,
	DrawPlayerCharacterInfo                  = 22,
	DrawFlipbookSocket                       = 23,
	DrawBattleEffectInfo                     = 24,
	DrawBattleLocationInfo                   = 25,
	DrawEventDebugInfo                       = 26,
	DrawParameterCollectionInfo01            = 27,
	DrawParameterCollectionInfo02            = 28,
	DrawDebugTrace                           = 29,
	DrawSoundInfo                            = 30,
	DrawBattleStatusInfo                     = 31,
	DrawSearchDistanceTOUZOKUNOHANA          = 32,
	DrawSearchDistanceREMIRAMA               = 33,
	DrawSearchDistanceEchoFlute              = 34,
	DrawSearchDistanceYASEINOKAN             = 35,
	DrawBattleSpriteInfo                     = 36,
	DebugDisplayGOPID                        = 37,
	DrawEncountStep                          = 38,
	DrawHardwareInfo                         = 39,
	DrawCameraTriggerBounds                  = 40,
	DrawLightingEnvTriggerBounds             = 41,
	DrawFieldEffectTriggerBounds             = 42,
	DrawCameraEffectTriggerBounds            = 43,
	DrawStatusEffectCountInfo                = 44,
	WorldCompositionStreamingInfo            = 45,
	DebugDrawFlagsEnd                        = 46,
	EDebugDrawFlags_MAX                      = 47,
};

// Enum Nicola.EDebugActionFlags
// NumValues: 0x0022
enum class EDebugActionFlags : uint8
{
	StopCelestialSphereTime                  = 0,
	ForceMapTimeProgress                     = 1,
	ForceMapTimeHalt                         = 2,
	MapTimeSetStarting                       = 3,
	DisableCharDirAdjust                     = 4,
	EnablePlayerFastMove                     = 5,
	DisablePlayerHitWall                     = 6,
	EnableFlyMode                            = 7,
	EnableCameraChangeMode                   = 8,
	DisableTutorial                          = 9,
	DisableTransitionMap                     = 10,
	ForceVisibleHandLamp                     = 11,
	DisableAirWalk                           = 12,
	DisableCameraCollision                   = 13,
	DisablePlayEventSceneVolume              = 14,
	DisableEncount                           = 15,
	DisableVisibleHandLamp                   = 16,
	DisableSpriteHandLamp                    = 17,
	EnableWaitVisibleFieldMapAtLocation      = 18,
	EnableNavMeshMove                        = 19,
	DisableFixingMapTimeInUnderground        = 20,
	DisableButtonGuide                       = 21,
	EnableSwitchRecollectionCapture          = 22,
	EnableDataTracking                       = 23,
	EnableInitialToDefault                   = 24,
	EnableChangeRecordCount                  = 25,
	EnableEventSequencerDebugFunction        = 26,
	EnableResearchByItemEmpty                = 27,
	HideSearchEventGimmick                   = 28,
	EnableErrorDialogByPackage               = 29,
	MaxPlayTime                              = 30,
	FadeWidgetTranslucent                    = 31,
	DebugActionFlagsEnd                      = 32,
	EDebugActionFlags_MAX                    = 33,
};

// Enum Nicola.EEventFlagType
// NumValues: 0x0009
enum class EEventFlagType : uint8
{
	FLAG_EVENT                               = 0,
	FLAG_DUNGEON                             = 1,
	FLAG_FLOOR                               = 2,
	FLAG_SUSPEND                             = 3,
	VALUE_EVENT                              = 4,
	VALUE_DUNGEON                            = 5,
	VALUE_ORB                                = 6,
	VALUE_SAVE_EVENT                         = 7,
	EEventFlagType_MAX                       = 8,
};

// Enum Nicola.ERestorePatternAfterEvent
// NumValues: 0x0006
enum class ERestorePatternAfterEvent : uint8
{
	NoChange                                 = 0,
	NpcCollision                             = 1,
	NpcShadowOffset                          = 2,
	NpcRenderPath                            = 4,
	NpcPrePass                               = 8,
	ERestorePatternAfterEvent_MAX            = 9,
};

// Enum Nicola.ENicolaFieldTriggerActorTypeFlag
// NumValues: 0x0005
enum class ENicolaFieldTriggerActorTypeFlag : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Camera                                   = 2,
	PlayerAndCamera                          = 3,
	ENicolaFieldTriggerActorTypeFlag_MAX     = 4,
};

// Enum Nicola.GamePlatformType
// NumValues: 0x0003
enum class EGamePlatformType : uint8
{
	Switch                                   = 0,
	Windows                                  = 1,
	GamePlatformType_MAX                     = 2,
};

// Enum Nicola.SaveType
// NumValues: 0x0005
enum class ESaveType : uint8
{
	Normal                                   = 0,
	Auto                                     = 1,
	Continue                                 = 2,
	ClearSave                                = 3,
	SaveType_MAX                             = 4,
};

// Enum Nicola.GameTypeVersion
// NumValues: 0x0004
enum class EGameTypeVersion : uint8
{
	PRODUCT_VERSION                          = 0,
	TRIAL_VERSION1                           = 1,
	TRIAL_VERSION2                           = 2,
	GameTypeVersion_MAX                      = 3,
};

// Enum Nicola.SaveGameDataType
// NumValues: 0x0003
enum class ESaveGameDataType : uint8
{
	System                                   = 0,
	Game                                     = 1,
	SaveGameDataType_MAX                     = 2,
};

// Enum Nicola.EGameFlowMode
// NumValues: 0x0006
enum class EGameFlowMode : uint8
{
	INVALID                                  = 0,
	TITLE                                    = 1,
	RESEARCH                                 = 2,
	FIELD                                    = 3,
	BATTLE                                   = 4,
	EGameFlowMode_MAX                        = 5,
};

// Enum Nicola.ENicolaUIWidgets
// NumValues: 0x0002
enum class ENicolaUIWidgets : uint8
{
	None                                     = 0,
	ENicolaUIWidgets_MAX                     = 1,
};

// Enum Nicola.ENicolaUICategories
// NumValues: 0x0004
enum class ENicolaUICategories : uint8
{
	None                                     = 0,
	Core                                     = 1,
	All                                      = 1,
	ENicolaUICategories_MAX                  = 2,
};

// Enum Nicola.ENicolaAction
// NumValues: 0x002B
enum class ENicolaAction : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	UpBtnOnly                                = 4,
	DownBtnOnly                              = 5,
	LeftBtnOnly                              = 6,
	RightBtnOnly                             = 7,
	Search                                   = 8,
	Dash                                     = 9,
	DashHuman                                = 10,
	MenuOpen                                 = 11,
	MapOpen                                  = 12,
	Ride                                     = 13,
	Landing                                  = 14,
	TargetMarkerReset                        = 15,
	CameraZoomIn                             = 16,
	CameraZoomOut                            = 17,
	CameraReset                              = 18,
	CameraFOVWiden                           = 19,
	CameraFOVNarrow                          = 20,
	Decide                                   = 21,
	Cancel                                   = 22,
	DebugMenu                                = 23,
	DebugConsole                             = 24,
	DebugSuperDash1                          = 25,
	DebugSuperDash2                          = 26,
	DebugSuperDash3                          = 27,
	DebugFly                                 = 28,
	SoundTestStopSound                       = 29,
	SoundSuperVisionVolumeRateUpCurrentFocus = 30,
	SoundSuperVisionVolumeRateDownCurrentFocus = 31,
	SoundSuperVisionStartPositionAdd         = 32,
	SoundSuperVisionStartPositionSub         = 33,
	SoundSuperVisionPlayCurrentFocus         = 34,
	SoundSuperVisionHoldCurrentFocus         = 35,
	SoundSuperVisionStopCurrentPlaying       = 36,
	SoundSuperVisionTogglePlayStateHolding   = 37,
	SoundSuperVisionSaveEdit                 = 38,
	SoundSuperVisionDisposeEdit              = 39,
	SoundSuperVisionReloadSetting            = 40,
	Num                                      = 41,
	ENicolaAction_MAX                        = 42,
};

// Enum Nicola.ENicolaInputMode
// NumValues: 0x0009
enum class ENicolaInputMode : uint8
{
	GamePlay                                 = 0,
	GameMessage                              = 1,
	StandbyLua                               = 2,
	GameEvent                                = 3,
	GameUI                                   = 4,
	GameBattle                               = 5,
	NoInput                                  = 6,
	DebugMenu                                = 7,
	Max                                      = 8,
};

// Enum Nicola.ENicolaKeyConfigType
// NumValues: 0x0003
enum class ENicolaKeyConfigType : uint8
{
	TypeA                                    = 0,
	Num                                      = 1,
	ENicolaKeyConfigType_MAX                 = 2,
};

// Enum Nicola.ENicolaAnalogStick
// NumValues: 0x0004
enum class ENicolaAnalogStick : uint8
{
	L                                        = 0,
	R                                        = 1,
	Num                                      = 2,
	ENicolaAnalogStick_MAX                   = 3,
};

// Enum Nicola.ENicolaButton
// NumValues: 0x001A
enum class ENicolaButton : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	RUp                                      = 4,
	RDown                                    = 5,
	RRight                                   = 6,
	RLeft                                    = 7,
	LShoulder                                = 8,
	LTrigger                                 = 9,
	RShoulder                                = 10,
	RTrigger                                 = 11,
	StickL_Up                                = 12,
	StickL_Down                              = 13,
	StickL_Left                              = 14,
	StickL_Right                             = 15,
	StickL_Button                            = 16,
	StickR_Up                                = 17,
	StickR_Down                              = 18,
	StickR_Left                              = 19,
	StickR_Right                             = 20,
	StickR_Button                            = 21,
	SpecialRight                             = 22,
	SpecialLeft                              = 23,
	Num                                      = 24,
	ENicolaButton_MAX                        = 25,
};

// Enum Nicola.ENicolaLightCorrectionFlag
// NumValues: 0x0006
enum class ENicolaLightCorrectionFlag : uint8
{
	None                                     = 0,
	LightIntensity                           = 1,
	LightColor                               = 2,
	SkySphereOverallColor                    = 4,
	All                                      = 255,
	ENicolaLightCorrectionFlag_MAX           = 256,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_FieldSymbol
// NumValues: 0x0004
enum class ENicolaNicolaLightingEnvParam_FieldSymbol : uint8
{
	None                                     = 0,
	Lighting_Rate                            = 1,
	Num                                      = 2,
	ENicolaNicolaLightingEnvParam_MAX        = 3,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_MPC_HeatHaze
// NumValues: 0x0004
enum class ENicolaNicolaLightingEnvParam_MPC_HeatHaze : uint8
{
	None                                     = 0,
	HeatHaze_Power                           = 1,
	Num                                      = 2,
	ENicolaNicolaLightingEnvParam_MPC_MAX    = 3,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_MPC_Foliage
// NumValues: 0x0004
enum class ENicolaNicolaLightingEnvParam_MPC_Foliage : uint8
{
	None                                     = 0,
	Foliage_DayLightColor                    = 1,
	Num                                      = 2,
	ENicolaNicolaLightingEnvParam_MPC_MAX    = 3,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_MPC_Water
// NumValues: 0x000D
enum class ENicolaNicolaLightingEnvParam_MPC_Water : uint8
{
	None                                     = 0,
	WaterColor                               = 1,
	WaterFakeSpecColor                       = 2,
	WaterFakeSpecPower                       = 3,
	WaveDirection                            = 4,
	WaveHeight                               = 5,
	CausticsColor                            = 6,
	SeaFoamColor                             = 7,
	Effect_DisappearCameraFakeSpecular       = 8,
	Effect_RangeMin                          = 9,
	Effect_ZPositionOffset                   = 10,
	Num                                      = 11,
	ENicolaNicolaLightingEnvParam_MPC_MAX    = 12,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_MPC_Cloud
// NumValues: 0x0004
enum class ENicolaNicolaLightingEnvParam_MPC_Cloud : uint8
{
	None                                     = 0,
	ShadowIntensity                          = 1,
	Num                                      = 2,
	ENicolaNicolaLightingEnvParam_MPC_MAX    = 3,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_MPC_SkySphere
// NumValues: 0x000B
enum class ENicolaNicolaLightingEnvParam_MPC_SkySphere : uint8
{
	None                                     = 0,
	SkyChange                                = 1,
	StarBrightness                           = 2,
	SkyColor                                 = 3,
	HorizonColor                             = 4,
	SunPosition                              = 5,
	SunColor                                 = 6,
	CloudColor                               = 7,
	VoidColor                                = 8,
	Num                                      = 9,
	ENicolaNicolaLightingEnvParam_MPC_MAX    = 10,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_MPC_Emissive
// NumValues: 0x0005
enum class ENicolaNicolaLightingEnvParam_MPC_Emissive : uint8
{
	None                                     = 0,
	GlobalEmissiveAdjust                     = 1,
	WindowEmissiveIntensity                  = 2,
	Num                                      = 3,
	ENicolaNicolaLightingEnvParam_MPC_MAX    = 4,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_PostProcessVolume
// NumValues: 0x000B
enum class ENicolaNicolaLightingEnvParam_PostProcessVolume : uint8
{
	None                                     = 0,
	Bloom_Intensity                          = 1,
	AutoExposure_MinBrightness               = 2,
	AutoExposure_MaxBrightness               = 3,
	AutoExposure_SpeedUp                     = 4,
	AutoExposure_SpeedDown                   = 5,
	LensFlare_Intensity                      = 6,
	ImageEffects_VignetteIntensity           = 7,
	SceneColorTint                           = 8,
	Num                                      = 9,
	ENicolaNicolaLightingEnvParam_MAX        = 10,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_ExponentialHeightFog
// NumValues: 0x000C
enum class ENicolaNicolaLightingEnvParam_ExponentialHeightFog : uint8
{
	None                                     = 0,
	Density                                  = 1,
	InscatteringColor                        = 2,
	HeightFallOff                            = 3,
	MaxOpacity                               = 4,
	StartDistance                            = 5,
	CutOffDistance                           = 6,
	DirectionalInscatteringExponent          = 7,
	DirectionalInscatteringStartDistance     = 8,
	DirectionalInscatteringColor             = 9,
	Num                                      = 10,
	ENicolaNicolaLightingEnvParam_MAX        = 11,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_SkyLight
// NumValues: 0x0005
enum class ENicolaNicolaLightingEnvParam_SkyLight : uint8
{
	None                                     = 0,
	Intensity                                = 1,
	Color                                    = 2,
	Num                                      = 3,
	ENicolaNicolaLightingEnvParam_MAX        = 4,
};

// Enum Nicola.ENicolaNicolaLightingEnvParam_DirectionalLight
// NumValues: 0x0005
enum class ENicolaNicolaLightingEnvParam_DirectionalLight : uint8
{
	None                                     = 0,
	Intensity                                = 1,
	Color                                    = 2,
	Num                                      = 3,
	ENicolaNicolaLightingEnvParam_MAX        = 4,
};

// Enum Nicola.ENicolaDateType
// NumValues: 0x0004
enum class ENicolaDateType : uint8
{
	ASIA                                     = 0,
	AMERICA                                  = 1,
	EUROPE                                   = 2,
	ENicolaDateType_MAX                      = 3,
};

// Enum Nicola.ENicolaLanguageChangeFlag
// NumValues: 0x0005
enum class ENicolaLanguageChangeFlag : uint8
{
	NONE                                     = 0,
	TEXT                                     = 1,
	VOICE                                    = 2,
	ALL                                      = 255,
	ENicolaLanguageChangeFlag_MAX            = 256,
};

// Enum Nicola.ENicolaLanguageVoice
// NumValues: 0x0003
enum class ENicolaLanguageVoice : uint8
{
	JP                                       = 0,
	EN                                       = 1,
	ENicolaLanguageVoice_MAX                 = 2,
};

// Enum Nicola.ENicolaLanguage
// NumValues: 0x000C
enum class ENicolaLanguage : uint8
{
	JP                                       = 0,
	JP_HI                                    = 1,
	TW                                       = 2,
	CN                                       = 3,
	KO                                       = 4,
	EN                                       = 5,
	FR                                       = 6,
	IT                                       = 7,
	DE                                       = 8,
	ES                                       = 9,
	ES_419                                   = 10,
	ENicolaLanguage_MAX                      = 11,
};

// Enum Nicola.ETrajectoryParticleType
// NumValues: 0x0009
enum class ETrajectoryParticleType : uint8
{
	NONE                                     = 0,
	NORMAL                                   = 1,
	DANGER                                   = 2,
	DANGER_SPECIAL                           = 3,
	JUMP                                     = 4,
	JUDGEMENTRAY                             = 5,
	SHORYUKEN                                = 6,
	MOVE_UNIT                                = 7,
	ETrajectoryParticleType_MAX              = 8,
};

// Enum Nicola.ETrajectoryOrbitBlockType
// NumValues: 0x0003
enum class ETrajectoryOrbitBlockType : uint8
{
	ATTACK                                   = 0,
	JUMP_MOVE                                = 1,
	ETrajectoryOrbitBlockType_MAX            = 2,
};

// Enum Nicola.EAnimationType
// NumValues: 0x0042
enum class EAnimationType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Idle_HandLamp                            = 2,
	IdleSway                                 = 3,
	IdleSway_HandLamp                        = 4,
	BattleIdle                               = 5,
	BattleIdleSway                           = 6,
	Talk                                     = 7,
	Walk                                     = 8,
	Walk_HandLamp                            = 9,
	Ladder                                   = 10,
	Ladder_HandLamp                          = 11,
	Rope                                     = 12,
	Rope_HandLamp                            = 13,
	Attack                                   = 14,
	Damage                                   = 15,
	Death                                    = 16,
	BattleDeath                              = 17,
	Act1                                     = 18,
	Act2                                     = 19,
	Act3                                     = 20,
	Act4                                     = 21,
	Act5                                     = 22,
	Act6                                     = 23,
	Act7                                     = 24,
	Act8                                     = 25,
	Act9                                     = 26,
	Act10                                    = 27,
	Act11                                    = 28,
	Act12                                    = 29,
	Act13                                    = 30,
	Act14                                    = 31,
	Act15                                    = 32,
	Act16                                    = 33,
	Act17                                    = 34,
	Act18                                    = 35,
	Act19                                    = 36,
	Act20                                    = 37,
	Act21                                    = 38,
	Act22                                    = 39,
	Act23                                    = 40,
	Act24                                    = 41,
	Act25                                    = 42,
	Act26                                    = 43,
	Act27                                    = 44,
	Act28                                    = 45,
	Act29                                    = 46,
	Act30                                    = 47,
	Act31                                    = 48,
	Act32                                    = 49,
	Act33                                    = 50,
	Act34                                    = 51,
	Act35                                    = 52,
	Act36                                    = 53,
	Act37                                    = 54,
	Act38                                    = 55,
	Act39                                    = 56,
	Act40                                    = 57,
	Act41                                    = 58,
	Act42                                    = 59,
	Act43                                    = 60,
	Bed                                      = 61,
	Floor                                    = 62,
	Sit_L                                    = 63,
	Sit_R                                    = 64,
	Max                                      = 65,
};

// Enum Nicola.EFlipbookMirroringType
// NumValues: 0x0004
enum class EFlipbookMirroringType : uint8
{
	NONE                                     = 0,
	PRE_MIRRORED                             = 1,
	DYNAMIC_MIRRORED                         = 2,
	EFlipbookMirroringType_MAX               = 3,
};

// Enum Nicola.EFlipbookUseType
// NumValues: 0x0006
enum class EFlipbookUseType : uint8
{
	NONE                                     = 0,
	CHARACTER                                = 1,
	WEAPON                                   = 2,
	HAND_LAMP                                = 3,
	OTHER                                    = 4,
	EFlipbookUseType_MAX                     = 5,
};

// Enum Nicola.ENicolaStageCameraParamCopyType
// NumValues: 0x0008
enum class ENicolaStageCameraParamCopyType : uint8
{
	CurrentMap                               = 0,
	CurrentTrace                             = 1,
	CurrentStage                             = 2,
	CurrentBattle                            = 3,
	Event01                                  = 4,
	Event02                                  = 5,
	Event03                                  = 6,
	Max                                      = 7,
};

// Enum Nicola.ENicolaInputStickDirection
// NumValues: 0x0005
enum class ENicolaInputStickDirection : uint8
{
	UP                                       = 0,
	DOWN                                     = 1,
	RIGHT                                    = 2,
	LEFT                                     = 3,
	ENicolaInputStickDirection_MAX           = 4,
};

// Enum Nicola.EButtonGuideIconType
// NumValues: 0x0006
enum class EButtonGuideIconType : uint8
{
	None                                     = 0,
	Search                                   = 1,
	Talk                                     = 2,
	Ride                                     = 3,
	Move                                     = 4,
	EButtonGuideIconType_MAX                 = 5,
};

// Enum Nicola.EResearchPriority
// NumValues: 0x0006
enum class EResearchPriority : uint8
{
	None                                     = 0,
	OpenedSearchObject                       = 1,
	NPC                                      = 2,
	Vehicle                                  = 3,
	SearchObject                             = 4,
	EResearchPriority_MAX                    = 5,
};

// Enum Nicola.ESkillParamType
// NumValues: 0x0005
enum class ESkillParamType : uint8
{
	NONE                                     = 0,
	INT                                      = 1,
	FLOAT                                    = 2,
	PERCENT                                  = 3,
	ESkillParamType_MAX                      = 4,
};

// Enum Nicola.ESkillResultType
// NumValues: 0x000A
enum class ESkillResultType : uint8
{
	NONE                                     = 0,
	SUCCESS_NORMAL                           = 1,
	SUCCESS_SPECIAL                          = 2,
	FAILED_NORMAL                            = 3,
	FAILED_NORMAL_2                          = 4,
	FAILED_DEAD                              = 5,
	FAILED_SPECIAL                           = 6,
	FAILED_RURA                              = 7,
	COUNT                                    = 8,
	ESkillResultType_MAX                     = 9,
};

// Enum Nicola.ESkipSequenceAfterBgmPlayType
// NumValues: 0x0007
enum class ESkipSequenceAfterBgmPlayType : uint8
{
	NONE                                     = 0,
	STOP                                     = 1,
	PAUSE                                    = 2,
	RESUME                                   = 3,
	PLAY_BGM                                 = 4,
	PLAY_BATTLE_BGM                          = 5,
	ESkipSequenceAfterBgmPlayType_MAX        = 6,
};

// Enum Nicola.EBgmPlayerManagerLineTypeOnMEEnd
// NumValues: 0x0005
enum class EBgmPlayerManagerLineTypeOnMEEnd : uint8
{
	NONE                                     = 0,
	MAIN                                     = 1,
	BATTLE                                   = 2,
	CURRENT                                  = 3,
	EBgmPlayerManagerLineTypeOnMEEnd_MAX     = 4,
};

// Enum Nicola.EBgmPlayerManagerMEPlayRequestType
// NumValues: 0x0007
enum class EBgmPlayerManagerMEPlayRequestType : uint8
{
	INVALID                                  = 0,
	RESUME                                   = 1,
	STOP                                     = 2,
	PAUSE                                    = 3,
	PLAY_NEW                                 = 4,
	PLAY_SAME                                = 5,
	EBgmPlayerManagerMEPlayRequestType_MAX   = 6,
};

// Enum Nicola.ENicolaSoundBgmManagementTypeOnMapTransitionPreMapBgm
// NumValues: 0x0004
enum class ENicolaSoundBgmManagementTypeOnMapTransitionPreMapBgm : uint8
{
	DEFAULT                                  = 0,
	PAUSE                                    = 1,
	NOP                                      = 2,
	ENicolaSoundBgmManagementTypeOnMapTransitionPreMapBgm_MAX = 3,
};

// Enum Nicola.ENicolaSoundBgmManagementTypeOnMapTransition
// NumValues: 0x0004
enum class ENicolaSoundBgmManagementTypeOnMapTransition : uint8
{
	DEFAULT                                  = 0,
	RESUME                                   = 1,
	NOP                                      = 2,
	ENicolaSoundBgmManagementTypeOnMapTransition_MAX = 3,
};

// Enum Nicola.ENicolaSoundPlayOptionFlags
// NumValues: 0x0005
enum class ENicolaSoundPlayOptionFlags : uint8
{
	NONE                                     = 0,
	FADE_IN                                  = 1,
	FORCE_VOLUME0                            = 2,
	ALL                                      = 255,
	ENicolaSoundPlayOptionFlags_MAX          = 256,
};

// Enum Nicola.ENicolaListenerType
// NumValues: 0x0002
enum class ENicolaListenerType : uint8
{
	SE_DEFAULT                               = 0,
	MAX                                      = 1,
};

// Enum Nicola.ENicolaSoundDataTableType
// NumValues: 0x0004
enum class ENicolaSoundDataTableType : uint8
{
	BGM                                      = 0,
	SE                                       = 1,
	VOICE                                    = 2,
	ENicolaSoundDataTableType_MAX            = 3,
};

// Enum Nicola.EFlipbookAnimationOptionFlag
// NumValues: 0x000A
enum class EFlipbookAnimationOptionFlag : uint8
{
	NONE                                     = 0,
	EFFECT_OFF                               = 1,
	SE_OFF                                   = 2,
	VOICE_OFF                                = 4,
	RANDOM_START                             = 8,
	WEAPON_OFF                               = 16,
	FOOTSTEP_OFF                             = 32,
	REVERSE                                  = 64,
	ALL                                      = 255,
	EFlipbookAnimationOptionFlag_MAX         = 256,
};

// Enum Nicola.ESkillUsableTyming
// NumValues: 0x0005
enum class ESkillUsableTyming : uint8
{
	NONE                                     = 0,
	ALL                                      = 1,
	BATTLE                                   = 2,
	NO_BATTLE                                = 3,
	ESkillUsableTyming_MAX                   = 4,
};

// Enum Nicola.ESkillMasterState
// NumValues: 0x0005
enum class ESkillMasterState : uint8
{
	NONE                                     = 0,
	NOT_MASTERED                             = 1,
	MASTERED_CURRENT_JOB                     = 2,
	MASTERED_BEFORE_JOB                      = 3,
	ESkillMasterState_MAX                    = 4,
};

// Enum Nicola.ENicolaUnitStatusEffectFlag
// NumValues: 0x0022
enum class ENicolaUnitStatusEffectFlag : uint64
{
	NONE                                     = 0,
	DEAD                                     = 1,
	POISON                                   = 2,
	PARALYZE                                 = 4,
	CURSE                                    = 8,
	CONFUSION                                = 16,
	MAHOTON                                  = 32,
	MAHOKANTA                                = 64,
	ASUTORON                                 = 128,
	MOSHASU                                  = 256,
	DORAGORAMU                               = 512,
	MANUSA                                   = 1024,
	FUBAHA                                   = 2048,
	BAIKIRUTO                                = 4096,
	ALL_KAISIN                               = 8192,
	TIME_STOP                                = 16384,
	SLEEP                                    = 32768,
	STUN                                     = 65536,
	BEAST                                    = 131072,
	COUNTER_BREATH                           = 262144,
	BUILD_UP                                 = 524288,
	NO_DAMAGE                                = 1048576,
	AUTO_HEAL_MP                             = 2097152,
	DISABLE_SPELL                            = 4194304,
	PARRY                                    = 8388608,
	COVER_UP                                 = 16777216,
	ALL_COVER                                = 33554432,
	DAMAGE_DOWN                              = 67108864,
	LEAVE                                    = 134217728,
	LIQUOR                                   = 268435456,
	ALL                                      = 18446744073709551615,
	ALL_EXCLUDE_CURSE                        = 18446744073709551607,
	LEVEL_UP_REMOVE                          = 32790,
	ENicolaUnitStatusEffectFlag_MAX          = 268435457,
};

// Enum Nicola.EEquipCostumeType
// NumValues: 0x0004
enum class EEquipCostumeType : uint8
{
	DEFAULT                                  = 0,
	CATSUIT                                  = 1,
	SWIMSUIT                                 = 2,
	EEquipCostumeType_MAX                    = 3,
};

// Enum Nicola.EEquipPosition
// NumValues: 0x0008
enum class EEquipPosition : uint8
{
	NONE                                     = 0,
	WEAPON                                   = 1,
	SHIELD                                   = 2,
	HELMET                                   = 3,
	ARMOR                                    = 4,
	ACCESSORY_MAIN                           = 5,
	ACCESSORY_SUB                            = 6,
	EEquipPosition_MAX                       = 7,
};

// Enum Nicola.EBagSortType
// NumValues: 0x0006
enum class EBagSortType : uint8
{
	NONE                                     = 0,
	TYPE                                     = 1,
	ABC                                      = 2,
	PARAM                                    = 3,
	NUM                                      = 4,
	EBagSortType_MAX                         = 5,
};

// Enum Nicola.EDebugCharaMakeOption
// NumValues: 0x0005
enum class EDebugCharaMakeOption : uint8
{
	NONE                                     = 0,
	DEAD                                     = 1,
	SWIM_SUIT                                = 2,
	COSTUME                                  = 3,
	EDebugCharaMakeOption_MAX                = 4,
};

// Enum Nicola.EMantanResultType
// NumValues: 0x0009
enum class EMantanResultType : uint8
{
	NONE                                     = 0,
	ALL_SUCCESS                              = 1,
	PART_SUCCESS_MP                          = 2,
	PART_SUCCESS_NO_EXIST_USER               = 3,
	FAILED_MP                                = 4,
	FAILED_NO_EXIST_USER                     = 5,
	UNNECESSARY                              = 6,
	COUNT                                    = 7,
	EMantanResultType_MAX                    = 8,
};

// Enum Nicola.EPatrolState
// NumValues: 0x0008
enum class EPatrolState : uint8
{
	NONE                                     = 0,
	WAIT_VISIBLE_FLOOR                       = 1,
	WAIT                                     = 2,
	DECIDE_LOCATION                          = 3,
	RUN                                      = 4,
	TURN                                     = 5,
	SCRIPT_COMMAND                           = 6,
	EPatrolState_MAX                         = 7,
};

// Enum Nicola.ENpcDirectionType
// NumValues: 0x0008
enum class ENpcDirectionType : uint8
{
	Upper                                    = 0,
	Right                                    = 1,
	Lower                                    = 2,
	Left                                     = 3,
	ToPlayer                                 = 10,
	InitialRot                               = 11,
	None                                     = 12,
	ENpcDirectionType_MAX                    = 13,
};

// Enum Nicola.ENpcMovePattern
// NumValues: 0x000F
enum class ENpcMovePattern : uint8
{
	None                                     = 0,
	TurnAround                               = 1,
	MoveRandomRange                          = 2,
	MoveRandomLR                             = 3,
	MoveRandomUD                             = 4,
	MoveTurnRight                            = 5,
	MoveTurnLeft                             = 6,
	PlayerBlockX                             = 7,
	PlayerBlockY                             = 8,
	MoveRandomRangeVH                        = 9,
	MoveRandomRangeHV                        = 10,
	MoveRandomRangeVHR                       = 11,
	PlayerBlockXNoTurn                       = 12,
	PlayerBlockYNoTurn                       = 13,
	ENpcMovePattern_MAX                      = 14,
};

// Enum Nicola.ETestPatrolState
// NumValues: 0x0003
enum class ETestPatrolState : uint8
{
	WAIT                                     = 0,
	RUN                                      = 1,
	MAX                                      = 2,
};

// Enum Nicola.EPlayerType
// NumValues: 0x000A
enum class EPlayerType : uint8
{
	TownDungeon                              = 1,
	Field                                    = 2,
	Swim                                     = 4,
	Fly                                      = 8,
	King                                     = 16,
	Monster                                  = 32,
	Unknown                                  = 192,
	TransitionDefault                        = 192,
	TransitionMorphEnd                       = 128,
	EPlayerType_MAX                          = 193,
};

// Enum Nicola.EVolumeType
// NumValues: 0x0006
enum class EVolumeType : uint8
{
	None                                     = 255,
	Lantern                                  = 0,
	Encount                                  = 1,
	Fall                                     = 2,
	MapTransition                            = 3,
	Max                                      = 4,
};

// Enum Nicola.ENicolaCameraParamType
// NumValues: 0x0005
enum class ENicolaCameraParamType : uint8
{
	Trace                                    = 0,
	Battle                                   = 1,
	StageMain                                = 2,
	StageSub                                 = 3,
	Max                                      = 4,
};

// Enum Nicola.EPS5ActivityOutcome
// NumValues: 0x0004
enum class EPS5ActivityOutcome : uint8
{
	Completed                                = 0,
	Failed                                   = 1,
	Abandoned                                = 2,
	EPS5ActivityOutcome_MAX                  = 3,
};

// Enum Nicola.ERecollectionMessageType
// NumValues: 0x0003
enum class ERecollectionMessageType : uint8
{
	DEFAULT                                  = 0,
	SELECT                                   = 1,
	ERecollectionMessageType_MAX             = 2,
};

// Enum Nicola.ERecollectionInfoType
// NumValues: 0x0004
enum class ERecollectionInfoType : uint8
{
	NONE                                     = 0,
	MESSAGE                                  = 1,
	TAG                                      = 2,
	ERecollectionInfoType_MAX                = 3,
};

// Enum Nicola.EDifficulty
// NumValues: 0x0005
enum class EDifficulty : uint8
{
	EASY                                     = 0,
	NORMAL                                   = 1,
	HARD                                     = 2,
	NUM                                      = 3,
	EDifficulty_MAX                          = 4,
};

// Enum Nicola.EPlatformDlcResult
// NumValues: 0x0004
enum class EPlatformDlcResult : uint8
{
	SUCCESS                                  = 0,
	FAILED                                   = 1,
	OTHER                                    = 2,
	MAX                                      = 3,
};

// Enum Nicola.EDlcType
// NumValues: 0x0006
enum class EDlcType : uint8
{
	DLC_EARLY                                = 0,
	DLC_FAST_GUIDE                           = 1,
	DLC_OFFICIAL_GUIDE                       = 2,
	DLC_LAWSON                               = 3,
	DLC_AMAZON                               = 4,
	MAX                                      = 5,
};

// Enum Nicola.ECallFriendAppearDirectionType
// NumValues: 0x0005
enum class ECallFriendAppearDirectionType : uint8
{
	FROM_TOP                                 = 0,
	FROM_BOTTOM                              = 1,
	FROM_LEFT                                = 2,
	FROM_RIGHT                               = 3,
	FROM_MAX                                 = 4,
};

// Enum Nicola.ETownTelopColorType
// NumValues: 0x0003
enum class ETownTelopColorType : uint8
{
	GOLD                                     = 0,
	SHILVER                                  = 1,
	ETownTelopColorType_MAX                  = 2,
};

// Enum Nicola.EEventBattleCameraChangeType
// NumValues: 0x0003
enum class EEventBattleCameraChangeType : uint8
{
	HP_RATE                                  = 0,
	KILL_COUNT                               = 1,
	EEventBattleCameraChangeType_MAX         = 2,
};

// Enum Nicola.EMapChangeGroupType
// NumValues: 0x0006
enum class EMapChangeGroupType : uint8
{
	BURG                                     = 0,
	VOLCANO                                  = 1,
	NOANIEL                                  = 2,
	GIGAPIT                                  = 3,
	NUM                                      = 4,
	EMapChangeGroupType_MAX                  = 5,
};

// Enum Nicola.EUIBTExtraType
// NumValues: 0x0009
enum class EUIBTExtraType : uint8
{
	NONE                                     = 0,
	KABAU                                    = 1,
	NIOUDATI                                 = 2,
	ZAO                                      = 3,
	ZAORARU                                  = 4,
	ZAORIKU                                  = 5,
	YGGDRASIL_LEAF                           = 6,
	NUM                                      = 7,
	EUIBTExtraType_MAX                       = 8,
};

// Enum Nicola.EGuideIconType
// NumValues: 0x0003
enum class EGuideIconType : uint8
{
	MAIN                                     = 0,
	SUB                                      = 1,
	EGuideIconType_MAX                       = 2,
};

// Enum Nicola.EBurgGrowthType
// NumValues: 0x0008
enum class EBurgGrowthType : uint8
{
	NONE                                     = 0,
	BURG_GROWTH_01                           = 1,
	BURG_GROWTH_02                           = 2,
	BURG_GROWTH_03                           = 3,
	BURG_GROWTH_04                           = 4,
	BURG_GROWTH_05                           = 5,
	BURG_GROWTH_06                           = 6,
	EBurgGrowthType_MAX                      = 7,
};

// Enum Nicola.EMapLocationCategoryType
// NumValues: 0x0005
enum class EMapLocationCategoryType : uint8
{
	TOWN                                     = 0,
	DUNGEON                                  = 1,
	OTHER                                    = 2,
	NUM                                      = 3,
	EMapLocationCategoryType_MAX             = 4,
};

// Enum Nicola.EMapLocationIconType
// NumValues: 0x000E
enum class EMapLocationIconType : uint8
{
	CASTLE_YELLOW                            = 0,
	CASTLE_PURPLE                            = 1,
	CAVE_PURPLE                              = 2,
	CAVE_RED                                 = 3,
	TOWN_YELLOW                              = 4,
	TOWN_RED                                 = 5,
	TOWER_PURPLE                             = 6,
	VOLCANO                                  = 7,
	PYRAMID                                  = 8,
	SHRINE_RED                               = 9,
	SHRINE_YELLOW                            = 10,
	CROSS_MARK                               = 11,
	NUM                                      = 12,
	EMapLocationIconType_MAX                 = 13,
};

// Enum Nicola.EUIBTTgtWindowDispType
// NumValues: 0x0016
enum class EUIBTTgtWindowDispType : uint8
{
	NONE                                     = 0,
	HP                                       = 1,
	MP                                       = 2,
	ATTACK_UP                                = 3,
	DEFENSE_UP                               = 4,
	SPEED_UP                                 = 5,
	BUILD_UP                                 = 6,
	MAHOKANTA                                = 7,
	DEAD                                     = 8,
	POISON                                   = 9,
	PARALYZE                                 = 10,
	CURSE                                    = 11,
	SLEEP                                    = 12,
	MANUSA                                   = 13,
	MAHOTON                                  = 14,
	CONFUSION                                = 15,
	ATTACK_DOWN                              = 16,
	DEFENSE_DOWN                             = 17,
	SPEED_DOWN                               = 18,
	TUKKOMI                                  = 19,
	NUM                                      = 20,
	EUIBTTgtWindowDispType_MAX               = 21,
};

// Enum Nicola.EScreenshotProcessType
// NumValues: 0x0002
enum class EScreenshotProcessType : uint8
{
	DEFAULT                                  = 0,
	EScreenshotProcessType_MAX               = 1,
};

// Enum Nicola.EMBRScoutConditionType
// NumValues: 0x0006
enum class EMBRScoutConditionType : uint8
{
	NONE                                     = 0,
	LOOK                                     = 1,
	SOUND                                    = 2,
	SMELL                                    = 3,
	DISGUISE_HUMAN                           = 4,
	EMBRScoutConditionType_MAX               = 5,
};

// Enum Nicola.ELocalizeGenderType
// NumValues: 0x0004
enum class ELocalizeGenderType : uint8
{
	NO                                       = 0,
	MALE                                     = 1,
	FEMALE                                   = 2,
	ELocalizeGenderType_MAX                  = 3,
};

// Enum Nicola.ESoundAmbientCoastType
// NumValues: 0x0003
enum class ESoundAmbientCoastType : uint8
{
	INVALID                                  = 0,
	DEFAULT                                  = 1,
	ESoundAmbientCoastType_MAX               = 2,
};

// Enum Nicola.EOrbColorType
// NumValues: 0x0008
enum class EOrbColorType : uint8
{
	NONE                                     = 0,
	RED                                      = 1,
	GREEN                                    = 2,
	PURPLE                                   = 3,
	BLUE                                     = 4,
	SHILVER                                  = 5,
	YELLOW                                   = 6,
	EOrbColorType_MAX                        = 7,
};

// Enum Nicola.ESwayAnimationType
// NumValues: 0x0004
enum class ESwayAnimationType : uint8
{
	NONE                                     = 0,
	ALWAYS                                   = 1,
	RANDOM                                   = 2,
	ESwayAnimationType_MAX                   = 3,
};

// Enum Nicola.EButtonIcon
// NumValues: 0x0018
enum class EButtonIcon : uint8
{
	EMPTY                                    = 0,
	BTN_CIRCLE                               = 1,
	BTN_CROSS                                = 2,
	BTN_TRIANGLE                             = 3,
	BTN_SQUARE                               = 4,
	BTN_L1                                   = 5,
	BTN_L2                                   = 6,
	BTN_L3                                   = 7,
	BTN_R1                                   = 8,
	BTN_R2                                   = 9,
	BTN_R3                                   = 10,
	LEV_UDLR                                 = 11,
	LEV_UD                                   = 12,
	LEV_LR                                   = 13,
	LEV_U                                    = 14,
	LEV_D                                    = 15,
	LEV_L                                    = 16,
	LEV_R                                    = 17,
	STK_L                                    = 18,
	STK_R                                    = 19,
	BTN_OPTIONS                              = 20,
	BTN_TOUCH                                = 21,
	NUM                                      = 22,
	EButtonIcon_MAX                          = 23,
};

// Enum Nicola.EBuffDebuffAffectSide
// NumValues: 0x0004
enum class EBuffDebuffAffectSide : uint8
{
	NONE                                     = 0,
	PARTY                                    = 1,
	ENEMY                                    = 2,
	EBuffDebuffAffectSide_MAX                = 3,
};

// Enum Nicola.EBuffDebuffChangeType
// NumValues: 0x0005
enum class EBuffDebuffChangeType : uint8
{
	NONE                                     = 0,
	DEFFENSE                                 = 1,
	OFFENSE                                  = 2,
	SPEED                                    = 3,
	EBuffDebuffChangeType_MAX                = 4,
};

// Enum Nicola.EStatusChangeCountTiming
// NumValues: 0x0004
enum class EStatusChangeCountTiming : uint8
{
	NONE                                     = 0,
	TURN_COUNT                               = 1,
	ACTION_COUNT                             = 2,
	EStatusChangeCountTiming_MAX             = 3,
};

// Enum Nicola.EStatusChangeType
// NumValues: 0x0029
enum class EStatusChangeType : uint8
{
	NONE                                     = 0,
	SLEEP                                    = 1,
	POISON                                   = 2,
	PARALYZE                                 = 3,
	CONFUSION                                = 4,
	DEAD                                     = 5,
	MAHOTON                                  = 6,
	MANUSA                                   = 7,
	MOSHASU                                  = 8,
	DORAGORAMU                               = 9,
	ASUTORON                                 = 10,
	MAHOKANTA                                = 11,
	FUBAHA                                   = 12,
	BAIKIRUTO                                = 13,
	STUN                                     = 14,
	RUN_AWAY                                 = 15,
	CRITICAL_HIT                             = 16,
	SPEED_UP                                 = 17,
	SPEED_DOWN                               = 18,
	DEFENSE_UP                               = 19,
	DEFENSE_DOWN                             = 20,
	DEFENSE_DOWN_NOW                         = 21,
	POWER_DOWN                               = 22,
	DAMAGE_UP                                = 23,
	DAMAGE_DOWN                              = 24,
	NO_DAMAGE                                = 25,
	SPELL_DAMAGE_DOWN                        = 26,
	PARRY                                    = 27,
	COVER_UP                                 = 28,
	ALL_COVER                                = 29,
	SPELL_WEAKNESS                           = 30,
	SPELL_ATTACK_UP                          = 31,
	BUILD_UP_STRENGTH                        = 32,
	AUTO_HEAL_MP                             = 33,
	BEAST                                    = 34,
	COUNTER_BREATH                           = 35,
	DISABLE_SPELL                            = 36,
	TIME_STOP                                = 37,
	LEAVE                                    = 38,
	LIQUOR                                   = 39,
	EStatusChangeType_MAX                    = 40,
};

// Enum Nicola.EBattleKillType
// NumValues: 0x0006
enum class EBattleKillType : uint8
{
	NONE                                     = 0,
	GONE                                     = 1,
	VANISH                                   = 2,
	GONE_GOLD_ITEM                           = 3,
	KILL                                     = 4,
	EBattleKillType_MAX                      = 5,
};

// Enum Nicola.EBattleTargetDeadType
// NumValues: 0x0004
enum class EBattleTargetDeadType : uint8
{
	ALIVE                                    = 0,
	DEAD                                     = 1,
	ALL                                      = 2,
	EBattleTargetDeadType_MAX                = 3,
};

// Enum Nicola.EBattleActionSEType
// NumValues: 0x0008
enum class EBattleActionSEType : uint8
{
	NONE                                     = 0,
	ATTACK                                   = 1,
	SPELL                                    = 2,
	ESCAPE                                   = 3,
	SKILL                                    = 4,
	SKILL_ATTACK                             = 5,
	OTHER                                    = 6,
	EBattleActionSEType_MAX                  = 7,
};

// Enum Nicola.EBattleChangeWeightCondition
// NumValues: 0x0006
enum class EBattleChangeWeightCondition : uint8
{
	NONE                                     = 0,
	ALL_GROUP_ACTION_MORE                    = 1,
	ALL_GROUP_ACTION_LESS_THEN               = 2,
	SELF_GROUP_ACTION_MORE                   = 3,
	SELF_GROUP_ACTION_LESS_THEN              = 4,
	EBattleChangeWeightCondition_MAX         = 5,
};

// Enum Nicola.EBattleAddActedListCondition
// NumValues: 0x0006
enum class EBattleAddActedListCondition : uint8
{
	NONE                                     = 0,
	TAKE_ACTION                              = 1,
	SUCCESS                                  = 2,
	ANY_SUCCESS                              = 3,
	ALL_SUCCESS                              = 4,
	EBattleAddActedListCondition_MAX         = 5,
};

// Enum Nicola.EBattleActionTargetCondition
// NumValues: 0x005D
enum class EBattleActionTargetCondition : uint8
{
	NONE                                     = 0,
	SELF                                     = 1,
	OTHER_PR                                 = 2,
	OTHER                                    = 3,
	SELF_GROUP_PR                            = 4,
	SELF_GROUP                               = 5,
	OTHER_GROUP_PR                           = 6,
	OTHER_GROUP                              = 7,
	DEAD_PR                                  = 8,
	DEAD                                     = 9,
	FEMALE_PR                                = 10,
	FEMALE                                   = 11,
	ORDER                                    = 12,
	ORDER_REVERSE                            = 13,
	NOT_MAHOKANTA                            = 14,
	NOT_MAHOTON                              = 15,
	NOT_MANUSA                               = 16,
	NOT_POISON                               = 17,
	NOT_SLEEP                                = 18,
	NOT_PARALYSIS                            = 19,
	NOT_CONFUSION                            = 20,
	HP_25                                    = 21,
	HP_50                                    = 22,
	NOT_MP_ZERO                              = 23,
	ENOUGH_MP_LV2                            = 24,
	ENOUGH_MP_LV1                            = 25,
	NOT_MP_LOSS                              = 26,
	NOT_SPEED_ZERO                           = 27,
	LEVEL_DIFF_5                             = 28,
	CALL_FRIEND                              = 29,
	CALL_FRIEND_ACTION                       = 30,
	CALL_HOIMI_SLIME                         = 31,
	CALL_DAIMAJIN                            = 32,
	CALL_ZOMBI                               = 33,
	CALL_GOKURAKU_TYOU                       = 34,
	CALL_ZOMBI_MASTER                        = 35,
	CALL_MONSTER                             = 36,
	ENABLE_ITETSUKU                          = 37,
	MOST_HP                                  = 38,
	LEAST_HP                                 = 39,
	ATTACKER                                 = 40,
	HEALER                                   = 41,
	SUPPORTER                                = 42,
	NOT_ATTACKER                             = 43,
	NOT_HEALER                               = 44,
	NOT_SUPPORTER                            = 45,
	BOSS                                     = 46,
	NOT_BOSS                                 = 47,
	METAL                                    = 48,
	NOT_METAL                                = 49,
	MOST_DAMAGE                              = 50,
	HAS_SLEEP                                = 51,
	HAS_POISON                               = 52,
	HAS_PARALYZE                             = 53,
	HAS_CONFUSION                            = 54,
	HAS_MAHOTON                              = 55,
	HAS_MANUSA                               = 56,
	HAS_MOSHASU                              = 57,
	HAS_DORAGORAMU                           = 58,
	HAS_ASUTORON                             = 59,
	HAS_MAHOKANTA                            = 60,
	HAS_FUBAHA                               = 61,
	HAS_BAIKIRUTO                            = 62,
	HAS_STUN                                 = 63,
	HAS_CRITICAL_HIT                         = 64,
	HAS_SPEED_UP                             = 65,
	HAS_SPEED_DOWN                           = 66,
	HAS_DEFENSE_UP                           = 67,
	HAS_DEFENSE_DOWN                         = 68,
	HAS_POWER_DOWN                           = 69,
	HAS_DAMAGE_UP                            = 70,
	HAS_DAMAGE_DOWN                          = 71,
	HAS_NO_DAMAGE                            = 72,
	HAS_SPELL_DAMAGE_DOWN                    = 73,
	HAS_PARRY                                = 74,
	HAS_COVER_UP                             = 75,
	HAS_SPELL_WEAKNESS                       = 76,
	HAS_SPELL_ATTACK_UP                      = 77,
	HAS_BUILD_UP_STRENGTH                    = 78,
	HAS_BEAST                                = 79,
	HAS_COUNTER_BREATH                       = 80,
	HAS_DISABLE_SPELL                        = 81,
	HAS_TIME_STOP                            = 82,
	NOT_STUN                                 = 83,
	NOT_POWER_DOWN                           = 84,
	NOT_SPELL_WEAKNESS                       = 85,
	NOT_BAIKIRUTO                            = 86,
	NOT_BUILD_UP_STRENGTH                    = 87,
	GAMEMODE_EASY                            = 88,
	NOT_GAMEMODE_EASY                        = 89,
	GAMEMODE_HARD                            = 90,
	NOT_GAMEMODE_HARD                        = 91,
	EBattleActionTargetCondition_MAX         = 92,
};

// Enum Nicola.EBattleActionActorCondition
// NumValues: 0x0002
enum class EBattleActionActorCondition : uint8
{
	NONE                                     = 0,
	EBattleActionActorCondition_MAX          = 1,
};

// Enum Nicola.EBattleActionListCondition
// NumValues: 0x0014
enum class EBattleActionListCondition : uint8
{
	NONE                                     = 0,
	SELF_HP_MORE                             = 1,
	SELF_HP_LESS_THEN                        = 2,
	PC_ALIVE_MORE                            = 3,
	PC_ALIVE_LESS_THEN                       = 4,
	MONSTER_ALIVE_MORE                       = 5,
	MONSTER_ALIVE_LESS_THEN                  = 6,
	MONSTER_ALIVE_WITH_PARAM                 = 7,
	MONSTER_ALIVE_WITH_PARAM_MORE            = 8,
	MONSTER_ALIVE_WITH_PARAM_LESS_THEN       = 9,
	SELF_BUFF                                = 10,
	SELF_NOT_BUFF                            = 11,
	ANY_MONSTER_BUFF                         = 12,
	ANY_PARTY_BUFF                           = 13,
	PARTY_BUFF_COUNT_MORE                    = 14,
	PARTY_BUFF_COUNT_LESS_THEN               = 15,
	PARTY_LV_MORE                            = 16,
	BLACK_OUT                                = 17,
	NOT_BLACK_OUT                            = 18,
	EBattleActionListCondition_MAX           = 19,
};

// Enum Nicola.EUnitVoicePattern
// NumValues: 0x0016
enum class EUnitVoicePattern : uint8
{
	NONE                                     = 0,
	M_SNA                                    = 1,
	M_YAN                                    = 2,
	M_OKB                                    = 3,
	M_COL                                    = 4,
	M_NKT                                    = 5,
	M_HYK                                    = 6,
	M_GNK                                    = 7,
	M_ONW                                    = 8,
	M_IJW                                    = 9,
	F_KWI                                    = 10,
	F_UCK                                    = 11,
	F_JJU                                    = 12,
	F_SEI                                    = 13,
	F_HTM                                    = 14,
	F_GAL                                    = 15,
	F_URW                                    = 16,
	F_SAB                                    = 17,
	F_OIR                                    = 18,
	M_HRO                                    = 19,
	F_HRO                                    = 20,
	EUnitVoicePattern_MAX                    = 21,
};

// Enum Nicola.EMapSpotType
// NumValues: 0x0011
enum class EMapSpotType : uint8
{
	NONE                                     = 0,
	CHURCH                                   = 1,
	SHOP_WEAPON                              = 2,
	SHOP_ARMOR                               = 3,
	SHOP_ITEM                                = 4,
	SHOP_EQUIP                               = 5,
	INN                                      = 6,
	BAR                                      = 7,
	ARENA                                    = 8,
	DAMA_TEMPLE                              = 9,
	MEDAL_EXCHAGE                            = 10,
	WELL                                     = 11,
	TABI_NO_TOBIRA                           = 12,
	MONSTER_ZOO                              = 13,
	BANK                                     = 14,
	HOUSE                                    = 15,
	EMapSpotType_MAX                         = 16,
};

// Enum Nicola.ENpcMoveWaitTime
// NumValues: 0x0007
enum class ENpcMoveWaitTime : uint8
{
	NO_WAIT                                  = 0,
	SHORT                                    = 1,
	LITTLE_SHORT                             = 2,
	NORMAL                                   = 3,
	LITTLE_LONG                              = 4,
	LONG                                     = 5,
	ENpcMoveWaitTime_MAX                     = 6,
};

// Enum Nicola.ENpcMoveSpeed
// NumValues: 0x0006
enum class ENpcMoveSpeed : uint8
{
	SLOW                                     = 0,
	LITTLE_SLOW                              = 1,
	NORMAL                                   = 2,
	LITTLE_FAST                              = 3,
	FAST                                     = 4,
	ENpcMoveSpeed_MAX                        = 5,
};

// Enum Nicola.ESearchObjectType
// NumValues: 0x0010
enum class ESearchObjectType : uint8
{
	NONE                                     = 0,
	STORAGE                                  = 1,
	DRAWER                                   = 2,
	BOOKSHELF                                = 3,
	BARREL                                   = 4,
	POT                                      = 5,
	SACK                                     = 6,
	GROUND                                   = 7,
	SHINE_SEA                                = 8,
	SHINE_GROUND                             = 9,
	EVENT                                    = 10,
	TREASURE_NORMAL                          = 11,
	TREASURE_IMPORTANT                       = 12,
	TREASURE_ENEMY                           = 13,
	TREASURE_PYRAMID                         = 14,
	ESearchObjectType_MAX                    = 15,
};

// Enum Nicola.EShopType
// NumValues: 0x0007
enum class EShopType : uint8
{
	NONE                                     = 0,
	ITEM                                     = 1,
	WEAPON                                   = 2,
	ARMOR                                    = 3,
	EQUIP                                    = 4,
	RIPOFF                                   = 5,
	EShopType_MAX                            = 6,
};

// Enum Nicola.EBattleTactics
// NumValues: 0x000B
enum class EBattleTactics : uint8
{
	GANGAN                                   = 0,
	GANBARE                                  = 1,
	MAKASERO                                 = 2,
	JUMON                                    = 3,
	INOCHI                                   = 4,
	MEIREI                                   = 5,
	MBR_GANGAN                               = 6,
	MBR_GANBARE                              = 7,
	MBR_JUMON                                = 8,
	MBR_INOCHI                               = 9,
	EBattleTactics_MAX                       = 10,
};

// Enum Nicola.EFieldBGType
// NumValues: 0x000D
enum class EFieldBGType : uint8
{
	NONE                                     = 0,
	GRASS                                    = 1,
	BUSH                                     = 2,
	ROAD                                     = 3,
	FOREST                                   = 4,
	MOUNTAIN                                 = 5,
	SAND                                     = 6,
	BEACH                                    = 7,
	SNOW                                     = 8,
	POISON                                   = 9,
	SEA                                      = 10,
	RIVER                                    = 11,
	EFieldBGType_MAX                         = 12,
};

// Enum Nicola.EBattleEffectLocationType
// NumValues: 0x000D
enum class EBattleEffectLocationType : uint8
{
	ACTOR                                    = 0,
	ACTOR_FOOT                               = 1,
	FORMATION                                = 2,
	CAMERA_FORWARD                           = 3,
	GROUND                                   = 4,
	PLAYER_BOTTOM                            = 5,
	SOCKET_HIT                               = 6,
	SOCKET_HEAD                              = 7,
	SOCKET_TOP                               = 8,
	SOCKET_CENTER                            = 9,
	SOCKET_BREATH                            = 10,
	SOCKET_BULLET_START                      = 11,
	EBattleEffectLocationType_MAX            = 12,
};

// Enum Nicola.EBattleEffectType
// NumValues: 0x0009
enum class EBattleEffectType : uint8
{
	UNIT                                     = 0,
	GROUP                                    = 1,
	ALL                                      = 2,
	USER_TO_TARGET                           = 3,
	TARGET_TO_USER                           = 4,
	UNIT_TO_ALL                              = 5,
	UNIT_TO_ALL_MOVE_END                     = 6,
	LEFT_TO_RIGHT                            = 7,
	EBattleEffectType_MAX                    = 8,
};

// Enum Nicola.EActionTargetType
// NumValues: 0x0009
enum class EActionTargetType : uint8
{
	NONE                                     = 0,
	USER                                     = 1,
	PARTY                                    = 2,
	ENEMY                                    = 3,
	ALL                                      = 4,
	EXCEPT_USER                              = 5,
	EXCEPT_USER_PARTY                        = 6,
	EXCEPT_USER_ENEMY                        = 7,
	EActionTargetType_MAX                    = 8,
};

// Enum Nicola.EActionTargetCount
// NumValues: 0x0005
enum class EActionTargetCount : uint8
{
	NONE                                     = 0,
	SINGLE                                   = 1,
	GROUP                                    = 2,
	ALL                                      = 3,
	EActionTargetCount_MAX                   = 4,
};

// Enum Nicola.EAttributeType
// NumValues: 0x0027
enum class EAttributeType : uint8
{
	NONE                                     = 0,
	MELA                                     = 1,
	GILA                                     = 2,
	IO                                       = 3,
	HYADO                                    = 4,
	BAGI                                     = 5,
	ZAKI                                     = 6,
	MEGANTE                                  = 7,
	DEIN                                     = 8,
	DORAGORAM                                = 9,
	BOMIOS                                   = 10,
	RUKANI                                   = 11,
	MANUSA                                   = 12,
	MAHOTON                                  = 13,
	MEDAPANI                                 = 14,
	RARIHO                                   = 15,
	BASHIRULER                               = 16,
	NIFURAM                                  = 17,
	MAHOTORA                                 = 18,
	FLAME                                    = 19,
	BLIZZARD                                 = 20,
	DEATH                                    = 21,
	POISON                                   = 22,
	PARALYZE                                 = 23,
	STAN                                     = 24,
	ALLCANCEL                                = 25,
	NORMAL                                   = 26,
	FLY                                      = 27,
	BEAST                                    = 28,
	ZOMBIE                                   = 29,
	KAJIN                                    = 30,
	DEVIL                                    = 31,
	DRAGON                                   = 32,
	METAL1                                   = 33,
	WEAK                                     = 34,
	WEAK2                                    = 35,
	CRITICAL                                 = 36,
	FOOT_SWEEP                               = 37,
	MAX                                      = 38,
};

// Enum Nicola.EUnitClassType
// NumValues: 0x000F
enum class EUnitClassType : uint8
{
	NONE                                     = 0,
	HERO                                     = 1,
	WARRIOR                                  = 2,
	FIGHTER                                  = 3,
	MAGE                                     = 4,
	PRIEST                                   = 5,
	MERCHANT                                 = 6,
	GADABOUT                                 = 7,
	THIEF                                    = 8,
	SAGE                                     = 9,
	BREEDER                                  = 10,
	BAG_ITEM                                 = 11,
	BAG_EQUIP                                = 12,
	BAG_IMPORTANT                            = 13,
	EUnitClassType_MAX                       = 14,
};

// Enum Nicola.EUnitTransformType
// NumValues: 0x000A
enum class EUnitTransformType : uint8
{
	NONE                                     = 0,
	HOBBIT                                   = 1,
	MONSTER                                  = 2,
	SLIME                                    = 3,
	GARL                                     = 4,
	OLD_MAN                                  = 5,
	RUFFIAN                                  = 6,
	MERCHANT                                 = 7,
	DANCER                                   = 8,
	EUnitTransformType_MAX                   = 9,
};

// Enum Nicola.EUnitGenderType
// NumValues: 0x0004
enum class EUnitGenderType : uint8
{
	NONE                                     = 0,
	MALE                                     = 1,
	FEMALE                                   = 2,
	EUnitGenderType_MAX                      = 3,
};

// Enum Nicola.EEquipClassCategoryType
// NumValues: 0x0003
enum class EEquipClassCategoryType : uint8
{
	NONE                                     = 0,
	ALL                                      = 1,
	EEquipClassCategoryType_MAX              = 2,
};

// Enum Nicola.EWeaponType
// NumValues: 0x000D
enum class EWeaponType : uint8
{
	NONE                                     = 0,
	SWORD                                    = 1,
	AXE                                      = 2,
	BLOW                                     = 3,
	WAND                                     = 4,
	CLAW                                     = 5,
	SHORT_SWORD                              = 6,
	BOOMERANG                                = 7,
	WHIP                                     = 8,
	SPEAR                                    = 9,
	ABACUS                                   = 10,
	OTHER                                    = 11,
	EWeaponType_MAX                          = 12,
};

// Enum Nicola.EParamUpType
// NumValues: 0x0005
enum class EParamUpType : uint8
{
	NONE                                     = 0,
	ADD                                      = 1,
	RATIO                                    = 2,
	SPECIAL                                  = 3,
	EParamUpType_MAX                         = 4,
};

// Enum Nicola.EEquipParamType
// NumValues: 0x000A
enum class EEquipParamType : uint8
{
	NONE                                     = 0,
	OFFENSE                                  = 1,
	DEFENSE                                  = 2,
	PHYSICAL                                 = 3,
	INTELLIGENCE                             = 4,
	AGILITY                                  = 5,
	LUC                                      = 6,
	MAXHP                                    = 7,
	MAXMP                                    = 8,
	EEquipParamType_MAX                      = 9,
};

// Enum Nicola.EStatusType
// NumValues: 0x000A
enum class EStatusType : uint8
{
	NONE                                     = 0,
	MAX_HP                                   = 1,
	MAX_MP                                   = 2,
	STR                                      = 3,
	ARM                                      = 4,
	AGI                                      = 5,
	VIT                                      = 6,
	INT                                      = 7,
	LUC                                      = 8,
	EStatusType_MAX                          = 9,
};

// Enum Nicola.ETargetCampsType
// NumValues: 0x0008
enum class ETargetCampsType : uint8
{
	NONE                                     = 0,
	PARTY                                    = 1,
	ENEMY                                    = 2,
	ALL                                      = 3,
	EXCEPT_USER                              = 4,
	EXCEPT_USER_PARTY                        = 5,
	EXCEPT_USER_ENEMY                        = 6,
	ETargetCampsType_MAX                     = 7,
};

// Enum Nicola.ETargetType
// NumValues: 0x0006
enum class ETargetType : uint8
{
	NONE                                     = 0,
	YOURSELF                                 = 1,
	SINGLE                                   = 2,
	GROUP                                    = 3,
	ALL                                      = 4,
	ETargetType_MAX                          = 5,
};

// Enum Nicola.EActionEffectCategory
// NumValues: 0x0004
enum class EActionEffectCategory : uint8
{
	NONE                                     = 0,
	DAMAGE                                   = 1,
	SUPPORT                                  = 2,
	EActionEffectCategory_MAX                = 3,
};

// Enum Nicola.EWarpMagicType
// NumValues: 0x0004
enum class EWarpMagicType : uint8
{
	NONE                                     = 0,
	RURA                                     = 1,
	RIREMITO                                 = 2,
	EWarpMagicType_MAX                       = 3,
};

// Enum Nicola.ERandomMagicType
// NumValues: 0x000B
enum class ERandomMagicType : uint8
{
	NONE                                     = 0,
	MAGIC_PARUPUNTE                          = 1,
	SKILL_ANAHORI                            = 2,
	PLAYACTION_FALL                          = 3,
	PLAYACTION_STONE                         = 4,
	PLAYACTION_ROLL_FINGER                   = 5,
	PLAYACTION_SING                          = 6,
	PLAYACTION_SNEEZE                        = 7,
	PLAYACTION_LIQUOR                        = 8,
	PLAYACTION_SWEARING                      = 9,
	ERandomMagicType_MAX                     = 10,
};

// Enum Nicola.MagicEffectType
// NumValues: 0x0043
enum class EMagicEffectType : uint8
{
	ENEMY_DAMEAGE                            = 0,
	ENEMY_DAMEAGE_BIG_SWING                  = 1,
	TURNING_KICK                             = 2,
	MOONSAULT                                = 3,
	ADDITIONAL_DAMAGE                        = 4,
	CRITICAL_HIT                             = 5,
	FIRST_ATTACK                             = 6,
	RECOIL_DAMAGE                            = 7,
	HIT_VITAL_POINT                          = 8,
	ENEMY_DEATH                              = 9,
	SELF_DESTRUCT                            = 10,
	FLY_KILLER                               = 11,
	KAIJIN_KILLER                            = 12,
	SLEEP_KILLER                             = 13,
	DESPERATE_ATTACK                         = 14,
	ENEMY_FADE_AWAY                          = 15,
	ABSORB_MP                                = 16,
	DAMAGE_MP                                = 17,
	ALL_CANCEL                               = 18,
	BIG_SWING                                = 19,
	CHANGE_STATE                             = 20,
	COMPENSATION                             = 21,
	CONTINUOUS_ATTACK_1                      = 22,
	CONTINUOUS_ATTACK_2                      = 23,
	CONTINUOUS_ATTACK_3                      = 24,
	HOCUS_POCUS_1                            = 25,
	HOCUS_POCUS_2                            = 26,
	HOCUS_POCUS_3                            = 27,
	HOCUS_POCUS_4                            = 28,
	HOCUS_POCUS_5                            = 29,
	HOCUS_POCUS_6                            = 30,
	METAL_KILLER                             = 31,
	MONSTER_ATTRACT2                         = 32,
	MONSTER_RADAR                            = 33,
	RESET_STATE                              = 34,
	SURE_HIT                                 = 35,
	CRITICAL_SURE_HIT                        = 36,
	RECOVER_HP                               = 37,
	MEGAZARU                                 = 38,
	RECOVER_MAGIC_CURSE                      = 39,
	RECOVER_DEATH                            = 40,
	TELEPORTATION                            = 41,
	DUNGEON_ESCAPE                           = 42,
	ENCOUNTER_SEAL                           = 43,
	ENCOUNTER_DOWN                           = 44,
	RELEASE_TRAP                             = 45,
	TREASURE_APPRAISAL                       = 46,
	TREASURE_COUNT                           = 47,
	TREASURE_SEARCH                          = 48,
	UNLOCK                                   = 49,
	TIME_CHANGE                              = 50,
	PARTY_DISAPPEAR                          = 51,
	DIG_A_HOLE                               = 52,
	CALL_SHOP                                = 53,
	NORMAL_ATTACK                            = 54,
	GUARD                                    = 55,
	RUN_AWAY                                 = 56,
	CALL_FRIEND                              = 57,
	RANDOM                                   = 58,
	ALL_OUT_ATTACK                           = 59,
	RANDOM_SUPPORT                           = 60,
	RANDOM_DAMAGE                            = 61,
	RANDOM_ACTION                            = 62,
	BRANCH_VALUE                             = 63,
	NO_EFFECT_SUCCESS                        = 64,
	NO_EFFECT_FAILURE                        = 65,
	MagicEffectType_MAX                      = 66,
};

// Enum Nicola.ESkillUser
// NumValues: 0x0005
enum class ESkillUser : uint8
{
	NONE                                     = 0,
	PLAYER                                   = 1,
	ENEMY                                    = 2,
	DUAL_USE                                 = 3,
	ESkillUser_MAX                           = 4,
};

// Enum Nicola.ESkillType
// NumValues: 0x0005
enum class ESkillType : uint8
{
	NONE                                     = 0,
	MAGIC                                    = 1,
	SKILL                                    = 2,
	ATTACK                                   = 3,
	ESkillType_MAX                           = 4,
};

// Enum Nicola.EItemConsumeType
// NumValues: 0x0005
enum class EItemConsumeType : uint8
{
	NONE                                     = 0,
	CONSUME                                  = 1,
	IMMORTAL                                 = 2,
	SOMETIMES_BREAK                          = 3,
	EItemConsumeType_MAX                     = 4,
};

// Enum Nicola.EItemUsableType
// NumValues: 0x0007
enum class EItemUsableType : uint8
{
	NONE                                     = 0,
	BATTLE                                   = 1,
	SEARCH                                   = 2,
	FIELD                                    = 3,
	ALL                                      = 4,
	TOWNDUNGEON                              = 5,
	EItemUsableType_MAX                      = 6,
};

// Enum Nicola.ItemEffectType
// NumValues: 0x0064
enum class EItemEffectType : uint8
{
	UNUSABLE                                 = 0,
	RECOVER_HP                               = 1,
	RECOVER_MP                               = 2,
	RECOVER_POISON                           = 3,
	RECOVER_PARALYSIS                        = 4,
	RECOVER_SLEEP                            = 5,
	RECOVER_CONFUSION                        = 6,
	RECOVER_MAGIC_SEAL                       = 7,
	RECOVER_PHANTOM                          = 8,
	RECOVER_DEATH                            = 9,
	ENCOUNTER_SEAL                           = 10,
	ENEMY_DAMEAGE                            = 11,
	ENEMY_AGILITY_DOWN                       = 12,
	ENEMY_CONFUSION                          = 13,
	ATTACK_DAMAGE_UP                         = 14,
	DAIN_DAMAGE_UP                           = 15,
	TELEPORTATION                            = 16,
	BATTLE_ESCAPE                            = 17,
	RESIST_DEATH                             = 18,
	POWER_UP                                 = 19,
	PROTECTION_UP                            = 20,
	PHYSICAL_UP                              = 21,
	INTELLIGENCE_UP                          = 22,
	AGILITY_UP                               = 23,
	LUC_UP                                   = 24,
	MAXHP_UP                                 = 25,
	MAXMP_UP                                 = 26,
	CHANGE_BASIC_PERSONALITY                 = 27,
	DESTROY_DARKNESS                         = 28,
	INVISIBLE_PARTY                          = 29,
	MONSTER_ATTRACT1                         = 30,
	MONSTER_ATTRACT2                         = 31,
	CHANGE_NIGHT                             = 32,
	PARALYZE                                 = 33,
	SLEEP                                    = 34,
	TRANSFORM_RANDOM                         = 35,
	GHOST_SHIP_RADAR                         = 36,
	ORB_RADAR                                = 37,
	MAGIC_ACTIVATION                         = 38,
	SPECIAL_SKILL_ACTIVATION                 = 39,
	CRITHICAL_UP                             = 40,
	ZOMBIE_KILLER                            = 41,
	DORAGON_KILLER                           = 42,
	KAIJIN_KILLER                            = 43,
	BEAST_KILLER                             = 44,
	INSECT_KILLER                            = 45,
	METAL_KILLER                             = 46,
	FLAME_ATTACK                             = 47,
	WIND_ATTACK                              = 48,
	ONE_SHOT_KILL                            = 49,
	DOUBLE_ATTACK                            = 50,
	DOUBLE_MAGIC                             = 51,
	GROUP_ATTACK                             = 52,
	GENERAL_ATTACK                           = 53,
	AVOID_UP                                 = 54,
	DEATH_RESIST                             = 55,
	MAGIC_RESIST                             = 56,
	FIRE_RESIST                              = 57,
	IO_RESIST                                = 58,
	BLIZZARD_RESIST                          = 59,
	WIND_RESIST                              = 60,
	BREATH_RESIST                            = 61,
	MAGIC_BREATH_RESIST1                     = 62,
	MAGIC_BREATH_RESIST2                     = 63,
	POISON_RESIST                            = 64,
	DAZZLE_RESIST                            = 65,
	SLEEP_RESIST                             = 66,
	PARALYSIS_RESIST                         = 67,
	CONFUSION_RESIST                         = 68,
	MAGIC_SEAL_RESIST1                       = 69,
	MAGIC_SEAL_RESIST2                       = 70,
	MAGIC_SEAL_RESIST3                       = 71,
	DEBUFF_SET1_RESIST                       = 72,
	DEBUFF_SET2_RESIST                       = 73,
	DEBUFF_SET3_RESIST                       = 74,
	DEBUFF_SET4_RESIST                       = 75,
	REFLECTION_DAMAGE_ENEMY                  = 76,
	REFLECTION_DAMAGE_PARTY                  = 77,
	MAGIC_REFLECTION                         = 78,
	INTELLIGENCE_RISE                        = 79,
	AGILITY_RISE                             = 80,
	MP_SAVINGS                               = 81,
	WALKING_RECOVERY_HP                      = 82,
	WALKING_RECOVERY_MP                      = 83,
	WALKING_GET_EXP                          = 84,
	REHOIMI                                  = 85,
	MP_ABSORB                                = 86,
	COSUTUME_CHANGE                          = 87,
	OVERWRITE_PERSONALITY                    = 88,
	ACCURACY_DOWN                            = 89,
	DOUBLE_EDGED                             = 90,
	ATTACK_MP_DOWN                           = 91,
	CURSE_OF_BIND                            = 92,
	CURSE_OF_CONFUSION                       = 93,
	LUCK_ZORO                                = 94,
	STUN_BEAT                                = 95,
	USE_NO_EFFECT_GENDER                     = 96,
	OPEN_MAP_MENU                            = 97,
	CALCULATE_GOLD                           = 98,
	ItemEffectType_MAX                       = 99,
};

// Enum Nicola.EItemGenderType
// NumValues: 0x0004
enum class EItemGenderType : uint8
{
	GENDER_LESS                              = 0,
	MALE_ONLY                                = 1,
	FEMALE_ONLY                              = 2,
	EItemGenderType_MAX                      = 3,
};

// Enum Nicola.EItemType
// NumValues: 0x000A
enum class EItemType : uint8
{
	NONE                                     = 0,
	EQUIP_WEAPON                             = 1,
	EQUIP_SHIELD                             = 2,
	EQUIP_HELMET                             = 3,
	EQUIP_ARMOR                              = 4,
	EQUIP_ACCESSORY                          = 5,
	ITEM_USE                                 = 6,
	ITEM_IMPORTANT                           = 7,
	ITEM_BOOK                                = 8,
	EItemType_MAX                            = 9,
};

// Enum Nicola.EEventTriggerType
// NumValues: 0x0012
enum class EEventTriggerType : uint8
{
	NONE                                     = 0,
	SCENE                                    = 1,
	VOLUME                                   = 2,
	ACTOR                                    = 3,
	BATTLE_END                               = 4,
	EVENT_END                                = 5,
	BRANCH                                   = 6,
	ITEM                                     = 7,
	HOLE                                     = 8,
	OBJECT                                   = 9,
	ROCK                                     = 10,
	MBR_SCOUT                                = 11,
	VOLUME_ONE_FRAME                         = 12,
	TALK_KING                                = 13,
	TALK_INVISIBLE                           = 14,
	TALK_CHANGE                              = 15,
	TALK_CLEAR                               = 16,
	EEventTriggerType_MAX                    = 17,
};

// Enum Nicola.ELightOnLantern
// NumValues: 0x0004
enum class ELightOnLantern : uint8
{
	NOT_USE                                  = 0,
	ALWAYS                                   = 1,
	NIGHT_ONLY                               = 2,
	ELightOnLantern_MAX                      = 3,
};

// Enum Nicola.EFieldTimeFrame
// NumValues: 0x0009
enum class EFieldTimeFrame : uint8
{
	F_COMMON                                 = 0,
	F_NOON                                   = 1,
	F_AFTERNOON                              = 2,
	F_EVENING                                = 3,
	F_NIGHT                                  = 4,
	F_MIDNIGHT                               = 5,
	F_EARLYMONING                            = 6,
	F_MORNING                                = 7,
	F_MAX                                    = 8,
};

// Enum Nicola.EMapTimeFrame
// NumValues: 0x0006
enum class EMapTimeFrame : uint8
{
	COMMON                                   = 0,
	DAYTIME                                  = 1,
	EVENING                                  = 2,
	NIGHT                                    = 3,
	DAYTIME_AND_EVENING                      = 4,
	EMapTimeFrame_MAX                        = 5,
};

// Enum Nicola.ENicolaFlipbookOverrideType
// NumValues: 0x0005
enum class ENicolaFlipbookOverrideType : uint8
{
	DEFAULT                                  = 0,
	BATTLE_STYLE_1                           = 1,
	BATTLE_STYLE_2                           = 2,
	BATTLE_STYLE_3                           = 3,
	ENicolaFlipbookOverrideType_MAX          = 4,
};

// Enum Nicola.EGOPEnumDoorType
// NumValues: 0x004E
enum class EGOPEnumDoorType : uint16
{
	Default                                  = 0,
	C01_Aliahan_Castle_1F_Out_Thief          = 1,
	C01_Aliahan_Castle_1F_Out_Gate           = 2,
	C01_Aliahan_Castle_1F_Najimi_Nomal       = 3,
	C01_Aliahan_Castle_B1F_Najimi_Nomal      = 4,
	C01_Aliahan_Brave_1F_out_Normal          = 5,
	C01_Aliahan_Inn_1F_Out                   = 6,
	C01_Aliahan_Church_1F_Out                = 7,
	C02_Romaria_Inn_1F_Out_North_Nomal       = 8,
	C02_Romaria_Inn_1F_Out_West_Nomal        = 9,
	C02_Romaria_Shop_1F_Out_Normal           = 10,
	C02_Romaria_Church_1F_Out_Normal         = 11,
	C03_Isis_Inn_1F_Out_Normal               = 12,
	C03_Isis_Church_1F_Out_Normal            = 13,
	C04_Portoga_Castle_1F_Out_Gate           = 14,
	C04_Portoga_Inn_1F_Out_Normal            = 15,
	C04_Portoga_Inn_1F_Out_South_Normal      = 16,
	C07_Edinbear_Castle_1F_E_Normal          = 17,
	C07_Edinbear_Castle_1F_W_Normal          = 18,
	C07_Edinbear_Castle_2F_Gate              = 19,
	C08_Samanosa_Castle_1F_Out_Gate          = 20,
	C08_Samanosa_Castle_1F_Magic             = 21,
	C08_Samanosa_Castle_2F_Magic             = 22,
	C08_Samanosa_Inn_1F_Out_Normal           = 23,
	C08_Samanosa_Church_1F_Out_Normal        = 24,
	C09_DragonQueen_Castle_Gate              = 25,
	C09_DragonQueen_Castle_East              = 26,
	C09_DragonQueen_Castle_West              = 27,
	C09_DragonQueen_Castle_Back              = 28,
	C10_Ludatorm_Castle_1F_Nomal             = 29,
	C10_Ludatorm_House_1F_Out_East_Normal    = 30,
	C10_Ludatorm_House_1F_Out_West_Normal    = 31,
	C10_Ludatorm_Inn_1F_Out_West_Normal      = 32,
	C10_Ludatorm_Church_1F_Out_West_Normal   = 33,
	C11_Mercado_Inn_1F_Out_Normal            = 34,
	T01_Reeve_Inn_1F_Out_Normal              = 35,
	T01_Reeve_Church_1F_Out_Normal           = 36,
	T02_Kazave_Church_1F_Out_Normal          = 37,
	T02_Kazave_ChurchSouth_1F_Out_Normal     = 38,
	T02_Kazave_Inn_1F_Out_Normal             = 39,
	T03_Noaniel_Inn_1F_Out_Normal            = 40,
	T03_Noaniel_After_Inn_1F_Out_Normal      = 41,
	T04_Ashalam_Church_1F_Out_R_Normal       = 42,
	T04_Ashalam_Church_1F_Out_L_Normal       = 43,
	T05_Baharata_Inn_1F_Out_Normal           = 44,
	T05_Baharata_Shop_R_1F_Out_Normal        = 45,
	T05_Baharata_Shop_L_1F_Out_Normal        = 46,
	T05_Baharata_Church_L_1F_Out_Normal      = 47,
	T06_Lancel_Inn_1F_Out_East_Normal        = 48,
	T06_Lancel_Inn_1F_Out_North_Normal       = 49,
	T06_Lancel_Temple_Out_East_Last          = 50,
	T06_Lancel_Temple_Out_Center_Last        = 51,
	T06_Lancel_Temple_Out_West_Last          = 52,
	T08_Domdora_Inn_1F_Out_Normal            = 53,
	T09_Myra_Inn_1F_Out_Normal               = 54,
	T10_Rimuldar_Inn_1F_Out_Normal           = 55,
	T10_Rimuldar_Church_1F_Out_Normal        = 56,
	T12_Muor_Inn_1F_Out_R_Normal             = 57,
	T12_Muor_Inn_1F_Out_L_Normal             = 58,
	T12_Muor_Church_1F_Out_Normal            = 59,
	T15_Burg_3_Inn_1F_Out_Normal             = 60,
	T15_Burg_4_Inn_1F_Out_Normal             = 61,
	T15_Burg_5_Inn_1F_Out_Normal             = 62,
	T15_Burg_6_Inn_1F_Out_Normal             = 63,
	H02_ReeveSouth_1F_Out_Last               = 64,
	H21_WestPort_House_1F_Out_R_Normal       = 65,
	H21_WestPort_House_1F_Out_L_Normal       = 66,
	D02_NajimiTower_4F_Thief                 = 67,
	D15_BaramosCastle_Out_Nomal              = 68,
	D15_BaramosCastle_Out_Nomal_1FC          = 69,
	D15_BaramosCastle_Out_Nomal_1FD          = 70,
	D15_BaramosCastle_Out_Gate               = 71,
	D15_BaramosCastle_Out_Boss               = 72,
	D18_RubissTower_1FC_Thief                = 73,
	D20_SecretCave_B4FB_East_Normal          = 74,
	D20_SecretCave_B4FB_West_Normal          = 75,
	NUM                                      = 76,
	EGOPEnumDoorType_MAX                     = 77,
};

// Enum Nicola.EGOPEnumMapBgmType
// NumValues: 0x0008
enum class EGOPEnumMapBgmType : uint8
{
	NONE                                     = 0,
	ARIAHAN_HOUSE01                          = 1,
	SAMANOSA_CITY01                          = 2,
	PYRAMID_UNDERGROUND                      = 3,
	FIELD_SHIP                               = 4,
	FIELD_RAMIA                              = 5,
	NUM                                      = 6,
	EGOPEnumMapBgmType_MAX                   = 7,
};

// Enum Nicola.EGOPEnumMBRType
// NumValues: 0x00B0
enum class EGOPEnumMBRType : uint16
{
	NONE                                     = 0,
	MBR_001                                  = 1,
	MBR_002                                  = 2,
	MBR_003                                  = 3,
	MBR_004                                  = 4,
	MBR_005                                  = 5,
	MBR_006                                  = 6,
	MBR_007                                  = 7,
	MBR_008                                  = 8,
	MBR_009                                  = 9,
	MBR_010                                  = 10,
	MBR_011                                  = 11,
	MBR_012                                  = 12,
	MBR_013                                  = 13,
	MBR_014                                  = 14,
	MBR_015                                  = 15,
	MBR_016                                  = 16,
	MBR_017                                  = 17,
	MBR_018                                  = 18,
	MBR_019                                  = 19,
	MBR_020                                  = 20,
	MBR_021                                  = 21,
	MBR_022                                  = 22,
	MBR_023                                  = 23,
	MBR_024                                  = 24,
	MBR_025                                  = 25,
	MBR_026                                  = 26,
	MBR_027                                  = 27,
	MBR_028                                  = 28,
	MBR_029                                  = 29,
	MBR_030                                  = 30,
	MBR_031                                  = 31,
	MBR_032                                  = 32,
	MBR_033                                  = 33,
	MBR_034                                  = 34,
	MBR_035                                  = 35,
	MBR_036                                  = 36,
	MBR_037                                  = 37,
	MBR_038                                  = 38,
	MBR_039                                  = 39,
	MBR_040                                  = 40,
	MBR_041                                  = 41,
	MBR_042                                  = 42,
	MBR_043                                  = 43,
	MBR_044                                  = 44,
	MBR_045                                  = 45,
	MBR_046                                  = 46,
	MBR_047                                  = 47,
	MBR_048                                  = 48,
	MBR_049                                  = 49,
	MBR_050                                  = 50,
	MBR_051                                  = 51,
	MBR_052                                  = 52,
	MBR_053                                  = 53,
	MBR_054                                  = 54,
	MBR_055                                  = 55,
	MBR_056                                  = 56,
	MBR_057                                  = 57,
	MBR_058                                  = 58,
	MBR_059                                  = 59,
	MBR_060                                  = 60,
	MBR_061                                  = 61,
	MBR_062                                  = 62,
	MBR_063                                  = 63,
	MBR_064                                  = 64,
	MBR_065                                  = 65,
	MBR_066                                  = 66,
	MBR_067                                  = 67,
	MBR_068                                  = 68,
	MBR_069                                  = 69,
	MBR_070                                  = 70,
	MBR_071                                  = 71,
	MBR_072                                  = 72,
	MBR_073                                  = 73,
	MBR_074                                  = 74,
	MBR_075                                  = 75,
	MBR_076                                  = 76,
	MBR_077                                  = 77,
	MBR_078                                  = 78,
	MBR_079                                  = 79,
	MBR_080                                  = 80,
	MBR_081                                  = 81,
	MBR_082                                  = 82,
	MBR_083                                  = 83,
	MBR_084                                  = 84,
	MBR_085                                  = 85,
	MBR_086                                  = 86,
	MBR_087                                  = 87,
	MBR_088                                  = 88,
	MBR_089                                  = 89,
	MBR_090                                  = 90,
	MBR_091                                  = 91,
	MBR_092                                  = 92,
	MBR_093                                  = 93,
	MBR_094                                  = 94,
	MBR_095                                  = 95,
	MBR_096                                  = 96,
	MBR_097                                  = 97,
	MBR_098                                  = 98,
	MBR_099                                  = 99,
	MBR_100                                  = 100,
	MBR_101                                  = 101,
	MBR_102                                  = 102,
	MBR_103                                  = 103,
	MBR_104                                  = 104,
	MBR_105                                  = 105,
	MBR_106                                  = 106,
	MBR_107                                  = 107,
	MBR_108                                  = 108,
	MBR_109                                  = 109,
	MBR_110                                  = 110,
	MBR_111                                  = 111,
	MBR_112                                  = 112,
	MBR_113                                  = 113,
	MBR_114                                  = 114,
	MBR_115                                  = 115,
	MBR_116                                  = 116,
	MBR_117                                  = 117,
	MBR_118                                  = 118,
	MBR_119                                  = 119,
	MBR_120                                  = 120,
	MBR_121                                  = 121,
	MBR_122                                  = 122,
	MBR_123                                  = 123,
	MBR_124                                  = 124,
	MBR_125                                  = 125,
	MBR_126                                  = 126,
	MBR_127                                  = 127,
	MBR_128                                  = 128,
	MBR_129                                  = 129,
	MBR_130                                  = 130,
	MBR_131                                  = 131,
	MBR_132                                  = 132,
	MBR_133                                  = 133,
	MBR_134                                  = 134,
	MBR_135                                  = 135,
	MBR_136                                  = 136,
	MBR_137                                  = 137,
	MBR_138                                  = 138,
	MBR_139                                  = 139,
	MBR_140                                  = 140,
	MBR_141                                  = 141,
	MBR_142                                  = 142,
	MBR_143                                  = 143,
	MBR_144                                  = 144,
	MBR_145                                  = 145,
	MBR_146                                  = 146,
	MBR_147                                  = 147,
	MBR_148                                  = 148,
	MBR_149                                  = 149,
	MBR_150                                  = 150,
	MBR_H_START                              = 151,
	MBR_H_WIN                                = 152,
	MBR_H_WINTALK                            = 153,
	MBR_G_WIN                                = 154,
	MBR_F_WIN                                = 155,
	MBR_E_WIN                                = 156,
	MBR_D_WIN                                = 157,
	MBR_C_WIN                                = 158,
	MBR_B_WIN                                = 159,
	MBR_A_WIN                                = 160,
	MBR_S_WIN                                = 161,
	MBR_SS_WIN                               = 162,
	MBR_SSS_WIN                              = 163,
	MBR_G_BOSS                               = 164,
	MBR_E_BOSS                               = 165,
	MBR_B_BOSS                               = 166,
	MBR_S_BOSS                               = 167,
	MBR_S_BOSSWIN                            = 168,
	MBR_S_BOSSWINARENA                       = 169,
	MBR_SS_BOSS                              = 170,
	MBR_SS_BOSSWIN                           = 171,
	MBR_SSS_BOSS                             = 172,
	MBR_Battle_WIN                           = 173,
	NUM                                      = 174,
	EGOPEnumMBRType_MAX                      = 175,
};

// Enum Nicola.EGOPEnumProgressType
// NumValues: 0x00AE
enum class EGOPEnumProgressType : uint16
{
	NONE                                     = 0,
	MAIN_PersonalTest_Start                  = 1,
	MAIN_ALIAHAN_Wake                        = 2,
	MAIN_ALIAHAN_ArriveCastle                = 3,
	MAIN_ALIAHAN_MeetKing                    = 4,
	MAIN_ALIAHAN_PartyMem                    = 5,
	MAIN_ALIAHAN_TalkMedalCollector          = 6,
	MAIN_ALIAHAN_BraveHouseMorning           = 7,
	MAIN_ALIAHAN_BraveHouseNight             = 8,
	MAIN_NAJIMITOWER_Arrival1F               = 9,
	MAIN_NAJIMITOWER_GetKey                  = 10,
	MAIN_IZANAICAVE_TalkOldMan               = 11,
	MAIN_REEVE_ArriveOut                     = 12,
	MAIN_REEVE_TalkNorthHouseNPC             = 13,
	MAIN_REEVE_GetMagicBall                  = 14,
	MAIN_IZANAICAVE_BreakWall                = 15,
	MAIN_IZANAICAVE_GetWorldMap              = 16,
	MAIN_IZANAICAVE_Warp                     = 17,
	MAIN_ROMARIAROAD_TalkHawker              = 18,
	MAIN_ROMARIABARRIER_TalkGatekeeper       = 19,
	MAIN_SHAMPANETOWER_KandataTrap           = 20,
	MAIN_SHAMPANETOWER_DefeatKandata         = 21,
	MAIN_ROMARIA_BraveKing                   = 22,
	MAIN_ISIS_ArriveSecret                   = 23,
	MAIN_PYRAMID_ArriveB1F                   = 24,
	MAIN_PYRAMID_FindB2FRoot                 = 25,
	MAIN_PYRAMID_GetMagicKey                 = 26,
	MAIN_PYRAMID_CurseGoldenClaws            = 27,
	MAIN_PYRAMID_HasPartyCurseGoldenClaws    = 28,
	MAIN_NOANIEL_TalkHeadman                 = 29,
	MAIN_ELFVILLAGE_TalkQueen                = 30,
	MAIN_UNDERGROUNDLAKE_GetDreamstone       = 31,
	MAIN_ELFVILLAGE_GetWakeyDust             = 32,
	MAIN_NOANIEL_WakeUp                      = 33,
	MAIN_PORTOGA_GetLetter                   = 34,
	MAIN_NORUDCAVE_TalkWithLetter            = 35,
	MAIN_NORUDCAVE_OpenCave                  = 36,
	MAIN_BAHARATA_TalkGupta                  = 37,
	MAIN_BAHARATAEASTCAVE_DefeatHenchman     = 38,
	MAIN_BAHARATAEASTCAVE_OpenPrison         = 39,
	MAIN_BAHARATAEASTCAVE_DefeatKandata      = 40,
	MAIN_BAHARATA_TalkGuptaAfterRescue       = 41,
	MAIN_BAHARATA_GetPepper                  = 42,
	MAIN_DHARMA_TalkAbbot                    = 43,
	MAIN_MUOR_ArriveOut                      = 44,
	MAIN_MUOR_TalkPopotaGranpa               = 45,
	MAIN_MUOR_TalkPopota                     = 46,
	MAIN_PORTOGA_TalkWithPepper              = 47,
	MAIN_PORTOGA_RideShip                    = 48,
	MAIN_MULTI_HintOrb                       = 49,
	MAIN_EDINBEAR_GateKeeperBlock            = 50,
	MAIN_EDINBEAR_Arrive1F                   = 51,
	MAIN_EDINBEAR_GetBottomlessPot           = 52,
	MAIN_SHALLOWSHRINE_UsePot                = 53,
	MAIN_SHALLOWSHRINE_GetLastKey            = 54,
	MAIN_SHALLOWSHRINE_TalkCorpse            = 55,
	MAIN_LANCEL_StartTrial                   = 56,
	MAIN_LANCEL_BackTrial                    = 57,
	MAIN_GAIANAVEL_CheckStatue               = 58,
	MAIN_GAIANAVEL_GetBlueOrb                = 59,
	MAIN_TEDON_GetGreenOrb                   = 60,
	MAIN_PIRATESBASE_MoveStatue              = 61,
	MAIN_PIRATESBASE_GetRedOrb               = 62,
	MAIN_JIPANG_ArriveOut                    = 63,
	MAIN_JIPANGCAVE_DefeatOrochi             = 64,
	MAIN_JIPANG_DefeatOrochi                 = 65,
	MAIN_JIPANG_FindYayoi                    = 66,
	MAIN_BURG_1_TalkOldMan                   = 67,
	MAIN_BURG_1_DepositMerchant              = 68,
	MAIN_BURG_1_MerchantNearPond             = 69,
	MAIN_BURG_1_TalkMerchant                 = 70,
	MAIN_BURG_2_ChangeFrom1                  = 71,
	MAIN_BURG_3_ChangeFrom2                  = 72,
	MAIN_BURG_4_ChangeFrom3                  = 73,
	MAIN_BURG_4_PlanRevolution               = 74,
	MAIN_BURG_5_ChangeFrom4                  = 75,
	MAIN_BURG_5_TalkMerchant                 = 76,
	MAIN_BURG_6_ChangeFrom5                  = 77,
	MAIN_BURG_GetYellowOrb                   = 78,
	MAIN_TRAVELERSCHURCH_UnlookDoor          = 79,
	MAIN_TRAVELERSCHURCH_GoOut               = 80,
	MAIN_SAMANOSA_TalkSaimonSon              = 81,
	MAIN_SAMANOSA_Imprison                   = 82,
	MAIN_SAMANOSA_PrisonBreak                = 83,
	MAIN_RACAVE_GetRaMirror                  = 84,
	MAIN_SAMANOSA_DefeatBossTroll            = 85,
	MAIN_GREENLAD_GetBoatmanBone             = 86,
	MAIN_GHOSTSHIP_GetLoveLocket             = 87,
	MAIN_OLIVIAMISAKI_Dispel                 = 88,
	MAIN_SHRINEPRISON_EnccountGhost          = 89,
	MAIN_SHRINEPRISON_GetGaiaSword           = 90,
	MAIN_VOLCANO_ThrowGaiaSword              = 91,
	MAIN_NECROGONDSHRINE_GetSilverOrb        = 92,
	MAIN_MULTI_GetAllOrb                     = 93,
	MAIN_REIAMULAND_RevivalLamia             = 94,
	MAIN_BARAMOSCASTLE_ArriveCastle          = 95,
	MAIN_BARAMOSCASTLE_RestartWarp           = 96,
	MAIN_BARAMOSCASTLE_DefeatBaramos         = 97,
	MAIN_ALIAHAN_BackHome                    = 98,
	MAIN_ALIAHAN_DreamDragon                 = 99,
	MAIN_DRAGONQUEEN_ArriveOut               = 100,
	MAIN_DRAGONQUEEN_GetShineBall            = 101,
	MAIN_GIAGAPIT_UseShineBall               = 102,
	MAIN_GIAGAPIT_ArriveAlefgard             = 103,
	MAIN_WESTPORT_TalkArakure                = 104,
	MAIN_WESTPORT_RideShip                   = 105,
	MAIN_LUDATORM_ArriveOut                  = 106,
	MAIN_LUDATORM_GetSunStone                = 107,
	MAIN_SPIRITSHRINE_GetRainStick           = 108,
	MAIN_RIMULDAR_ArriveOut                  = 109,
	MAIN_RIMULDAR_OrtegaMemo                 = 110,
	MAIN_DOMDORA_ArriveOut                   = 111,
	MAIN_MERCADO_ArriveOut                   = 112,
	MAIN_MYRA_ArriveOut                      = 113,
	MAIN_MYRA_GetFairyFlute                  = 114,
	MAIN_MYRA_TalkGaiaHanmer                 = 115,
	MAIN_MYRA_TalkBrokenSword                = 116,
	MAIN_MYRA_TalkOrichalcum                 = 117,
	MAIN_JIPANG_GetGaiaHanmer                = 118,
	MAIN_MERCADO_GetBrokenSword              = 119,
	MAIN_DOMDORA_GetOrichalcum               = 120,
	MAIN_MYRA_ChangeShopItem                 = 121,
	MAIN_MYRA_GetKingSword                   = 122,
	MAIN_HOBBITSHRINE_TalkHobbit             = 123,
	MAIN_SWAMPCAVE_TalkHenchman              = 124,
	MAIN_GAIANAVEL_FindDeposit               = 125,
	MAIN_REEVE_GetMagicBall_2                = 126,
	MAIN_GAIANAVEL_GetBlueMetal              = 127,
	MAIN_RUBISSTOWER_Dispel                  = 128,
	MAIN_HOLYSHRINE_GetRainbowDrop           = 129,
	MAIN_DEVILSILAND_UseRainbowDrop          = 130,
	MAIN_ZOMACASTLE_Arrive1F                 = 131,
	MAIN_ZOMACASTLE_FindSecretStair          = 132,
	MAIN_ZOMACASTLE_ArriveB1F                = 133,
	MAIN_ZOMACASTLE_EndOrtegaBattle          = 134,
	MAIN_ZOMACASTLE_RestartWarp              = 135,
	MAIN_ZOMACASTLE_DefeatZoma               = 136,
	MAIN_HEROCAVE_Warp                       = 137,
	MAIN_HEROCAVE_GoOut                      = 138,
	MAIN_Ludatorm_Ending                     = 139,
	MAIN_SECRETCAVE_ArriveB1F                = 140,
	MAIN_ZENITH_TalkZenithKing               = 141,
	MAIN_Xenlon_NewMBR                       = 142,
	MAIN_Xenlon_Ortega                       = 143,
	MAIN_Xenlon_Looks                        = 144,
	MAIN_Xenlon_RubissSword                  = 145,
	MAIN_Xenlon_Hbook_1                      = 146,
	MAIN_Xenlon_Hbook_2                      = 147,
	MAIN_Xenlon_NewDungeon                   = 148,
	MAIN_SECRETTOWER_AllGrant                = 149,
	MAIN_GRANDRAGON_Pay                      = 150,
	MAIN_GRANDRAGON_Protect                  = 151,
	MAIN_GRANDRAGON_Appreciation             = 152,
	MAIN_GRANDRAGON_Weapon1                  = 153,
	MAIN_GRANDRAGON_Weapon2                  = 154,
	MAIN_GRANDRAGON_OpenDoor                 = 155,
	SUB_INFORMATION_SHIP                     = 156,
	SUB_INFORMATION_RAMIA                    = 157,
	SUB_INFORMATION_JOB_CHANGE               = 158,
	SUB_INFORMATION_CURSE                    = 159,
	SUB_INFORMATION_INVENTORY                = 160,
	SUB_INFORMATION_KEY                      = 161,
	SUB_INFORMATION_RULER                    = 162,
	SUB_INFORMATION_BATTLEROAD               = 163,
	SUB_INFORMATION_BATTLEROAD_BATTLE        = 164,
	SUB_INFORMATION_BREED_MONSTER            = 165,
	SUB_INFORMATION_BREED_MONSTER_2          = 166,
	SUB_INFORMATION_PUZZLE                   = 167,
	SUB_INFORMATION_ACCESSORY_PERSONALITY    = 168,
	SUB_INFORMATION_CHANGE_STATUS            = 169,
	SUB_INFORMATION_SECRET_AREA              = 170,
	SUB_INFORMATION_CLEAR                    = 171,
	NUM                                      = 172,
	EGOPEnumProgressType_MAX                 = 173,
};

// Enum Nicola.EGOPEnumSearchType
// NumValues: 0x055D
enum class EGOPEnumSearchType : uint16
{
	NONE                                     = 0,
	SEARCH_Certainly_True                    = 1,
	SEARCH_Aliahan_Out_BARREL_0              = 2,
	SEARCH_Aliahan_Out_BARREL_1              = 3,
	SEARCH_Aliahan_Out_POT_0                 = 4,
	SEARCH_Aliahan_Out_POT_1                 = 5,
	SEARCH_Aliahan_Out_GROUND_0              = 6,
	SEARCH_Aliahan_Out_GROUND_1              = 7,
	SEARCH_Aliahan_Out_GROUND_2              = 8,
	SEARCH_Aliahan_Out_GROUND_3              = 9,
	SEARCH_Aliahan_Out_TREASURE_NORMAL_0     = 10,
	SEARCH_Aliahan_House1_1F_BARREL_0        = 11,
	SEARCH_Aliahan_House1_2F_DRAWER_0        = 12,
	SEARCH_Aliahan_House1_2F_DRAWER_1        = 13,
	SEARCH_Aliahan_House2_1F_POT_0           = 14,
	SEARCH_Aliahan_House2_2F_DRAWER_0        = 15,
	SEARCH_Aliahan_Inn_1F_SACK_0             = 16,
	SEARCH_Aliahan_Inn_2F_SACK_0             = 17,
	SEARCH_Aliahan_Inn_2F_STORAGE_0          = 18,
	SEARCH_Aliahan_Inn_2F_POT_0              = 19,
	SEARCH_Aliahan_Inn_2F_POT_1              = 20,
	SEARCH_Aliahan_Luida_1F_BARREL_0         = 21,
	SEARCH_Aliahan_Luida_2F_POT_0            = 22,
	SEARCH_Aliahan_Castle_1F_BARREL_0        = 23,
	SEARCH_Aliahan_Castle_1F_BARREL_1        = 24,
	SEARCH_Aliahan_Castle_1F_BARREL_2        = 25,
	SEARCH_Aliahan_Castle_1F_BARREL_3        = 26,
	SEARCH_Aliahan_Castle_1F_TREASURE_NORMAL_0 = 27,
	SEARCH_Aliahan_Castle_1F_TREASURE_NORMAL_1 = 28,
	SEARCH_Aliahan_Castle_1F_TREASURE_NORMAL_2 = 29,
	SEARCH_Aliahan_Castle_1F_TREASURE_NORMAL_3 = 30,
	SEARCH_Aliahan_Castle_1F_TREASURE_NORMAL_4 = 31,
	SEARCH_Aliahan_Castle_1F_TREASURE_NORMAL_5 = 32,
	SEARCH_Aliahan_Castle_1F_POT_0           = 33,
	SEARCH_Aliahan_Castle_1F_POT_1           = 34,
	SEARCH_Aliahan_Castle_1F_GROUND_0        = 35,
	SEARCH_Aliahan_Castle_1F_GROUND_1        = 36,
	SEARCH_Aliahan_Castle_1FA_DRAWER_0       = 37,
	SEARCH_Aliahan_Castle_1FB_BARREL_0       = 38,
	SEARCH_Aliahan_Castle_1FB_POT_0          = 39,
	SEARCH_Aliahan_Castle_2F_STORAGE_0       = 40,
	SEARCH_Aliahan_Castle_2F_GROUND_0        = 41,
	SEARCH_Aliahan_Castle_B1F_POT_0          = 42,
	SEARCH_Aliahan_Castle_B1F_POT_1          = 43,
	SEARCH_Aliahan_Castle_B1F_BARREL_0       = 44,
	SEARCH_Aliahan_Castle_B1FB_POT_0         = 45,
	SEARCH_Aliahan_Castle_1F_Out_BARREL_0    = 46,
	SEARCH_Reeve_Out_GROUND_0                = 47,
	SEARCH_Reeve_Out_GROUND_1                = 48,
	SEARCH_Reeve_Out_BARREL_0                = 49,
	SEARCH_Reeve_Out_BARREL_1                = 50,
	SEARCH_Reeve_Out_POT_0                   = 51,
	SEARCH_Reeve_House1_1F_BOOKSHELF_0       = 52,
	SEARCH_Reeve_House2_1F_POT_0             = 53,
	SEARCH_Reeve_House2_2F_DRAWER_0          = 54,
	SEARCH_Reeve_Church_1F_POT_0             = 55,
	SEARCH_Reeve_Inn_1F_POT_0                = 56,
	SEARCH_Reeve_Inn_2F_POT_0                = 57,
	SEARCH_ReeveSouth_BARREL_0               = 58,
	SEARCH_ReeveSouth_POT_0                  = 59,
	SEARCH_MisakiCave_B2F_TREASURE_NORMAL_0  = 60,
	SEARCH_MisakiCave_B2F_TREASURE_NORMAL_1  = 61,
	SEARCH_MisakiCave_B2F_TREASURE_NORMAL_2  = 62,
	SEARCH_MisakiCave_B2F_TREASURE_NORMAL_3  = 63,
	SEARCH_NajimiTower_B1F_TREASURE_NORMAL_0 = 64,
	SEARCH_NajimiTower_B1F_TREASURE_NORMAL_1 = 65,
	SEARCH_NajimiTower_B1F_TREASURE_NORMAL_2 = 66,
	SEARCH_NajimiTower_1F_TREASURE_NORMAL_0  = 67,
	SEARCH_NajimiTower_1F_POT_0              = 68,
	SEARCH_NajimiTower_2F_TREASURE_NORMAL_0  = 69,
	SEARCH_NajimiTower_2F_TREASURE_NORMAL_1  = 70,
	SEARCH_NajimiTower_3F_TREASURE_NORMAL_0  = 71,
	SEARCH_NajimiTower_3F_TREASURE_NORMAL_1  = 72,
	SEARCH_NajimiTower_Penthouse_TREASURE_NORMAL_0 = 73,
	SEARCH_NajimiTower_Penthouse_BOOKSHELF_0 = 74,
	SEARCH_SmallShrine_B1F_POT_0             = 75,
	SEARCH_SmallShrine_B1F_POT_1             = 76,
	SEARCH_IzanaiCave_B1F_After_TREASURE_IMPORTANT_0 = 77,
	SEARCH_IzanaiCave_B2F_TREASURE_NORMAL_0  = 78,
	SEARCH_IzanaiCave_B2F_TREASURE_NORMAL_1  = 79,
	SEARCH_IzanaiCave_B2F_TREASURE_NORMAL_2  = 80,
	SEARCH_IzanaiCave_B2F_BARREL_0           = 81,
	SEARCH_IzanaiCave_B2F_GROUND_0           = 82,
	SEARCH_IzanaiCave_B3FA_TREASURE_NORMAL_0 = 83,
	SEARCH_IzanaiCave_B3FA_POT_0             = 84,
	SEARCH_IzanaiCave_B3FA_POT_1             = 85,
	SEARCH_IzanaiCave_B3FB_TREASURE_NORMAL_0 = 86,
	SEARCH_IzanaiCave_B3FB_POT_0             = 87,
	SEARCH_IzanaiCave_B3FB_POT_1             = 88,
	SEARCH_IzanaiShrine_1F_GROUND_0          = 89,
	SEARCH_IzanaiShrine_1F_POT_0             = 90,
	SEARCH_Romaria_Out_GROUND_0              = 91,
	SEARCH_Romaria_Out_GROUND_1              = 92,
	SEARCH_Romaria_Out_POT_0                 = 93,
	SEARCH_Romaria_Out_POT_1                 = 94,
	SEARCH_Romaria_Out_BARREL_0              = 95,
	SEARCH_Romaria_Out_BARREL_1              = 96,
	SEARCH_Romaria_Out_BARREL_2              = 97,
	SEARCH_Romaria_Inn_1F_DRAWER_0           = 98,
	SEARCH_Romaria_Inn_2F_DRAWER_0           = 99,
	SEARCH_Romaria_House_DRAWER_0            = 100,
	SEARCH_Romaria_House_POT_0               = 101,
	SEARCH_Romaria_Church_DRAWER_0           = 102,
	SEARCH_Romaria_Church_BOOKSHELF_0        = 103,
	SEARCH_Romaria_Shop_POT_0                = 104,
	SEARCH_Romaria_BattleRoad_POT_0          = 105,
	SEARCH_Romaria_BattleRoad_BARREL_0       = 106,
	SEARCH_Romaria_Castle_1F_GROUND_0        = 107,
	SEARCH_Romaria_Castle_1F_GROUND_1        = 108,
	SEARCH_Romaria_Castle_1F_POT_0           = 109,
	SEARCH_Romaria_Castle_1F_POT_1           = 110,
	SEARCH_Romaria_Castle_1F_POT_2           = 111,
	SEARCH_Romaria_Castle_1F_POT_3           = 112,
	SEARCH_Romaria_Castle_1F_BARREL_0        = 113,
	SEARCH_Romaria_Castle_2F_GROUND_0        = 114,
	SEARCH_Romaria_Castle_2F_POT_0           = 115,
	SEARCH_Romaria_Castle_2F_POT_1           = 116,
	SEARCH_Romaria_Castle_4F_A_BOOKSHELF_0   = 117,
	SEARCH_Romaria_Castle_4F_A_DRAWER_0      = 118,
	SEARCH_Romaria_Castle_4F_B_GROUND_0      = 119,
	SEARCH_Romaria_Castle_B1_TREASURE_NORMAL_0 = 120,
	SEARCH_Romaria_Castle_B1_TREASURE_NORMAL_1 = 121,
	SEARCH_RomariaHighroad_Out_BARREL_0      = 122,
	SEARCH_Kazave_Out_GROUND_0               = 123,
	SEARCH_Kazave_Out_POT_0                  = 124,
	SEARCH_Kazave_Out_BARREL_0               = 125,
	SEARCH_Kazave_Shop_TREASURE_NORMAL_0     = 126,
	SEARCH_Kazave_Shop_TREASURE_NORMAL_1     = 127,
	SEARCH_Kazave_Shop_DRAWER_0              = 128,
	SEARCH_Kazave_Bar_1F_BARREL_0            = 129,
	SEARCH_Kazave_Bar_2F_DRAWER_0            = 130,
	SEARCH_Kazave_Bar_2F_BARREL_1            = 131,
	SEARCH_Kazave_Inn_1F_DRAWER_0            = 132,
	SEARCH_Kazave_Inn_1F_DRAWER_1            = 133,
	SEARCH_ShampaneTower_1F_TREASURE_NORMAL_0 = 134,
	SEARCH_ShampaneTower_1F_BARREL_0         = 135,
	SEARCH_ShampaneTower_2F_TREASURE_NORMAL_0 = 136,
	SEARCH_ShampaneTower_2F_BARREL_0         = 137,
	SEARCH_ShampaneTower_2F_BARREL_1         = 138,
	SEARCH_ShampaneTower_3F_TREASURE_NORMAL_0 = 139,
	SEARCH_ShampaneTower_3F_POT_0            = 140,
	SEARCH_ShampaneTower_3F_POT_1            = 141,
	SEARCH_ShampaneTower_4F_TREASURE_NORMAL_0 = 142,
	SEARCH_ShampaneTower_4F_TREASURE_NORMAL_1 = 143,
	SEARCH_ShampaneTower_4F_POT_0            = 144,
	SEARCH_ShampaneTower_4F_POT_1            = 145,
	SEARCH_ShampaneTower_4F_POT_2            = 146,
	SEARCH_ShampaneTower_3F_EVENT_0          = 147,
	SEARCH_ShampaneTower_6F_TREASURE_NORMAL_0 = 148,
	SEARCH_ShampaneTower_6F_TREASURE_NORMAL_1 = 149,
	SEARCH_Noaniel_Out_GROUND_0              = 150,
	SEARCH_Noaniel_Out_GROUND_1              = 151,
	SEARCH_Noaniel_Out_BARREL_0              = 152,
	SEARCH_Noaniel_Out_BARREL_1              = 153,
	SEARCH_Noaniel_Inn_2F_DRAWER_0           = 154,
	SEARCH_Noaniel_Inn_2F_DRAWER_1           = 155,
	SEARCH_Noaniel_Inn_2F_POT_0              = 156,
	SEARCH_Noaniel_Inn_2F_SACK_0             = 157,
	SEARCH_Noaniel_Shop_POT_0                = 158,
	SEARCH_Noaniel_Room01_1F_POT_0           = 159,
	SEARCH_Noaniel_Room02_1F_POT_0           = 160,
	SEARCH_Noaniel_Room02_2F_BOOKSHELF_0     = 161,
	SEARCH_Noaniel_Room02_2F_TREASURE_NORMAL_0 = 162,
	SEARCH_ElfVillage_Out_GROUND_0           = 163,
	SEARCH_ElfVillage_Out_GROUND_1           = 164,
	SEARCH_ElfVillage_Out_GROUND_2           = 165,
	SEARCH_ElfVillage_Out_POT_0              = 166,
	SEARCH_ElfVillage_Out_POT_1              = 167,
	SEARCH_ElfVillage_Out_POT_2              = 168,
	SEARCH_ElfVillage_House_GROUND_0         = 169,
	SEARCH_UndergroundLake_B1F_TREASURE_NORMAL_0 = 170,
	SEARCH_UndergroundLake_B1F_TREASURE_NORMAL_1 = 171,
	SEARCH_UndergroundLake_B2F_A_TREASURE_NORMAL_0 = 172,
	SEARCH_UndergroundLake_B2F_A_TREASURE_NORMAL_1 = 173,
	SEARCH_UndergroundLake_B2F_B3F_TREASURE_NORMAL_0 = 174,
	SEARCH_UndergroundLake_B3F_TREASURE_NORMAL_0 = 175,
	SEARCH_UndergroundLake_B3F_TREASURE_NORMAL_1 = 176,
	SEARCH_UndergroundLake_B3F_TREASURE_NORMAL_2 = 177,
	SEARCH_UndergroundLake_B3F_TREASURE_NORMAL_3 = 178,
	SEARCH_UndergroundLake_B4F_TREASURE_IMPORTANT_0 = 179,
	SEARCH_UndergroundLake_B4F_TREASURE_NORMAL_0 = 180,
	SEARCH_Ashalam_Out_BARREL_0              = 181,
	SEARCH_Ashalam_Out_BARREL_1              = 182,
	SEARCH_Ashalam_Out_POT_0                 = 183,
	SEARCH_Ashalam_Out_POT_1                 = 184,
	SEARCH_Ashalam_House01_2F_STORAGE_0      = 185,
	SEARCH_Ashalam_House02_1F_POT_0          = 186,
	SEARCH_Ashalam_House02_2F_GROUND_0       = 187,
	SEARCH_Ashalam_House02_2F_BOOKSHELF_0    = 188,
	SEARCH_Ashalam_House03_POT_0             = 189,
	SEARCH_Ashalam_Hotel_STORAGE_0           = 190,
	SEARCH_Ashalam_Hotel_POT_0               = 191,
	SEARCH_Ashalam_Theater_GROUND_0          = 192,
	SEARCH_Isis_Out_GROUND_0                 = 193,
	SEARCH_Isis_Out_GROUND_1                 = 194,
	SEARCH_Isis_Out_POT_0                    = 195,
	SEARCH_Isis_Out_POT_1                    = 196,
	SEARCH_Isis_Out_BARREL_0                 = 197,
	SEARCH_Isis_HouseA1F_SACK_0              = 198,
	SEARCH_Isis_HouseA1F_GROUND_0            = 199,
	SEARCH_Isis_HouseA2F_STORAGE_0           = 200,
	SEARCH_Isis_HouseB1F_SACK_0              = 201,
	SEARCH_Isis_HouseB2F_BOOKSHELF_0         = 202,
	SEARCH_Isis_Inn_STORAGE_0                = 203,
	SEARCH_Isis_WeaponShop_POT_0             = 204,
	SEARCH_Isis_Well_TREASURE_NORMAL_0       = 205,
	SEARCH_Isis_BattleRoad_BARREL_0          = 206,
	SEARCH_Isis_BattleRoad_POT_0             = 207,
	SEARCH_Isis_Castle_Out_GROUND_0          = 208,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_0  = 209,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_1  = 210,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_2  = 211,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_3  = 212,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_4  = 213,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_5  = 214,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_6  = 215,
	SEARCH_Isis_Castle_1F_TREASURE_NORMAL_7  = 216,
	SEARCH_Isis_Castle_1F_DRAWER_0           = 217,
	SEARCH_Isis_Castle_1F_BOOKSHELF_0        = 218,
	SEARCH_Isis_Castle_1F_POT_0              = 219,
	SEARCH_Isis_Castle_1F_POT_1              = 220,
	SEARCH_Isis_Castle_2F_GROUND_0           = 221,
	SEARCH_Isis_Castle_2F_Out_GROUND_0       = 222,
	SEARCH_Isis_Castle_3F_GROUND_0           = 223,
	SEARCH_Isis_Castle_B2F_TREASURE_NORMAL_0 = 224,
	SEARCH_DesertShrine_1F_POT_0             = 225,
	SEARCH_DesertShrine_1F_BOOKSHELF_0       = 226,
	SEARCH_DesertShrine_1F_DRAWER_0          = 227,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_0      = 228,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_1      = 229,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_2      = 230,
	SEARCH_Pyramid_1F_TREASURE_ENEMY_3       = 231,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_4      = 232,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_5      = 233,
	SEARCH_Pyramid_1F_TREASURE_ENEMY_6       = 234,
	SEARCH_Pyramid_1F_TREASURE_ENEMY_7       = 235,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_8      = 236,
	SEARCH_Pyramid_1F_TREASURE_NORMAL_9      = 237,
	SEARCH_Pyramid_1F_POT_0                  = 238,
	SEARCH_Pyramid_1F_POT_1                  = 239,
	SEARCH_Pyramid_2F_TREASURE_NORMAL_0      = 240,
	SEARCH_Pyramid_2F_POT_0                  = 241,
	SEARCH_Pyramid_2F_POT_1                  = 242,
	SEARCH_Pyramid_2F_POT_2                  = 243,
	SEARCH_Pyramid_3F_TREASURE_NORMAL_0      = 244,
	SEARCH_Pyramid_3F_TREASURE_IMPORTANT_0   = 245,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_0     = 246,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_1     = 247,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_2     = 248,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_3     = 249,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_4     = 250,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_5     = 251,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_6     = 252,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_7     = 253,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_8     = 254,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_9     = 255,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_10    = 256,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_11    = 257,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_12    = 258,
	SEARCH_Pyramid_4F_TREASURE_PYRAMID_13    = 259,
	SEARCH_Pyramid_5F_TREASURE_NORMAL_0      = 260,
	SEARCH_Pyramid_B1F_POT_0                 = 261,
	SEARCH_Pyramid_B1F_POT_1                 = 262,
	SEARCH_Pyramid_out_GROUND_0              = 263,
	SEARCH_RomariaBarrier_Out_GROUND_0       = 264,
	SEARCH_RomariaBarrier_Out_POT_0          = 265,
	SEARCH_RomariaBarrier_B1F_GROUND_0       = 266,
	SEARCH_RomariaBarrier_B1F_GROUND_1       = 267,
	SEARCH_RomariaBarrier_B1F_BARREL_0       = 268,
	SEARCH_Portoga_Out_GROUND_0              = 269,
	SEARCH_Portoga_Out_GROUND_1              = 270,
	SEARCH_Portoga_Out_GROUND_2              = 271,
	SEARCH_Portoga_Out_POT_0                 = 272,
	SEARCH_Portoga_Out_POT_1                 = 273,
	SEARCH_Portoga_Out_POT_2                 = 274,
	SEARCH_Portoga_Out_POT_3                 = 275,
	SEARCH_Portoga_Out_BARREL_0              = 276,
	SEARCH_Portoga_Out_BARREL_1              = 277,
	SEARCH_Portoga_Out_BARREL_2              = 278,
	SEARCH_Portoga_Inn_DRAWER_0              = 279,
	SEARCH_Portoga_Room01_1F_SACK_0          = 280,
	SEARCH_Portoga_Room02_B1F_POT_0          = 281,
	SEARCH_Portoga_Room02_B1F_BOOKSHELF_0    = 282,
	SEARCH_Portoga_Castle_1F_TREASURE_NORMAL_0 = 283,
	SEARCH_Portoga_Castle_1F_TREASURE_NORMAL_1 = 284,
	SEARCH_Portoga_Castle_1F_TREASURE_NORMAL_2 = 285,
	SEARCH_Portoga_Castle_1F_DRAWER_0        = 286,
	SEARCH_NorudCave_B1F_TREASURE_NORMAL_0   = 287,
	SEARCH_NorudCave_B1F_TREASURE_NORMAL_1   = 288,
	SEARCH_NorudCave_B1F_BARREL_1            = 289,
	SEARCH_NorudCave_B1F_BARREL_2            = 290,
	SEARCH_NorudCave_Well_GROUND_0           = 291,
	SEARCH_NorudCave_Well_GROUND_1           = 292,
	SEARCH_Baharata_Out_GROUND_0             = 293,
	SEARCH_Baharata_Out_BARREL_0             = 294,
	SEARCH_Baharata_Out_BARREL_1             = 295,
	SEARCH_Baharata_Out_POT_0                = 296,
	SEARCH_Baharata_Out_POT_1                = 297,
	SEARCH_Baharata_Out_POT_2                = 298,
	SEARCH_Baharata_House1_1F_DRAWER_0       = 299,
	SEARCH_Baharata_inn_1F_DRAWER_0          = 300,
	SEARCH_Baharata_Shop3_1F_SACK_0          = 301,
	SEARCH_Baharata_Shop3_2F_DRAWER_0        = 302,
	SEARCH_BaharataEastCave_B1F_TREASURE_ENEMY_0 = 303,
	SEARCH_BaharataEastCave_B1F_TREASURE_NORMAL_1 = 304,
	SEARCH_BaharataEastCave_B1F_TREASURE_NORMAL_2 = 305,
	SEARCH_BaharataEastCave_B1F_TREASURE_ENEMY_3 = 306,
	SEARCH_BaharataEastCave_B1F_TREASURE_NORMAL_4 = 307,
	SEARCH_BaharataEastCave_B1F_TREASURE_NORMAL_5 = 308,
	SEARCH_BaharataEastCave_B1F_BARREL_0     = 309,
	SEARCH_BaharataEastCave_B1F_BARREL_1     = 310,
	SEARCH_BaharataEastCave_B1F_BARREL_2     = 311,
	SEARCH_BaharataEastCave_B1F_GROUND_0     = 312,
	SEARCH_BaharataEastCave_B2F_TREASURE_NORMAL_0 = 313,
	SEARCH_BaharataEastCave_B2F_TREASURE_NORMAL_1 = 314,
	SEARCH_BaharataEastCave_B2F_TREASURE_NORMAL_2 = 315,
	SEARCH_BaharataEastCave_B2F_TREASURE_NORMAL_3 = 316,
	SEARCH_BaharataEastCave_B2F_SACK_0       = 317,
	SEARCH_BaharataEastCave_B2F_GROUND_0     = 318,
	SEARCH_BaharataEastCave_B2F_GROUND_1     = 319,
	SEARCH_BaharataEastCave_B2F_BARREL_0     = 320,
	SEARCH_Dharma_Castle_1F_GROUND_0         = 321,
	SEARCH_Dharma_Castle_1F_POT_0            = 322,
	SEARCH_Dharma_Castle_1F_POT_1            = 323,
	SEARCH_Dharma_Castle_B1F_GROUND_0        = 324,
	SEARCH_Dharma_Castle_B1F_POT_0           = 325,
	SEARCH_Dharma_Castle_B1F_POT_1           = 326,
	SEARCH_GarunaTower_1F_TREASURE_NORMAL_0  = 327,
	SEARCH_GarunaTower_1F_POT_0              = 328,
	SEARCH_GarunaTower_1F_POT_1              = 329,
	SEARCH_GarunaTower_2F_TREASURE_IMPORTANT_0 = 330,
	SEARCH_GarunaTower_2F_POT_0              = 331,
	SEARCH_GarunaTower_3F_TREASURE_NORMAL_0  = 332,
	SEARCH_GarunaTower_3F_TREASURE_NORMAL_1  = 333,
	SEARCH_GarunaTower_3F_TREASURE_NORMAL_2  = 334,
	SEARCH_GarunaTower_3F_TREASURE_NORMAL_3  = 335,
	SEARCH_GarunaTower_4F_TREASURE_NORMAL_0  = 336,
	SEARCH_GarunaTower_4F_POT_0              = 337,
	SEARCH_GarunaTower_5F_TREASURE_NORMAL_0  = 338,
	SEARCH_PortogaLight_2F_BARREL_0          = 339,
	SEARCH_PortogaLight_3F_TREASURE_NORMAL_0 = 340,
	SEARCH_PortogaLight_4F_POT_0             = 341,
	SEARCH_TravelersShrine_1F_POT_0          = 342,
	SEARCH_Tedon_Out_GROUND_0                = 343,
	SEARCH_Tedon_Out_GROUND_1                = 344,
	SEARCH_Tedon_Out_POT_0                   = 345,
	SEARCH_Tedon_Out_STORAGE_0               = 346,
	SEARCH_Tedon_Out_TREASURE_NORMAL_0       = 347,
	SEARCH_Tedon_Out_BARREL_0                = 348,
	SEARCH_Tedon_Room_B1F_GROUND_0           = 349,
	SEARCH_Tedon_Shop_1F_BARREL_0            = 350,
	SEARCH_TravelersHotel_House_DRAWER_0     = 351,
	SEARCH_TravelersHotel_House_DRAWER_1     = 352,
	SEARCH_Jipang_Out_GROUND_0               = 353,
	SEARCH_Jipang_Out_GROUND_1               = 354,
	SEARCH_Jipang_Out_POT_0                  = 355,
	SEARCH_Jipang_House1_STORAGE_0           = 356,
	SEARCH_Jipang_House2_STORAGE_0           = 357,
	SEARCH_Jipang_House2_SACK_0              = 358,
	SEARCH_Jipang_House3_POT_0               = 359,
	SEARCH_Jipang_House3_SACK_0              = 360,
	SEARCH_Jipang_House3_GROUND_0            = 361,
	SEARCH_Jipang_Storehouse_POT_0           = 362,
	SEARCH_Jipang_Storehouse_POT_1           = 363,
	SEARCH_Jipang_Storehouse_POT_2           = 364,
	SEARCH_Jipang_Well_GROUND_0              = 365,
	SEARCH_Jipang_BattleRoad_BARREL_0        = 366,
	SEARCH_Jipang_BattleRoad_POT_0           = 367,
	SEARCH_Jipang_Castle_Room_POT_0          = 368,
	SEARCH_Jipang_Castle_Room_POT_1          = 369,
	SEARCH_Jipang_Castle_Room_POT_2          = 370,
	SEARCH_Jipang_Castle_Room_STORAGE_0      = 371,
	SEARCH_Jipang_Castle_Room_STORAGE_1      = 372,
	SEARCH_JipangCave_1F_TREASURE_NORMAL_0   = 373,
	SEARCH_JipangCave_1F_TREASURE_NORMAL_1   = 374,
	SEARCH_JipangCave_1F_TREASURE_NORMAL_2   = 375,
	SEARCH_JipangCave_1F_TREASURE_NORMAL_3   = 376,
	SEARCH_JipangCave_2F_TREASURE_NORMAL_0   = 377,
	SEARCH_Muor_Out_BARREL_0                 = 378,
	SEARCH_Muor_Out_BARREL_1                 = 379,
	SEARCH_Muor_Out_BARREL_2                 = 380,
	SEARCH_Muor_Out_SACK_1                   = 381,
	SEARCH_Muor_Church_1F_GROUND_0           = 382,
	SEARCH_Muor_Inn_1F_STORAGE_0             = 383,
	SEARCH_Muor_Inn_1F_POT_0                 = 384,
	SEARCH_Muor_Market_1F_GROUND_0           = 385,
	SEARCH_Muor_Market_2F_POT_0              = 386,
	SEARCH_Muor_Market_2F_POT_1              = 387,
	SEARCH_Muor_House1_1F_POT_0              = 388,
	SEARCH_HobbitShrine_1F_GROUND_0          = 389,
	SEARCH_HobbitShrine_1F_BARREL_0          = 390,
	SEARCH_ArpTower_1F_TREASURE_NORMAL_0     = 391,
	SEARCH_ArpTower_2F_TREASURE_NORMAL_0     = 392,
	SEARCH_ArpTower_2F_TREASURE_NORMAL_1     = 393,
	SEARCH_ArpTower_3F_TREASURE_IMPORTANT_0  = 394,
	SEARCH_ArpTower_3F_TREASURE_NORMAL_1     = 395,
	SEARCH_ArpTower_3F_TREASURE_NORMAL_2     = 396,
	SEARCH_ArpTower_3F_TREASURE_NORMAL_3     = 397,
	SEARCH_ArpTower_3F_TREASURE_NORMAL_4     = 398,
	SEARCH_ArpTower_5F_TREASURE_NORMAL_0     = 399,
	SEARCH_ArpTower_5F_TREASURE_NORMAL_1     = 400,
	SEARCH_ArpTower_5F_TREASURE_ENEMY_2      = 401,
	SEARCH_Lancel_Out_GROUND_0               = 402,
	SEARCH_Lancel_Out_POT_0                  = 403,
	SEARCH_Lancel_Out_POT_1                  = 404,
	SEARCH_Lancel_Out_BARREL_0               = 405,
	SEARCH_Lancel_Out_BARREL_1               = 406,
	SEARCH_Lancel_Out_BARREL_2               = 407,
	SEARCH_Lancel_Out_SACK_0                 = 408,
	SEARCH_Lancel_Out_TREASURE_NORMAL_0      = 409,
	SEARCH_Lancel_Inn_SACK_0                 = 410,
	SEARCH_Lancel_House_POT_0                = 411,
	SEARCH_Lancel_House_DRAWER_0             = 412,
	SEARCH_Lancel_WeaponShop_POT_0           = 413,
	SEARCH_Lancel_Bridge_TREASURE_NORMAL_0   = 414,
	SEARCH_GaiaNavel_B1FA_TREASURE_NORMAL_0  = 415,
	SEARCH_GaiaNavel_B1FA_TREASURE_NORMAL_1  = 416,
	SEARCH_GaiaNavel_B1FA_TREASURE_ENEMY_2   = 417,
	SEARCH_GaiaNavel_B1FA_TREASURE_NORMAL_3  = 418,
	SEARCH_GaiaNavel_B1FB_TREASURE_NORMAL_0  = 419,
	SEARCH_GaiaNavel_B1FC_TREASURE_NORMAL_0  = 420,
	SEARCH_GaiaNavel_B2F_POT_0               = 421,
	SEARCH_GaiaNavel_B2F_POT_1               = 422,
	SEARCH_GaiaNavel_B2F_POT_2               = 423,
	SEARCH_GaiaNavel_B3F_TREASURE_NORMAL_0   = 424,
	SEARCH_GaiaNavel_B3F_TREASURE_IMPORTANT_0 = 425,
	SEARCH_Edinbear_Castle_Out_GROUND_0      = 426,
	SEARCH_Edinbear_Castle_Out_GROUND_1      = 427,
	SEARCH_Edinbear_Castle_Out_POT_0         = 428,
	SEARCH_Edinbear_Castle_Out_POT_1         = 429,
	SEARCH_Edinbear_Castle_Out_BARREL_0      = 430,
	SEARCH_Edinbear_Castle_Out_BARREL_1      = 431,
	SEARCH_Edinbear_Castle_1F_BOOKSHELF_0    = 432,
	SEARCH_Edinbear_Castle_1F_STORAGE_0      = 433,
	SEARCH_Edinbear_Castle_1F_STORAGE_1      = 434,
	SEARCH_Edinbear_Castle_1F_STORAGE_2      = 435,
	SEARCH_Edinbear_Castle_1F_BARREL_0       = 436,
	SEARCH_Edinbear_Castle_1F_BARREL_1       = 437,
	SEARCH_Edinbear_Castle_B1FB_TREASURE_IMPORTANT_0 = 438,
	SEARCH_Luzami_Out_GROUND_0               = 439,
	SEARCH_Luzami_Out_GROUND_1               = 440,
	SEARCH_Luzami_House1_1F_BOOKSHELF_0      = 441,
	SEARCH_Luzami_House1_1F_BOOKSHELF_1      = 442,
	SEARCH_Luzami_House1_1F_BOOKSHELF_2      = 443,
	SEARCH_Luzami_House1_1F_BOOKSHELF_3      = 444,
	SEARCH_Luzami_House1_1F_BOOKSHELF_4      = 445,
	SEARCH_Luzami_House1_1F_DRAWER_0         = 446,
	SEARCH_Luzami_House1_2F_GROUND_0         = 447,
	SEARCH_Luzami_House2_BOOKSHELF_0         = 448,
	SEARCH_Luzami_House2_BOOKSHELF_1         = 449,
	SEARCH_ShallowShrine_B1F_TREASURE_IMPORTANT_0 = 450,
	SEARCH_ShallowShrine_B1F_GROUND_0        = 451,
	SEARCH_Soo_Out_GROUND_0                  = 452,
	SEARCH_Soo_Out_GROUND_1                  = 453,
	SEARCH_Soo_Out_POT_0                     = 454,
	SEARCH_Soo_Out_POT_1                     = 455,
	SEARCH_Soo_Room01_POT_0                  = 456,
	SEARCH_Soo_Room02_POT_0                  = 457,
	SEARCH_Soo_Room03_BARREL_0               = 458,
	SEARCH_Soo_Room03_BARREL_1               = 459,
	SEARCH_Soo_Well_DRAWER_0                 = 460,
	SEARCH_Soo_Inn_SACK_0                    = 461,
	SEARCH_Burg_3_Out_GROUND_0               = 462,
	SEARCH_Burg_3_House01_2F_POT_0           = 463,
	SEARCH_Burg_3_Inn_1F_SACK_0              = 464,
	SEARCH_Burg_3_Inn_1F_DRAWER_0            = 465,
	SEARCH_Burg_4_House01_1F_TREASURE_NORMAL_0 = 466,
	SEARCH_Burg_4_House01_1F_TREASURE_NORMAL_1 = 467,
	SEARCH_Burg_4_Theater_1F_DRAWER_0        = 468,
	SEARCH_Burg_4_Theater_1F_DRAWER_1        = 469,
	SEARCH_Burg_5_House01_1F_GROUND_0        = 470,
	SEARCH_Burg_6_Theater_1F_DRAWER_0        = 471,
	SEARCH_Burg_6_House02_2F_DRAWER_0        = 472,
	SEARCH_TravelDoorShrine_1F_GROUND_0      = 473,
	SEARCH_TravelersChurch_1F_BARREL_0       = 474,
	SEARCH_Samanosa_Out_GROUND_0             = 475,
	SEARCH_Samanosa_Out_GROUND_1             = 476,
	SEARCH_Samanosa_Out_GROUND_2             = 477,
	SEARCH_Samanosa_Out_GROUND_3             = 478,
	SEARCH_Samanosa_Out_BARREL_0             = 479,
	SEARCH_Samanosa_Out_BARREL_1             = 480,
	SEARCH_Samanosa_Out_POT_0                = 481,
	SEARCH_Samanosa_House1_POT_0             = 482,
	SEARCH_Samanosa_House1_SACK_0            = 483,
	SEARCH_Samanosa_House2_1F_DRAWER_0       = 484,
	SEARCH_Samanosa_House2_1F_SACK_0         = 485,
	SEARCH_Samanosa_House3_POT_0             = 486,
	SEARCH_Samanosa_Inn_DRAWER_0             = 487,
	SEARCH_Samanosa_Inn_SACK_0               = 488,
	SEARCH_Samanosa_Castle_1F_BARREL_0       = 489,
	SEARCH_Samanosa_Castle_1F_GROUND_0       = 490,
	SEARCH_Samanosa_Castle_1F_POT_0          = 491,
	SEARCH_Samanosa_Castle_2F_POT_0          = 492,
	SEARCH_Samanosa_Castle_2F_POT_1          = 493,
	SEARCH_Samanosa_Castle_2F_BedRoom_BOOKSHELF_0 = 494,
	SEARCH_Samanosa_Castle_2F_BedRoom_DRAWER_0 = 495,
	SEARCH_Samanosa_Castle_2F_BedRoom_TREASURE_IMPORTANT_0 = 496,
	SEARCH_Samanosa_Castle_B1_POT_0          = 497,
	SEARCH_Samanosa_Castle_B2_A_GROUND_0     = 498,
	SEARCH_Samanosa_Castle_B2_A_POT_0        = 499,
	SEARCH_Samanosa_BattleRoad_POT_0         = 500,
	SEARCH_Samanosa_BattleRoad_BARREL_0      = 501,
	SEARCH_Samanosa_BattleRoad_BARREL_1      = 502,
	SEARCH_RaCave_B1_TREASURE_NORMAL_0       = 503,
	SEARCH_RaCave_B1_TREASURE_NORMAL_1       = 504,
	SEARCH_RaCave_B2_TREASURE_ENEMY_0        = 505,
	SEARCH_RaCave_B2_TREASURE_ENEMY_1        = 506,
	SEARCH_RaCave_B2_TREASURE_ENEMY_2        = 507,
	SEARCH_RaCave_B2_TREASURE_NORMAL_3       = 508,
	SEARCH_RaCave_B2_TREASURE_ENEMY_4        = 509,
	SEARCH_RaCave_B2_TREASURE_NORMAL_5       = 510,
	SEARCH_RaCave_B2_TREASURE_NORMAL_6       = 511,
	SEARCH_RaCave_B2_TREASURE_ENEMY_7        = 512,
	SEARCH_RaCave_B2_TREASURE_NORMAL_8       = 513,
	SEARCH_RaCave_B2_TREASURE_NORMAL_9       = 514,
	SEARCH_RaCave_B2_TREASURE_NORMAL_10      = 515,
	SEARCH_RaCave_B2_TREASURE_NORMAL_11      = 516,
	SEARCH_RaCave_B2_TREASURE_ENEMY_12       = 517,
	SEARCH_RaCave_B2_TREASURE_ENEMY_13       = 518,
	SEARCH_RaCave_B2_TREASURE_NORMAL_14      = 519,
	SEARCH_RaCave_B2_TREASURE_NORMAL_15      = 520,
	SEARCH_RaCave_B2_TREASURE_ENEMY_16       = 521,
	SEARCH_RaCave_B2_TREASURE_NORMAL_17      = 522,
	SEARCH_RaCave_B2_TREASURE_ENEMY_18       = 523,
	SEARCH_RaCave_B2_TREASURE_ENEMY_19       = 524,
	SEARCH_RaCave_B2_TREASURE_NORMAL_20      = 525,
	SEARCH_RaCave_B3_TREASURE_NORMAL_0       = 526,
	SEARCH_RaCave_B3_TREASURE_IMPORTANT_1    = 527,
	SEARCH_Greenlad_Out_TREASURE_NORMAL_0    = 528,
	SEARCH_Greenlad_Out_TREASURE_NORMAL_1    = 529,
	SEARCH_Greenlad_Out_TREASURE_NORMAL_2    = 530,
	SEARCH_Greenlad_Out_POT_0                = 531,
	SEARCH_Greenlad_Out_SACK_0               = 532,
	SEARCH_Greenlad_House_DRAWER_0           = 533,
	SEARCH_Greenlad_House_DRAWER_1           = 534,
	SEARCH_GhostShip_1F_BARREL_0             = 535,
	SEARCH_GhostShip_1F_BARREL_1             = 536,
	SEARCH_GhostShip_1F_POT_0                = 537,
	SEARCH_GhostShip_B1_DRAWER_0             = 538,
	SEARCH_GhostShip_B1_TREASURE_NORMAL_0    = 539,
	SEARCH_GhostShip_B1_TREASURE_NORMAL_1    = 540,
	SEARCH_GhostShip_B1_TREASURE_NORMAL_2    = 541,
	SEARCH_GhostShip_B1_TREASURE_ENEMY_3     = 542,
	SEARCH_GhostShip_B1_TREASURE_NORMAL_4    = 543,
	SEARCH_GhostShip_B1_TREASURE_IMPORTANT_5 = 544,
	SEARCH_GhostShip_B1_BARREL_0             = 545,
	SEARCH_GhostShip_B1_POT_0                = 546,
	SEARCH_OliviaMisaki_1F_GROUND_0          = 547,
	SEARCH_OliviaMisaki_1F_DRAWER_0          = 548,
	SEARCH_OliviaMisaki_1F_SACK_0            = 549,
	SEARCH_OliviaMisaki_Out_GROUND_0         = 550,
	SEARCH_ShrinePrison_1F_POT_0             = 551,
	SEARCH_ShrinePrison_1F_POT_1             = 552,
	SEARCH_ShrinePrison_1F_POT_2             = 553,
	SEARCH_ShrinePrison_1F_GROUND_0          = 554,
	SEARCH_PiratesBase_Out_BARREL_0          = 555,
	SEARCH_PiratesBase_Out_BARREL_1          = 556,
	SEARCH_PiratesBase_1F_DRAWER_0           = 557,
	SEARCH_PiratesBase_1F_POT_0              = 558,
	SEARCH_PiratesBase_1F_POT_1              = 559,
	SEARCH_PiratesBase_1F_BARREL_0           = 560,
	SEARCH_PiratesBase_1F_BARREL_1           = 561,
	SEARCH_PiratesBase_1F_SACK_0             = 562,
	SEARCH_PiratesBase_B1F_GROUND_0          = 563,
	SEARCH_PiratesBase_Secret_TREASURE_NORMAL_0 = 564,
	SEARCH_PiratesBase_Secret_TREASURE_NORMAL_1 = 565,
	SEARCH_PiratesBase_Secret_TREASURE_IMPORTANT_0 = 566,
	SEARCH_NecrogondCave_1F_TREASURE_NORMAL_0 = 567,
	SEARCH_NecrogondCave_1F_TREASURE_NORMAL_1 = 568,
	SEARCH_NecrogondCave_1F_TREASURE_NORMAL_2 = 569,
	SEARCH_NecrogondCave_1F_TREASURE_NORMAL_3 = 570,
	SEARCH_NecrogondCave_2FA_TREASURE_NORMAL_0 = 571,
	SEARCH_NecrogondCave_2FA_Loop_TREASURE_ENEMY_0 = 572,
	SEARCH_NecrogondCave_2FB_GROUND_0        = 573,
	SEARCH_NecrogondCave_2FB_TREASURE_NORMAL_0 = 574,
	SEARCH_NecrogondCave_2FB_TREASURE_NORMAL_1 = 575,
	SEARCH_NecrogondCave_3F_TREASURE_NORMAL_0 = 576,
	SEARCH_NecrogondCave_3F_TREASURE_NORMAL_1 = 577,
	SEARCH_NecrogondCave_4F_TREASURE_NORMAL_0 = 578,
	SEARCH_NecrogondCave_4F_TREASURE_NORMAL_1 = 579,
	SEARCH_NecrogondCave_4F_TREASURE_NORMAL_2 = 580,
	SEARCH_NecrogondCave_4F_TREASURE_ENEMY_3 = 581,
	SEARCH_NecrogondCave_4F_TREASURE_NORMAL_4 = 582,
	SEARCH_NecrogondCave_4F_TREASURE_NORMAL_5 = 583,
	SEARCH_NecrogondShrine_House_GROUND_0    = 584,
	SEARCH_NecrogondShrine_House_GROUND_1    = 585,
	SEARCH_NecrogondShrine_House_GROUND_2    = 586,
	SEARCH_NecrogondShrine_Out_BARREL_0      = 587,
	SEARCH_Reiamuland_Out_GROUND_0           = 588,
	SEARCH_SpiritSpring_1F_GROUND_0          = 589,
	SEARCH_SpiritSpring_1F_GROUND_1          = 590,
	SEARCH_GiagaPit_1F_Before_BARREL_0       = 591,
	SEARCH_BaramosCastle_Out_GROUND_0        = 592,
	SEARCH_BaramosCastle_Out_TREASURE_NORMAL_0 = 593,
	SEARCH_BaramosCastle_1FB_TREASURE_NORMAL_0 = 594,
	SEARCH_BaramosCastle_1FB_TREASURE_NORMAL_1 = 595,
	SEARCH_BaramosCastle_1FB_TREASURE_NORMAL_2 = 596,
	SEARCH_BaramosCastle_1FB_TREASURE_NORMAL_3 = 597,
	SEARCH_BaramosCastle_1FC_TREASURE_NORMAL_0 = 598,
	SEARCH_BaramosCastle_1FC_TREASURE_NORMAL_1 = 599,
	SEARCH_BaramosCastle_1FF_GROUND_0        = 600,
	SEARCH_BaramosCastle_B1A_GROUND_0        = 601,
	SEARCH_BaramosCastle_B1B_TREASURE_NORMAL_0 = 602,
	SEARCH_DragonQueen_back_GROUND_0         = 603,
	SEARCH_DragonQueen_Queen_room_GROUND_0   = 604,
	SEARCH_WestPort_Out_GROUND_0             = 605,
	SEARCH_WestPort_Out_GROUND_1             = 606,
	SEARCH_WestPort_House_DRAWER_0           = 607,
	SEARCH_Ludatorm_Out_GROUND_0             = 608,
	SEARCH_Ludatorm_Out_GROUND_1             = 609,
	SEARCH_Ludatorm_Out_GROUND_2             = 610,
	SEARCH_Ludatorm_Out_BARREL_0             = 611,
	SEARCH_Ludatorm_Out_BARREL_1             = 612,
	SEARCH_Ludatorm_Out_POT_0                = 613,
	SEARCH_Ludatorm_Out_SACK_0               = 614,
	SEARCH_Ludatorm_Out_TREASURE_NORMAL_0    = 615,
	SEARCH_Ludatorm_House1_2F_BOOKSHELF_0    = 616,
	SEARCH_Ludatorm_House1_2F_BOOKSHELF_1    = 617,
	SEARCH_Ludatorm_House2_2F_STORAGE_0      = 618,
	SEARCH_Ludatorm_Church_1F_POT_0          = 619,
	SEARCH_Ludatorm_Church_2F_POT_0          = 620,
	SEARCH_Ludatorm_Inn_BARREL_0             = 621,
	SEARCH_Ludatorm_Inn_POT_0                = 622,
	SEARCH_Ludatorm_Inn_SACK_0               = 623,
	SEARCH_Ludatorm_Castle_1F_TREASURE_NORMAL_0 = 624,
	SEARCH_Ludatorm_Castle_1F_TREASURE_NORMAL_1 = 625,
	SEARCH_Ludatorm_Castle_1F_TREASURE_NORMAL_2 = 626,
	SEARCH_Ludatorm_Castle_1F_TREASURE_NORMAL_3 = 627,
	SEARCH_Ludatorm_Castle_1F_TREASURE_NORMAL_4 = 628,
	SEARCH_Ludatorm_Castle_1F_BARREL_0       = 629,
	SEARCH_Ludatorm_Castle_1F_POT_0          = 630,
	SEARCH_Ludatorm_Castle_2F_STORAGE_0      = 631,
	SEARCH_Ludatorm_Castle_2F_POT_0          = 632,
	SEARCH_Ludatorm_Castle_2F_hidden_room_TREASURE_IMPORTANT_0 = 633,
	SEARCH_Ludatorm_Castle_2F_hidden_room_BARREL_0 = 634,
	SEARCH_Ludatorm_Castle_2F_hidden_room_BARREL_1 = 635,
	SEARCH_Ludatorm_Castle_1F_Out_GROUND_0   = 636,
	SEARCH_Ludatorm_Castle_B1F_POT_0         = 637,
	SEARCH_HeroCave_B1F_TREASURE_NORMAL_0    = 638,
	SEARCH_HeroCave_B1F_TREASURE_NORMAL_1    = 639,
	SEARCH_HeroCave_B2F_TREASURE_NORMAL_0    = 640,
	SEARCH_HeroCave_B2F_TREASURE_NORMAL_1    = 641,
	SEARCH_HeroCave_B3F_TREASURE_NORMAL_0    = 642,
	SEARCH_HeroCave_B3F_TREASURE_ENEMY_1     = 643,
	SEARCH_HeroCave_B3F_TREASURE_NORMAL_2    = 644,
	SEARCH_HeroCave_B3F_TREASURE_NORMAL_3    = 645,
	SEARCH_HeroCave_B3F_TREASURE_IMPORTANT_4 = 646,
	SEARCH_GaraiHouse_Out_BARREL_0           = 647,
	SEARCH_GaraiHouse_Out_POT_0              = 648,
	SEARCH_GaraiHouse_1F_DRAWER_0            = 649,
	SEARCH_GaraiHouse_1F_DRAWER_1            = 650,
	SEARCH_GaraiHouse_B1F_TREASURE_NORMAL_0  = 651,
	SEARCH_GaraiHouse_B1F_GROUND_0           = 652,
	SEARCH_GaraiHouse_B1F_EVENT_0            = 653,
	SEARCH_RockMtCave_B1F_TREASURE_NORMAL_0  = 654,
	SEARCH_RockMtCave_B1F_TREASURE_NORMAL_1  = 655,
	SEARCH_RockMtCave_B1F_TREASURE_NORMAL_2  = 656,
	SEARCH_RockMtCave_B1F_POT_0              = 657,
	SEARCH_RockMtCave_B2FA_TREASURE_NORMAL_0 = 658,
	SEARCH_RockMtCave_B2FA_TREASURE_NORMAL_1 = 659,
	SEARCH_RockMtCave_B2FA_TREASURE_NORMAL_2 = 660,
	SEARCH_RockMtCave_B2FA_TREASURE_NORMAL_3 = 661,
	SEARCH_RockMtCave_B2FB_BARREL_0          = 662,
	SEARCH_RockMtCave_B2FB_BARREL_1          = 663,
	SEARCH_RockMtCave_B2FB_GROUND_0          = 664,
	SEARCH_Domdora_Out_GROUND_0              = 665,
	SEARCH_Domdora_Out_GROUND_1              = 666,
	SEARCH_Domdora_Out_BARREL_0              = 667,
	SEARCH_Domdora_House01_1F_BARREL_0       = 668,
	SEARCH_Domdora_House02_1F_POT_0          = 669,
	SEARCH_Domdora_House02_1F_BOOKSHELF_1    = 670,
	SEARCH_Domdora_House03_1F_STORAGE_0      = 671,
	SEARCH_Domdora_Inn_2F_STORAGE_0          = 672,
	SEARCH_Domdora_Inn_2F_SACK_0             = 673,
	SEARCH_Domdora_Inn_2F_SACK_1             = 674,
	SEARCH_Domdora_Weapon_Shop02_2F_STORAGE_0 = 675,
	SEARCH_Domdora_Weapon_Shop02_2F_SACK_0   = 676,
	SEARCH_Domdora_Well_GROUND_0             = 677,
	SEARCH_Mercado_Out_GROUND_0              = 678,
	SEARCH_Mercado_Out_GROUND_1              = 679,
	SEARCH_Mercado_Out_GROUND_2              = 680,
	SEARCH_Mercado_Out_GROUND_3              = 681,
	SEARCH_Mercado_Out_BARREL_0              = 682,
	SEARCH_Mercado_Out_POT_1                 = 683,
	SEARCH_Mercado_Out_POT_2                 = 684,
	SEARCH_Mercado_Hotel_STORAGE_0           = 685,
	SEARCH_Mercado_Shop01_1F_SACK_0          = 686,
	SEARCH_Mercado_Shop02_2F_BOOKSHELF_0     = 687,
	SEARCH_Mercado_Shop02_2F_BOOKSHELF_1     = 688,
	SEARCH_Mercado_Shop02_2F_BOOKSHELF_2     = 689,
	SEARCH_Mercado_Shop02_2F_BOOKSHELF_3     = 690,
	SEARCH_Mercado_Shop02_2F_BOOKSHELF_4     = 691,
	SEARCH_Mercado_Shop02_2F_STORAGE_0       = 692,
	SEARCH_Mercado_Shop02_2F_DRAWER_0        = 693,
	SEARCH_Mercado_Shop02_2F_EVENT_0         = 694,
	SEARCH_Mercado_BattleRoad_POT_0          = 695,
	SEARCH_Mercado_BattleRoad_POT_1          = 696,
	SEARCH_Mercado_BattleRoad_BARREL_0       = 697,
	SEARCH_SpiritShrine_2F_GROUND_0          = 698,
	SEARCH_SpiritShrine_2F_GROUND_1          = 699,
	SEARCH_HolyShrine_2F_GROUND_0            = 700,
	SEARCH_Myra_Out_GROUND_0                 = 701,
	SEARCH_Myra_Out_GROUND_1                 = 702,
	SEARCH_Myra_Out_GROUND_2                 = 703,
	SEARCH_Myra_House_STORAGE_0              = 704,
	SEARCH_Myra_House_DRAWER_0               = 705,
	SEARCH_Myra_Shop_1F_GROUND_0             = 706,
	SEARCH_Myra_Shop_1F_BARREL_0             = 707,
	SEARCH_Myra_Shop_2F_SACK_0               = 708,
	SEARCH_Myra_Shop_2F_SACK_1               = 709,
	SEARCH_Myra_Well_GROUND_0                = 710,
	SEARCH_SwampCave_1F_GROUND_0             = 711,
	SEARCH_SwampCave_1F_GROUND_1             = 712,
	SEARCH_SwampCave_1F_POT_0                = 713,
	SEARCH_RubissTower_1F_TREASURE_ENEMY_0   = 714,
	SEARCH_RubissTower_1F_TREASURE_NORMAL_1  = 715,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_0  = 716,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_1  = 717,
	SEARCH_RubissTower_2F_TREASURE_ENEMY_2   = 718,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_3  = 719,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_4  = 720,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_5  = 721,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_6  = 722,
	SEARCH_RubissTower_2F_TREASURE_NORMAL_7  = 723,
	SEARCH_RubissTower_3F_TREASURE_NORMAL_0  = 724,
	SEARCH_RubissTower_3F_GROUND_0           = 725,
	SEARCH_RubissTower_4F_TREASURE_NORMAL_0  = 726,
	SEARCH_RubissTower_4FA_TREASURE_NORMAL_0 = 727,
	SEARCH_RubissTower_5F_TREASURE_NORMAL_0  = 728,
	SEARCH_Rimuldar_Out_BARREL_0             = 729,
	SEARCH_Rimuldar_Out_BARREL_1             = 730,
	SEARCH_Rimuldar_Out_POT_0                = 731,
	SEARCH_Rimuldar_Out_POT_1                = 732,
	SEARCH_Rimuldar_Out_POT_2                = 733,
	SEARCH_Rimuldar_Out_GROUND_0             = 734,
	SEARCH_Rimuldar_Church_2F_GROUND_0       = 735,
	SEARCH_Rimuldar_House1_DRAWER_0          = 736,
	SEARCH_Rimuldar_House1_DRAWER_1          = 737,
	SEARCH_Rimuldar_House1_POT_0             = 738,
	SEARCH_Rimuldar_House1_POT_1             = 739,
	SEARCH_Rimuldar_House2_DRAWER_0          = 740,
	SEARCH_Rimuldar_House2_DRAWER_1          = 741,
	SEARCH_Rimuldar_House2_POT_0             = 742,
	SEARCH_Rimuldar_Inn_STORAGE_0            = 743,
	SEARCH_Rimuldar_Inn_TREASURE_NORMAL_1    = 744,
	SEARCH_ZomaCastle_1F_GROUND_0            = 745,
	SEARCH_ZomaCastle_1F_GROUND_1            = 746,
	SEARCH_ZomaCastle_B1FA_TREASURE_NORMAL_0 = 747,
	SEARCH_ZomaCastle_B2F_TREASURE_NORMAL_0  = 748,
	SEARCH_ZomaCastle_B2F_TREASURE_NORMAL_1  = 749,
	SEARCH_ZomaCastle_B3FA_TREASURE_NORMAL_0 = 750,
	SEARCH_ZomaCastle_B3FA_TREASURE_NORMAL_1 = 751,
	SEARCH_ZomaCastle_B3FB_TREASURE_NORMAL_0 = 752,
	SEARCH_ZomaCastle_B4F_TREASURE_NORMAL_0  = 753,
	SEARCH_ZomaCastle_B4F_TREASURE_NORMAL_1  = 754,
	SEARCH_ZomaCastle_B4F_TREASURE_NORMAL_2  = 755,
	SEARCH_ZomaCastle_B4F_TREASURE_NORMAL_3  = 756,
	SEARCH_ZomaCastle_B4F_TREASURE_NORMAL_4  = 757,
	SEARCH_ZomaCastle_B4F_TREASURE_NORMAL_5  = 758,
	SEARCH_SecretCave_B1F_TREASURE_NORMAL_0  = 759,
	SEARCH_SecretCave_B1F_TREASURE_ENEMY_1   = 760,
	SEARCH_SecretCave_B1F_TREASURE_NORMAL_2  = 761,
	SEARCH_SecretCave_B2F_TREASURE_NORMAL_0  = 762,
	SEARCH_SecretCave_B2F_TREASURE_NORMAL_1  = 763,
	SEARCH_SecretCave_B2F_TREASURE_NORMAL_2  = 764,
	SEARCH_SecretCave_B2F_TREASURE_NORMAL_3  = 765,
	SEARCH_SecretCave_B3F_TREASURE_NORMAL_0  = 766,
	SEARCH_SecretCave_B3F_TREASURE_NORMAL_1  = 767,
	SEARCH_SecretCave_B3F_TREASURE_NORMAL_2  = 768,
	SEARCH_SecretCave_B3F_TREASURE_NORMAL_3  = 769,
	SEARCH_SecretCave_B4F_TREASURE_NORMAL_0  = 770,
	SEARCH_SecretCave_B5F_A_GROUND_0         = 771,
	SEARCH_SecretCave_B5F_B_TREASURE_NORMAL_0 = 772,
	SEARCH_SecretCave_B5F_B_TREASURE_NORMAL_1 = 773,
	SEARCH_SecretCave_B5F_C_GROUND_0         = 774,
	SEARCH_SecretCave_B5F_C_POT_0            = 775,
	SEARCH_SecretCave_B6F_GROUND_0           = 776,
	SEARCH_SecretCave_B6F_GROUND_1           = 777,
	SEARCH_Zenis_2F_TREASURE_NORMAL_0        = 778,
	SEARCH_Zenis_1F_POT_0                    = 779,
	SEARCH_Zenis_1F_POT_1                    = 780,
	SEARCH_SecretTower_1F_B_TREASURE_NORMAL_0 = 781,
	SEARCH_SecretTower_1F_B_TREASURE_NORMAL_1 = 782,
	SEARCH_SecretTower_3F_TREASURE_NORMAL_0  = 783,
	SEARCH_SecretTower_3F_TREASURE_NORMAL_1  = 784,
	SEARCH_SecretTower_3F_TREASURE_NORMAL_2  = 785,
	SEARCH_GranDragon_Entrance_GROUND_0      = 786,
	SEARCH_GranDragon_Entrance_GROUND_1      = 787,
	SEARCH_GranDragon_Entrance_GROUND_2      = 788,
	SEARCH_GranDragon_Entrance_GROUND_3      = 789,
	SEARCH_GranDragon_Entrance_GROUND_4      = 790,
	SEARCH_GranDragon_Weapon1_TREASURE_ENEMY_0 = 791,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_1 = 792,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_2 = 793,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_3 = 794,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_4 = 795,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_5 = 796,
	SEARCH_GranDragon_Weapon1_TREASURE_ENEMY_6 = 797,
	SEARCH_GranDragon_Weapon1_TREASURE_ENEMY_7 = 798,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_8 = 799,
	SEARCH_GranDragon_Weapon1_TREASURE_ENEMY_9 = 800,
	SEARCH_GranDragon_Weapon1_TREASURE_ENEMY_10 = 801,
	SEARCH_GranDragon_Weapon1_TREASURE_ENEMY_11 = 802,
	SEARCH_GranDragon_Weapon1_TREASURE_NORMAL_12 = 803,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_0 = 804,
	SEARCH_GranDragon_Weapon2_TREASURE_ENEMY_1 = 805,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_2 = 806,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_3 = 807,
	SEARCH_GranDragon_Weapon2_TREASURE_ENEMY_4 = 808,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_5 = 809,
	SEARCH_GranDragon_Weapon2_TREASURE_ENEMY_6 = 810,
	SEARCH_GranDragon_Weapon2_TREASURE_ENEMY_7 = 811,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_8 = 812,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_9 = 813,
	SEARCH_GranDragon_Weapon2_TREASURE_NORMAL_10 = 814,
	SEARCH_GranDragon_SecretPlain_01_POT_0   = 815,
	SEARCH_GranDragon_SecretPlain_02_TREASURE_NORMAL_0 = 816,
	SEARCH_GranDragon_SecretPlain_03_POT_0   = 817,
	SEARCH_GranDragon_SecretPlain_03_SACK_0  = 818,
	SEARCH_GranDragon_SecretPlain_06_SACK_0  = 819,
	SEARCH_GranDragon_SecretPlain_07_BARREL_0 = 820,
	SEARCH_GranDragon_SecretPlain_09_TREASURE_NORMAL_0 = 821,
	SEARCH_GranDragon_SecretPlain_09_TREASURE_NORMAL_1 = 822,
	SEARCH_GranDragon_SecretPlain_11_POT_0   = 823,
	SEARCH_GranDragon_SecretPlain_11_SACK_0  = 824,
	SEARCH_GranDragon_SecretPlain_13_POT_0   = 825,
	SEARCH_GranDragon_SecretPlain_14_GROUND_0 = 826,
	SEARCH_GranDragon_SecretPlain_14_POT_0   = 827,
	SEARCH_GranDragon_SecretPlain_15_POT_0   = 828,
	SEARCH_GranDragon_SecretPlain_16_SACK_0  = 829,
	SEARCH_GranDragon_SecretPlain_16_BARREL_0 = 830,
	SEARCH_GranDragon_SecretPlain_16_POT_0   = 831,
	SEARCH_GranDragon_SecretPlain_16_POT_1   = 832,
	SEARCH_GranDragon_SecretPlain_17_BARREL_0 = 833,
	SEARCH_GranDragon_SecretPlain_17_POT_0   = 834,
	SEARCH_GranDragon_SecretPlain_18_BARREL_0 = 835,
	SEARCH_GranDragon_SecretPlain_18_BARREL_1 = 836,
	SEARCH_GranDragon_SecretPlain_18_SACK_0  = 837,
	SEARCH_GranDragon_SecretPlain_91_BARREL_0 = 838,
	SEARCH_GranDragon_SecretPlain_92_POT_0   = 839,
	SEARCH_GranDragon_SecretPlain_92_GROUND_0 = 840,
	SEARCH_GranDragon_SecretPlain_92_GROUND_1 = 841,
	SEARCH_GranDragon_SecretForest_01_SACK_0 = 842,
	SEARCH_GranDragon_SecretForest_02_TREASURE_NORMAL_0 = 843,
	SEARCH_GranDragon_SecretForest_03_BARREL_0 = 844,
	SEARCH_GranDragon_SecretForest_03_POT_0  = 845,
	SEARCH_GranDragon_SecretForest_04_POT_0  = 846,
	SEARCH_GranDragon_SecretForest_04_SACK_0 = 847,
	SEARCH_GranDragon_SecretForest_05_GROUND_0 = 848,
	SEARCH_GranDragon_SecretForest_05_SACK_0 = 849,
	SEARCH_GranDragon_SecretForest_06_BARREL_0 = 850,
	SEARCH_GranDragon_SecretForest_06_BARREL_1 = 851,
	SEARCH_GranDragon_SecretForest_07_POT_0  = 852,
	SEARCH_GranDragon_SecretForest_07_POT_1  = 853,
	SEARCH_GranDragon_SecretForest_08_BARREL_0 = 854,
	SEARCH_GranDragon_SecretForest_08_SACK_0 = 855,
	SEARCH_GranDragon_SecretForest_09_POT_0  = 856,
	SEARCH_GranDragon_SecretForest_09_POT_1  = 857,
	SEARCH_GranDragon_SecretForest_10_GROUND_0 = 858,
	SEARCH_GranDragon_SecretForest_10_TREASURE_NORMAL_0 = 859,
	SEARCH_GranDragon_SecretForest_11_SACK_0 = 860,
	SEARCH_GranDragon_SecretForest_11_BARREL_0 = 861,
	SEARCH_GranDragon_SecretForest_12_BARREL_0 = 862,
	SEARCH_GranDragon_SecretForest_12_POT_0  = 863,
	SEARCH_GranDragon_SecretForest_13_TREASURE_NORMAL_0 = 864,
	SEARCH_GranDragon_SecretForest_13_TREASURE_NORMAL_1 = 865,
	SEARCH_GranDragon_SecretForest_15_GROUND_0 = 866,
	SEARCH_GranDragon_SecretForest_15_TREASURE_NORMAL_0 = 867,
	SEARCH_GranDragon_SecretForest_16_BARREL_0 = 868,
	SEARCH_GranDragon_SecretForest_16_BARREL_1 = 869,
	SEARCH_GranDragon_SecretForest_16_BARREL_2 = 870,
	SEARCH_GranDragon_SecretForest_16_BARREL_3 = 871,
	SEARCH_GranDragon_SecretForest_17_GROUND_0 = 872,
	SEARCH_GranDragon_SecretForest_17_BARREL_0 = 873,
	SEARCH_GranDragon_SecretForest_17_BARREL_1 = 874,
	SEARCH_GranDragon_SecretForest_17_BARREL_2 = 875,
	SEARCH_GranDragon_SecretForest_18_TREASURE_NORMAL_0 = 876,
	SEARCH_GranDragon_SecretForest_18_TREASURE_NORMAL_1 = 877,
	SEARCH_GranDragon_SecretForest_19_POT_0  = 878,
	SEARCH_GranDragon_SecretForest_20_BARREL_0 = 879,
	SEARCH_GranDragon_SecretForest_20_POT_0  = 880,
	SEARCH_GranDragon_SecretForest_20_GROUND_0 = 881,
	SEARCH_GranDragon_SecretForest_31_POT_0  = 882,
	SEARCH_GranDragon_SecretForest_32_GROUND_0 = 883,
	SEARCH_GranDragon_SecretForest_32_POT_0  = 884,
	SEARCH_GranDragon_SecretForest_33_GROUND_0 = 885,
	SEARCH_GranDragon_SecretForest_33_TREASURE_NORMAL_0 = 886,
	SEARCH_GranDragon_SecretForest_33_TREASURE_NORMAL_1 = 887,
	SEARCH_GranDragon_SecretForest_34_SACK_0 = 888,
	SEARCH_GranDragon_SecretForest_34_SACK_1 = 889,
	SEARCH_GranDragon_SecretForest_34_SACK_2 = 890,
	SEARCH_GranDragon_SecretForest_35_GROUND_0 = 891,
	SEARCH_GranDragon_SecretForest_35_SACK_0 = 892,
	SEARCH_GranDragon_SecretMountain_01_BARREL_0 = 893,
	SEARCH_GranDragon_SecretMountain_01_BARREL_1 = 894,
	SEARCH_GranDragon_SecretMountain_02_BARREL_0 = 895,
	SEARCH_GranDragon_SecretMountain_02_BARREL_1 = 896,
	SEARCH_GranDragon_SecretMountain_02_BARREL_2 = 897,
	SEARCH_GranDragon_SecretMountain_03_BARREL_0 = 898,
	SEARCH_GranDragon_SecretMountain_03_BARREL_1 = 899,
	SEARCH_GranDragon_SecretMountain_04_TREASURE_NORMAL_0 = 900,
	SEARCH_GranDragon_SecretMountain_05_POT_0 = 901,
	SEARCH_GranDragon_SecretMountain_05_POT_1 = 902,
	SEARCH_GranDragon_SecretMountain_05_POT_2 = 903,
	SEARCH_GranDragon_SecretMountain_05_POT_3 = 904,
	SEARCH_GranDragon_SecretMountain_05_POT_4 = 905,
	SEARCH_GranDragon_SecretMountain_06_GROUND_0 = 906,
	SEARCH_GranDragon_SecretMountain_06_BARREL_0 = 907,
	SEARCH_GranDragon_SecretMountain_07_TREASURE_NORMAL_0 = 908,
	SEARCH_GranDragon_SecretMountain_08_POT_0 = 909,
	SEARCH_GranDragon_SecretMountain_08_POT_1 = 910,
	SEARCH_GranDragon_SecretMountain_08_POT_2 = 911,
	SEARCH_GranDragon_SecretMountain_09_BARREL_0 = 912,
	SEARCH_GranDragon_SecretMountain_10_BARREL_0 = 913,
	SEARCH_GranDragon_SecretMountain_11_BARREL_0 = 914,
	SEARCH_GranDragon_SecretMountain_11_BARREL_1 = 915,
	SEARCH_GranDragon_SecretMountain_11_BARREL_2 = 916,
	SEARCH_GranDragon_SecretMountain_12_TREASURE_NORMAL_0 = 917,
	SEARCH_GranDragon_SecretMountain_12_TREASURE_NORMAL_1 = 918,
	SEARCH_GranDragon_SecretMountain_13_GROUND_0 = 919,
	SEARCH_GranDragon_SecretMountain_13_TREASURE_NORMAL_0 = 920,
	SEARCH_GranDragon_SecretMountain_14_BARREL_0 = 921,
	SEARCH_GranDragon_SecretMountain_14_BARREL_1 = 922,
	SEARCH_GranDragon_SecretMountain_14_BARREL_2 = 923,
	SEARCH_GranDragon_SecretMountain_14_BARREL_3 = 924,
	SEARCH_GranDragon_SecretMountain_14_GROUND_0 = 925,
	SEARCH_GranDragon_SecretMountain_15_BARREL_0 = 926,
	SEARCH_GranDragon_SecretMountain_15_BARREL_1 = 927,
	SEARCH_GranDragon_SecretMountain_16_TREASURE_NORMAL_0 = 928,
	SEARCH_GranDragon_SecretMountain_16_TREASURE_NORMAL_1 = 929,
	SEARCH_GranDragon_SecretMountain_16_TREASURE_NORMAL_2 = 930,
	SEARCH_GranDragon_SecretMountain_17_GROUND_0 = 931,
	SEARCH_GranDragon_SecretMountain_17_BARREL_0 = 932,
	SEARCH_GranDragon_SecretMountain_18_BARREL_0 = 933,
	SEARCH_GranDragon_SecretMountain_19_GROUND_0 = 934,
	SEARCH_GranDragon_SecretMountain_19_TREASURE_NORMAL_0 = 935,
	SEARCH_GranDragon_SecretMountain_19_TREASURE_NORMAL_1 = 936,
	SEARCH_GranDragon_SecretMountain_21_GROUND_0 = 937,
	SEARCH_GranDragon_SecretMountain_21_TREASURE_NORMAL_0 = 938,
	SEARCH_GranDragon_SecretMountain_22_TREASURE_NORMAL_0 = 939,
	SEARCH_GranDragon_SecretMountain_22_TREASURE_NORMAL_1 = 940,
	SEARCH_GranDragon_SecretMountain_22_TREASURE_NORMAL_2 = 941,
	SEARCH_GranDragon_SecretMountain_91_TREASURE_NORMAL_0 = 942,
	SEARCH_GranDragon_SecretMountain_91_TREASURE_NORMAL_1 = 943,
	SEARCH_GranDragon_SecretMountain_92_TREASURE_NORMAL_0 = 944,
	SEARCH_GranDragon_SecretMountain_92_BARREL_0 = 945,
	SEARCH_GranDragon_SecretMountain_92_BARREL_1 = 946,
	SEARCH_GranDragon_SecretDesert_01_BARREL_0 = 947,
	SEARCH_GranDragon_SecretDesert_01_BARREL_1 = 948,
	SEARCH_GranDragon_SecretDesert_01_BARREL_2 = 949,
	SEARCH_GranDragon_SecretDesert_02_POT_0  = 950,
	SEARCH_GranDragon_SecretDesert_03_POT_0  = 951,
	SEARCH_GranDragon_SecretDesert_03_POT_1  = 952,
	SEARCH_GranDragon_SecretDesert_03_POT_2  = 953,
	SEARCH_GranDragon_SecretDesert_03_POT_3  = 954,
	SEARCH_GranDragon_SecretDesert_03_POT_4  = 955,
	SEARCH_GranDragon_SecretDesert_04_BARREL_0 = 956,
	SEARCH_GranDragon_SecretDesert_05_TREASURE_NORMAL_0 = 957,
	SEARCH_GranDragon_SecretDesert_06_BARREL_0 = 958,
	SEARCH_GranDragon_SecretDesert_06_BARREL_1 = 959,
	SEARCH_GranDragon_SecretDesert_06_GROUND_0 = 960,
	SEARCH_GranDragon_SecretDesert_07_TREASURE_NORMAL_0 = 961,
	SEARCH_GranDragon_SecretDesert_07_TREASURE_NORMAL_1 = 962,
	SEARCH_GranDragon_SecretDesert_08_TREASURE_NORMAL_0 = 963,
	SEARCH_GranDragon_SecretDesert_08_GROUND_0 = 964,
	SEARCH_GranDragon_SecretSea_32_POT_0     = 965,
	SEARCH_GranDragon_SecretSea_32_POT_1     = 966,
	SEARCH_GranDragon_SecretSea_32_POT_2     = 967,
	SEARCH_GranDragon_SecretSea_32_POT_3     = 968,
	SEARCH_GranDragon_SecretSea_33_TREASURE_NORMAL_0 = 969,
	SEARCH_GranDragon_SecretSea_34_POT_0     = 970,
	SEARCH_GranDragon_SecretSea_34_GROUND_0  = 971,
	SEARCH_GranDragon_SecretSea_34_GROUND_1  = 972,
	SEARCH_GranDragon_SecretSea_35_TREASURE_NORMAL_0 = 973,
	SEARCH_GranDragon_SecretSea_35_BARREL_0  = 974,
	SEARCH_GranDragon_SecretSea_35_BARREL_1  = 975,
	SEARCH_GranDragon_SecretSea_36_POT_0     = 976,
	SEARCH_GranDragon_SecretSea_36_POT_1     = 977,
	SEARCH_GranDragon_SecretSea_37_GROUND_0  = 978,
	SEARCH_GranDragon_SecretSea_37_POT_0     = 979,
	SEARCH_GranDragon_SecretSea_39_POT_0     = 980,
	SEARCH_GranDragon_SecretSea_39_POT_1     = 981,
	SEARCH_GranDragon_SecretSea_40_BARREL_0  = 982,
	SEARCH_GranDragon_SecretSea_41_BARREL_0  = 983,
	SEARCH_GranDragon_SecretSea_41_POT_0     = 984,
	SEARCH_GranDragon_SecretSea_41_POT_1     = 985,
	SEARCH_GranDragon_SecretSea_41_POT_2     = 986,
	SEARCH_GranDragon_SecretSea_41_POT_3     = 987,
	SEARCH_GranDragon_SecretSea_42_TREASURE_NORMAL_0 = 988,
	SEARCH_GranDragon_SecretSea_43_POT_0     = 989,
	SEARCH_GranDragon_SecretSea_43_POT_1     = 990,
	SEARCH_GranDragon_SecretSea_43_GROUND_0  = 991,
	SEARCH_GranDragon_SecretSea_44_POT_0     = 992,
	SEARCH_GranDragon_SecretSea_44_POT_1     = 993,
	SEARCH_GranDragon_SecretSea_45_POT_0     = 994,
	SEARCH_GranDragon_SecretSea_45_POT_1     = 995,
	SEARCH_GranDragon_SecretSea_45_POT_2     = 996,
	SEARCH_GranDragon_SecretSea_46_GROUND_0  = 997,
	SEARCH_GranDragon_SecretSea_46_GROUND_1  = 998,
	SEARCH_GranDragon_SecretSea_46_GROUND_2  = 999,
	SEARCH_GranDragon_SecretSea_46_GROUND_3  = 1000,
	SEARCH_GranDragon_SecretSea_46_GROUND_4  = 1001,
	SEARCH_GranDragon_SecretSea_46_GROUND_5  = 1002,
	SEARCH_GranDragon_SecretSea_46_GROUND_6  = 1003,
	SEARCH_GranDragon_SecretSea_47_POT_0     = 1004,
	SEARCH_GranDragon_SecretSea_61_GROUND_0  = 1005,
	SEARCH_GranDragon_SecretSea_61_GROUND_1  = 1006,
	SEARCH_GranDragon_SecretSea_61_GROUND_2  = 1007,
	SEARCH_GranDragon_SecretSea_62_TREASURE_NORMAL_0 = 1008,
	SEARCH_GranDragon_SecretSea_62_POT_0     = 1009,
	SEARCH_GranDragon_SecretSea_62_POT_1     = 1010,
	SEARCH_GranDragon_SecretSea_63_POT_0     = 1011,
	SEARCH_GranDragon_SecretSea_63_POT_1     = 1012,
	SEARCH_GranDragon_SecretSea_64_TREASURE_NORMAL_1 = 1013,
	SEARCH_GranDragon_SecretSea_91_TREASURE_NORMAL_1 = 1014,
	SEARCH_GranDragon_SecretSea_92_POT_0     = 1015,
	SEARCH_GranDragon_SecretSea_92_POT_1     = 1016,
	SEARCH_GranDragon_SecretSea_92_POT_2     = 1017,
	SEARCH_GranDragon_SecretSnow_01_BARREL_0 = 1018,
	SEARCH_GranDragon_SecretSnow_02_GROUND_0 = 1019,
	SEARCH_GranDragon_SecretSnow_03_TREASURE_NORMAL_0 = 1020,
	SEARCH_GranDragon_SecretSnow_04_TREASURE_NORMAL_0 = 1021,
	SEARCH_GranDragon_SecretSnow_31_BARREL_0 = 1022,
	SEARCH_GranDragon_SecretSnow_31_BARREL_1 = 1023,
	SEARCH_GranDragon_SecretSnow_31_POT_0    = 1024,
	SEARCH_GranDragon_SecretSnow_32_BARREL_0 = 1025,
	SEARCH_Shine_Field_Ground_000            = 1026,
	SEARCH_Shine_Field_Ground_001            = 1027,
	SEARCH_Shine_Field_Ground_002            = 1028,
	SEARCH_Shine_Field_Ground_003            = 1029,
	SEARCH_Shine_Field_Ground_004            = 1030,
	SEARCH_Shine_Field_Ground_005            = 1031,
	SEARCH_Shine_Field_Ground_006            = 1032,
	SEARCH_Shine_Field_Ground_007            = 1033,
	SEARCH_Shine_Field_Ground_008            = 1034,
	SEARCH_Shine_Field_Ground_009            = 1035,
	SEARCH_Shine_Field_Ground_010            = 1036,
	SEARCH_Shine_Field_Ground_011            = 1037,
	SEARCH_Shine_Field_Ground_012            = 1038,
	SEARCH_Shine_Field_Ground_013            = 1039,
	SEARCH_Shine_Field_Ground_014            = 1040,
	SEARCH_Shine_Field_Ground_015            = 1041,
	SEARCH_Shine_Field_Ground_016            = 1042,
	SEARCH_Shine_Field_Ground_017            = 1043,
	SEARCH_Shine_Field_Ground_018            = 1044,
	SEARCH_Shine_Field_Ground_019            = 1045,
	SEARCH_Shine_Field_Ground_020            = 1046,
	SEARCH_Shine_Field_Ground_021            = 1047,
	SEARCH_Shine_Field_Ground_022            = 1048,
	SEARCH_Shine_Field_Ground_023            = 1049,
	SEARCH_Shine_Field_Ground_024            = 1050,
	SEARCH_Shine_Field_Ground_025            = 1051,
	SEARCH_Shine_Field_Ground_026            = 1052,
	SEARCH_Shine_Field_Ground_027            = 1053,
	SEARCH_Shine_Field_Ground_028            = 1054,
	SEARCH_Shine_Field_Ground_029            = 1055,
	SEARCH_Shine_Field_Ground_030            = 1056,
	SEARCH_Shine_Field_Ground_031            = 1057,
	SEARCH_Shine_Field_Ground_032            = 1058,
	SEARCH_Shine_Field_Ground_033            = 1059,
	SEARCH_Shine_Field_Ground_034            = 1060,
	SEARCH_Shine_Field_Ground_035            = 1061,
	SEARCH_Shine_Field_Ground_036            = 1062,
	SEARCH_Shine_Field_Ground_037            = 1063,
	SEARCH_Shine_Field_Ground_038            = 1064,
	SEARCH_Shine_Field_Ground_039            = 1065,
	SEARCH_Shine_Field_Ground_040            = 1066,
	SEARCH_Shine_Field_Ground_041            = 1067,
	SEARCH_Shine_Field_Ground_042            = 1068,
	SEARCH_Shine_Field_Ground_043            = 1069,
	SEARCH_Shine_Field_Ground_044            = 1070,
	SEARCH_Shine_Field_Ground_045            = 1071,
	SEARCH_Shine_Field_Ground_046            = 1072,
	SEARCH_Shine_Field_Ground_047            = 1073,
	SEARCH_Shine_Field_Ground_048            = 1074,
	SEARCH_Shine_Field_Ground_049            = 1075,
	SEARCH_Shine_Field_Ground_050            = 1076,
	SEARCH_Shine_Field_Ground_051            = 1077,
	SEARCH_Shine_Field_Ground_052            = 1078,
	SEARCH_Shine_Field_Ground_053            = 1079,
	SEARCH_Shine_Field_Ground_054            = 1080,
	SEARCH_Shine_Field_Ground_055            = 1081,
	SEARCH_Shine_Field_Ground_056            = 1082,
	SEARCH_Shine_Field_Ground_057            = 1083,
	SEARCH_Shine_Field_Ground_058            = 1084,
	SEARCH_Shine_Field_Ground_059            = 1085,
	SEARCH_Shine_Field_Ground_060            = 1086,
	SEARCH_Shine_Field_Ground_061            = 1087,
	SEARCH_Shine_Field_Ground_062            = 1088,
	SEARCH_Shine_Field_Ground_063            = 1089,
	SEARCH_Shine_Field_Ground_064            = 1090,
	SEARCH_Shine_Field_Ground_065            = 1091,
	SEARCH_Shine_Field_Ground_066            = 1092,
	SEARCH_Shine_Field_Ground_067            = 1093,
	SEARCH_Shine_Field_Ground_068            = 1094,
	SEARCH_Shine_Field_Ground_069            = 1095,
	SEARCH_Shine_Field_Ground_070            = 1096,
	SEARCH_Shine_Field_Ground_071            = 1097,
	SEARCH_Shine_Field_Ground_072            = 1098,
	SEARCH_Shine_Field_Ground_073            = 1099,
	SEARCH_Shine_Field_Ground_074            = 1100,
	SEARCH_Shine_Field_Ground_075            = 1101,
	SEARCH_Shine_Field_Ground_076            = 1102,
	SEARCH_Shine_Field_Ground_077            = 1103,
	SEARCH_Shine_Field_Ground_078            = 1104,
	SEARCH_Shine_Field_Ground_079            = 1105,
	SEARCH_Shine_Field_Ground_080            = 1106,
	SEARCH_Shine_Field_Ground_081            = 1107,
	SEARCH_Shine_Field_Ground_082            = 1108,
	SEARCH_Shine_Field_Ground_083            = 1109,
	SEARCH_Shine_Field_Ground_084            = 1110,
	SEARCH_Shine_Field_Ground_085            = 1111,
	SEARCH_Shine_Field_Ground_086            = 1112,
	SEARCH_Shine_Field_Ground_087            = 1113,
	SEARCH_Shine_Field_Ground_088            = 1114,
	SEARCH_Shine_Field_Ground_089            = 1115,
	SEARCH_Shine_Field_Ground_090            = 1116,
	SEARCH_Shine_Field_Ground_091            = 1117,
	SEARCH_Shine_Field_Ground_092            = 1118,
	SEARCH_Shine_Field_Ground_093            = 1119,
	SEARCH_Shine_Field_Ground_094            = 1120,
	SEARCH_Shine_Field_Ground_095            = 1121,
	SEARCH_Shine_Field_Ground_096            = 1122,
	SEARCH_Shine_Field_Ground_097            = 1123,
	SEARCH_Shine_Field_Ground_098            = 1124,
	SEARCH_Shine_Field_Ground_099            = 1125,
	SEARCH_Shine_Field_Ground_100            = 1126,
	SEARCH_Shine_Field_Ground_101            = 1127,
	SEARCH_Shine_Field_Ground_102            = 1128,
	SEARCH_Shine_Field_Ground_103            = 1129,
	SEARCH_Shine_Field_Ground_104            = 1130,
	SEARCH_Shine_Field_Ground_105            = 1131,
	SEARCH_Shine_Field_Ground_106            = 1132,
	SEARCH_Shine_Field_Ground_107            = 1133,
	SEARCH_Shine_Field_Ground_108            = 1134,
	SEARCH_Shine_Field_Ground_109            = 1135,
	SEARCH_Shine_Field_Ground_110            = 1136,
	SEARCH_Shine_Field_Ground_111            = 1137,
	SEARCH_Shine_Field_Ground_112            = 1138,
	SEARCH_Shine_Field_Ground_113            = 1139,
	SEARCH_Shine_Field_Ground_114            = 1140,
	SEARCH_Shine_Field_Ground_115            = 1141,
	SEARCH_Shine_Field_Ground_116            = 1142,
	SEARCH_Shine_Field_Ground_117            = 1143,
	SEARCH_Shine_Field_Ground_118            = 1144,
	SEARCH_Shine_Field_Ground_119            = 1145,
	SEARCH_Shine_Field_Ground_120            = 1146,
	SEARCH_Shine_Field_Ground_121            = 1147,
	SEARCH_Shine_Field_Ground_122            = 1148,
	SEARCH_Shine_Field_Ground_123            = 1149,
	SEARCH_Shine_Field_Ground_124            = 1150,
	SEARCH_Shine_Field_Ground_125            = 1151,
	SEARCH_Shine_Field_Ground_126            = 1152,
	SEARCH_Shine_Field_Ground_127            = 1153,
	SEARCH_Shine_Field_Ground_128            = 1154,
	SEARCH_Shine_Field_Ground_129            = 1155,
	SEARCH_Shine_Field_Ground_130            = 1156,
	SEARCH_Shine_Field_Ground_131            = 1157,
	SEARCH_Shine_Field_Ground_132            = 1158,
	SEARCH_Shine_Field_Ground_133            = 1159,
	SEARCH_Shine_Field_Ground_134            = 1160,
	SEARCH_Shine_Field_Ground_135            = 1161,
	SEARCH_Shine_Field_Ground_136            = 1162,
	SEARCH_Shine_Field_Ground_137            = 1163,
	SEARCH_Shine_Field_Ground_138            = 1164,
	SEARCH_Shine_Field_Ground_139            = 1165,
	SEARCH_Shine_Field_Ground_140            = 1166,
	SEARCH_Shine_Field_Ground_141            = 1167,
	SEARCH_Shine_Field_Ground_142            = 1168,
	SEARCH_Shine_Field_Ground_143            = 1169,
	SEARCH_Shine_Field_Ground_144            = 1170,
	SEARCH_Shine_Field_Ground_145            = 1171,
	SEARCH_Shine_Field_Ground_146            = 1172,
	SEARCH_Shine_Field_Ground_147            = 1173,
	SEARCH_Shine_Field_Ground_148            = 1174,
	SEARCH_Shine_Field_Ground_149            = 1175,
	SEARCH_Shine_Field_Ground_150            = 1176,
	SEARCH_Shine_Field_Ground_151            = 1177,
	SEARCH_Shine_Field_Ground_152            = 1178,
	SEARCH_Shine_Field_Ground_153            = 1179,
	SEARCH_Shine_Field_Ground_154            = 1180,
	SEARCH_Shine_Field_Ground_155            = 1181,
	SEARCH_Shine_Field_Ground_156            = 1182,
	SEARCH_Shine_Field_Ground_157            = 1183,
	SEARCH_Shine_Field_Ground_158            = 1184,
	SEARCH_Shine_Field_Ground_159            = 1185,
	SEARCH_Shine_Field_Ground_160            = 1186,
	SEARCH_Shine_Field_Ground_161            = 1187,
	SEARCH_Shine_Field_Ground_162            = 1188,
	SEARCH_Shine_Field_Ground_163            = 1189,
	SEARCH_Shine_Field_Ground_164            = 1190,
	SEARCH_Shine_Field_Ground_165            = 1191,
	SEARCH_Shine_Field_Ground_166            = 1192,
	SEARCH_Shine_Field_Ground_167            = 1193,
	SEARCH_Shine_Field_Ground_168            = 1194,
	SEARCH_Shine_Field_Ground_169            = 1195,
	SEARCH_Shine_Field_Ground_170            = 1196,
	SEARCH_Shine_Field_Ground_171            = 1197,
	SEARCH_Shine_Field_Ground_172            = 1198,
	SEARCH_Shine_Field_Ground_173            = 1199,
	SEARCH_Shine_Field_Ground_174            = 1200,
	SEARCH_Shine_Field_Ground_175            = 1201,
	SEARCH_Shine_Field_Ground_176            = 1202,
	SEARCH_Shine_Field_Ground_177            = 1203,
	SEARCH_Shine_Field_Ground_178            = 1204,
	SEARCH_Shine_Field_Ground_179            = 1205,
	SEARCH_Shine_Field_Ground_180            = 1206,
	SEARCH_Shine_Field_Ground_181            = 1207,
	SEARCH_Shine_Field_Ground_182            = 1208,
	SEARCH_Shine_Field_Ground_183            = 1209,
	SEARCH_Shine_Field_Ground_184            = 1210,
	SEARCH_Shine_Field_Ground_185            = 1211,
	SEARCH_Shine_Field_Ground_186            = 1212,
	SEARCH_Shine_Field_Ground_187            = 1213,
	SEARCH_Shine_Field_Ground_188            = 1214,
	SEARCH_Shine_Field_Ground_189            = 1215,
	SEARCH_Shine_Field_Ground_190            = 1216,
	SEARCH_Shine_Field_Ground_191            = 1217,
	SEARCH_Shine_Field_Ground_192            = 1218,
	SEARCH_Shine_Field_Ground_193            = 1219,
	SEARCH_Shine_Field_Ground_194            = 1220,
	SEARCH_Shine_Field_Ground_195            = 1221,
	SEARCH_Shine_Field_Ground_196            = 1222,
	SEARCH_Shine_Field_Ground_197            = 1223,
	SEARCH_Shine_Field_Ground_198            = 1224,
	SEARCH_Shine_Field_Ground_199            = 1225,
	SEARCH_Shine_Field_Ground_200            = 1226,
	SEARCH_Shine_Field_Ground_201            = 1227,
	SEARCH_Shine_Field_Ground_202            = 1228,
	SEARCH_Shine_Field_Ground_203            = 1229,
	SEARCH_Shine_Field_Ground_204            = 1230,
	SEARCH_Shine_Field_Ground_205            = 1231,
	SEARCH_Shine_Field_Ground_206            = 1232,
	SEARCH_Shine_Field_Ground_207            = 1233,
	SEARCH_Shine_Field_Ground_208            = 1234,
	SEARCH_Shine_Field_Ground_209            = 1235,
	SEARCH_Shine_Field_Ground_210            = 1236,
	SEARCH_Shine_Field_Ground_211            = 1237,
	SEARCH_Shine_Field_Ground_212            = 1238,
	SEARCH_Shine_Field_Ground_213            = 1239,
	SEARCH_Shine_Field_Ground_214            = 1240,
	SEARCH_Shine_Field_Ground_215            = 1241,
	SEARCH_Shine_Field_Ground_216            = 1242,
	SEARCH_Shine_Field_Ground_217            = 1243,
	SEARCH_Shine_Field_Ground_218            = 1244,
	SEARCH_Shine_Field_Ground_219            = 1245,
	SEARCH_Shine_Field_Ground_220            = 1246,
	SEARCH_Shine_Field_Ground_221            = 1247,
	SEARCH_Shine_Field_Ground_222            = 1248,
	SEARCH_Shine_Field_Ground_223            = 1249,
	SEARCH_Shine_Field_Ground_224            = 1250,
	SEARCH_Shine_Field_Ground_225            = 1251,
	SEARCH_Shine_Field_Ground_226            = 1252,
	SEARCH_Shine_Field_Ground_227            = 1253,
	SEARCH_Shine_Field_Ground_228            = 1254,
	SEARCH_Shine_Field_Ground_229            = 1255,
	SEARCH_Shine_Field_Ground_230            = 1256,
	SEARCH_Shine_Field_Ground_231            = 1257,
	SEARCH_Shine_Field_Ground_232            = 1258,
	SEARCH_Shine_Field_Ground_233            = 1259,
	SEARCH_Shine_Field_Ground_234            = 1260,
	SEARCH_Shine_Field_Ground_235            = 1261,
	SEARCH_Shine_Field_Ground_236            = 1262,
	SEARCH_Shine_Field_Ground_237            = 1263,
	SEARCH_Shine_Field_Ground_238            = 1264,
	SEARCH_Shine_Field_Ground_239            = 1265,
	SEARCH_Shine_Field_Ground_240            = 1266,
	SEARCH_Shine_Field_Ground_241            = 1267,
	SEARCH_Shine_Field_Ground_242            = 1268,
	SEARCH_Shine_Field_Ground_243            = 1269,
	SEARCH_Shine_Field_Ground_244            = 1270,
	SEARCH_Shine_Field_Ground_245            = 1271,
	SEARCH_Shine_Field_Ground_246            = 1272,
	SEARCH_Shine_Field_Ground_247            = 1273,
	SEARCH_Shine_Field_Ground_248            = 1274,
	SEARCH_Shine_Field_Ground_249            = 1275,
	SEARCH_Shine_Field_Ground_250            = 1276,
	SEARCH_Shine_Field_Ground_251            = 1277,
	SEARCH_Shine_Field_Ground_252            = 1278,
	SEARCH_Shine_Field_Ground_253            = 1279,
	SEARCH_Shine_Field_Ground_254            = 1280,
	SEARCH_Shine_Field_Ground_255            = 1281,
	SEARCH_Shine_Field_Ground_256            = 1282,
	SEARCH_Shine_Field_Ground_257            = 1283,
	SEARCH_Shine_Field_Ground_258            = 1284,
	SEARCH_Shine_Field_Ground_259            = 1285,
	SEARCH_Shine_Field_Ground_260            = 1286,
	SEARCH_Shine_Field_Ground_261            = 1287,
	SEARCH_Shine_Field_Ground_262            = 1288,
	SEARCH_Shine_Field_Ground_263            = 1289,
	SEARCH_Shine_Field_Ground_264            = 1290,
	SEARCH_Shine_Field_Ground_265            = 1291,
	SEARCH_Shine_Field_Sea_000               = 1292,
	SEARCH_Shine_Field_Sea_001               = 1293,
	SEARCH_Shine_Field_Sea_002               = 1294,
	SEARCH_Shine_Field_Sea_003               = 1295,
	SEARCH_Shine_Field_Sea_004               = 1296,
	SEARCH_Shine_Field_Sea_005               = 1297,
	SEARCH_Shine_Field_Sea_006               = 1298,
	SEARCH_Shine_Field_Sea_007               = 1299,
	SEARCH_Shine_Field_Sea_008               = 1300,
	SEARCH_Shine_Field_Sea_009               = 1301,
	SEARCH_Shine_Field_Sea_010               = 1302,
	SEARCH_Shine_Field_Sea_011               = 1303,
	SEARCH_Shine_Field_Sea_012               = 1304,
	SEARCH_Shine_Field_Sea_013               = 1305,
	SEARCH_Shine_Field_Sea_014               = 1306,
	SEARCH_Shine_Field_Sea_015               = 1307,
	SEARCH_Shine_Field_Sea_016               = 1308,
	SEARCH_Shine_Field_Sea_017               = 1309,
	SEARCH_Shine_Field_Sea_018               = 1310,
	SEARCH_Shine_Field_Sea_019               = 1311,
	SEARCH_Shine_Field_Sea_020               = 1312,
	SEARCH_Shine_Field_Sea_021               = 1313,
	SEARCH_Shine_Field_Sea_022               = 1314,
	SEARCH_Shine_Field_Sea_023               = 1315,
	SEARCH_Shine_Field_Sea_024               = 1316,
	SEARCH_Shine_Field_Sea_025               = 1317,
	SEARCH_Shine_Field_Sea_026               = 1318,
	SEARCH_Shine_Field_Sea_027               = 1319,
	SEARCH_Shine_Field_Sea_028               = 1320,
	SEARCH_Shine_Field_Sea_029               = 1321,
	SEARCH_Shine_Field_Sea_030               = 1322,
	SEARCH_Shine_Field_Sea_031               = 1323,
	SEARCH_Shine_Field_Sea_032               = 1324,
	SEARCH_Shine_Field_Sea_033               = 1325,
	SEARCH_Shine_Field_Sea_034               = 1326,
	SEARCH_Shine_Field_Sea_035               = 1327,
	SEARCH_Shine_Field_Sea_036               = 1328,
	SEARCH_Shine_Field_Sea_037               = 1329,
	SEARCH_Shine_Field_Sea_038               = 1330,
	SEARCH_Shine_Field_Sea_039               = 1331,
	SEARCH_Shine_Field_Sea_040               = 1332,
	SEARCH_Shine_Field_Sea_041               = 1333,
	SEARCH_Shine_Field_Sea_042               = 1334,
	SEARCH_Shine_Field_Sea_043               = 1335,
	SEARCH_Shine_Field_Sea_044               = 1336,
	SEARCH_Shine_Field_Sea_045               = 1337,
	SEARCH_Shine_Field_Sea_046               = 1338,
	SEARCH_Shine_Field_Sea_047               = 1339,
	SEARCH_Shine_Field_Sea_048               = 1340,
	SEARCH_Shine_Field_Sea_049               = 1341,
	SEARCH_Shine_Field_Sea_050               = 1342,
	SEARCH_Shine_Field_Sea_051               = 1343,
	SEARCH_Shine_Field_Sea_052               = 1344,
	SEARCH_Shine_Field_Sea_053               = 1345,
	SEARCH_Shine_Field_Sea_054               = 1346,
	SEARCH_Shine_Field_Sea_055               = 1347,
	SEARCH_Shine_Field_Sea_056               = 1348,
	SEARCH_Shine_Field_Sea_057               = 1349,
	SEARCH_Shine_Field_Sea_058               = 1350,
	SEARCH_Shine_Field_Sea_059               = 1351,
	SEARCH_Shine_Field_Sea_060               = 1352,
	SEARCH_Shine_Field_Sea_061               = 1353,
	SEARCH_Shine_Field_Sea_062               = 1354,
	SEARCH_Shine_Field_Sea_063               = 1355,
	SEARCH_Shine_Field_Sea_064               = 1356,
	SEARCH_Shine_Field_Sea_065               = 1357,
	SEARCH_Shine_Field_Sea_066               = 1358,
	SEARCH_Shine_Field_Sea_067               = 1359,
	SEARCH_Shine_Field_Sea_068               = 1360,
	SEARCH_Shine_Field_Sea_069               = 1361,
	SEARCH_Shine_Field_Sea_070               = 1362,
	SEARCH_Shine_Field_Sea_071               = 1363,
	SEARCH_Shine_Field_Sea_072               = 1364,
	SEARCH_Shine_Field_Sea_073               = 1365,
	SEARCH_Shine_Field_Sea_074               = 1366,
	SEARCH_Shine_Field_Sea_075               = 1367,
	SEARCH_Shine_Field_Sea_076               = 1368,
	SEARCH_Shine_Field_Sea_077               = 1369,
	SEARCH_Shine_Field_Sea_078               = 1370,
	NUM                                      = 1371,
	EGOPEnumSearchType_MAX                   = 1372,
};

// Enum Nicola.EGOPEnumSpecialEntranceType
// NumValues: 0x0027
enum class EGOPEnumSpecialEntranceType : uint16
{
	NONE                                     = 0,
	Aliahan_S                                = 1,
	Aliahan_E                                = 2,
	Aliahan_W                                = 3,
	Romaria_S                                = 4,
	Romaria_E                                = 5,
	Romaria_W                                = 6,
	Isis_Castle                              = 7,
	Isis_S                                   = 8,
	Isis_W                                   = 9,
	Portoga_E                                = 10,
	Portoga_N                                = 11,
	Portoga_Ship                             = 12,
	Dhama_N                                  = 13,
	Dhama_S                                  = 14,
	Jipang_S                                 = 15,
	Jipang_E                                 = 16,
	Jipang_W                                 = 17,
	Samanosa_N                               = 18,
	Samanosa_S                               = 19,
	Samanosa_E                               = 20,
	Ludatorm_N                               = 21,
	Ludatorm_W                               = 22,
	Muor_N                                   = 23,
	Muor_S                                   = 24,
	Muor_E                                   = 25,
	Muor_W                                   = 26,
	Westport_Ship                            = 27,
	Ludatorm_Ship                            = 28,
	Luzami_N                                 = 29,
	Luzami_S                                 = 30,
	Luzami_E                                 = 31,
	Luzami_W                                 = 32,
	Yard_N                                   = 33,
	Yard_S                                   = 34,
	Yard_E                                   = 35,
	Yard_W                                   = 36,
	NUM                                      = 37,
	EGOPEnumSpecialEntranceType_MAX          = 38,
};

// Enum Nicola.ESearchObjectOpenedBehaviourType
// NumValues: 0x0006
enum class ESearchObjectOpenedBehaviourType : uint8
{
	None                                     = 0,
	Hidden                                   = 1,
	OpenedAnimation                          = 2,
	ExecuteBlueprint                         = 4,
	Destroy                                  = 8,
	ESearchObjectOpenedBehaviourType_MAX     = 9,
};

// Enum Nicola.ESearchOpenedCheckType
// NumValues: 0x0004
enum class ESearchOpenedCheckType : uint8
{
	None                                     = 0,
	EventFlag                                = 1,
	SearchObjectFlag                         = 2,
	ESearchOpenedCheckType_MAX               = 3,
};

// Enum Nicola.EItemGetType
// NumValues: 0x0003
enum class EItemGetType : uint8
{
	MEDAL_SHOP                               = 0,
	EVENT_COMMAND                            = 1,
	EItemGetType_MAX                         = 2,
};

// Enum Nicola.ESearchObjectEnableSkillFlag
// NumValues: 0x0004
enum class ESearchObjectEnableSkillFlag : uint8
{
	AllDisabled                              = 0,
	Remirama                                 = 1,
	TreasureCount                            = 2,
	ESearchObjectEnableSkillFlag_MAX         = 3,
};

// Enum Nicola.EShipSpeedType
// NumValues: 0x0005
enum class EShipSpeedType : uint8
{
	Stop                                     = 0,
	Slow                                     = 1,
	Fast                                     = 2,
	Num                                      = 3,
	EShipSpeedType_MAX                       = 4,
};

// Enum Nicola.EStartPointType
// NumValues: 0x0008
enum class EStartPointType : uint8
{
	Default                                  = 0,
	Sky                                      = 1,
	Sea                                      = 2,
	Fall                                     = 3,
	Ladder                                   = 4,
	King                                     = 5,
	Monster                                  = 6,
	EStartPointType_MAX                      = 7,
};

// Enum Nicola.EStrikeStickDirection
// NumValues: 0x0006
enum class EStrikeStickDirection : uint8
{
	LEFT                                     = 0,
	RIGHT                                    = 1,
	UP                                       = 2,
	DOWN                                     = 3,
	NONE                                     = 4,
	EStrikeStickDirection_MAX                = 5,
};

// Enum Nicola.EAxis2Direction
// NumValues: 0x0005
enum class EAxis2Direction : uint8
{
	PlusX                                    = 0,
	MinusX                                   = 1,
	PlusY                                    = 2,
	MinusY                                   = 3,
	EAxis2Direction_MAX                      = 4,
};

// Enum Nicola.EChurchMenuMenuMode
// NumValues: 0x0004
enum class EChurchMenuMenuMode : uint8
{
	DEFAULT                                  = 0,
	GAME_START                               = 1,
	DEFEATED                                 = 2,
	EChurchMenuMenuMode_MAX                  = 3,
};

// Enum Nicola.EUIEquipmentSlotType
// NumValues: 0x0007
enum class EUIEquipmentSlotType : uint8
{
	WEAPON                                   = 0,
	SHIELD                                   = 1,
	HELMET                                   = 2,
	ARMOR                                    = 3,
	ACCESSORY_MAIN                           = 4,
	ACCESSORY_SUB                            = 5,
	MAX                                      = 6,
};

// Enum Nicola.EDEBUG_RecordCategory
// NumValues: 0x000F
enum class EDEBUG_RecordCategory : uint8
{
	TIME_HOUR                                = 0,
	TIME_MINUTE                              = 1,
	WIN_COUNT                                = 2,
	ESCAPE_COUNT                             = 3,
	DEFEAT_COUNT                             = 4,
	KILL_COUNT                               = 5,
	KILL_TYPE_COUNT                          = 6,
	GET_ITEM_TYPE                            = 7,
	GET_GOLD_ALL                             = 8,
	GET_SMALL_MEDAL                          = 9,
	MBR_RANK                                 = 10,
	MBR_WIN_COUNT                            = 11,
	MBR_SCOUT_COUNT                          = 12,
	MBR_SCOUT_TYPE_COUNT                     = 13,
	EDEBUG_MAX                               = 14,
};

// Enum Nicola.EUIFieldTacticsStatusDataViewType
// NumValues: 0x0003
enum class EUIFieldTacticsStatusDataViewType : uint8
{
	STATUS                                   = 0,
	FORMATION                                = 1,
	EUIFieldTacticsStatusDataViewType_MAX    = 2,
};

// Enum Nicola.ESystemSettingItemType
// NumValues: 0x0015
enum class ESystemSettingItemType : uint16
{
	DECIDE                                   = 0,
	BATTLE_SPEED_NORMAL                      = 110,
	BATTLE_SPEED_MBR                         = 115,
	LIGHTNESS                                = 210,
	CAMERA_DISTANCE                          = 220,
	MINI_MAP                                 = 230,
	MINI_MAP_SCALE                           = 240,
	MODE_CHANGE_PERFORMANCE                  = 250,
	BGM                                      = 310,
	AMBIENT                                  = 315,
	SE                                       = 320,
	VOICE                                    = 330,
	VOICE_FEED                               = 340,
	TARGET_GUIDE_TEXT                        = 360,
	MAP_MARKER                               = 370,
	GAME_MODE                                = 371,
	PLAYER_DASH_MODE                         = 375,
	MESSAGE_DISP_TYPE                        = 380,
	LANGUAGE_TEXT                            = 560,
	LANGUAGE_VOICE                           = 570,
	ESystemSettingItemType_MAX               = 571,
};

// Enum Nicola.EMessageTagItemType
// NumValues: 0x0002
enum class EMessageTagItemType : uint8
{
	BAG                                      = 0,
	EMessageTagItemType_MAX                  = 1,
};

// Enum Nicola.EMessageTagValueType
// NumValues: 0x0006
enum class EMessageTagValueType : uint8
{
	VALUE                                    = 0,
	VALUE2                                   = 1,
	VALUE3                                   = 2,
	MONTH                                    = 3,
	DAY                                      = 4,
	EMessageTagValueType_MAX                 = 5,
};

// Enum Nicola.EMessageTagNameType
// NumValues: 0x0002
enum class EMessageTagNameType : uint8
{
	TEXT_FEED_SE_ID                          = 0,
	TEXT_FEED_SE_MAX                         = 1,
};

// Enum Nicola.EMessageTagDataType
// NumValues: 0x000D
enum class EMessageTagDataType : uint8
{
	NONE                                     = 0,
	ACTOR                                    = 1,
	TARGET                                   = 2,
	NAME                                     = 3,
	I_NAME                                   = 4,
	I_NAME2                                  = 5,
	I_NAME3                                  = 6,
	M_NAME                                   = 7,
	WORD                                     = 8,
	WORD2                                    = 9,
	WORD3                                    = 10,
	WINDOW_NAME                              = 11,
	EMessageTagDataType_MAX                  = 12,
};

// Enum Nicola.EMessageWindowMessageDispType
// NumValues: 0x0003
enum class EMessageWindowMessageDispType : uint8
{
	DEFAULT                                  = 0,
	FAST                                     = 1,
	EMessageWindowMessageDispType_MAX        = 2,
};

// Enum Nicola.EMessageWindowPositionType
// NumValues: 0x0004
enum class EMessageWindowPositionType : uint8
{
	TOP                                      = 0,
	CENTER                                   = 1,
	BOTTOM                                   = 2,
	EMessageWindowPositionType_MAX           = 3,
};

// Enum Nicola.EMessageWindowType
// NumValues: 0x000C
enum class EMessageWindowType : uint8
{
	DEFAULT                                  = 0,
	BATTLE                                   = 1,
	PERSONALITY_TEST                         = 2,
	BATTLE2                                  = 3,
	BATTLE3                                  = 4,
	SUMMARY                                  = 5,
	SEQ_DEFAULT                              = 6,
	SEQ_NO_WINDOW                            = 7,
	SEQ_CENTER_NO_WINDOW                     = 8,
	SEQ_SUMMARY                              = 9,
	GUIDE                                    = 10,
	EMessageWindowType_MAX                   = 11,
};

// Enum Nicola.ESaveLoadUIMessage
// NumValues: 0x000C
enum class ESaveLoadUIMessage : uint8
{
	INVALID                                  = 0,
	INIT                                     = 1,
	REQUEST_SAVE                             = 2,
	REQUEST_SAVE_OVERWRITE                   = 3,
	REQUEST_LOAD                             = 4,
	REQUEST_LOAD_NEWGAME                     = 5,
	REQUEST_CREATE                           = 6,
	REQUEST_CREATE_OVERWRITE                 = 7,
	REQUEST_DELETE                           = 8,
	DISPLAY_ONLY                             = 9,
	CANCEL                                   = 10,
	ESaveLoadUIMessage_MAX                   = 11,
};

// Enum Nicola.ESaveLoadUIMode
// NumValues: 0x000B
enum class ESaveLoadUIMode : uint8
{
	INVALID                                  = 0,
	SAVE                                     = 1,
	SAVE_CONTINUE                            = 2,
	LOAD                                     = 3,
	LOAD_AUTO                                = 4,
	LOAD_CONTINUE                            = 5,
	CREATE_DATA                              = 6,
	DELETE_DATA                              = 7,
	DISPLAY_AUTO                             = 8,
	DISPLAY_SAME_DATA                        = 9,
	ESaveLoadUIMode_MAX                      = 10,
};

// Enum Nicola.ETitleMenuMessage
// NumValues: 0x0009
enum class ETitleMenuMessage : uint8
{
	INVALID                                  = 0,
	INIT                                     = 1,
	START                                    = 2,
	START_AUTO                               = 3,
	START_CONTINUE                           = 4,
	CREATE_DATA                              = 5,
	DELETE_DATA                              = 6,
	CANCEL                                   = 7,
	ETitleMenuMessage_MAX                    = 8,
};

// Enum Nicola.EUIWidgetId
// NumValues: 0x005B
enum class EUIWidgetId : uint8
{
	EMPTY                                    = 0,
	ROOT                                     = 1,
	WINDOW                                   = 2,
	CTRL                                     = 3,
	LIST                                     = 4,
	RESIDENT_TOP                             = 10,
	TEST_COMMON                              = 10,
	FIELD_MENU                               = 11,
	MESSAGE_WINDOW                           = 12,
	COMMON_MENU_CHECK                        = 13,
	MAP_MENU                                 = 14,
	MINI_MAP_MENU                            = 15,
	FIELD_EFX_MENU                           = 16,
	FIELD_RECOLLECTION_POPUP                 = 17,
	MAP2_MENU                                = 18,
	SAVE_ICON_MENU                           = 19,
	SIMPLE_LOADING_MENU                      = 20,
	EVENT_MOVIE_CONTROL                      = 21,
	MESSAGE_WINDOW_XR                        = 22,
	MENU_TOP                                 = 50,
	TEST_MENU                                = 50,
	BATTLE_ENCOUNT_MENU                      = 51,
	BATTLE_TOP_MENU                          = 52,
	BATTLE_UNIT_MENU                         = 53,
	BATTLE_PLAYER_STATUS                     = 54,
	SHOP_MENU                                = 55,
	INN_MENU                                 = 56,
	SELECT_ITEM_MENU                         = 57,
	FIELD_EQUIP_MENU                         = 58,
	FIELD_MEMORY_MENU                        = 59,
	FIELD_MAGIC_SKILL_MENU                   = 60,
	FIELD_TACTICS_MENU                       = 61,
	FIELD_HANDOVER_SELECT_MENU               = 62,
	BANK_MENU                                = 63,
	CHURCH_MENU                              = 64,
	TUTORIAL                                 = 65,
	FIELD_TACTICS_STATUS_MENU                = 66,
	BATTLE_RESULT_MENU                       = 67,
	TITLE_MENU                               = 68,
	FIELD_TACTICS_CONTINUE_SAVE_MENU         = 69,
	FIELD_TACTICS_GOTO_TITLE_MENU            = 70,
	BAR_MENU                                 = 71,
	MEDAL_TRADE_MENU                         = 72,
	MEDAL_REWARD_MENU                        = 73,
	MEMBER_CREATE_MENU                       = 74,
	KEYBOARD_NAME_JP_MENU                    = 75,
	KEYBOARD_NAME_EN_MENU                    = 76,
	KEYBOARD_NAME_PF_MENU                    = 77,
	TEST_WINDOW_MENU                         = 78,
	KEYBOARD_MONTH_JP_MENU                   = 79,
	KEYBOARD_MONTH_EN_MENU                   = 80,
	KEYBOARD_DAY_JP_MENU                     = 81,
	KEYBOARD_DAY_EN_MENU                     = 82,
	TEST_WINDOW_MENU2                        = 83,
	RENAME_MENU                              = 84,
	CHANGE_JOB_MENU                          = 85,
	CHANGE_VISUAL_MENU                       = 86,
	BAR2_MENU                                = 87,
	TITLE2_MENU                              = 88,
	MBR_INFO_MENU                            = 89,
	MBR_ZOO_MENU                             = 90,
	MBR_ENTRY_MENU                           = 91,
	FIELD_TACTICS_RECORD_MENU                = 92,
	MBR_BATTLE_MENU                          = 93,
	TOWN_NAME_MENU                           = 94,
	MBR_BATTLE_STATUS                        = 95,
	MBR_BATTLE_ENCOUNT_MENU                  = 96,
	TEST_SCROLL_MENU                         = 97,
	FIELD_TACTICS_TUTORIAL_MENU              = 98,
	XENLON                                   = 99,
	MBR_RECRUIT_MENU                         = 100,
	BATTLE_RETRY_MENU                        = 101,
	TEST_MOUSE_MENU                          = 102,
	TITLE_DEMO_MENU                          = 103,
	INITIAL_MENU                             = 104,
	KEYBOARD_NAME_REAL_JP_MENU               = 105,
	KEYBOARD_NAME_REAL_EN_MENU               = 106,
	ENDING_STAFFROLL                         = 107,
	ENDING_SAVE_MENU                         = 108,
	EVENT_SCREEN_SHOT_MENU                   = 109,
	KEYBOARD_NAME_REAL_PF_MENU               = 110,
	DEBUG_RICH_TEXT_BLOCK_MENU               = 111,
	DLC_MENU                                 = 112,
	ENDING_LOGO                              = 113,
	KEYBOARD_NAME_INPUT_MENU                 = 114,
	KEYBOARD_NAME_REAL_INPUT_MENU            = 115,
	EXTRA_TOP                                = 120,
	LV_FIELD                                 = 120,
	LV_TITLE                                 = 121,
	LV_DEFAULT                               = 122,
	EUIWidgetId_MAX                          = 123,
};

// Enum Nicola.EWidgetSoundSuperVisionState
// NumValues: 0x0005
enum class EWidgetSoundSuperVisionState : uint8
{
	NOP                                      = 0,
	NOP_DECO                                 = 1,
	FOCUS                                    = 2,
	SELECTED                                 = 3,
	EWidgetSoundSuperVisionState_MAX         = 4,
};

// ScriptStruct Nicola.BattleCameraSetting
// 0x0020 (0x0020 - 0x0000)
struct FBattleCameraSetting final
{
public:
	EBattleCameraSettingType                      CameraType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleCameraSetting) == 0x000004, "Wrong alignment on FBattleCameraSetting");
static_assert(sizeof(FBattleCameraSetting) == 0x000020, "Wrong size on FBattleCameraSetting");
static_assert(offsetof(FBattleCameraSetting, CameraType) == 0x000000, "Member 'FBattleCameraSetting::CameraType' has a wrong offset!");
static_assert(offsetof(FBattleCameraSetting, Location) == 0x000004, "Member 'FBattleCameraSetting::Location' has a wrong offset!");
static_assert(offsetof(FBattleCameraSetting, Rotation) == 0x000010, "Member 'FBattleCameraSetting::Rotation' has a wrong offset!");
static_assert(offsetof(FBattleCameraSetting, FieldOfView) == 0x00001C, "Member 'FBattleCameraSetting::FieldOfView' has a wrong offset!");

// ScriptStruct Nicola.SwitchEffectInfo
// 0x0020 (0x0020 - 0x0000)
struct FSwitchEffectInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFXSystemComponent*>             FxCompList;                                        // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwitchEffectInfo) == 0x000008, "Wrong alignment on FSwitchEffectInfo");
static_assert(sizeof(FSwitchEffectInfo) == 0x000020, "Wrong size on FSwitchEffectInfo");
static_assert(offsetof(FSwitchEffectInfo, FxCompList) == 0x000008, "Member 'FSwitchEffectInfo::FxCompList' has a wrong offset!");

// ScriptStruct Nicola.BuffDebuffStageIdSetting
// 0x0020 (0x0020 - 0x0000)
struct FBuffDebuffStageIdSetting final
{
public:
	TArray<class FName>                           PositiveEffectBattleIdTable;                       // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           NegativeEffectBattleIdTable;                       // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuffDebuffStageIdSetting) == 0x000008, "Wrong alignment on FBuffDebuffStageIdSetting");
static_assert(sizeof(FBuffDebuffStageIdSetting) == 0x000020, "Wrong size on FBuffDebuffStageIdSetting");
static_assert(offsetof(FBuffDebuffStageIdSetting, PositiveEffectBattleIdTable) == 0x000000, "Member 'FBuffDebuffStageIdSetting::PositiveEffectBattleIdTable' has a wrong offset!");
static_assert(offsetof(FBuffDebuffStageIdSetting, NegativeEffectBattleIdTable) == 0x000010, "Member 'FBuffDebuffStageIdSetting::NegativeEffectBattleIdTable' has a wrong offset!");

// ScriptStruct Nicola.BattleEffectSetting
// 0x01D0 (0x01D0 - 0x0000)
struct FBattleEffectSetting final
{
public:
	TArray<float>                                 ScreenXRatioTablePlayer1;                          // 0x0000(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ScreenXRatioTablePlayer2;                          // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ScreenXRatioTablePlayer3;                          // 0x0020(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ScreenXRatioTablePlayer4;                          // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ScreenYRatio;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenYRatioForPlayerBottom;                       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerEffectForward;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayerSize;                                        // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEffectScale;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerEffectBulletStartForward;                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerEffectBulletStartHeight;                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerEffectBulletTargetForward;                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerEffectBulletTargetHeight;                    // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerAllEffectForward;                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENicolaUnitStatusEffectFlag, class FName> StatusEffectOneShotIdTable;                        // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         StatusEffectSwitchInterval;                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENicolaUnitStatusEffectFlag, class FName> StatusEffectIdTable;                               // 0x00C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         BuffDebuffEffectSwitchInterval;                    // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBattleBuffDebuffFlag, class FName>      BuffDebuffEffectIdTable;                           // 0x0120(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EAttachEventType, struct FBuffDebuffStageIdSetting> BuffDebuffStepEffectIdTable;                       // 0x0170(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	bool                                          bMoveFormationEdgeToEdge;                          // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         endLocationMoveSec;                                // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         endLocationMoveWaitSec;                            // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleEffectSetting) == 0x000008, "Wrong alignment on FBattleEffectSetting");
static_assert(sizeof(FBattleEffectSetting) == 0x0001D0, "Wrong size on FBattleEffectSetting");
static_assert(offsetof(FBattleEffectSetting, ScreenXRatioTablePlayer1) == 0x000000, "Member 'FBattleEffectSetting::ScreenXRatioTablePlayer1' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, ScreenXRatioTablePlayer2) == 0x000010, "Member 'FBattleEffectSetting::ScreenXRatioTablePlayer2' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, ScreenXRatioTablePlayer3) == 0x000020, "Member 'FBattleEffectSetting::ScreenXRatioTablePlayer3' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, ScreenXRatioTablePlayer4) == 0x000030, "Member 'FBattleEffectSetting::ScreenXRatioTablePlayer4' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, ScreenYRatio) == 0x000040, "Member 'FBattleEffectSetting::ScreenYRatio' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, ScreenYRatioForPlayerBottom) == 0x000044, "Member 'FBattleEffectSetting::ScreenYRatioForPlayerBottom' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerEffectForward) == 0x000048, "Member 'FBattleEffectSetting::PlayerEffectForward' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerSize) == 0x00004C, "Member 'FBattleEffectSetting::PlayerSize' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, MaxEffectScale) == 0x000054, "Member 'FBattleEffectSetting::MaxEffectScale' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerEffectBulletStartForward) == 0x000058, "Member 'FBattleEffectSetting::PlayerEffectBulletStartForward' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerEffectBulletStartHeight) == 0x00005C, "Member 'FBattleEffectSetting::PlayerEffectBulletStartHeight' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerEffectBulletTargetForward) == 0x000060, "Member 'FBattleEffectSetting::PlayerEffectBulletTargetForward' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerEffectBulletTargetHeight) == 0x000064, "Member 'FBattleEffectSetting::PlayerEffectBulletTargetHeight' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, PlayerAllEffectForward) == 0x000068, "Member 'FBattleEffectSetting::PlayerAllEffectForward' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, StatusEffectOneShotIdTable) == 0x000070, "Member 'FBattleEffectSetting::StatusEffectOneShotIdTable' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, StatusEffectSwitchInterval) == 0x0000C0, "Member 'FBattleEffectSetting::StatusEffectSwitchInterval' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, StatusEffectIdTable) == 0x0000C8, "Member 'FBattleEffectSetting::StatusEffectIdTable' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, BuffDebuffEffectSwitchInterval) == 0x000118, "Member 'FBattleEffectSetting::BuffDebuffEffectSwitchInterval' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, BuffDebuffEffectIdTable) == 0x000120, "Member 'FBattleEffectSetting::BuffDebuffEffectIdTable' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, BuffDebuffStepEffectIdTable) == 0x000170, "Member 'FBattleEffectSetting::BuffDebuffStepEffectIdTable' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, bMoveFormationEdgeToEdge) == 0x0001C0, "Member 'FBattleEffectSetting::bMoveFormationEdgeToEdge' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, endLocationMoveSec) == 0x0001C4, "Member 'FBattleEffectSetting::endLocationMoveSec' has a wrong offset!");
static_assert(offsetof(FBattleEffectSetting, endLocationMoveWaitSec) == 0x0001C8, "Member 'FBattleEffectSetting::endLocationMoveWaitSec' has a wrong offset!");

// ScriptStruct Nicola.BattleEncountInfo
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FBattleEncountInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopIdEncounterMonster;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdField;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdBattleEvent;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleEncountInfo) == 0x000008, "Wrong alignment on FBattleEncountInfo");
static_assert(sizeof(FBattleEncountInfo) == 0x000068, "Wrong size on FBattleEncountInfo");
static_assert(offsetof(FBattleEncountInfo, GopIdEncounterMonster) == 0x000010, "Member 'FBattleEncountInfo::GopIdEncounterMonster' has a wrong offset!");
static_assert(offsetof(FBattleEncountInfo, GopIdField) == 0x000018, "Member 'FBattleEncountInfo::GopIdField' has a wrong offset!");
static_assert(offsetof(FBattleEncountInfo, GopIdBattleEvent) == 0x000020, "Member 'FBattleEncountInfo::GopIdBattleEvent' has a wrong offset!");

// ScriptStruct Nicola.BattleEncountMonsterInfoSet
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FBattleEncountMonsterInfoSet final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleEncountMonsterInfoSet) == 0x000008, "Wrong alignment on FBattleEncountMonsterInfoSet");
static_assert(sizeof(FBattleEncountMonsterInfoSet) == 0x000050, "Wrong size on FBattleEncountMonsterInfoSet");

// ScriptStruct Nicola.BattleEncountMonsterInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBattleEncountMonsterInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleEncountMonsterInfo) == 0x000008, "Wrong alignment on FBattleEncountMonsterInfo");
static_assert(sizeof(FBattleEncountMonsterInfo) == 0x000010, "Wrong size on FBattleEncountMonsterInfo");

// ScriptStruct Nicola.BattlePositionLineParam
// 0x0008 (0x0008 - 0x0000)
struct FBattlePositionLineParam final
{
public:
	float                                         OffsetX;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetY;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlePositionLineParam) == 0x000004, "Wrong alignment on FBattlePositionLineParam");
static_assert(sizeof(FBattlePositionLineParam) == 0x000008, "Wrong size on FBattlePositionLineParam");
static_assert(offsetof(FBattlePositionLineParam, OffsetX) == 0x000000, "Member 'FBattlePositionLineParam::OffsetX' has a wrong offset!");
static_assert(offsetof(FBattlePositionLineParam, OffsetY) == 0x000004, "Member 'FBattlePositionLineParam::OffsetY' has a wrong offset!");

// ScriptStruct Nicola.BattlePositionLineSetting
// 0x0020 (0x0020 - 0x0000)
struct FBattlePositionLineSetting final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMax;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBattlePositionLineParam>       Params;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlePositionLineSetting) == 0x000008, "Wrong alignment on FBattlePositionLineSetting");
static_assert(sizeof(FBattlePositionLineSetting) == 0x000020, "Wrong size on FBattlePositionLineSetting");
static_assert(offsetof(FBattlePositionLineSetting, Distance) == 0x000000, "Member 'FBattlePositionLineSetting::Distance' has a wrong offset!");
static_assert(offsetof(FBattlePositionLineSetting, ScaleMin) == 0x000004, "Member 'FBattlePositionLineSetting::ScaleMin' has a wrong offset!");
static_assert(offsetof(FBattlePositionLineSetting, ScaleMax) == 0x000008, "Member 'FBattlePositionLineSetting::ScaleMax' has a wrong offset!");
static_assert(offsetof(FBattlePositionLineSetting, Params) == 0x000010, "Member 'FBattlePositionLineSetting::Params' has a wrong offset!");

// ScriptStruct Nicola.BattleResultInfo
// 0x00A8 (0x00A8 - 0x0000)
struct alignas(0x08) FBattleResultInfo final
{
public:
	uint8                                         Pad_0[0xA8];                                       // 0x0000(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleResultInfo) == 0x000008, "Wrong alignment on FBattleResultInfo");
static_assert(sizeof(FBattleResultInfo) == 0x0000A8, "Wrong size on FBattleResultInfo");

// ScriptStruct Nicola.BattleResultBreederSkillInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBattleResultBreederSkillInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleResultBreederSkillInfo) == 0x000008, "Wrong alignment on FBattleResultBreederSkillInfo");
static_assert(sizeof(FBattleResultBreederSkillInfo) == 0x000018, "Wrong size on FBattleResultBreederSkillInfo");

// ScriptStruct Nicola.BattleResultLevelUpInfo
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FBattleResultLevelUpInfo final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleResultLevelUpInfo) == 0x000008, "Wrong alignment on FBattleResultLevelUpInfo");
static_assert(sizeof(FBattleResultLevelUpInfo) == 0x000070, "Wrong size on FBattleResultLevelUpInfo");

// ScriptStruct Nicola.DebugCameraParam
// 0x0038 (0x0038 - 0x0000)
struct FDebugCameraParam final
{
public:
	bool                                          bUpdate;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FovLeftPlaneShrinkRate;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovRightPlaneShrinkRate;                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovTopPlaneShrinkRate;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovBottomPlaneShrinkRate;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftOffset;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightOffset;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopOffset;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomOffset;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraFov;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugCameraParam) == 0x000004, "Wrong alignment on FDebugCameraParam");
static_assert(sizeof(FDebugCameraParam) == 0x000038, "Wrong size on FDebugCameraParam");
static_assert(offsetof(FDebugCameraParam, bUpdate) == 0x000000, "Member 'FDebugCameraParam::bUpdate' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, FovLeftPlaneShrinkRate) == 0x000004, "Member 'FDebugCameraParam::FovLeftPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, FovRightPlaneShrinkRate) == 0x000008, "Member 'FDebugCameraParam::FovRightPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, FovTopPlaneShrinkRate) == 0x00000C, "Member 'FDebugCameraParam::FovTopPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, FovBottomPlaneShrinkRate) == 0x000010, "Member 'FDebugCameraParam::FovBottomPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, LeftOffset) == 0x000014, "Member 'FDebugCameraParam::LeftOffset' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, RightOffset) == 0x000018, "Member 'FDebugCameraParam::RightOffset' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, TopOffset) == 0x00001C, "Member 'FDebugCameraParam::TopOffset' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, BottomOffset) == 0x000020, "Member 'FDebugCameraParam::BottomOffset' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, ZOffset) == 0x000024, "Member 'FDebugCameraParam::ZOffset' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, CameraRotation) == 0x000028, "Member 'FDebugCameraParam::CameraRotation' has a wrong offset!");
static_assert(offsetof(FDebugCameraParam, CameraFov) == 0x000034, "Member 'FDebugCameraParam::CameraFov' has a wrong offset!");

// ScriptStruct Nicola.BattleCharaInfoViewData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FBattleCharaInfoViewData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleCharaInfoViewData) == 0x000008, "Wrong alignment on FBattleCharaInfoViewData");
static_assert(sizeof(FBattleCharaInfoViewData) == 0x000028, "Wrong size on FBattleCharaInfoViewData");

// ScriptStruct Nicola.BgmPlayerManagerReservedInfoOnPostFadeOut
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBgmPlayerManagerReservedInfoOnPostFadeOut final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBgmPlayerManagerReservedInfoOnPostFadeOut) == 0x000004, "Wrong alignment on FBgmPlayerManagerReservedInfoOnPostFadeOut");
static_assert(sizeof(FBgmPlayerManagerReservedInfoOnPostFadeOut) == 0x000010, "Wrong size on FBgmPlayerManagerReservedInfoOnPostFadeOut");

// ScriptStruct Nicola.JumpPointInformation
// 0x0040 (0x0040 - 0x0000)
struct FJumpPointInformation final
{
public:
	class FString                                 jumpMapLevelID;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 jumpPlayerStartID;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 jumpSE;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterToTravel;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrientationType                              Orientation;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSave;                                         // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RiremitoPointID;                                   // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotPlayBGM;                                        // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeShip;                                       // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhiteFade;                                        // 0x003E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJumpPointInformation) == 0x000008, "Wrong alignment on FJumpPointInformation");
static_assert(sizeof(FJumpPointInformation) == 0x000040, "Wrong size on FJumpPointInformation");
static_assert(offsetof(FJumpPointInformation, jumpMapLevelID) == 0x000000, "Member 'FJumpPointInformation::jumpMapLevelID' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, jumpPlayerStartID) == 0x000010, "Member 'FJumpPointInformation::jumpPlayerStartID' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, jumpSE) == 0x000020, "Member 'FJumpPointInformation::jumpSE' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, bEnterToTravel) == 0x000030, "Member 'FJumpPointInformation::bEnterToTravel' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, Orientation) == 0x000031, "Member 'FJumpPointInformation::Orientation' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, bAutoSave) == 0x000032, "Member 'FJumpPointInformation::bAutoSave' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, RiremitoPointID) == 0x000034, "Member 'FJumpPointInformation::RiremitoPointID' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, NotPlayBGM) == 0x00003C, "Member 'FJumpPointInformation::NotPlayBGM' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, bChangeShip) == 0x00003D, "Member 'FJumpPointInformation::bChangeShip' has a wrong offset!");
static_assert(offsetof(FJumpPointInformation, bWhiteFade) == 0x00003E, "Member 'FJumpPointInformation::bWhiteFade' has a wrong offset!");

// ScriptStruct Nicola.FlagConditionData
// 0x0004 (0x0004 - 0x0000)
struct FFlagConditionData final
{
public:
	ELuaFlag                                      FlagData;                                          // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrueCondition;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFlag;                                       // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlagConditionData) == 0x000002, "Wrong alignment on FFlagConditionData");
static_assert(sizeof(FFlagConditionData) == 0x000004, "Wrong size on FFlagConditionData");
static_assert(offsetof(FFlagConditionData, FlagData) == 0x000000, "Member 'FFlagConditionData::FlagData' has a wrong offset!");
static_assert(offsetof(FFlagConditionData, bIsTrueCondition) == 0x000002, "Member 'FFlagConditionData::bIsTrueCondition' has a wrong offset!");
static_assert(offsetof(FFlagConditionData, bEnableFlag) == 0x000003, "Member 'FFlagConditionData::bEnableFlag' has a wrong offset!");

// ScriptStruct Nicola.JumpPointOverrideInformation
// 0x0030 (0x0030 - 0x0000)
struct FJumpPointOverrideInformation final
{
public:
	class FName                                   overrideTargetKey;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 overrideJumpMapLevelID;                            // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 overrideJumpPlayerStartID;                         // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlagConditionData                     FlagConditionData;                                 // 0x0028(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJumpPointOverrideInformation) == 0x000008, "Wrong alignment on FJumpPointOverrideInformation");
static_assert(sizeof(FJumpPointOverrideInformation) == 0x000030, "Wrong size on FJumpPointOverrideInformation");
static_assert(offsetof(FJumpPointOverrideInformation, overrideTargetKey) == 0x000000, "Member 'FJumpPointOverrideInformation::overrideTargetKey' has a wrong offset!");
static_assert(offsetof(FJumpPointOverrideInformation, overrideJumpMapLevelID) == 0x000008, "Member 'FJumpPointOverrideInformation::overrideJumpMapLevelID' has a wrong offset!");
static_assert(offsetof(FJumpPointOverrideInformation, overrideJumpPlayerStartID) == 0x000018, "Member 'FJumpPointOverrideInformation::overrideJumpPlayerStartID' has a wrong offset!");
static_assert(offsetof(FJumpPointOverrideInformation, FlagConditionData) == 0x000028, "Member 'FJumpPointOverrideInformation::FlagConditionData' has a wrong offset!");

// ScriptStruct Nicola.CheckBreederResultInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCheckBreederResultInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCheckBreederResultInfo) == 0x000008, "Wrong alignment on FCheckBreederResultInfo");
static_assert(sizeof(FCheckBreederResultInfo) == 0x000010, "Wrong size on FCheckBreederResultInfo");

// ScriptStruct Nicola.ReturnPointInformation
// 0x0048 (0x0048 - 0x0000)
struct FReturnPointInformation final
{
public:
	class FString                                 returnFunction;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 returnInfoAtGlobalSysVar;                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fadeOutTime;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fadeInTime;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 jumpSE;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReturnPointInformation) == 0x000008, "Wrong alignment on FReturnPointInformation");
static_assert(sizeof(FReturnPointInformation) == 0x000048, "Wrong size on FReturnPointInformation");
static_assert(offsetof(FReturnPointInformation, returnFunction) == 0x000000, "Member 'FReturnPointInformation::returnFunction' has a wrong offset!");
static_assert(offsetof(FReturnPointInformation, returnInfoAtGlobalSysVar) == 0x000010, "Member 'FReturnPointInformation::returnInfoAtGlobalSysVar' has a wrong offset!");
static_assert(offsetof(FReturnPointInformation, fadeOutTime) == 0x000020, "Member 'FReturnPointInformation::fadeOutTime' has a wrong offset!");
static_assert(offsetof(FReturnPointInformation, fadeInTime) == 0x000024, "Member 'FReturnPointInformation::fadeInTime' has a wrong offset!");
static_assert(offsetof(FReturnPointInformation, jumpSE) == 0x000028, "Member 'FReturnPointInformation::jumpSE' has a wrong offset!");

// ScriptStruct Nicola.JumpPointShortcatExtension
// 0x000C (0x000C - 0x0000)
struct FJumpPointShortcatExtension final
{
public:
	class FName                                   textID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          progress;                                          // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJumpPointShortcatExtension) == 0x000004, "Wrong alignment on FJumpPointShortcatExtension");
static_assert(sizeof(FJumpPointShortcatExtension) == 0x00000C, "Wrong size on FJumpPointShortcatExtension");
static_assert(offsetof(FJumpPointShortcatExtension, textID) == 0x000000, "Member 'FJumpPointShortcatExtension::textID' has a wrong offset!");
static_assert(offsetof(FJumpPointShortcatExtension, progress) == 0x000008, "Member 'FJumpPointShortcatExtension::progress' has a wrong offset!");

// ScriptStruct Nicola.ButtonIconLongPress
// 0x0018 (0x0018 - 0x0000)
struct FButtonIconLongPress final
{
public:
	class UCommonItemWidget*                      ViewItem;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemGauge;                                         // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FButtonIconLongPress) == 0x000008, "Wrong alignment on FButtonIconLongPress");
static_assert(sizeof(FButtonIconLongPress) == 0x000018, "Wrong size on FButtonIconLongPress");
static_assert(offsetof(FButtonIconLongPress, ViewItem) == 0x000000, "Member 'FButtonIconLongPress::ViewItem' has a wrong offset!");
static_assert(offsetof(FButtonIconLongPress, ItemGauge) == 0x000008, "Member 'FButtonIconLongPress::ItemGauge' has a wrong offset!");
static_assert(offsetof(FButtonIconLongPress, ItemIcon) == 0x000010, "Member 'FButtonIconLongPress::ItemIcon' has a wrong offset!");

// ScriptStruct Nicola.CameraKeepOutInfo
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FCameraKeepOutInfo final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraKeepOutInfo) == 0x000010, "Wrong alignment on FCameraKeepOutInfo");
static_assert(sizeof(FCameraKeepOutInfo) == 0x000090, "Wrong size on FCameraKeepOutInfo");

// ScriptStruct Nicola.PageListCursor
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FPageListCursor final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPageListCursor) == 0x000004, "Wrong alignment on FPageListCursor");
static_assert(sizeof(FPageListCursor) == 0x00001C, "Wrong size on FPageListCursor");

// ScriptStruct Nicola.CameraCollisionInfo
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x10) FCameraCollisionInfo final
{
public:
	uint8                                         Pad_0[0xC0];                                       // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraCollisionInfo) == 0x000010, "Wrong alignment on FCameraCollisionInfo");
static_assert(sizeof(FCameraCollisionInfo) == 0x0000C0, "Wrong size on FCameraCollisionInfo");

// ScriptStruct Nicola.CameraShakeAssetTable
// 0x0028 (0x0030 - 0x0008)
struct FCameraShakeAssetTable final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   CameraShake;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraShakeAssetTable) == 0x000008, "Wrong alignment on FCameraShakeAssetTable");
static_assert(sizeof(FCameraShakeAssetTable) == 0x000030, "Wrong size on FCameraShakeAssetTable");
static_assert(offsetof(FCameraShakeAssetTable, CameraShake) == 0x000008, "Member 'FCameraShakeAssetTable::CameraShake' has a wrong offset!");

// ScriptStruct Nicola.CharacterMaterial
// 0x0088 (0x0088 - 0x0000)
struct FCharacterMaterial final
{
public:
	class UMeshComponent*                         Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       caches;                                            // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x70];                                      // 0x0018(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMaterial) == 0x000008, "Wrong alignment on FCharacterMaterial");
static_assert(sizeof(FCharacterMaterial) == 0x000088, "Wrong size on FCharacterMaterial");
static_assert(offsetof(FCharacterMaterial, Owner) == 0x000000, "Member 'FCharacterMaterial::Owner' has a wrong offset!");
static_assert(offsetof(FCharacterMaterial, caches) == 0x000008, "Member 'FCharacterMaterial::caches' has a wrong offset!");

// ScriptStruct Nicola.ComonBaseAnimInfo
// 0x0010 (0x0010 - 0x0000)
struct FComonBaseAnimInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       Animation;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComonBaseAnimInfo) == 0x000008, "Wrong alignment on FComonBaseAnimInfo");
static_assert(sizeof(FComonBaseAnimInfo) == 0x000010, "Wrong size on FComonBaseAnimInfo");
static_assert(offsetof(FComonBaseAnimInfo, Animation) == 0x000008, "Member 'FComonBaseAnimInfo::Animation' has a wrong offset!");

// ScriptStruct Nicola.SequenceEventTriggerFunctionData
// 0x0050 (0x0050 - 0x0000)
struct FSequenceEventTriggerFunctionData final
{
public:
	struct FMovieSceneEventPtrs                   FuncPtr;                                           // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                BindObject;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSequenceEventTriggerFunctionData) == 0x000008, "Wrong alignment on FSequenceEventTriggerFunctionData");
static_assert(sizeof(FSequenceEventTriggerFunctionData) == 0x000050, "Wrong size on FSequenceEventTriggerFunctionData");
static_assert(offsetof(FSequenceEventTriggerFunctionData, FuncPtr) == 0x000000, "Member 'FSequenceEventTriggerFunctionData::FuncPtr' has a wrong offset!");
static_assert(offsetof(FSequenceEventTriggerFunctionData, BindObject) == 0x000040, "Member 'FSequenceEventTriggerFunctionData::BindObject' has a wrong offset!");

// ScriptStruct Nicola.CrossHListCursor
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FCrossHListCursor final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrossHListCursor) == 0x000004, "Wrong alignment on FCrossHListCursor");
static_assert(sizeof(FCrossHListCursor) == 0x000030, "Wrong size on FCrossHListCursor");

// ScriptStruct Nicola.CrossVListCursor
// 0x0034 (0x0034 - 0x0000)
struct alignas(0x04) FCrossVListCursor final
{
public:
	uint8                                         Pad_0[0x34];                                       // 0x0000(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrossVListCursor) == 0x000004, "Wrong alignment on FCrossVListCursor");
static_assert(sizeof(FCrossVListCursor) == 0x000034, "Wrong size on FCrossVListCursor");

// ScriptStruct Nicola.DebugMenuCustomItem
// 0x0018 (0x0018 - 0x0000)
struct FDebugMenuCustomItem final
{
public:
	EDebugMenuCustomItemType                      Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugMenuCustomItem) == 0x000008, "Wrong alignment on FDebugMenuCustomItem");
static_assert(sizeof(FDebugMenuCustomItem) == 0x000018, "Wrong size on FDebugMenuCustomItem");
static_assert(offsetof(FDebugMenuCustomItem, Type) == 0x000000, "Member 'FDebugMenuCustomItem::Type' has a wrong offset!");
static_assert(offsetof(FDebugMenuCustomItem, Name) == 0x000008, "Member 'FDebugMenuCustomItem::Name' has a wrong offset!");

// ScriptStruct Nicola.UnitResidentCreateOption
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FUnitResidentCreateOption final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnitResidentCreateOption) == 0x000004, "Wrong alignment on FUnitResidentCreateOption");
static_assert(sizeof(FUnitResidentCreateOption) == 0x000028, "Wrong size on FUnitResidentCreateOption");

// ScriptStruct Nicola.EventCutSceneBindData
// 0x0038 (0x0038 - 0x0000)
struct FEventCutSceneBindData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BindTargetActor;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     BindingIds;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventCutSceneBindData) == 0x000008, "Wrong alignment on FEventCutSceneBindData");
static_assert(sizeof(FEventCutSceneBindData) == 0x000038, "Wrong size on FEventCutSceneBindData");
static_assert(offsetof(FEventCutSceneBindData, BindTargetActor) == 0x000010, "Member 'FEventCutSceneBindData::BindTargetActor' has a wrong offset!");
static_assert(offsetof(FEventCutSceneBindData, BindingIds) == 0x000020, "Member 'FEventCutSceneBindData::BindingIds' has a wrong offset!");

// ScriptStruct Nicola.UnitInstanceCreateOption
// 0x0008 (0x0008 - 0x0000)
struct FUnitInstanceCreateOption final
{
public:
	class FName                                   GopIdUnitMaster;                                   // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitInstanceCreateOption) == 0x000004, "Wrong alignment on FUnitInstanceCreateOption");
static_assert(sizeof(FUnitInstanceCreateOption) == 0x000008, "Wrong size on FUnitInstanceCreateOption");
static_assert(offsetof(FUnitInstanceCreateOption, GopIdUnitMaster) == 0x000000, "Member 'FUnitInstanceCreateOption::GopIdUnitMaster' has a wrong offset!");

// ScriptStruct Nicola.FlipbookMimicData
// 0x000C (0x000C - 0x0000)
struct FFlipbookMimicData final
{
public:
	class FName                                   TargetGopIdUnitLooks;                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENicolaFlipbookOverrideType                   NicolaFlipbookOverrideType;                        // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlipbookMimicData) == 0x000004, "Wrong alignment on FFlipbookMimicData");
static_assert(sizeof(FFlipbookMimicData) == 0x00000C, "Wrong size on FFlipbookMimicData");
static_assert(offsetof(FFlipbookMimicData, TargetGopIdUnitLooks) == 0x000000, "Member 'FFlipbookMimicData::TargetGopIdUnitLooks' has a wrong offset!");
static_assert(offsetof(FFlipbookMimicData, NicolaFlipbookOverrideType) == 0x000008, "Member 'FFlipbookMimicData::NicolaFlipbookOverrideType' has a wrong offset!");

// ScriptStruct Nicola.UnitLooksActorCreateOption
// 0x0090 (0x0090 - 0x0000)
struct FUnitLooksActorCreateOption final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENicolaFlipbookOverrideType                   FlipbookOverrideType;                              // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlipbookMimicData                     FlipbookMimicData;                                 // 0x0028(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EActorType>                            ActorTypes;                                        // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   MapId;                                             // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         hairType;                                          // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionType                                   defaultActionType;                                 // 0x0064(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwayAnimationType                            defaultSwayType;                                   // 0x0065(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isInvisible;                                       // 0x0066(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         badStatusFlag;                                     // 0x0068(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         lanternShadowOpacity;                              // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         lanternShadowYaw;                                  // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                decalLocation;                                     // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                decalSize;                                         // 0x0084(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitLooksActorCreateOption) == 0x000008, "Wrong alignment on FUnitLooksActorCreateOption");
static_assert(sizeof(FUnitLooksActorCreateOption) == 0x000090, "Wrong size on FUnitLooksActorCreateOption");
static_assert(offsetof(FUnitLooksActorCreateOption, Location) == 0x000000, "Member 'FUnitLooksActorCreateOption::Location' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, Rotation) == 0x00000C, "Member 'FUnitLooksActorCreateOption::Rotation' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, Scale) == 0x000018, "Member 'FUnitLooksActorCreateOption::Scale' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, FlipbookOverrideType) == 0x000024, "Member 'FUnitLooksActorCreateOption::FlipbookOverrideType' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, FlipbookMimicData) == 0x000028, "Member 'FUnitLooksActorCreateOption::FlipbookMimicData' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, Tags) == 0x000038, "Member 'FUnitLooksActorCreateOption::Tags' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, ActorTypes) == 0x000048, "Member 'FUnitLooksActorCreateOption::ActorTypes' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, MapId) == 0x000058, "Member 'FUnitLooksActorCreateOption::MapId' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, hairType) == 0x000060, "Member 'FUnitLooksActorCreateOption::hairType' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, defaultActionType) == 0x000064, "Member 'FUnitLooksActorCreateOption::defaultActionType' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, defaultSwayType) == 0x000065, "Member 'FUnitLooksActorCreateOption::defaultSwayType' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, isInvisible) == 0x000066, "Member 'FUnitLooksActorCreateOption::isInvisible' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, badStatusFlag) == 0x000068, "Member 'FUnitLooksActorCreateOption::badStatusFlag' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, Opacity) == 0x00006C, "Member 'FUnitLooksActorCreateOption::Opacity' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, lanternShadowOpacity) == 0x000070, "Member 'FUnitLooksActorCreateOption::lanternShadowOpacity' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, lanternShadowYaw) == 0x000074, "Member 'FUnitLooksActorCreateOption::lanternShadowYaw' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, decalLocation) == 0x000078, "Member 'FUnitLooksActorCreateOption::decalLocation' has a wrong offset!");
static_assert(offsetof(FUnitLooksActorCreateOption, decalSize) == 0x000084, "Member 'FUnitLooksActorCreateOption::decalSize' has a wrong offset!");

// ScriptStruct Nicola.UnitCommonCreateOption
// 0x0010 (0x0010 - 0x0000)
struct FUnitCommonCreateOption final
{
public:
	class FString                                 UnitName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitCommonCreateOption) == 0x000008, "Wrong alignment on FUnitCommonCreateOption");
static_assert(sizeof(FUnitCommonCreateOption) == 0x000010, "Wrong size on FUnitCommonCreateOption");
static_assert(offsetof(FUnitCommonCreateOption, UnitName) == 0x000000, "Member 'FUnitCommonCreateOption::UnitName' has a wrong offset!");

// ScriptStruct Nicola.DirectionalLightParameterTable
// 0x0098 (0x00A0 - 0x0008)
struct FDirectionalLightParameterTable : public FTableRowBase
{
public:
	class FName                                   MapId;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 UseTimeFrame;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowBias_Switch;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowBias_Low;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowBias_Mid;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowBias_High;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowBias_Epic;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Switch;                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Low;                         // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Mid;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_High;                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Epic;                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Switch;                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Low;                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Mid;                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_High;                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Epic;                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Switch;                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Low;                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Mid;                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_High;                  // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Epic;                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Switch;                  // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Low;                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Mid;                     // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_High;                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Epic;                    // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Switch;              // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Low;                 // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Mid;                 // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_High;                // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Epic;                // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Switch;                  // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Low;                     // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Mid;                     // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_High;                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Epic;                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionalLightParameterTable) == 0x000008, "Wrong alignment on FDirectionalLightParameterTable");
static_assert(sizeof(FDirectionalLightParameterTable) == 0x0000A0, "Wrong size on FDirectionalLightParameterTable");
static_assert(offsetof(FDirectionalLightParameterTable, MapId) == 0x000008, "Member 'FDirectionalLightParameterTable::MapId' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, UseTimeFrame) == 0x000010, "Member 'FDirectionalLightParameterTable::UseTimeFrame' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowBias_Switch) == 0x000014, "Member 'FDirectionalLightParameterTable::ShadowBias_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowBias_Low) == 0x000018, "Member 'FDirectionalLightParameterTable::ShadowBias_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowBias_Mid) == 0x00001C, "Member 'FDirectionalLightParameterTable::ShadowBias_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowBias_High) == 0x000020, "Member 'FDirectionalLightParameterTable::ShadowBias_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowBias_Epic) == 0x000024, "Member 'FDirectionalLightParameterTable::ShadowBias_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, DynamicShadowDistance_Switch) == 0x000028, "Member 'FDirectionalLightParameterTable::DynamicShadowDistance_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, DynamicShadowDistance_Low) == 0x00002C, "Member 'FDirectionalLightParameterTable::DynamicShadowDistance_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, DynamicShadowDistance_Mid) == 0x000030, "Member 'FDirectionalLightParameterTable::DynamicShadowDistance_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, DynamicShadowDistance_High) == 0x000034, "Member 'FDirectionalLightParameterTable::DynamicShadowDistance_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, DynamicShadowDistance_Epic) == 0x000038, "Member 'FDirectionalLightParameterTable::DynamicShadowDistance_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, NumDynamicShadowCascades_Switch) == 0x00003C, "Member 'FDirectionalLightParameterTable::NumDynamicShadowCascades_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, NumDynamicShadowCascades_Low) == 0x000040, "Member 'FDirectionalLightParameterTable::NumDynamicShadowCascades_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, NumDynamicShadowCascades_Mid) == 0x000044, "Member 'FDirectionalLightParameterTable::NumDynamicShadowCascades_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, NumDynamicShadowCascades_High) == 0x000048, "Member 'FDirectionalLightParameterTable::NumDynamicShadowCascades_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, NumDynamicShadowCascades_Epic) == 0x00004C, "Member 'FDirectionalLightParameterTable::NumDynamicShadowCascades_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeDistributionExponent_Switch) == 0x000050, "Member 'FDirectionalLightParameterTable::CascadeDistributionExponent_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeDistributionExponent_Low) == 0x000054, "Member 'FDirectionalLightParameterTable::CascadeDistributionExponent_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeDistributionExponent_Mid) == 0x000058, "Member 'FDirectionalLightParameterTable::CascadeDistributionExponent_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeDistributionExponent_High) == 0x00005C, "Member 'FDirectionalLightParameterTable::CascadeDistributionExponent_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeDistributionExponent_Epic) == 0x000060, "Member 'FDirectionalLightParameterTable::CascadeDistributionExponent_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeTransitionFraction_Switch) == 0x000064, "Member 'FDirectionalLightParameterTable::CascadeTransitionFraction_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeTransitionFraction_Low) == 0x000068, "Member 'FDirectionalLightParameterTable::CascadeTransitionFraction_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeTransitionFraction_Mid) == 0x00006C, "Member 'FDirectionalLightParameterTable::CascadeTransitionFraction_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeTransitionFraction_High) == 0x000070, "Member 'FDirectionalLightParameterTable::CascadeTransitionFraction_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, CascadeTransitionFraction_Epic) == 0x000074, "Member 'FDirectionalLightParameterTable::CascadeTransitionFraction_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowDistanceFadeoutFraction_Switch) == 0x000078, "Member 'FDirectionalLightParameterTable::ShadowDistanceFadeoutFraction_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowDistanceFadeoutFraction_Low) == 0x00007C, "Member 'FDirectionalLightParameterTable::ShadowDistanceFadeoutFraction_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowDistanceFadeoutFraction_Mid) == 0x000080, "Member 'FDirectionalLightParameterTable::ShadowDistanceFadeoutFraction_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowDistanceFadeoutFraction_High) == 0x000084, "Member 'FDirectionalLightParameterTable::ShadowDistanceFadeoutFraction_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, ShadowDistanceFadeoutFraction_Epic) == 0x000088, "Member 'FDirectionalLightParameterTable::ShadowDistanceFadeoutFraction_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, LightFunctionFadeDistance_Switch) == 0x00008C, "Member 'FDirectionalLightParameterTable::LightFunctionFadeDistance_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, LightFunctionFadeDistance_Low) == 0x000090, "Member 'FDirectionalLightParameterTable::LightFunctionFadeDistance_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, LightFunctionFadeDistance_Mid) == 0x000094, "Member 'FDirectionalLightParameterTable::LightFunctionFadeDistance_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, LightFunctionFadeDistance_High) == 0x000098, "Member 'FDirectionalLightParameterTable::LightFunctionFadeDistance_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterTable, LightFunctionFadeDistance_Epic) == 0x00009C, "Member 'FDirectionalLightParameterTable::LightFunctionFadeDistance_Epic' has a wrong offset!");

// ScriptStruct Nicola.DirectionalLightParameterTable_CutScene
// 0x0000 (0x00A0 - 0x00A0)
struct FDirectionalLightParameterTable_CutScene final : public FDirectionalLightParameterTable
{
};
static_assert(alignof(FDirectionalLightParameterTable_CutScene) == 0x000008, "Wrong alignment on FDirectionalLightParameterTable_CutScene");
static_assert(sizeof(FDirectionalLightParameterTable_CutScene) == 0x0000A0, "Wrong size on FDirectionalLightParameterTable_CutScene");

// ScriptStruct Nicola.KeyIconResult
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FKeyIconResult final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyIconResult) == 0x000008, "Wrong alignment on FKeyIconResult");
static_assert(sizeof(FKeyIconResult) == 0x000060, "Wrong size on FKeyIconResult");

// ScriptStruct Nicola.EffectAssetTable
// 0x00B0 (0x00B8 - 0x0008)
struct FEffectAssetTable final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UParticleSystem>         Particle;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          NiagaraParticle;                                   // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       Decal;                                             // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DecalActorClass;                                   // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalOffset;                                       // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Disposable;                                        // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEffectAssetTable) == 0x000008, "Wrong alignment on FEffectAssetTable");
static_assert(sizeof(FEffectAssetTable) == 0x0000B8, "Wrong size on FEffectAssetTable");
static_assert(offsetof(FEffectAssetTable, Particle) == 0x000008, "Member 'FEffectAssetTable::Particle' has a wrong offset!");
static_assert(offsetof(FEffectAssetTable, NiagaraParticle) == 0x000030, "Member 'FEffectAssetTable::NiagaraParticle' has a wrong offset!");
static_assert(offsetof(FEffectAssetTable, Decal) == 0x000058, "Member 'FEffectAssetTable::Decal' has a wrong offset!");
static_assert(offsetof(FEffectAssetTable, DecalActorClass) == 0x000080, "Member 'FEffectAssetTable::DecalActorClass' has a wrong offset!");
static_assert(offsetof(FEffectAssetTable, DecalOffset) == 0x0000A8, "Member 'FEffectAssetTable::DecalOffset' has a wrong offset!");
static_assert(offsetof(FEffectAssetTable, Disposable) == 0x0000B4, "Member 'FEffectAssetTable::Disposable' has a wrong offset!");

// ScriptStruct Nicola.FallAnimationData
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x10) FFallAnimationData final
{
public:
	uint8                                         Pad_0[0x130];                                      // 0x0000(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFallAnimationData) == 0x000010, "Wrong alignment on FFallAnimationData");
static_assert(sizeof(FFallAnimationData) == 0x000130, "Wrong size on FFallAnimationData");

// ScriptStruct Nicola.FlexibleHListCursor
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FFlexibleHListCursor final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlexibleHListCursor) == 0x000008, "Wrong alignment on FFlexibleHListCursor");
static_assert(sizeof(FFlexibleHListCursor) == 0x000038, "Wrong size on FFlexibleHListCursor");

// ScriptStruct Nicola.NicolaFlipbookWidgetChangeSpriteData
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FNicolaFlipbookWidgetChangeSpriteData final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaFlipbookWidgetChangeSpriteData) == 0x000004, "Wrong alignment on FNicolaFlipbookWidgetChangeSpriteData");
static_assert(sizeof(FNicolaFlipbookWidgetChangeSpriteData) == 0x000024, "Wrong size on FNicolaFlipbookWidgetChangeSpriteData");

// ScriptStruct Nicola.NicolaFlipbookWidgetKeyFrameData
// 0x00C8 (0x00C8 - 0x0000)
struct FNicolaFlipbookWidgetKeyFrameData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0088)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x38];                                      // 0x0090(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaFlipbookWidgetKeyFrameData) == 0x000008, "Wrong alignment on FNicolaFlipbookWidgetKeyFrameData");
static_assert(sizeof(FNicolaFlipbookWidgetKeyFrameData) == 0x0000C8, "Wrong size on FNicolaFlipbookWidgetKeyFrameData");
static_assert(offsetof(FNicolaFlipbookWidgetKeyFrameData, Brush) == 0x000008, "Member 'FNicolaFlipbookWidgetKeyFrameData::Brush' has a wrong offset!");

// ScriptStruct Nicola.NicolaFlipbookBrushData
// 0x0098 (0x0098 - 0x0000)
struct FNicolaFlipbookBrushData final
{
public:
	int32                                         FrameLength;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0088)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              CustomPivotOffset;                                 // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaFlipbookBrushData) == 0x000008, "Wrong alignment on FNicolaFlipbookBrushData");
static_assert(sizeof(FNicolaFlipbookBrushData) == 0x000098, "Wrong size on FNicolaFlipbookBrushData");
static_assert(offsetof(FNicolaFlipbookBrushData, FrameLength) == 0x000000, "Member 'FNicolaFlipbookBrushData::FrameLength' has a wrong offset!");
static_assert(offsetof(FNicolaFlipbookBrushData, Brush) == 0x000008, "Member 'FNicolaFlipbookBrushData::Brush' has a wrong offset!");
static_assert(offsetof(FNicolaFlipbookBrushData, CustomPivotOffset) == 0x000090, "Member 'FNicolaFlipbookBrushData::CustomPivotOffset' has a wrong offset!");

// ScriptStruct Nicola.CSWFlipbookBrush
// 0x0048 (0x0048 - 0x0000)
struct FCSWFlipbookBrush final
{
public:
	class UPaperFlipbook*                         SourceFlipbook;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlipbookDirectionType                        SpriteDirection;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ImageSize;                                         // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            Tint;                                              // 0x0018(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAutoPlay;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCSWFlipbookBrush) == 0x000008, "Wrong alignment on FCSWFlipbookBrush");
static_assert(sizeof(FCSWFlipbookBrush) == 0x000048, "Wrong size on FCSWFlipbookBrush");
static_assert(offsetof(FCSWFlipbookBrush, SourceFlipbook) == 0x000000, "Member 'FCSWFlipbookBrush::SourceFlipbook' has a wrong offset!");
static_assert(offsetof(FCSWFlipbookBrush, SpriteDirection) == 0x000008, "Member 'FCSWFlipbookBrush::SpriteDirection' has a wrong offset!");
static_assert(offsetof(FCSWFlipbookBrush, ImageSize) == 0x00000C, "Member 'FCSWFlipbookBrush::ImageSize' has a wrong offset!");
static_assert(offsetof(FCSWFlipbookBrush, Tint) == 0x000018, "Member 'FCSWFlipbookBrush::Tint' has a wrong offset!");
static_assert(offsetof(FCSWFlipbookBrush, bAutoPlay) == 0x000040, "Member 'FCSWFlipbookBrush::bAutoPlay' has a wrong offset!");
static_assert(offsetof(FCSWFlipbookBrush, bLoop) == 0x000041, "Member 'FCSWFlipbookBrush::bLoop' has a wrong offset!");
static_assert(offsetof(FCSWFlipbookBrush, PlayRate) == 0x000044, "Member 'FCSWFlipbookBrush::PlayRate' has a wrong offset!");

// ScriptStruct Nicola.ForceFeedbackAssetTable
// 0x0028 (0x0030 - 0x0008)
struct FForceFeedbackAssetTable final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UForceFeedbackEffect>    ForceFeedbackAsset;                                // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForceFeedbackAssetTable) == 0x000008, "Wrong alignment on FForceFeedbackAssetTable");
static_assert(sizeof(FForceFeedbackAssetTable) == 0x000030, "Wrong size on FForceFeedbackAssetTable");
static_assert(offsetof(FForceFeedbackAssetTable, ForceFeedbackAsset) == 0x000008, "Member 'FForceFeedbackAssetTable::ForceFeedbackAsset' has a wrong offset!");

// ScriptStruct Nicola.GameSystemDataCore
// 0x0010 (0x0010 - 0x0000)
struct FGameSystemDataCore final
{
public:
	uint64                                        Seed_HeroId;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSystemDataCore) == 0x000008, "Wrong alignment on FGameSystemDataCore");
static_assert(sizeof(FGameSystemDataCore) == 0x000010, "Wrong size on FGameSystemDataCore");
static_assert(offsetof(FGameSystemDataCore, Seed_HeroId) == 0x000000, "Member 'FGameSystemDataCore::Seed_HeroId' has a wrong offset!");

// ScriptStruct Nicola.GameSystemDataOption
// 0x0024 (0x0024 - 0x0000)
struct FGameSystemDataOption final
{
public:
	bool                                          reverseCameraH;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          reverseCameraV;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         cameraSpeedRateH;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         cameraSpeedRateV;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         textSpeedRate;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENicolaLanguage                               NicolaLanguageText;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENicolaLanguageVoice                          NicolaLanguageVoice;                               // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enableForceFeedback;                               // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         postProcessGammaRate;                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         postProcessGainRate;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enableCameraEffectDOF;                             // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enableCameraQuickMove;                             // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enableStageCameraAutoMove;                         // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          quickCameraRotation;                               // 0x001F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mode4K;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSystemDataOption) == 0x000004, "Wrong alignment on FGameSystemDataOption");
static_assert(sizeof(FGameSystemDataOption) == 0x000024, "Wrong size on FGameSystemDataOption");
static_assert(offsetof(FGameSystemDataOption, reverseCameraH) == 0x000000, "Member 'FGameSystemDataOption::reverseCameraH' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, reverseCameraV) == 0x000001, "Member 'FGameSystemDataOption::reverseCameraV' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, cameraSpeedRateH) == 0x000004, "Member 'FGameSystemDataOption::cameraSpeedRateH' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, cameraSpeedRateV) == 0x000008, "Member 'FGameSystemDataOption::cameraSpeedRateV' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, textSpeedRate) == 0x00000C, "Member 'FGameSystemDataOption::textSpeedRate' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, NicolaLanguageText) == 0x000010, "Member 'FGameSystemDataOption::NicolaLanguageText' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, NicolaLanguageVoice) == 0x000011, "Member 'FGameSystemDataOption::NicolaLanguageVoice' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, enableForceFeedback) == 0x000012, "Member 'FGameSystemDataOption::enableForceFeedback' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, postProcessGammaRate) == 0x000014, "Member 'FGameSystemDataOption::postProcessGammaRate' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, postProcessGainRate) == 0x000018, "Member 'FGameSystemDataOption::postProcessGainRate' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, enableCameraEffectDOF) == 0x00001C, "Member 'FGameSystemDataOption::enableCameraEffectDOF' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, enableCameraQuickMove) == 0x00001D, "Member 'FGameSystemDataOption::enableCameraQuickMove' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, enableStageCameraAutoMove) == 0x00001E, "Member 'FGameSystemDataOption::enableStageCameraAutoMove' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, quickCameraRotation) == 0x00001F, "Member 'FGameSystemDataOption::quickCameraRotation' has a wrong offset!");
static_assert(offsetof(FGameSystemDataOption, mode4K) == 0x000020, "Member 'FGameSystemDataOption::mode4K' has a wrong offset!");

// ScriptStruct Nicola.GameSystemDataOptionWithoutCloud
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FGameSystemDataOptionWithoutCloud final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSystemDataOptionWithoutCloud) == 0x000004, "Wrong alignment on FGameSystemDataOptionWithoutCloud");
static_assert(sizeof(FGameSystemDataOptionWithoutCloud) == 0x000030, "Wrong size on FGameSystemDataOptionWithoutCloud");

// ScriptStruct Nicola.RentalUnitInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FRentalUnitInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRentalUnitInfo) == 0x000008, "Wrong alignment on FRentalUnitInfo");
static_assert(sizeof(FRentalUnitInfo) == 0x000030, "Wrong size on FRentalUnitInfo");

// ScriptStruct Nicola.GameSystemDataRental
// 0x0018 (0x0018 - 0x0000)
struct FGameSystemDataRental final
{
public:
	int32                                         TestData;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRentalUnitInfo>                RentalInfos;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameSystemDataRental) == 0x000008, "Wrong alignment on FGameSystemDataRental");
static_assert(sizeof(FGameSystemDataRental) == 0x000018, "Wrong size on FGameSystemDataRental");
static_assert(offsetof(FGameSystemDataRental, TestData) == 0x000000, "Member 'FGameSystemDataRental::TestData' has a wrong offset!");
static_assert(offsetof(FGameSystemDataRental, RentalInfos) == 0x000008, "Member 'FGameSystemDataRental::RentalInfos' has a wrong offset!");

// ScriptStruct Nicola.GameSystemDataTracking
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameSystemDataTracking final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSystemDataTracking) == 0x000008, "Wrong alignment on FGameSystemDataTracking");
static_assert(sizeof(FGameSystemDataTracking) == 0x000010, "Wrong size on FGameSystemDataTracking");

// ScriptStruct Nicola.GOP_BankTable
// 0x00A8 (0x00B0 - 0x0008)
struct FGOP_BankTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_0;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_1;                                            // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_2;                                            // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_3;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_4;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_5;                                            // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_6;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_7;                                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_8;                                            // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_9;                                            // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_10;                                           // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_11;                                           // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_12;                                           // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_13;                                           // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_14;                                           // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_15;                                           // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_16;                                           // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_17;                                           // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_18;                                           // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_19;                                           // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_BankTable) == 0x000008, "Wrong alignment on FGOP_BankTable");
static_assert(sizeof(FGOP_BankTable) == 0x0000B0, "Wrong size on FGOP_BankTable");
static_assert(offsetof(FGOP_BankTable, SelfId) == 0x000008, "Member 'FGOP_BankTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_0) == 0x000010, "Member 'FGOP_BankTable::Talk_0' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_1) == 0x000018, "Member 'FGOP_BankTable::Talk_1' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_2) == 0x000020, "Member 'FGOP_BankTable::Talk_2' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_3) == 0x000028, "Member 'FGOP_BankTable::Talk_3' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_4) == 0x000030, "Member 'FGOP_BankTable::Talk_4' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_5) == 0x000038, "Member 'FGOP_BankTable::Talk_5' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_6) == 0x000040, "Member 'FGOP_BankTable::Talk_6' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_7) == 0x000048, "Member 'FGOP_BankTable::Talk_7' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_8) == 0x000050, "Member 'FGOP_BankTable::Talk_8' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_9) == 0x000058, "Member 'FGOP_BankTable::Talk_9' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_10) == 0x000060, "Member 'FGOP_BankTable::Talk_10' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_11) == 0x000068, "Member 'FGOP_BankTable::Talk_11' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_12) == 0x000070, "Member 'FGOP_BankTable::Talk_12' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_13) == 0x000078, "Member 'FGOP_BankTable::Talk_13' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_14) == 0x000080, "Member 'FGOP_BankTable::Talk_14' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_15) == 0x000088, "Member 'FGOP_BankTable::Talk_15' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_16) == 0x000090, "Member 'FGOP_BankTable::Talk_16' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_17) == 0x000098, "Member 'FGOP_BankTable::Talk_17' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_18) == 0x0000A0, "Member 'FGOP_BankTable::Talk_18' has a wrong offset!");
static_assert(offsetof(FGOP_BankTable, Talk_19) == 0x0000A8, "Member 'FGOP_BankTable::Talk_19' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_BuffDebuffTable
// 0x0040 (0x0048 - 0x0008)
struct FGOP_Battle_BuffDebuffTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuffDebuffChangeType                         ChangeType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuffDebuffAffectSide                         AffectSide;                                        // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Phase_negative_6;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_negative_5;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_negative_4;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_negative_3;                                  // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_negative_2;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_negative_1;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_0;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_1;                                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_2;                                           // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_3;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_4;                                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_5;                                           // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_6;                                           // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Battle_BuffDebuffTable) == 0x000008, "Wrong alignment on FGOP_Battle_BuffDebuffTable");
static_assert(sizeof(FGOP_Battle_BuffDebuffTable) == 0x000048, "Wrong size on FGOP_Battle_BuffDebuffTable");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, SelfId) == 0x000008, "Member 'FGOP_Battle_BuffDebuffTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, ChangeType) == 0x000010, "Member 'FGOP_Battle_BuffDebuffTable::ChangeType' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, AffectSide) == 0x000011, "Member 'FGOP_Battle_BuffDebuffTable::AffectSide' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_negative_6) == 0x000014, "Member 'FGOP_Battle_BuffDebuffTable::Phase_negative_6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_negative_5) == 0x000018, "Member 'FGOP_Battle_BuffDebuffTable::Phase_negative_5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_negative_4) == 0x00001C, "Member 'FGOP_Battle_BuffDebuffTable::Phase_negative_4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_negative_3) == 0x000020, "Member 'FGOP_Battle_BuffDebuffTable::Phase_negative_3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_negative_2) == 0x000024, "Member 'FGOP_Battle_BuffDebuffTable::Phase_negative_2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_negative_1) == 0x000028, "Member 'FGOP_Battle_BuffDebuffTable::Phase_negative_1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_0) == 0x00002C, "Member 'FGOP_Battle_BuffDebuffTable::Phase_0' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_1) == 0x000030, "Member 'FGOP_Battle_BuffDebuffTable::Phase_1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_2) == 0x000034, "Member 'FGOP_Battle_BuffDebuffTable::Phase_2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_3) == 0x000038, "Member 'FGOP_Battle_BuffDebuffTable::Phase_3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_4) == 0x00003C, "Member 'FGOP_Battle_BuffDebuffTable::Phase_4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_5) == 0x000040, "Member 'FGOP_Battle_BuffDebuffTable::Phase_5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_BuffDebuffTable, Phase_6) == 0x000044, "Member 'FGOP_Battle_BuffDebuffTable::Phase_6' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_CameraTable
// 0x0078 (0x0080 - 0x0008)
struct FGOP_Battle_CameraTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandLocationX;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandLocationY;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandLocationZ;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandPitch;                                      // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandYaw;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandRoll;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandFOV;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseActionLocation;                                // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionLocationX;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionLocationY;                                   // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionLocationZ;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionPitch;                                       // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionYaw;                                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionRoll;                                        // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionFOV;                                         // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionFOVLeftPlaneShrinkRate;                      // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionFOVRightPlaneShrinkRate;                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionFOVTopPlaneShrinkRate;                       // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionFOVBottomPlaneShrinkRate;                    // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionControlPointLeftOffset;                      // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionControlPointRightOffset;                     // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionControlPointTopOffset;                       // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionControlPointBottomOffset;                    // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionZOffset;                                     // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattlePostProcessActionId;                         // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattlePostProcessCommandId;                        // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Battle_CameraTable) == 0x000008, "Wrong alignment on FGOP_Battle_CameraTable");
static_assert(sizeof(FGOP_Battle_CameraTable) == 0x000080, "Wrong size on FGOP_Battle_CameraTable");
static_assert(offsetof(FGOP_Battle_CameraTable, SelfId) == 0x000008, "Member 'FGOP_Battle_CameraTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandLocationX) == 0x000010, "Member 'FGOP_Battle_CameraTable::CommandLocationX' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandLocationY) == 0x000014, "Member 'FGOP_Battle_CameraTable::CommandLocationY' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandLocationZ) == 0x000018, "Member 'FGOP_Battle_CameraTable::CommandLocationZ' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandPitch) == 0x00001C, "Member 'FGOP_Battle_CameraTable::CommandPitch' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandYaw) == 0x000020, "Member 'FGOP_Battle_CameraTable::CommandYaw' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandRoll) == 0x000024, "Member 'FGOP_Battle_CameraTable::CommandRoll' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, CommandFOV) == 0x000028, "Member 'FGOP_Battle_CameraTable::CommandFOV' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, bUseActionLocation) == 0x00002C, "Member 'FGOP_Battle_CameraTable::bUseActionLocation' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionLocationX) == 0x000030, "Member 'FGOP_Battle_CameraTable::ActionLocationX' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionLocationY) == 0x000034, "Member 'FGOP_Battle_CameraTable::ActionLocationY' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionLocationZ) == 0x000038, "Member 'FGOP_Battle_CameraTable::ActionLocationZ' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionPitch) == 0x00003C, "Member 'FGOP_Battle_CameraTable::ActionPitch' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionYaw) == 0x000040, "Member 'FGOP_Battle_CameraTable::ActionYaw' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionRoll) == 0x000044, "Member 'FGOP_Battle_CameraTable::ActionRoll' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionFOV) == 0x000048, "Member 'FGOP_Battle_CameraTable::ActionFOV' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionFOVLeftPlaneShrinkRate) == 0x00004C, "Member 'FGOP_Battle_CameraTable::ActionFOVLeftPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionFOVRightPlaneShrinkRate) == 0x000050, "Member 'FGOP_Battle_CameraTable::ActionFOVRightPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionFOVTopPlaneShrinkRate) == 0x000054, "Member 'FGOP_Battle_CameraTable::ActionFOVTopPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionFOVBottomPlaneShrinkRate) == 0x000058, "Member 'FGOP_Battle_CameraTable::ActionFOVBottomPlaneShrinkRate' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionControlPointLeftOffset) == 0x00005C, "Member 'FGOP_Battle_CameraTable::ActionControlPointLeftOffset' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionControlPointRightOffset) == 0x000060, "Member 'FGOP_Battle_CameraTable::ActionControlPointRightOffset' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionControlPointTopOffset) == 0x000064, "Member 'FGOP_Battle_CameraTable::ActionControlPointTopOffset' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionControlPointBottomOffset) == 0x000068, "Member 'FGOP_Battle_CameraTable::ActionControlPointBottomOffset' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, ActionZOffset) == 0x00006C, "Member 'FGOP_Battle_CameraTable::ActionZOffset' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, BattlePostProcessActionId) == 0x000070, "Member 'FGOP_Battle_CameraTable::BattlePostProcessActionId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraTable, BattlePostProcessCommandId) == 0x000078, "Member 'FGOP_Battle_CameraTable::BattlePostProcessCommandId' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_CameraShakeTable
// 0x0060 (0x0068 - 0x0008)
struct FGOP_Battle_CameraShakeTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShakeIDPlayerDamage;                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShakeIDPlayerLargeDamage;                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShakeIDMonsterRegistDamage;                  // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShakeIDMonsterDamage;                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShakeIDMonsterWeakDamage;                    // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayWhenBattlePlayDamage;                        // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Battle_CameraShakeTable) == 0x000008, "Wrong alignment on FGOP_Battle_CameraShakeTable");
static_assert(sizeof(FGOP_Battle_CameraShakeTable) == 0x000068, "Wrong size on FGOP_Battle_CameraShakeTable");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, SelfId) == 0x000008, "Member 'FGOP_Battle_CameraShakeTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, CameraShakeIDPlayerDamage) == 0x000010, "Member 'FGOP_Battle_CameraShakeTable::CameraShakeIDPlayerDamage' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, CameraShakeIDPlayerLargeDamage) == 0x000020, "Member 'FGOP_Battle_CameraShakeTable::CameraShakeIDPlayerLargeDamage' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, CameraShakeIDMonsterRegistDamage) == 0x000030, "Member 'FGOP_Battle_CameraShakeTable::CameraShakeIDMonsterRegistDamage' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, CameraShakeIDMonsterDamage) == 0x000040, "Member 'FGOP_Battle_CameraShakeTable::CameraShakeIDMonsterDamage' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, CameraShakeIDMonsterWeakDamage) == 0x000050, "Member 'FGOP_Battle_CameraShakeTable::CameraShakeIDMonsterWeakDamage' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_CameraShakeTable, IsPlayWhenBattlePlayDamage) == 0x000060, "Member 'FGOP_Battle_CameraShakeTable::IsPlayWhenBattlePlayDamage' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_EventTable
// 0x0070 (0x0078 - 0x0008)
struct FGOP_Battle_EventTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GOP_Encounter_Monster;                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GOP_MapList_Battle;                                // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BGM;                                               // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventBattleCameraChangeType                  ChangeConditionType;                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Change_Condition_1;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Change_Encounter_Monster1;                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Change_Condition_2;                                // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Change_Encounter_Monster2;                         // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Change_Condition_3;                                // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Change_Encounter_Monster3;                         // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Change_Condition_4;                                // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Change_Encounter_Monster4;                         // 0x0054(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_BossBattle;                                     // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Encounter_Effect;                                  // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReinforceMonsterId;                                // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReinforceMaxCount;                                 // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReinforceOnceCount;                                // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Battle_EventTable) == 0x000008, "Wrong alignment on FGOP_Battle_EventTable");
static_assert(sizeof(FGOP_Battle_EventTable) == 0x000078, "Wrong size on FGOP_Battle_EventTable");
static_assert(offsetof(FGOP_Battle_EventTable, SelfId) == 0x000008, "Member 'FGOP_Battle_EventTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, GOP_Encounter_Monster) == 0x000010, "Member 'FGOP_Battle_EventTable::GOP_Encounter_Monster' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, GOP_MapList_Battle) == 0x000018, "Member 'FGOP_Battle_EventTable::GOP_MapList_Battle' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, BGM) == 0x000020, "Member 'FGOP_Battle_EventTable::BGM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, ChangeConditionType) == 0x000028, "Member 'FGOP_Battle_EventTable::ChangeConditionType' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Condition_1) == 0x00002C, "Member 'FGOP_Battle_EventTable::Change_Condition_1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Encounter_Monster1) == 0x000030, "Member 'FGOP_Battle_EventTable::Change_Encounter_Monster1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Condition_2) == 0x000038, "Member 'FGOP_Battle_EventTable::Change_Condition_2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Encounter_Monster2) == 0x00003C, "Member 'FGOP_Battle_EventTable::Change_Encounter_Monster2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Condition_3) == 0x000044, "Member 'FGOP_Battle_EventTable::Change_Condition_3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Encounter_Monster3) == 0x000048, "Member 'FGOP_Battle_EventTable::Change_Encounter_Monster3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Condition_4) == 0x000050, "Member 'FGOP_Battle_EventTable::Change_Condition_4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Change_Encounter_Monster4) == 0x000054, "Member 'FGOP_Battle_EventTable::Change_Encounter_Monster4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Is_BossBattle) == 0x00005C, "Member 'FGOP_Battle_EventTable::Is_BossBattle' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, Encounter_Effect) == 0x000060, "Member 'FGOP_Battle_EventTable::Encounter_Effect' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, ReinforceMonsterId) == 0x000064, "Member 'FGOP_Battle_EventTable::ReinforceMonsterId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, ReinforceMaxCount) == 0x00006C, "Member 'FGOP_Battle_EventTable::ReinforceMaxCount' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_EventTable, ReinforceOnceCount) == 0x000070, "Member 'FGOP_Battle_EventTable::ReinforceOnceCount' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_FormationTable
// 0x00E0 (0x00E8 - 0x0008)
struct FGOP_Battle_FormationTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLocationX;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLocationY;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLocationZ;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationX1;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY1;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ1;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance1;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve1;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX2;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY2;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ2;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance2;                                         // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve2;                                        // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX3;                                        // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY3;                                        // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ3;                                        // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance3;                                         // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve3;                                        // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX4;                                        // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY4;                                        // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ4;                                        // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance4;                                         // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve4;                                        // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX5;                                        // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY5;                                        // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ5;                                        // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance5;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve5;                                        // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX6;                                        // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY6;                                        // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ6;                                        // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance6;                                         // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve6;                                        // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX7;                                        // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY7;                                        // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ7;                                        // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance7;                                         // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve7;                                        // 0x00A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX8;                                        // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY8;                                        // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ8;                                        // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance8;                                         // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve8;                                        // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX9;                                        // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY9;                                        // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ9;                                        // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance9;                                         // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve9;                                        // 0x00CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX10;                                       // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY10;                                       // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationZ10;                                       // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance10;                                        // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserve10;                                       // 0x00E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Battle_FormationTable) == 0x000008, "Wrong alignment on FGOP_Battle_FormationTable");
static_assert(sizeof(FGOP_Battle_FormationTable) == 0x0000E8, "Wrong size on FGOP_Battle_FormationTable");
static_assert(offsetof(FGOP_Battle_FormationTable, SelfId) == 0x000008, "Member 'FGOP_Battle_FormationTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, BaseLocationX) == 0x000010, "Member 'FGOP_Battle_FormationTable::BaseLocationX' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, BaseLocationY) == 0x000014, "Member 'FGOP_Battle_FormationTable::BaseLocationY' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, BaseLocationZ) == 0x000018, "Member 'FGOP_Battle_FormationTable::BaseLocationZ' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX1) == 0x00001C, "Member 'FGOP_Battle_FormationTable::LocationX1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY1) == 0x000020, "Member 'FGOP_Battle_FormationTable::LocationY1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ1) == 0x000024, "Member 'FGOP_Battle_FormationTable::LocationZ1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance1) == 0x000028, "Member 'FGOP_Battle_FormationTable::Distance1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve1) == 0x00002C, "Member 'FGOP_Battle_FormationTable::IsReserve1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX2) == 0x000030, "Member 'FGOP_Battle_FormationTable::LocationX2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY2) == 0x000034, "Member 'FGOP_Battle_FormationTable::LocationY2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ2) == 0x000038, "Member 'FGOP_Battle_FormationTable::LocationZ2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance2) == 0x00003C, "Member 'FGOP_Battle_FormationTable::Distance2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve2) == 0x000040, "Member 'FGOP_Battle_FormationTable::IsReserve2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX3) == 0x000044, "Member 'FGOP_Battle_FormationTable::LocationX3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY3) == 0x000048, "Member 'FGOP_Battle_FormationTable::LocationY3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ3) == 0x00004C, "Member 'FGOP_Battle_FormationTable::LocationZ3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance3) == 0x000050, "Member 'FGOP_Battle_FormationTable::Distance3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve3) == 0x000054, "Member 'FGOP_Battle_FormationTable::IsReserve3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX4) == 0x000058, "Member 'FGOP_Battle_FormationTable::LocationX4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY4) == 0x00005C, "Member 'FGOP_Battle_FormationTable::LocationY4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ4) == 0x000060, "Member 'FGOP_Battle_FormationTable::LocationZ4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance4) == 0x000064, "Member 'FGOP_Battle_FormationTable::Distance4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve4) == 0x000068, "Member 'FGOP_Battle_FormationTable::IsReserve4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX5) == 0x00006C, "Member 'FGOP_Battle_FormationTable::LocationX5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY5) == 0x000070, "Member 'FGOP_Battle_FormationTable::LocationY5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ5) == 0x000074, "Member 'FGOP_Battle_FormationTable::LocationZ5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance5) == 0x000078, "Member 'FGOP_Battle_FormationTable::Distance5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve5) == 0x00007C, "Member 'FGOP_Battle_FormationTable::IsReserve5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX6) == 0x000080, "Member 'FGOP_Battle_FormationTable::LocationX6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY6) == 0x000084, "Member 'FGOP_Battle_FormationTable::LocationY6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ6) == 0x000088, "Member 'FGOP_Battle_FormationTable::LocationZ6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance6) == 0x00008C, "Member 'FGOP_Battle_FormationTable::Distance6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve6) == 0x000090, "Member 'FGOP_Battle_FormationTable::IsReserve6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX7) == 0x000094, "Member 'FGOP_Battle_FormationTable::LocationX7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY7) == 0x000098, "Member 'FGOP_Battle_FormationTable::LocationY7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ7) == 0x00009C, "Member 'FGOP_Battle_FormationTable::LocationZ7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance7) == 0x0000A0, "Member 'FGOP_Battle_FormationTable::Distance7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve7) == 0x0000A4, "Member 'FGOP_Battle_FormationTable::IsReserve7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX8) == 0x0000A8, "Member 'FGOP_Battle_FormationTable::LocationX8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY8) == 0x0000AC, "Member 'FGOP_Battle_FormationTable::LocationY8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ8) == 0x0000B0, "Member 'FGOP_Battle_FormationTable::LocationZ8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance8) == 0x0000B4, "Member 'FGOP_Battle_FormationTable::Distance8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve8) == 0x0000B8, "Member 'FGOP_Battle_FormationTable::IsReserve8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX9) == 0x0000BC, "Member 'FGOP_Battle_FormationTable::LocationX9' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY9) == 0x0000C0, "Member 'FGOP_Battle_FormationTable::LocationY9' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ9) == 0x0000C4, "Member 'FGOP_Battle_FormationTable::LocationZ9' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance9) == 0x0000C8, "Member 'FGOP_Battle_FormationTable::Distance9' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve9) == 0x0000CC, "Member 'FGOP_Battle_FormationTable::IsReserve9' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationX10) == 0x0000D0, "Member 'FGOP_Battle_FormationTable::LocationX10' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationY10) == 0x0000D4, "Member 'FGOP_Battle_FormationTable::LocationY10' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, LocationZ10) == 0x0000D8, "Member 'FGOP_Battle_FormationTable::LocationZ10' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, Distance10) == 0x0000DC, "Member 'FGOP_Battle_FormationTable::Distance10' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_FormationTable, IsReserve10) == 0x0000E0, "Member 'FGOP_Battle_FormationTable::IsReserve10' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_Monster_ActionTable
// 0x0040 (0x0048 - 0x0008)
struct FGOP_Battle_Monster_ActionTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Script;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Animation;                                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_enable_astron;                                  // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_confirm_luck;                                   // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Pierce_level;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_use_battle_road;                                // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GOP_Magic;                                         // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Battle_Monster_ActionTable) == 0x000008, "Wrong alignment on FGOP_Battle_Monster_ActionTable");
static_assert(sizeof(FGOP_Battle_Monster_ActionTable) == 0x000048, "Wrong size on FGOP_Battle_Monster_ActionTable");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, SelfId) == 0x000008, "Member 'FGOP_Battle_Monster_ActionTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, Script) == 0x000010, "Member 'FGOP_Battle_Monster_ActionTable::Script' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, Animation) == 0x000020, "Member 'FGOP_Battle_Monster_ActionTable::Animation' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, Is_enable_astron) == 0x000030, "Member 'FGOP_Battle_Monster_ActionTable::Is_enable_astron' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, Is_confirm_luck) == 0x000031, "Member 'FGOP_Battle_Monster_ActionTable::Is_confirm_luck' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, Pierce_level) == 0x000034, "Member 'FGOP_Battle_Monster_ActionTable::Pierce_level' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, Is_use_battle_road) == 0x000038, "Member 'FGOP_Battle_Monster_ActionTable::Is_use_battle_road' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionTable, GOP_Magic) == 0x00003C, "Member 'FGOP_Battle_Monster_ActionTable::GOP_Magic' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_Monster_ActionListTable
// 0x01D8 (0x01E0 - 0x0008)
struct FGOP_Battle_Monster_ActionListTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Monster_ActionList_ID;                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionListCondition                    Condition1;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Condition1_Param;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Condition1_ParamStr;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionListCondition                    Condition2;                                        // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Condition2_Param;                                  // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Condition2_ParamStr;                               // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionListCondition                    Condition3;                                        // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Condition3_Param;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Condition3_ParamStr;                               // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionListCondition                    Condition4;                                        // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Condition4_Param;                                  // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Condition4_ParamStr;                               // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num_Turn;                                          // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action1_ID;                                        // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action1_TargetConditionA;                          // 0x0084(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action1_TargetConditionB;                          // 0x0085(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action1_TargetConditionC;                          // 0x0086(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action1_TargetConditionD;                          // 0x0087(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action1;                            // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action1;                      // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action1_Add_ActedList_Condition;                   // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x1];                                       // 0x008B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action1_Default_Weight;                            // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action1_Change_Weight_Condition;                   // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action1_Num_TurnList_Condition;                    // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action1_Change_Weight_Condition_ParamA;            // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action1_Change_Weight_Condition_ParamB;            // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action1_Changed_Weight;                            // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action2_ID;                                        // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action2_TargetConditionA;                          // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action2_TargetConditionB;                          // 0x00B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action2_TargetConditionC;                          // 0x00B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action2_TargetConditionD;                          // 0x00B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action2;                            // 0x00B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action2;                      // 0x00B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action2_Add_ActedList_Condition;                   // 0x00B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action2_Default_Weight;                            // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action2_Change_Weight_Condition;                   // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action2_Num_TurnList_Condition;                    // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action2_Change_Weight_Condition_ParamA;            // 0x00C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action2_Change_Weight_Condition_ParamB;            // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action2_Changed_Weight;                            // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action3_ID;                                        // 0x00D4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action3_TargetConditionA;                          // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action3_TargetConditionB;                          // 0x00DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action3_TargetConditionC;                          // 0x00DE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action3_TargetConditionD;                          // 0x00DF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action3;                            // 0x00E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action3;                      // 0x00E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action3_Add_ActedList_Condition;                   // 0x00E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action3_Default_Weight;                            // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action3_Change_Weight_Condition;                   // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action3_Num_TurnList_Condition;                    // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action3_Change_Weight_Condition_ParamA;            // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action3_Change_Weight_Condition_ParamB;            // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action3_Changed_Weight;                            // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action4_ID;                                        // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action4_TargetConditionA;                          // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action4_TargetConditionB;                          // 0x0109(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action4_TargetConditionC;                          // 0x010A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action4_TargetConditionD;                          // 0x010B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action4;                            // 0x010C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action4;                      // 0x010D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action4_Add_ActedList_Condition;                   // 0x010E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F[0x1];                                      // 0x010F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action4_Default_Weight;                            // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action4_Change_Weight_Condition;                   // 0x0114(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action4_Num_TurnList_Condition;                    // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action4_Change_Weight_Condition_ParamA;            // 0x011C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action4_Change_Weight_Condition_ParamB;            // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action4_Changed_Weight;                            // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action5_ID;                                        // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action5_TargetConditionA;                          // 0x0134(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action5_TargetConditionB;                          // 0x0135(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action5_TargetConditionC;                          // 0x0136(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action5_TargetConditionD;                          // 0x0137(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action5;                            // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action5;                      // 0x0139(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action5_Add_ActedList_Condition;                   // 0x013A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x1];                                      // 0x013B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action5_Default_Weight;                            // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action5_Change_Weight_Condition;                   // 0x0140(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action5_Num_TurnList_Condition;                    // 0x0144(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action5_Change_Weight_Condition_ParamA;            // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action5_Change_Weight_Condition_ParamB;            // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action5_Changed_Weight;                            // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action6_ID;                                        // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action6_TargetConditionA;                          // 0x0160(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action6_TargetConditionB;                          // 0x0161(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action6_TargetConditionC;                          // 0x0162(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action6_TargetConditionD;                          // 0x0163(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action6;                            // 0x0164(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action6;                      // 0x0165(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action6_Add_ActedList_Condition;                   // 0x0166(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_167[0x1];                                      // 0x0167(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action6_Default_Weight;                            // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action6_Change_Weight_Condition;                   // 0x016C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action6_Num_TurnList_Condition;                    // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action6_Change_Weight_Condition_ParamA;            // 0x0174(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action6_Change_Weight_Condition_ParamB;            // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action6_Changed_Weight;                            // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action7_ID;                                        // 0x0184(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action7_TargetConditionA;                          // 0x018C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action7_TargetConditionB;                          // 0x018D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action7_TargetConditionC;                          // 0x018E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action7_TargetConditionD;                          // 0x018F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action7;                            // 0x0190(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action7;                      // 0x0191(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action7_Add_ActedList_Condition;                   // 0x0192(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193[0x1];                                      // 0x0193(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action7_Default_Weight;                            // 0x0194(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action7_Change_Weight_Condition;                   // 0x0198(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action7_Num_TurnList_Condition;                    // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action7_Change_Weight_Condition_ParamA;            // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action7_Change_Weight_Condition_ParamB;            // 0x01A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action7_Changed_Weight;                            // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action8_ID;                                        // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action8_TargetConditionA;                          // 0x01B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action8_TargetConditionB;                          // 0x01B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action8_TargetConditionC;                          // 0x01BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionTargetCondition                  Action8_TargetConditionD;                          // 0x01BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Target_Action8;                            // 0x01BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Same_Group_Target_Action8;                      // 0x01BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAddActedListCondition                  Action8_Add_ActedList_Condition;                   // 0x01BE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BF[0x1];                                      // 0x01BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action8_Default_Weight;                            // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleChangeWeightCondition                  Action8_Change_Weight_Condition;                   // 0x01C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action8_Num_TurnList_Condition;                    // 0x01C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action8_Change_Weight_Condition_ParamA;            // 0x01CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action8_Change_Weight_Condition_ParamB;            // 0x01D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action8_Changed_Weight;                            // 0x01D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Battle_Monster_ActionListTable) == 0x000008, "Wrong alignment on FGOP_Battle_Monster_ActionListTable");
static_assert(sizeof(FGOP_Battle_Monster_ActionListTable) == 0x0001E0, "Wrong size on FGOP_Battle_Monster_ActionListTable");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, SelfId) == 0x000008, "Member 'FGOP_Battle_Monster_ActionListTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Monster_ActionList_ID) == 0x000010, "Member 'FGOP_Battle_Monster_ActionListTable::Monster_ActionList_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition1) == 0x000018, "Member 'FGOP_Battle_Monster_ActionListTable::Condition1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition1_Param) == 0x00001C, "Member 'FGOP_Battle_Monster_ActionListTable::Condition1_Param' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition1_ParamStr) == 0x000020, "Member 'FGOP_Battle_Monster_ActionListTable::Condition1_ParamStr' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition2) == 0x000030, "Member 'FGOP_Battle_Monster_ActionListTable::Condition2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition2_Param) == 0x000034, "Member 'FGOP_Battle_Monster_ActionListTable::Condition2_Param' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition2_ParamStr) == 0x000038, "Member 'FGOP_Battle_Monster_ActionListTable::Condition2_ParamStr' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition3) == 0x000048, "Member 'FGOP_Battle_Monster_ActionListTable::Condition3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition3_Param) == 0x00004C, "Member 'FGOP_Battle_Monster_ActionListTable::Condition3_Param' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition3_ParamStr) == 0x000050, "Member 'FGOP_Battle_Monster_ActionListTable::Condition3_ParamStr' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition4) == 0x000060, "Member 'FGOP_Battle_Monster_ActionListTable::Condition4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition4_Param) == 0x000064, "Member 'FGOP_Battle_Monster_ActionListTable::Condition4_Param' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Condition4_ParamStr) == 0x000068, "Member 'FGOP_Battle_Monster_ActionListTable::Condition4_ParamStr' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Num_Turn) == 0x000078, "Member 'FGOP_Battle_Monster_ActionListTable::Num_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_ID) == 0x00007C, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_TargetConditionA) == 0x000084, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_TargetConditionB) == 0x000085, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_TargetConditionC) == 0x000086, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_TargetConditionD) == 0x000087, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action1) == 0x000088, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action1) == 0x000089, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action1' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Add_ActedList_Condition) == 0x00008A, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Default_Weight) == 0x00008C, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Change_Weight_Condition) == 0x000090, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Num_TurnList_Condition) == 0x000094, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Change_Weight_Condition_ParamA) == 0x000098, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Change_Weight_Condition_ParamB) == 0x0000A0, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action1_Changed_Weight) == 0x0000A4, "Member 'FGOP_Battle_Monster_ActionListTable::Action1_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_ID) == 0x0000A8, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_TargetConditionA) == 0x0000B0, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_TargetConditionB) == 0x0000B1, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_TargetConditionC) == 0x0000B2, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_TargetConditionD) == 0x0000B3, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action2) == 0x0000B4, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action2) == 0x0000B5, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Add_ActedList_Condition) == 0x0000B6, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Default_Weight) == 0x0000B8, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Change_Weight_Condition) == 0x0000BC, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Num_TurnList_Condition) == 0x0000C0, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Change_Weight_Condition_ParamA) == 0x0000C4, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Change_Weight_Condition_ParamB) == 0x0000CC, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action2_Changed_Weight) == 0x0000D0, "Member 'FGOP_Battle_Monster_ActionListTable::Action2_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_ID) == 0x0000D4, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_TargetConditionA) == 0x0000DC, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_TargetConditionB) == 0x0000DD, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_TargetConditionC) == 0x0000DE, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_TargetConditionD) == 0x0000DF, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action3) == 0x0000E0, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action3) == 0x0000E1, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action3' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Add_ActedList_Condition) == 0x0000E2, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Default_Weight) == 0x0000E4, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Change_Weight_Condition) == 0x0000E8, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Num_TurnList_Condition) == 0x0000EC, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Change_Weight_Condition_ParamA) == 0x0000F0, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Change_Weight_Condition_ParamB) == 0x0000F8, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action3_Changed_Weight) == 0x0000FC, "Member 'FGOP_Battle_Monster_ActionListTable::Action3_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_ID) == 0x000100, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_TargetConditionA) == 0x000108, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_TargetConditionB) == 0x000109, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_TargetConditionC) == 0x00010A, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_TargetConditionD) == 0x00010B, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action4) == 0x00010C, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action4) == 0x00010D, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action4' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Add_ActedList_Condition) == 0x00010E, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Default_Weight) == 0x000110, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Change_Weight_Condition) == 0x000114, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Num_TurnList_Condition) == 0x000118, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Change_Weight_Condition_ParamA) == 0x00011C, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Change_Weight_Condition_ParamB) == 0x000124, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action4_Changed_Weight) == 0x000128, "Member 'FGOP_Battle_Monster_ActionListTable::Action4_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_ID) == 0x00012C, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_TargetConditionA) == 0x000134, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_TargetConditionB) == 0x000135, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_TargetConditionC) == 0x000136, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_TargetConditionD) == 0x000137, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action5) == 0x000138, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action5) == 0x000139, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action5' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Add_ActedList_Condition) == 0x00013A, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Default_Weight) == 0x00013C, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Change_Weight_Condition) == 0x000140, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Num_TurnList_Condition) == 0x000144, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Change_Weight_Condition_ParamA) == 0x000148, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Change_Weight_Condition_ParamB) == 0x000150, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action5_Changed_Weight) == 0x000154, "Member 'FGOP_Battle_Monster_ActionListTable::Action5_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_ID) == 0x000158, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_TargetConditionA) == 0x000160, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_TargetConditionB) == 0x000161, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_TargetConditionC) == 0x000162, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_TargetConditionD) == 0x000163, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action6) == 0x000164, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action6) == 0x000165, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action6' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Add_ActedList_Condition) == 0x000166, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Default_Weight) == 0x000168, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Change_Weight_Condition) == 0x00016C, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Num_TurnList_Condition) == 0x000170, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Change_Weight_Condition_ParamA) == 0x000174, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Change_Weight_Condition_ParamB) == 0x00017C, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action6_Changed_Weight) == 0x000180, "Member 'FGOP_Battle_Monster_ActionListTable::Action6_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_ID) == 0x000184, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_TargetConditionA) == 0x00018C, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_TargetConditionB) == 0x00018D, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_TargetConditionC) == 0x00018E, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_TargetConditionD) == 0x00018F, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action7) == 0x000190, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action7) == 0x000191, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action7' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Add_ActedList_Condition) == 0x000192, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Default_Weight) == 0x000194, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Change_Weight_Condition) == 0x000198, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Num_TurnList_Condition) == 0x00019C, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Change_Weight_Condition_ParamA) == 0x0001A0, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Change_Weight_Condition_ParamB) == 0x0001A8, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action7_Changed_Weight) == 0x0001AC, "Member 'FGOP_Battle_Monster_ActionListTable::Action7_Changed_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_ID) == 0x0001B0, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_ID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_TargetConditionA) == 0x0001B8, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_TargetConditionA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_TargetConditionB) == 0x0001B9, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_TargetConditionB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_TargetConditionC) == 0x0001BA, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_TargetConditionC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_TargetConditionD) == 0x0001BB, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_TargetConditionD' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Target_Action8) == 0x0001BC, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Target_Action8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Is_Same_Group_Target_Action8) == 0x0001BD, "Member 'FGOP_Battle_Monster_ActionListTable::Is_Same_Group_Target_Action8' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Add_ActedList_Condition) == 0x0001BE, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Add_ActedList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Default_Weight) == 0x0001C0, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Default_Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Change_Weight_Condition) == 0x0001C4, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Change_Weight_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Num_TurnList_Condition) == 0x0001C8, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Num_TurnList_Condition' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Change_Weight_Condition_ParamA) == 0x0001CC, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Change_Weight_Condition_ParamA' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Change_Weight_Condition_ParamB) == 0x0001D4, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Change_Weight_Condition_ParamB' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Monster_ActionListTable, Action8_Changed_Weight) == 0x0001D8, "Member 'FGOP_Battle_Monster_ActionListTable::Action8_Changed_Weight' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_PC_ActionTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_Battle_PC_ActionTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Script;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_affect_curse;                                   // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_get_xp;                                         // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_get_gold;                                       // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_get_item;                                       // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_target_dead;                                    // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Pierce_level_forEnemy;                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Piece_level_forPC;                                 // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GOP_Magic;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Battle_PC_ActionTable) == 0x000008, "Wrong alignment on FGOP_Battle_PC_ActionTable");
static_assert(sizeof(FGOP_Battle_PC_ActionTable) == 0x000038, "Wrong size on FGOP_Battle_PC_ActionTable");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, SelfId) == 0x000008, "Member 'FGOP_Battle_PC_ActionTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Script) == 0x000010, "Member 'FGOP_Battle_PC_ActionTable::Script' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Is_affect_curse) == 0x000020, "Member 'FGOP_Battle_PC_ActionTable::Is_affect_curse' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Is_get_xp) == 0x000021, "Member 'FGOP_Battle_PC_ActionTable::Is_get_xp' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Is_get_gold) == 0x000022, "Member 'FGOP_Battle_PC_ActionTable::Is_get_gold' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Is_get_item) == 0x000023, "Member 'FGOP_Battle_PC_ActionTable::Is_get_item' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Is_target_dead) == 0x000024, "Member 'FGOP_Battle_PC_ActionTable::Is_target_dead' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Pierce_level_forEnemy) == 0x000028, "Member 'FGOP_Battle_PC_ActionTable::Pierce_level_forEnemy' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, Piece_level_forPC) == 0x00002C, "Member 'FGOP_Battle_PC_ActionTable::Piece_level_forPC' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_PC_ActionTable, GOP_Magic) == 0x000030, "Member 'FGOP_Battle_PC_ActionTable::GOP_Magic' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_ResistTable
// 0x00D0 (0x00D8 - 0x0008)
struct FGOP_Battle_ResistTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mela_Damage_Multiplier;                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gila_Damage_Multiplier;                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Io_Damage_Multiplier;                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hyado_Damage_Multiplier;                           // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bagi_Damage_Multiplier;                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Zaki_Resist_Probability;                           // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Megante_Resist_Probability;                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dein_Damage_Multiplier;                            // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Doragoram_Resist_Probability;                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bomios_Resist_Probability;                         // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bomios_Resist_Turn;                                // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rukani_Resist_Probability;                         // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rukani_Resist_Turn;                                // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Manusa_Resist_Probability;                         // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Manusa_Resist_Turn;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mahoton_Resist_Probability;                        // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mahoton_Resist_Turn;                               // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Medapani_Resist_Probability;                       // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medapani_Resist_Turn;                              // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rariho_Resist_Probability;                         // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rariho_Resist_Turn;                                // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bashiruler_Resist_Probability;                     // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nifuram_Resist_Probability;                        // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mahotora_Resist_Probability;                       // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Flame_Damage_Multiplier;                           // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blizzard_Damage_Multiplier;                        // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Death_Resist_Probability;                          // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Poison_Resist_Probability;                         // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Poison_Resist_Turn;                                // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Paralyze_Resist_Probability;                       // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Paralyze_Resist_Turn;                              // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stan_Resist_Probability;                           // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stan_Resist_Turn;                                  // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Allcancel_Resist_Probability;                      // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Allcancel_Resist_Turn;                             // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Normal_Damage_Multiplier;                          // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fly_Damage_Multiplier;                             // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Beast_Damage_Multiplier;                           // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Zombie_Damage_Multiplier;                          // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Kajin_Damage_Multiplier;                           // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Insect_Damage_Multiplier;                          // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Doragon_Damage_Multiplier;                         // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Metal_Damage_Multiplier;                           // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weak_Resist_Probability;                           // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weak_Resist_Turn;                                  // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weak2_Resist_Probability;                          // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weak2_Resist_Turn;                                 // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Critical_Damage_Multiplier;                        // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Foot_Sweep_Resist_Probability;                     // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Foot_Sweep_Resist_Turn;                            // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Battle_ResistTable) == 0x000008, "Wrong alignment on FGOP_Battle_ResistTable");
static_assert(sizeof(FGOP_Battle_ResistTable) == 0x0000D8, "Wrong size on FGOP_Battle_ResistTable");
static_assert(offsetof(FGOP_Battle_ResistTable, SelfId) == 0x000008, "Member 'FGOP_Battle_ResistTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Mela_Damage_Multiplier) == 0x000010, "Member 'FGOP_Battle_ResistTable::Mela_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Gila_Damage_Multiplier) == 0x000014, "Member 'FGOP_Battle_ResistTable::Gila_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Io_Damage_Multiplier) == 0x000018, "Member 'FGOP_Battle_ResistTable::Io_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Hyado_Damage_Multiplier) == 0x00001C, "Member 'FGOP_Battle_ResistTable::Hyado_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Bagi_Damage_Multiplier) == 0x000020, "Member 'FGOP_Battle_ResistTable::Bagi_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Zaki_Resist_Probability) == 0x000024, "Member 'FGOP_Battle_ResistTable::Zaki_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Megante_Resist_Probability) == 0x000028, "Member 'FGOP_Battle_ResistTable::Megante_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Dein_Damage_Multiplier) == 0x00002C, "Member 'FGOP_Battle_ResistTable::Dein_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Doragoram_Resist_Probability) == 0x000030, "Member 'FGOP_Battle_ResistTable::Doragoram_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Bomios_Resist_Probability) == 0x000034, "Member 'FGOP_Battle_ResistTable::Bomios_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Bomios_Resist_Turn) == 0x000038, "Member 'FGOP_Battle_ResistTable::Bomios_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Rukani_Resist_Probability) == 0x00003C, "Member 'FGOP_Battle_ResistTable::Rukani_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Rukani_Resist_Turn) == 0x000040, "Member 'FGOP_Battle_ResistTable::Rukani_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Manusa_Resist_Probability) == 0x000044, "Member 'FGOP_Battle_ResistTable::Manusa_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Manusa_Resist_Turn) == 0x000048, "Member 'FGOP_Battle_ResistTable::Manusa_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Mahoton_Resist_Probability) == 0x00004C, "Member 'FGOP_Battle_ResistTable::Mahoton_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Mahoton_Resist_Turn) == 0x000050, "Member 'FGOP_Battle_ResistTable::Mahoton_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Medapani_Resist_Probability) == 0x000054, "Member 'FGOP_Battle_ResistTable::Medapani_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Medapani_Resist_Turn) == 0x000058, "Member 'FGOP_Battle_ResistTable::Medapani_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Rariho_Resist_Probability) == 0x00005C, "Member 'FGOP_Battle_ResistTable::Rariho_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Rariho_Resist_Turn) == 0x000060, "Member 'FGOP_Battle_ResistTable::Rariho_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Bashiruler_Resist_Probability) == 0x000064, "Member 'FGOP_Battle_ResistTable::Bashiruler_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Nifuram_Resist_Probability) == 0x000068, "Member 'FGOP_Battle_ResistTable::Nifuram_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Mahotora_Resist_Probability) == 0x00006C, "Member 'FGOP_Battle_ResistTable::Mahotora_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Flame_Damage_Multiplier) == 0x000070, "Member 'FGOP_Battle_ResistTable::Flame_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Blizzard_Damage_Multiplier) == 0x000074, "Member 'FGOP_Battle_ResistTable::Blizzard_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Death_Resist_Probability) == 0x000078, "Member 'FGOP_Battle_ResistTable::Death_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Poison_Resist_Probability) == 0x00007C, "Member 'FGOP_Battle_ResistTable::Poison_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Poison_Resist_Turn) == 0x000080, "Member 'FGOP_Battle_ResistTable::Poison_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Paralyze_Resist_Probability) == 0x000084, "Member 'FGOP_Battle_ResistTable::Paralyze_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Paralyze_Resist_Turn) == 0x000088, "Member 'FGOP_Battle_ResistTable::Paralyze_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Stan_Resist_Probability) == 0x00008C, "Member 'FGOP_Battle_ResistTable::Stan_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Stan_Resist_Turn) == 0x000090, "Member 'FGOP_Battle_ResistTable::Stan_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Allcancel_Resist_Probability) == 0x000094, "Member 'FGOP_Battle_ResistTable::Allcancel_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Allcancel_Resist_Turn) == 0x000098, "Member 'FGOP_Battle_ResistTable::Allcancel_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Normal_Damage_Multiplier) == 0x00009C, "Member 'FGOP_Battle_ResistTable::Normal_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Fly_Damage_Multiplier) == 0x0000A0, "Member 'FGOP_Battle_ResistTable::Fly_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Beast_Damage_Multiplier) == 0x0000A4, "Member 'FGOP_Battle_ResistTable::Beast_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Zombie_Damage_Multiplier) == 0x0000A8, "Member 'FGOP_Battle_ResistTable::Zombie_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Kajin_Damage_Multiplier) == 0x0000AC, "Member 'FGOP_Battle_ResistTable::Kajin_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Insect_Damage_Multiplier) == 0x0000B0, "Member 'FGOP_Battle_ResistTable::Insect_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Doragon_Damage_Multiplier) == 0x0000B4, "Member 'FGOP_Battle_ResistTable::Doragon_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Metal_Damage_Multiplier) == 0x0000B8, "Member 'FGOP_Battle_ResistTable::Metal_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Weak_Resist_Probability) == 0x0000BC, "Member 'FGOP_Battle_ResistTable::Weak_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Weak_Resist_Turn) == 0x0000C0, "Member 'FGOP_Battle_ResistTable::Weak_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Weak2_Resist_Probability) == 0x0000C4, "Member 'FGOP_Battle_ResistTable::Weak2_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Weak2_Resist_Turn) == 0x0000C8, "Member 'FGOP_Battle_ResistTable::Weak2_Resist_Turn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Critical_Damage_Multiplier) == 0x0000CC, "Member 'FGOP_Battle_ResistTable::Critical_Damage_Multiplier' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Foot_Sweep_Resist_Probability) == 0x0000D0, "Member 'FGOP_Battle_ResistTable::Foot_Sweep_Resist_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_ResistTable, Foot_Sweep_Resist_Turn) == 0x0000D4, "Member 'FGOP_Battle_ResistTable::Foot_Sweep_Resist_Turn' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_StatusEffectTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_Battle_StatusEffectTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusChangeType                             StatusChangeType;                                  // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusChangeCountTiming                      StatusChangeTiming;                                // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeType                                StatusChangeAttribute;                             // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitRate;                                           // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEffectLuck;                                      // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectValue;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectValue2;                                      // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMin;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMax;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeplicate;                                       // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExtendTurn;                                      // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelBattleFinish;                                // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelItetsukuUser;                                // 0x002F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelItesukuEnemy;                                // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelBlackOut;                                    // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNotAction;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Battle_StatusEffectTable) == 0x000008, "Wrong alignment on FGOP_Battle_StatusEffectTable");
static_assert(sizeof(FGOP_Battle_StatusEffectTable) == 0x000038, "Wrong size on FGOP_Battle_StatusEffectTable");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, SelfId) == 0x000008, "Member 'FGOP_Battle_StatusEffectTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, StatusChangeType) == 0x000010, "Member 'FGOP_Battle_StatusEffectTable::StatusChangeType' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, StatusChangeTiming) == 0x000011, "Member 'FGOP_Battle_StatusEffectTable::StatusChangeTiming' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, StatusChangeAttribute) == 0x000012, "Member 'FGOP_Battle_StatusEffectTable::StatusChangeAttribute' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, HitRate) == 0x000014, "Member 'FGOP_Battle_StatusEffectTable::HitRate' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, IsEffectLuck) == 0x000018, "Member 'FGOP_Battle_StatusEffectTable::IsEffectLuck' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, EffectValue) == 0x00001C, "Member 'FGOP_Battle_StatusEffectTable::EffectValue' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, EffectValue2) == 0x000020, "Member 'FGOP_Battle_StatusEffectTable::EffectValue2' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, CountMin) == 0x000024, "Member 'FGOP_Battle_StatusEffectTable::CountMin' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, CountMax) == 0x000028, "Member 'FGOP_Battle_StatusEffectTable::CountMax' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, IsDeplicate) == 0x00002C, "Member 'FGOP_Battle_StatusEffectTable::IsDeplicate' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, IsExtendTurn) == 0x00002D, "Member 'FGOP_Battle_StatusEffectTable::IsExtendTurn' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, CancelBattleFinish) == 0x00002E, "Member 'FGOP_Battle_StatusEffectTable::CancelBattleFinish' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, CancelItetsukuUser) == 0x00002F, "Member 'FGOP_Battle_StatusEffectTable::CancelItetsukuUser' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, CancelItesukuEnemy) == 0x000030, "Member 'FGOP_Battle_StatusEffectTable::CancelItesukuEnemy' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, CancelBlackOut) == 0x000031, "Member 'FGOP_Battle_StatusEffectTable::CancelBlackOut' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_StatusEffectTable, IsNotAction) == 0x000032, "Member 'FGOP_Battle_StatusEffectTable::IsNotAction' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_Text_SetTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_Battle_Text_SetTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   textID;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextId_TargetEnemy;                                // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextId_ActorEnemy;                                 // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Battle_Text_SetTable) == 0x000008, "Wrong alignment on FGOP_Battle_Text_SetTable");
static_assert(sizeof(FGOP_Battle_Text_SetTable) == 0x000028, "Wrong size on FGOP_Battle_Text_SetTable");
static_assert(offsetof(FGOP_Battle_Text_SetTable, SelfId) == 0x000008, "Member 'FGOP_Battle_Text_SetTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Text_SetTable, textID) == 0x000010, "Member 'FGOP_Battle_Text_SetTable::textID' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Text_SetTable, TextId_TargetEnemy) == 0x000018, "Member 'FGOP_Battle_Text_SetTable::TextId_TargetEnemy' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Text_SetTable, TextId_ActorEnemy) == 0x000020, "Member 'FGOP_Battle_Text_SetTable::TextId_ActorEnemy' has a wrong offset!");

// ScriptStruct Nicola.GOP_Battle_Weapon_StyleTable
// 0x03E8 (0x03F0 - 0x0008)
struct FGOP_Battle_Weapon_StyleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleHeroM;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeHeroM;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorHeroM;                                       // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleHeroM;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixHeroM;                                 // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleHeroF;                                         // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeHeroF;                                       // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorHeroF;                                       // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleHeroF;                                  // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixHeroF;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleHeroMizugiF;                                   // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeHeroMizugiF;                                 // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorHeroMizugiF;                                 // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleHeroMizugiF;                            // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixHeroMizugiF;                           // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleWarriorM;                                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeWarriorM;                                    // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorWarriorM;                                    // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleWarriorM;                               // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixWarriorM;                              // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleWarriorF;                                      // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeWarriorF;                                    // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorWarriorF;                                    // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleWarriorF;                               // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixWarriorF;                              // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleWarriorMizugiF;                                // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeWarriorMizugiF;                              // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorWarriorMizugiF;                              // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleWarriorMizugiF;                         // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixWarriorMizugiF;                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleFighterM;                                      // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeFighterM;                                    // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorFighterM;                                    // 0x00D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleFighterM;                               // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixFighterM;                              // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleFighterF;                                      // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeFighterF;                                    // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorFighterF;                                    // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleFighterF;                               // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixFighterF;                              // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleFighterMizugiF;                                // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeFighterMizugiF;                              // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorFighterMizugiF;                              // 0x0118(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleFighterMizugiF;                         // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixFighterMizugiF;                        // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMageM;                                         // 0x0130(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMageM;                                       // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorMageM;                                       // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleMageM;                                  // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixMageM;                                 // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMageF;                                         // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMageF;                                       // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorMageF;                                       // 0x0158(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleMageF;                                  // 0x015C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixMageF;                                 // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMageMizugiF;                                   // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMageMizugiF;                                 // 0x0174(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorMageMizugiF;                                 // 0x0178(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleMageMizugiF;                            // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixMageMizugiF;                           // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdlePriestM;                                       // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreePriestM;                                     // 0x0194(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorPriestM;                                     // 0x0198(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScalePriestM;                                // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixPriestM;                               // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdlePriestF;                                       // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreePriestF;                                     // 0x01B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorPriestF;                                     // 0x01B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScalePriestF;                                // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixPriestF;                               // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdlePriestMizugiF;                                 // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreePriestMizugiF;                               // 0x01D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorPriestMizugiF;                               // 0x01D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScalePriestMizugiF;                          // 0x01DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixPriestMizugiF;                         // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMerchantM;                                     // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMerchantM;                                   // 0x01F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorMerchantM;                                   // 0x01F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleMerchantM;                              // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixMerchantM;                             // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMerchantF;                                     // 0x0210(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMerchantF;                                   // 0x0214(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorMerchantF;                                   // 0x0218(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleMerchantF;                              // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixMerchantF;                             // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMerchantMizugiF;                               // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMerchantMizugiF;                             // 0x0234(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorMerchantMizugiF;                             // 0x0238(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleMerchantMizugiF;                        // 0x023C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixMerchantMizugiF;                       // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleGadaboutM;                                     // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeGadaboutM;                                   // 0x0254(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorGadaboutM;                                   // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleGadaboutM;                              // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixGadaboutM;                             // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleGadaboutF;                                     // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeGadaboutF;                                   // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorGadaboutF;                                   // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleGadaboutF;                              // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixGadaboutF;                             // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleGadaboutMizugiF;                               // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeGadaboutMizugiF;                             // 0x0294(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorGadaboutMizugiF;                             // 0x0298(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleGadaboutMizugiF;                        // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixGadaboutMizugiF;                       // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleThiefM;                                        // 0x02B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeThiefM;                                      // 0x02B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorThiefM;                                      // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleThiefM;                                 // 0x02BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixThiefM;                                // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleThiefF;                                        // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeThiefF;                                      // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorThiefF;                                      // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleThiefF;                                 // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixThiefF;                                // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleThiefMizugiF;                                  // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeThiefMizugiF;                                // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorThiefMizugiF;                                // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleThiefMizugiF;                           // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixThiefMizugiF;                          // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleSageM;                                         // 0x0310(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeSageM;                                       // 0x0314(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorSageM;                                       // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleSageM;                                  // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixSageM;                                 // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleSageF;                                         // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeSageF;                                       // 0x0334(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorSageF;                                       // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleSageF;                                  // 0x033C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixSageF;                                 // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleSageMizugiF;                                   // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeSageMizugiF;                                 // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorSageMizugiF;                                 // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleSageMizugiF;                            // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixSageMizugiF;                           // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleBreederM;                                      // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeBreederM;                                    // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorBreederM;                                    // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleBreederM;                               // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixBreederM;                              // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleBreederF;                                      // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeBreederF;                                    // 0x0394(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorBreederF;                                    // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleBreederF;                               // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixBreederF;                              // 0x03A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleBreederMizugiF;                                // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeBreederMizugiF;                              // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorBreederMizugiF;                              // 0x03B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleBreederMizugiF;                         // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixBreederMizugiF;                        // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleNuigurumi;                                     // 0x03D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeNuigurumi;                                   // 0x03D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MirrorNuigurumi;                                   // 0x03D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleNuigurumi;                              // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderSuffixNuigurumi;                             // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Battle_Weapon_StyleTable) == 0x000008, "Wrong alignment on FGOP_Battle_Weapon_StyleTable");
static_assert(sizeof(FGOP_Battle_Weapon_StyleTable) == 0x0003F0, "Wrong size on FGOP_Battle_Weapon_StyleTable");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, SelfId) == 0x000008, "Member 'FGOP_Battle_Weapon_StyleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleHeroM) == 0x000010, "Member 'FGOP_Battle_Weapon_StyleTable::IdleHeroM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeHeroM) == 0x000014, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeHeroM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorHeroM) == 0x000018, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorHeroM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleHeroM) == 0x00001C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleHeroM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixHeroM) == 0x000020, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixHeroM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleHeroF) == 0x000030, "Member 'FGOP_Battle_Weapon_StyleTable::IdleHeroF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeHeroF) == 0x000034, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeHeroF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorHeroF) == 0x000038, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorHeroF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleHeroF) == 0x00003C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleHeroF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixHeroF) == 0x000040, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixHeroF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleHeroMizugiF) == 0x000050, "Member 'FGOP_Battle_Weapon_StyleTable::IdleHeroMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeHeroMizugiF) == 0x000054, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeHeroMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorHeroMizugiF) == 0x000058, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorHeroMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleHeroMizugiF) == 0x00005C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleHeroMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixHeroMizugiF) == 0x000060, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixHeroMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleWarriorM) == 0x000070, "Member 'FGOP_Battle_Weapon_StyleTable::IdleWarriorM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeWarriorM) == 0x000074, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeWarriorM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorWarriorM) == 0x000078, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorWarriorM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleWarriorM) == 0x00007C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleWarriorM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixWarriorM) == 0x000080, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixWarriorM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleWarriorF) == 0x000090, "Member 'FGOP_Battle_Weapon_StyleTable::IdleWarriorF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeWarriorF) == 0x000094, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeWarriorF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorWarriorF) == 0x000098, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorWarriorF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleWarriorF) == 0x00009C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleWarriorF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixWarriorF) == 0x0000A0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixWarriorF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleWarriorMizugiF) == 0x0000B0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleWarriorMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeWarriorMizugiF) == 0x0000B4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeWarriorMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorWarriorMizugiF) == 0x0000B8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorWarriorMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleWarriorMizugiF) == 0x0000BC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleWarriorMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixWarriorMizugiF) == 0x0000C0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixWarriorMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleFighterM) == 0x0000D0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleFighterM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeFighterM) == 0x0000D4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeFighterM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorFighterM) == 0x0000D8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorFighterM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleFighterM) == 0x0000DC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleFighterM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixFighterM) == 0x0000E0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixFighterM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleFighterF) == 0x0000F0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleFighterF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeFighterF) == 0x0000F4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeFighterF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorFighterF) == 0x0000F8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorFighterF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleFighterF) == 0x0000FC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleFighterF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixFighterF) == 0x000100, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixFighterF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleFighterMizugiF) == 0x000110, "Member 'FGOP_Battle_Weapon_StyleTable::IdleFighterMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeFighterMizugiF) == 0x000114, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeFighterMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorFighterMizugiF) == 0x000118, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorFighterMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleFighterMizugiF) == 0x00011C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleFighterMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixFighterMizugiF) == 0x000120, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixFighterMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleMageM) == 0x000130, "Member 'FGOP_Battle_Weapon_StyleTable::IdleMageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeMageM) == 0x000134, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeMageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorMageM) == 0x000138, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorMageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleMageM) == 0x00013C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleMageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixMageM) == 0x000140, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixMageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleMageF) == 0x000150, "Member 'FGOP_Battle_Weapon_StyleTable::IdleMageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeMageF) == 0x000154, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeMageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorMageF) == 0x000158, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorMageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleMageF) == 0x00015C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleMageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixMageF) == 0x000160, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixMageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleMageMizugiF) == 0x000170, "Member 'FGOP_Battle_Weapon_StyleTable::IdleMageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeMageMizugiF) == 0x000174, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeMageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorMageMizugiF) == 0x000178, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorMageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleMageMizugiF) == 0x00017C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleMageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixMageMizugiF) == 0x000180, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixMageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdlePriestM) == 0x000190, "Member 'FGOP_Battle_Weapon_StyleTable::IdlePriestM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreePriestM) == 0x000194, "Member 'FGOP_Battle_Weapon_StyleTable::DegreePriestM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorPriestM) == 0x000198, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorPriestM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScalePriestM) == 0x00019C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScalePriestM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixPriestM) == 0x0001A0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixPriestM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdlePriestF) == 0x0001B0, "Member 'FGOP_Battle_Weapon_StyleTable::IdlePriestF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreePriestF) == 0x0001B4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreePriestF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorPriestF) == 0x0001B8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorPriestF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScalePriestF) == 0x0001BC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScalePriestF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixPriestF) == 0x0001C0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixPriestF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdlePriestMizugiF) == 0x0001D0, "Member 'FGOP_Battle_Weapon_StyleTable::IdlePriestMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreePriestMizugiF) == 0x0001D4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreePriestMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorPriestMizugiF) == 0x0001D8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorPriestMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScalePriestMizugiF) == 0x0001DC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScalePriestMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixPriestMizugiF) == 0x0001E0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixPriestMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleMerchantM) == 0x0001F0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleMerchantM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeMerchantM) == 0x0001F4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeMerchantM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorMerchantM) == 0x0001F8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorMerchantM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleMerchantM) == 0x0001FC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleMerchantM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixMerchantM) == 0x000200, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixMerchantM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleMerchantF) == 0x000210, "Member 'FGOP_Battle_Weapon_StyleTable::IdleMerchantF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeMerchantF) == 0x000214, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeMerchantF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorMerchantF) == 0x000218, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorMerchantF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleMerchantF) == 0x00021C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleMerchantF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixMerchantF) == 0x000220, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixMerchantF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleMerchantMizugiF) == 0x000230, "Member 'FGOP_Battle_Weapon_StyleTable::IdleMerchantMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeMerchantMizugiF) == 0x000234, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeMerchantMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorMerchantMizugiF) == 0x000238, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorMerchantMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleMerchantMizugiF) == 0x00023C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleMerchantMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixMerchantMizugiF) == 0x000240, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixMerchantMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleGadaboutM) == 0x000250, "Member 'FGOP_Battle_Weapon_StyleTable::IdleGadaboutM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeGadaboutM) == 0x000254, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeGadaboutM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorGadaboutM) == 0x000258, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorGadaboutM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleGadaboutM) == 0x00025C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleGadaboutM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixGadaboutM) == 0x000260, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixGadaboutM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleGadaboutF) == 0x000270, "Member 'FGOP_Battle_Weapon_StyleTable::IdleGadaboutF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeGadaboutF) == 0x000274, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeGadaboutF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorGadaboutF) == 0x000278, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorGadaboutF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleGadaboutF) == 0x00027C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleGadaboutF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixGadaboutF) == 0x000280, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixGadaboutF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleGadaboutMizugiF) == 0x000290, "Member 'FGOP_Battle_Weapon_StyleTable::IdleGadaboutMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeGadaboutMizugiF) == 0x000294, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeGadaboutMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorGadaboutMizugiF) == 0x000298, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorGadaboutMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleGadaboutMizugiF) == 0x00029C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleGadaboutMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixGadaboutMizugiF) == 0x0002A0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixGadaboutMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleThiefM) == 0x0002B0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleThiefM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeThiefM) == 0x0002B4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeThiefM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorThiefM) == 0x0002B8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorThiefM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleThiefM) == 0x0002BC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleThiefM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixThiefM) == 0x0002C0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixThiefM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleThiefF) == 0x0002D0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleThiefF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeThiefF) == 0x0002D4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeThiefF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorThiefF) == 0x0002D8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorThiefF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleThiefF) == 0x0002DC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleThiefF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixThiefF) == 0x0002E0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixThiefF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleThiefMizugiF) == 0x0002F0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleThiefMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeThiefMizugiF) == 0x0002F4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeThiefMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorThiefMizugiF) == 0x0002F8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorThiefMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleThiefMizugiF) == 0x0002FC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleThiefMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixThiefMizugiF) == 0x000300, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixThiefMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleSageM) == 0x000310, "Member 'FGOP_Battle_Weapon_StyleTable::IdleSageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeSageM) == 0x000314, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeSageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorSageM) == 0x000318, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorSageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleSageM) == 0x00031C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleSageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixSageM) == 0x000320, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixSageM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleSageF) == 0x000330, "Member 'FGOP_Battle_Weapon_StyleTable::IdleSageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeSageF) == 0x000334, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeSageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorSageF) == 0x000338, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorSageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleSageF) == 0x00033C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleSageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixSageF) == 0x000340, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixSageF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleSageMizugiF) == 0x000350, "Member 'FGOP_Battle_Weapon_StyleTable::IdleSageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeSageMizugiF) == 0x000354, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeSageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorSageMizugiF) == 0x000358, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorSageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleSageMizugiF) == 0x00035C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleSageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixSageMizugiF) == 0x000360, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixSageMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleBreederM) == 0x000370, "Member 'FGOP_Battle_Weapon_StyleTable::IdleBreederM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeBreederM) == 0x000374, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeBreederM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorBreederM) == 0x000378, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorBreederM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleBreederM) == 0x00037C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleBreederM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixBreederM) == 0x000380, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixBreederM' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleBreederF) == 0x000390, "Member 'FGOP_Battle_Weapon_StyleTable::IdleBreederF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeBreederF) == 0x000394, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeBreederF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorBreederF) == 0x000398, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorBreederF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleBreederF) == 0x00039C, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleBreederF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixBreederF) == 0x0003A0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixBreederF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleBreederMizugiF) == 0x0003B0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleBreederMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeBreederMizugiF) == 0x0003B4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeBreederMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorBreederMizugiF) == 0x0003B8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorBreederMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleBreederMizugiF) == 0x0003BC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleBreederMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixBreederMizugiF) == 0x0003C0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixBreederMizugiF' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, IdleNuigurumi) == 0x0003D0, "Member 'FGOP_Battle_Weapon_StyleTable::IdleNuigurumi' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, DegreeNuigurumi) == 0x0003D4, "Member 'FGOP_Battle_Weapon_StyleTable::DegreeNuigurumi' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, MirrorNuigurumi) == 0x0003D8, "Member 'FGOP_Battle_Weapon_StyleTable::MirrorNuigurumi' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, WeaponScaleNuigurumi) == 0x0003DC, "Member 'FGOP_Battle_Weapon_StyleTable::WeaponScaleNuigurumi' has a wrong offset!");
static_assert(offsetof(FGOP_Battle_Weapon_StyleTable, FolderSuffixNuigurumi) == 0x0003E0, "Member 'FGOP_Battle_Weapon_StyleTable::FolderSuffixNuigurumi' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_EntryTable
// 0x0070 (0x0078 - 0x0008)
struct FGOP_BattleRoad_EntryTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rank01;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rank02;                                            // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rank03;                                            // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rank04;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rank05;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapID_Entry;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartID_Entry;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapID_Arena;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartID_Arena;                                     // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_BattleRoad_EntryTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_EntryTable");
static_assert(sizeof(FGOP_BattleRoad_EntryTable) == 0x000078, "Wrong size on FGOP_BattleRoad_EntryTable");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_EntryTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, Rank01) == 0x000010, "Member 'FGOP_BattleRoad_EntryTable::Rank01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, Rank02) == 0x000018, "Member 'FGOP_BattleRoad_EntryTable::Rank02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, Rank03) == 0x000020, "Member 'FGOP_BattleRoad_EntryTable::Rank03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, Rank04) == 0x000028, "Member 'FGOP_BattleRoad_EntryTable::Rank04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, Rank05) == 0x000030, "Member 'FGOP_BattleRoad_EntryTable::Rank05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, MapID_Entry) == 0x000038, "Member 'FGOP_BattleRoad_EntryTable::MapID_Entry' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, StartID_Entry) == 0x000048, "Member 'FGOP_BattleRoad_EntryTable::StartID_Entry' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, MapID_Arena) == 0x000058, "Member 'FGOP_BattleRoad_EntryTable::MapID_Arena' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_EntryTable, StartID_Arena) == 0x000068, "Member 'FGOP_BattleRoad_EntryTable::StartID_Arena' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_InformationTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_BattleRoad_InformationTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortIndex;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestionTextId;                                    // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnswerTextId;                                      // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_BattleRoad_InformationTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_InformationTable");
static_assert(sizeof(FGOP_BattleRoad_InformationTable) == 0x000028, "Wrong size on FGOP_BattleRoad_InformationTable");
static_assert(offsetof(FGOP_BattleRoad_InformationTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_InformationTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_InformationTable, SortIndex) == 0x000010, "Member 'FGOP_BattleRoad_InformationTable::SortIndex' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_InformationTable, QuestionTextId) == 0x000014, "Member 'FGOP_BattleRoad_InformationTable::QuestionTextId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_InformationTable, AnswerTextId) == 0x00001C, "Member 'FGOP_BattleRoad_InformationTable::AnswerTextId' has a wrong offset!");

// ScriptStruct Nicola.NicolaConst
// 0x00C0 (0x00C0 - 0x0000)
struct FNicolaConst final
{
public:
	class FString                                 GopRoot;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GopSoundRoot;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LuaHandlingDir;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FieldLevel;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorldMapTextureFieldPath;                          // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MiniMapTextureFieldPath;                           // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapTextureFieldPath;                               // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartMapListId;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPlayerStart;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InitialChurchId;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameClearChurchId;                                 // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameClearVehicleRuraId;                            // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DebugVehicleRuraId;                                // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultBattleBGM;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainMenuBGM;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugHeroName;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialHour;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableMapTimePassed;                               // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaConst) == 0x000008, "Wrong alignment on FNicolaConst");
static_assert(sizeof(FNicolaConst) == 0x0000C0, "Wrong size on FNicolaConst");
static_assert(offsetof(FNicolaConst, GopRoot) == 0x000000, "Member 'FNicolaConst::GopRoot' has a wrong offset!");
static_assert(offsetof(FNicolaConst, GopSoundRoot) == 0x000010, "Member 'FNicolaConst::GopSoundRoot' has a wrong offset!");
static_assert(offsetof(FNicolaConst, LuaHandlingDir) == 0x000020, "Member 'FNicolaConst::LuaHandlingDir' has a wrong offset!");
static_assert(offsetof(FNicolaConst, FieldLevel) == 0x000030, "Member 'FNicolaConst::FieldLevel' has a wrong offset!");
static_assert(offsetof(FNicolaConst, WorldMapTextureFieldPath) == 0x000038, "Member 'FNicolaConst::WorldMapTextureFieldPath' has a wrong offset!");
static_assert(offsetof(FNicolaConst, MiniMapTextureFieldPath) == 0x000048, "Member 'FNicolaConst::MiniMapTextureFieldPath' has a wrong offset!");
static_assert(offsetof(FNicolaConst, MapTextureFieldPath) == 0x000058, "Member 'FNicolaConst::MapTextureFieldPath' has a wrong offset!");
static_assert(offsetof(FNicolaConst, StartMapListId) == 0x000068, "Member 'FNicolaConst::StartMapListId' has a wrong offset!");
static_assert(offsetof(FNicolaConst, StartPlayerStart) == 0x000070, "Member 'FNicolaConst::StartPlayerStart' has a wrong offset!");
static_assert(offsetof(FNicolaConst, InitialChurchId) == 0x000078, "Member 'FNicolaConst::InitialChurchId' has a wrong offset!");
static_assert(offsetof(FNicolaConst, GameClearChurchId) == 0x000080, "Member 'FNicolaConst::GameClearChurchId' has a wrong offset!");
static_assert(offsetof(FNicolaConst, GameClearVehicleRuraId) == 0x000088, "Member 'FNicolaConst::GameClearVehicleRuraId' has a wrong offset!");
static_assert(offsetof(FNicolaConst, DebugVehicleRuraId) == 0x000090, "Member 'FNicolaConst::DebugVehicleRuraId' has a wrong offset!");
static_assert(offsetof(FNicolaConst, DefaultBattleBGM) == 0x000098, "Member 'FNicolaConst::DefaultBattleBGM' has a wrong offset!");
static_assert(offsetof(FNicolaConst, MainMenuBGM) == 0x0000A0, "Member 'FNicolaConst::MainMenuBGM' has a wrong offset!");
static_assert(offsetof(FNicolaConst, DebugHeroName) == 0x0000A8, "Member 'FNicolaConst::DebugHeroName' has a wrong offset!");
static_assert(offsetof(FNicolaConst, InitialHour) == 0x0000B8, "Member 'FNicolaConst::InitialHour' has a wrong offset!");
static_assert(offsetof(FNicolaConst, EnableMapTimePassed) == 0x0000BC, "Member 'FNicolaConst::EnableMapTimePassed' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_MonsterTable
// 0x0048 (0x0050 - 0x0008)
struct FGOP_BattleRoad_MonsterTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterID;                                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magic01;                                           // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magic02;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magic03;                                           // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magic04;                                           // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magic05;                                           // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magic06;                                           // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_BattleRoad_MonsterTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_MonsterTable");
static_assert(sizeof(FGOP_BattleRoad_MonsterTable) == 0x000050, "Wrong size on FGOP_BattleRoad_MonsterTable");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_MonsterTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, NameId) == 0x000010, "Member 'FGOP_BattleRoad_MonsterTable::NameId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, MonsterID) == 0x000018, "Member 'FGOP_BattleRoad_MonsterTable::MonsterID' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, Magic01) == 0x000020, "Member 'FGOP_BattleRoad_MonsterTable::Magic01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, Magic02) == 0x000028, "Member 'FGOP_BattleRoad_MonsterTable::Magic02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, Magic03) == 0x000030, "Member 'FGOP_BattleRoad_MonsterTable::Magic03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, Magic04) == 0x000038, "Member 'FGOP_BattleRoad_MonsterTable::Magic04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, Magic05) == 0x000040, "Member 'FGOP_BattleRoad_MonsterTable::Magic05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterTable, Magic06) == 0x000048, "Member 'FGOP_BattleRoad_MonsterTable::Magic06' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_MonsterSpeciesTable
// 0x0088 (0x0090 - 0x0008)
struct FGOP_BattleRoad_MonsterSpeciesTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpeciesId;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpeciesOrder;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_jp;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_tw;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_cn;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_ko;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_en;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_fr;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_it;                                       // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_de;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_es;                                       // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOrder_es419;                                    // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBRMonsterId01;                                    // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBRMonsterId02;                                    // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBRMonsterId03;                                    // 0x0054(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBRMonsterId04;                                    // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBRMonsterId05;                                    // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleTactics                                DefaultTactics;                                    // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MBR_Offset;                                        // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBR_Scale;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Battle_Offset;                                     // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battle_Scale;                                      // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecruitMessagePattern;                             // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_BattleRoad_MonsterSpeciesTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_MonsterSpeciesTable");
static_assert(sizeof(FGOP_BattleRoad_MonsterSpeciesTable) == 0x000090, "Wrong size on FGOP_BattleRoad_MonsterSpeciesTable");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, SpeciesId) == 0x000010, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::SpeciesId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, SpeciesOrder) == 0x000018, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::SpeciesOrder' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_jp) == 0x00001C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_jp' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_tw) == 0x000020, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_tw' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_cn) == 0x000024, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_cn' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_ko) == 0x000028, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_ko' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_en) == 0x00002C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_en' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_fr) == 0x000030, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_fr' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_it) == 0x000034, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_it' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_de) == 0x000038, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_de' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_es) == 0x00003C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_es' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, ABCOrder_es419) == 0x000040, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::ABCOrder_es419' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBRMonsterId01) == 0x000044, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBRMonsterId01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBRMonsterId02) == 0x00004C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBRMonsterId02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBRMonsterId03) == 0x000054, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBRMonsterId03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBRMonsterId04) == 0x00005C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBRMonsterId04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBRMonsterId05) == 0x000064, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBRMonsterId05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, DefaultTactics) == 0x00006C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::DefaultTactics' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBR_Offset) == 0x000070, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBR_Offset' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, MBR_Scale) == 0x000078, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::MBR_Scale' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, Battle_Offset) == 0x00007C, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::Battle_Offset' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, Battle_Scale) == 0x000084, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::Battle_Scale' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_MonsterSpeciesTable, RecruitMessagePattern) == 0x000088, "Member 'FGOP_BattleRoad_MonsterSpeciesTable::RecruitMessagePattern' has a wrong offset!");

// ScriptStruct Nicola.GlowRand
// 0x0008 (0x0008 - 0x0000)
struct FGlowRand final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlowRand) == 0x000004, "Wrong alignment on FGlowRand");
static_assert(sizeof(FGlowRand) == 0x000008, "Wrong size on FGlowRand");
static_assert(offsetof(FGlowRand, Min) == 0x000000, "Member 'FGlowRand::Min' has a wrong offset!");
static_assert(offsetof(FGlowRand, Max) == 0x000004, "Member 'FGlowRand::Max' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_RankTable
// 0x00F8 (0x0100 - 0x0008)
struct FGOP_BattleRoad_RankTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameTextId;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionRank;                                     // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntryFee;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearPrize;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinningPrize;                                      // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId01;                                          // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum01;                                         // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask01;                                        // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId02;                                          // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum02;                                         // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask02;                                        // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId03;                                          // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum03;                                         // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask03;                                        // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId04;                                          // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum04;                                         // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask04;                                        // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId05;                                          // 0x006C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum05;                                         // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask05;                                        // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId06;                                          // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum06;                                         // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask06;                                        // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId07;                                          // 0x008C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum07;                                         // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemMask07;                                        // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GroupSet01;                                        // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleBGM01;                                       // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupSet02;                                        // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleBGM02;                                       // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupSet03;                                        // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleBGM03;                                       // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupSet04;                                        // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleBGM04;                                       // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_BattleRoad_RankTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_RankTable");
static_assert(sizeof(FGOP_BattleRoad_RankTable) == 0x000100, "Wrong size on FGOP_BattleRoad_RankTable");
static_assert(offsetof(FGOP_BattleRoad_RankTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_RankTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, NameTextId) == 0x000010, "Member 'FGOP_BattleRoad_RankTable::NameTextId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ConditionRank) == 0x000018, "Member 'FGOP_BattleRoad_RankTable::ConditionRank' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, EntryFee) == 0x000020, "Member 'FGOP_BattleRoad_RankTable::EntryFee' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ClearPrize) == 0x000024, "Member 'FGOP_BattleRoad_RankTable::ClearPrize' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, WinningPrize) == 0x000028, "Member 'FGOP_BattleRoad_RankTable::WinningPrize' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId01) == 0x00002C, "Member 'FGOP_BattleRoad_RankTable::ItemId01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum01) == 0x000034, "Member 'FGOP_BattleRoad_RankTable::ItemNum01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask01) == 0x000038, "Member 'FGOP_BattleRoad_RankTable::ItemMask01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId02) == 0x00003C, "Member 'FGOP_BattleRoad_RankTable::ItemId02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum02) == 0x000044, "Member 'FGOP_BattleRoad_RankTable::ItemNum02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask02) == 0x000048, "Member 'FGOP_BattleRoad_RankTable::ItemMask02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId03) == 0x00004C, "Member 'FGOP_BattleRoad_RankTable::ItemId03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum03) == 0x000054, "Member 'FGOP_BattleRoad_RankTable::ItemNum03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask03) == 0x000058, "Member 'FGOP_BattleRoad_RankTable::ItemMask03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId04) == 0x00005C, "Member 'FGOP_BattleRoad_RankTable::ItemId04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum04) == 0x000064, "Member 'FGOP_BattleRoad_RankTable::ItemNum04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask04) == 0x000068, "Member 'FGOP_BattleRoad_RankTable::ItemMask04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId05) == 0x00006C, "Member 'FGOP_BattleRoad_RankTable::ItemId05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum05) == 0x000074, "Member 'FGOP_BattleRoad_RankTable::ItemNum05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask05) == 0x000078, "Member 'FGOP_BattleRoad_RankTable::ItemMask05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId06) == 0x00007C, "Member 'FGOP_BattleRoad_RankTable::ItemId06' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum06) == 0x000084, "Member 'FGOP_BattleRoad_RankTable::ItemNum06' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask06) == 0x000088, "Member 'FGOP_BattleRoad_RankTable::ItemMask06' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemId07) == 0x00008C, "Member 'FGOP_BattleRoad_RankTable::ItemId07' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemNum07) == 0x000094, "Member 'FGOP_BattleRoad_RankTable::ItemNum07' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, ItemMask07) == 0x000098, "Member 'FGOP_BattleRoad_RankTable::ItemMask07' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, GroupSet01) == 0x0000A0, "Member 'FGOP_BattleRoad_RankTable::GroupSet01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, BattleBGM01) == 0x0000B0, "Member 'FGOP_BattleRoad_RankTable::BattleBGM01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, GroupSet02) == 0x0000B8, "Member 'FGOP_BattleRoad_RankTable::GroupSet02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, BattleBGM02) == 0x0000C8, "Member 'FGOP_BattleRoad_RankTable::BattleBGM02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, GroupSet03) == 0x0000D0, "Member 'FGOP_BattleRoad_RankTable::GroupSet03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, BattleBGM03) == 0x0000E0, "Member 'FGOP_BattleRoad_RankTable::BattleBGM03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, GroupSet04) == 0x0000E8, "Member 'FGOP_BattleRoad_RankTable::GroupSet04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RankTable, BattleBGM04) == 0x0000F8, "Member 'FGOP_BattleRoad_RankTable::BattleBGM04' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_RewardTable
// 0x0090 (0x0098 - 0x0008)
struct FGOP_BattleRoad_RewardTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterNum;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardTextId;                                      // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId01;                                          // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum01;                                         // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId02;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum02;                                         // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId03;                                          // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum03;                                         // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId04;                                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum04;                                         // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId05;                                          // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum05;                                         // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId06;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum06;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId07;                                          // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum07;                                         // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId08;                                          // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum08;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId09;                                          // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum09;                                         // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId10;                                          // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum10;                                         // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_BattleRoad_RewardTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_RewardTable");
static_assert(sizeof(FGOP_BattleRoad_RewardTable) == 0x000098, "Wrong size on FGOP_BattleRoad_RewardTable");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_RewardTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, MonsterNum) == 0x000010, "Member 'FGOP_BattleRoad_RewardTable::MonsterNum' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, RewardTextId) == 0x000014, "Member 'FGOP_BattleRoad_RewardTable::RewardTextId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId01) == 0x00001C, "Member 'FGOP_BattleRoad_RewardTable::ItemId01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum01) == 0x000024, "Member 'FGOP_BattleRoad_RewardTable::ItemNum01' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId02) == 0x000028, "Member 'FGOP_BattleRoad_RewardTable::ItemId02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum02) == 0x000030, "Member 'FGOP_BattleRoad_RewardTable::ItemNum02' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId03) == 0x000034, "Member 'FGOP_BattleRoad_RewardTable::ItemId03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum03) == 0x00003C, "Member 'FGOP_BattleRoad_RewardTable::ItemNum03' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId04) == 0x000040, "Member 'FGOP_BattleRoad_RewardTable::ItemId04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum04) == 0x000048, "Member 'FGOP_BattleRoad_RewardTable::ItemNum04' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId05) == 0x00004C, "Member 'FGOP_BattleRoad_RewardTable::ItemId05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum05) == 0x000054, "Member 'FGOP_BattleRoad_RewardTable::ItemNum05' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId06) == 0x000058, "Member 'FGOP_BattleRoad_RewardTable::ItemId06' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum06) == 0x000060, "Member 'FGOP_BattleRoad_RewardTable::ItemNum06' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId07) == 0x000064, "Member 'FGOP_BattleRoad_RewardTable::ItemId07' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum07) == 0x00006C, "Member 'FGOP_BattleRoad_RewardTable::ItemNum07' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId08) == 0x000070, "Member 'FGOP_BattleRoad_RewardTable::ItemId08' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum08) == 0x000078, "Member 'FGOP_BattleRoad_RewardTable::ItemNum08' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId09) == 0x00007C, "Member 'FGOP_BattleRoad_RewardTable::ItemId09' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum09) == 0x000084, "Member 'FGOP_BattleRoad_RewardTable::ItemNum09' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemId10) == 0x000088, "Member 'FGOP_BattleRoad_RewardTable::ItemId10' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_RewardTable, ItemNum10) == 0x000090, "Member 'FGOP_BattleRoad_RewardTable::ItemNum10' has a wrong offset!");

// ScriptStruct Nicola.TrajectoryTypeData
// 0x0048 (0x0048 - 0x0000)
struct FTrajectoryTypeData final
{
public:
	float                                         HeightAdjustStartPoint;                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAdjustEndPoint;                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectSpawnSpanSec;                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectSpeed;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainSecAfterLand;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucencySortPriority;                          // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryOrbitBlockType                     TrajectoryOrbitBlockType;                          // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         Particle;                                          // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrajectoryTypeData) == 0x000008, "Wrong alignment on FTrajectoryTypeData");
static_assert(sizeof(FTrajectoryTypeData) == 0x000048, "Wrong size on FTrajectoryTypeData");
static_assert(offsetof(FTrajectoryTypeData, HeightAdjustStartPoint) == 0x000000, "Member 'FTrajectoryTypeData::HeightAdjustStartPoint' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, HeightAdjustEndPoint) == 0x000004, "Member 'FTrajectoryTypeData::HeightAdjustEndPoint' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, EffectSpawnSpanSec) == 0x000008, "Member 'FTrajectoryTypeData::EffectSpawnSpanSec' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, EffectSpeed) == 0x00000C, "Member 'FTrajectoryTypeData::EffectSpeed' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, RemainSecAfterLand) == 0x000010, "Member 'FTrajectoryTypeData::RemainSecAfterLand' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, TranslucencySortPriority) == 0x000014, "Member 'FTrajectoryTypeData::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, TrajectoryOrbitBlockType) == 0x000018, "Member 'FTrajectoryTypeData::TrajectoryOrbitBlockType' has a wrong offset!");
static_assert(offsetof(FTrajectoryTypeData, Particle) == 0x000020, "Member 'FTrajectoryTypeData::Particle' has a wrong offset!");

// ScriptStruct Nicola.GOP_BattleRoad_ScoutTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_BattleRoad_ScoutTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBRMonsterSpeciesId;                               // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisguiseUnitMasterId;                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAppearDaytime;                                   // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAppearEvening;                                   // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAppearNight;                                     // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AppearanceTownId;                                  // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMBRScoutConditionType                        ScoutCondition;                                    // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x1];                                       // 0x002D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGOPEnumProgressType                          EnableProgressFlag;                                // 0x002E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableProgressFlagCondition;                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x1];                                       // 0x0031(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGOPEnumMBRType                               MBRScoutFlag;                                      // 0x0032(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_BattleRoad_ScoutTable) == 0x000008, "Wrong alignment on FGOP_BattleRoad_ScoutTable");
static_assert(sizeof(FGOP_BattleRoad_ScoutTable) == 0x000038, "Wrong size on FGOP_BattleRoad_ScoutTable");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, SelfId) == 0x000008, "Member 'FGOP_BattleRoad_ScoutTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, MBRMonsterSpeciesId) == 0x000010, "Member 'FGOP_BattleRoad_ScoutTable::MBRMonsterSpeciesId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, DisguiseUnitMasterId) == 0x000018, "Member 'FGOP_BattleRoad_ScoutTable::DisguiseUnitMasterId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, IsAppearDaytime) == 0x000020, "Member 'FGOP_BattleRoad_ScoutTable::IsAppearDaytime' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, IsAppearEvening) == 0x000021, "Member 'FGOP_BattleRoad_ScoutTable::IsAppearEvening' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, IsAppearNight) == 0x000022, "Member 'FGOP_BattleRoad_ScoutTable::IsAppearNight' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, AppearanceTownId) == 0x000024, "Member 'FGOP_BattleRoad_ScoutTable::AppearanceTownId' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, ScoutCondition) == 0x00002C, "Member 'FGOP_BattleRoad_ScoutTable::ScoutCondition' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, EnableProgressFlag) == 0x00002E, "Member 'FGOP_BattleRoad_ScoutTable::EnableProgressFlag' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, EnableProgressFlagCondition) == 0x000030, "Member 'FGOP_BattleRoad_ScoutTable::EnableProgressFlagCondition' has a wrong offset!");
static_assert(offsetof(FGOP_BattleRoad_ScoutTable, MBRScoutFlag) == 0x000032, "Member 'FGOP_BattleRoad_ScoutTable::MBRScoutFlag' has a wrong offset!");

// ScriptStruct Nicola.GOP_CharacterMaterialTable
// 0x0080 (0x0088 - 0x0008)
struct FGOP_CharacterMaterialTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OpacityName;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityMax;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseColorChange;                                    // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Custom1Name;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom1Start;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom1End;                                        // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Custom2Name;                                       // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom2Start;                                      // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom2End;                                        // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Custom3Name;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom3Start;                                      // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom3End;                                        // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Custom4Name;                                       // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom4Start;                                      // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Custom4End;                                        // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_CharacterMaterialTable) == 0x000008, "Wrong alignment on FGOP_CharacterMaterialTable");
static_assert(sizeof(FGOP_CharacterMaterialTable) == 0x000088, "Wrong size on FGOP_CharacterMaterialTable");
static_assert(offsetof(FGOP_CharacterMaterialTable, SelfId) == 0x000008, "Member 'FGOP_CharacterMaterialTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, OpacityName) == 0x000010, "Member 'FGOP_CharacterMaterialTable::OpacityName' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, OpacityMax) == 0x000020, "Member 'FGOP_CharacterMaterialTable::OpacityMax' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, UseColorChange) == 0x000024, "Member 'FGOP_CharacterMaterialTable::UseColorChange' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom1Name) == 0x000028, "Member 'FGOP_CharacterMaterialTable::Custom1Name' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom1Start) == 0x000038, "Member 'FGOP_CharacterMaterialTable::Custom1Start' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom1End) == 0x00003C, "Member 'FGOP_CharacterMaterialTable::Custom1End' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom2Name) == 0x000040, "Member 'FGOP_CharacterMaterialTable::Custom2Name' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom2Start) == 0x000050, "Member 'FGOP_CharacterMaterialTable::Custom2Start' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom2End) == 0x000054, "Member 'FGOP_CharacterMaterialTable::Custom2End' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom3Name) == 0x000058, "Member 'FGOP_CharacterMaterialTable::Custom3Name' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom3Start) == 0x000068, "Member 'FGOP_CharacterMaterialTable::Custom3Start' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom3End) == 0x00006C, "Member 'FGOP_CharacterMaterialTable::Custom3End' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom4Name) == 0x000070, "Member 'FGOP_CharacterMaterialTable::Custom4Name' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom4Start) == 0x000080, "Member 'FGOP_CharacterMaterialTable::Custom4Start' has a wrong offset!");
static_assert(offsetof(FGOP_CharacterMaterialTable, Custom4End) == 0x000084, "Member 'FGOP_CharacterMaterialTable::Custom4End' has a wrong offset!");

// ScriptStruct Nicola.UIMBRMatchInfo
// 0x0038 (0x0038 - 0x0000)
struct FUIMBRMatchInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           EncountGroups;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMBRMatchInfo) == 0x000008, "Wrong alignment on FUIMBRMatchInfo");
static_assert(sizeof(FUIMBRMatchInfo) == 0x000038, "Wrong size on FUIMBRMatchInfo");
static_assert(offsetof(FUIMBRMatchInfo, EncountGroups) == 0x000018, "Member 'FUIMBRMatchInfo::EncountGroups' has a wrong offset!");

// ScriptStruct Nicola.UIMBRRankRewardInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FUIMBRRankRewardInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMBRRankRewardInfo) == 0x000004, "Wrong alignment on FUIMBRRankRewardInfo");
static_assert(sizeof(FUIMBRRankRewardInfo) == 0x00001C, "Wrong size on FUIMBRRankRewardInfo");

// ScriptStruct Nicola.UIMBRRankInfo
// 0x0050 (0x0050 - 0x0000)
struct FUIMBRRankInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EncountGroups;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIMBRRankRewardInfo>           Rewards;                                           // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMBRRankInfo) == 0x000008, "Wrong alignment on FUIMBRRankInfo");
static_assert(sizeof(FUIMBRRankInfo) == 0x000050, "Wrong size on FUIMBRRankInfo");
static_assert(offsetof(FUIMBRRankInfo, EncountGroups) == 0x000028, "Member 'FUIMBRRankInfo::EncountGroups' has a wrong offset!");
static_assert(offsetof(FUIMBRRankInfo, Rewards) == 0x000040, "Member 'FUIMBRRankInfo::Rewards' has a wrong offset!");

// ScriptStruct Nicola.UIBattleRoadStorage
// 0x0098 (0x0098 - 0x0000)
struct FUIBattleRoadStorage final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMBRMatchInfo                        Match;                                             // 0x0020(0x0038)(NativeAccessSpecifierPublic)
	TArray<struct FUIMBRRankInfo>                 Ranks;                                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UUIMBRBuddyInfo*>                Buddys;                                            // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UUIMBRBuddyInfo*>                Partys;                                            // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleRoadStorage) == 0x000008, "Wrong alignment on FUIBattleRoadStorage");
static_assert(sizeof(FUIBattleRoadStorage) == 0x000098, "Wrong size on FUIBattleRoadStorage");
static_assert(offsetof(FUIBattleRoadStorage, Match) == 0x000020, "Member 'FUIBattleRoadStorage::Match' has a wrong offset!");
static_assert(offsetof(FUIBattleRoadStorage, Ranks) == 0x000058, "Member 'FUIBattleRoadStorage::Ranks' has a wrong offset!");
static_assert(offsetof(FUIBattleRoadStorage, Buddys) == 0x000068, "Member 'FUIBattleRoadStorage::Buddys' has a wrong offset!");
static_assert(offsetof(FUIBattleRoadStorage, Partys) == 0x000078, "Member 'FUIBattleRoadStorage::Partys' has a wrong offset!");

// ScriptStruct Nicola.GOP_ChurchTable
// 0x01D0 (0x01D8 - 0x0008)
struct FGOP_ChurchTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcTypeName;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSave;                                           // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanNextLevel;                                      // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FloorID;                                           // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerStartTag;                                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RestartDir;                                        // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_0;                                            // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_1;                                            // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_2;                                            // 0x0054(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_3;                                            // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_4;                                            // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_5;                                            // 0x006C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_6;                                            // 0x0074(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_7;                                            // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_8;                                            // 0x0084(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_9;                                            // 0x008C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_10;                                           // 0x0094(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_11;                                           // 0x009C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_12;                                           // 0x00A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_13;                                           // 0x00AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_14;                                           // 0x00B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_15;                                           // 0x00BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_16;                                           // 0x00C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_17;                                           // 0x00CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_18;                                           // 0x00D4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_19;                                           // 0x00DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_20;                                           // 0x00E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_21;                                           // 0x00EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_22;                                           // 0x00F4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_23;                                           // 0x00FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_24;                                           // 0x0104(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_25;                                           // 0x010C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_26;                                           // 0x0114(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_27;                                           // 0x011C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_28;                                           // 0x0124(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_29;                                           // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_30;                                           // 0x0134(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_31;                                           // 0x013C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_32;                                           // 0x0144(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_33;                                           // 0x014C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_34;                                           // 0x0154(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_35;                                           // 0x015C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_36;                                           // 0x0164(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_37;                                           // 0x016C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_38;                                           // 0x0174(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_39;                                           // 0x017C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_40;                                           // 0x0184(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_41;                                           // 0x018C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_42;                                           // 0x0194(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_43;                                           // 0x019C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_44;                                           // 0x01A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_45;                                           // 0x01AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_46;                                           // 0x01B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_47;                                           // 0x01BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_48;                                           // 0x01C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_49;                                           // 0x01CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_ChurchTable) == 0x000008, "Wrong alignment on FGOP_ChurchTable");
static_assert(sizeof(FGOP_ChurchTable) == 0x0001D8, "Wrong size on FGOP_ChurchTable");
static_assert(offsetof(FGOP_ChurchTable, SelfId) == 0x000008, "Member 'FGOP_ChurchTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, AreaName) == 0x000010, "Member 'FGOP_ChurchTable::AreaName' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, NpcTypeName) == 0x000018, "Member 'FGOP_ChurchTable::NpcTypeName' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, CanSave) == 0x000020, "Member 'FGOP_ChurchTable::CanSave' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, CanNextLevel) == 0x000021, "Member 'FGOP_ChurchTable::CanNextLevel' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, FloorID) == 0x000024, "Member 'FGOP_ChurchTable::FloorID' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, PlayerStartTag) == 0x000030, "Member 'FGOP_ChurchTable::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, RestartDir) == 0x000040, "Member 'FGOP_ChurchTable::RestartDir' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_0) == 0x000044, "Member 'FGOP_ChurchTable::Talk_0' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_1) == 0x00004C, "Member 'FGOP_ChurchTable::Talk_1' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_2) == 0x000054, "Member 'FGOP_ChurchTable::Talk_2' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_3) == 0x00005C, "Member 'FGOP_ChurchTable::Talk_3' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_4) == 0x000064, "Member 'FGOP_ChurchTable::Talk_4' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_5) == 0x00006C, "Member 'FGOP_ChurchTable::Talk_5' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_6) == 0x000074, "Member 'FGOP_ChurchTable::Talk_6' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_7) == 0x00007C, "Member 'FGOP_ChurchTable::Talk_7' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_8) == 0x000084, "Member 'FGOP_ChurchTable::Talk_8' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_9) == 0x00008C, "Member 'FGOP_ChurchTable::Talk_9' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_10) == 0x000094, "Member 'FGOP_ChurchTable::Talk_10' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_11) == 0x00009C, "Member 'FGOP_ChurchTable::Talk_11' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_12) == 0x0000A4, "Member 'FGOP_ChurchTable::Talk_12' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_13) == 0x0000AC, "Member 'FGOP_ChurchTable::Talk_13' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_14) == 0x0000B4, "Member 'FGOP_ChurchTable::Talk_14' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_15) == 0x0000BC, "Member 'FGOP_ChurchTable::Talk_15' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_16) == 0x0000C4, "Member 'FGOP_ChurchTable::Talk_16' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_17) == 0x0000CC, "Member 'FGOP_ChurchTable::Talk_17' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_18) == 0x0000D4, "Member 'FGOP_ChurchTable::Talk_18' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_19) == 0x0000DC, "Member 'FGOP_ChurchTable::Talk_19' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_20) == 0x0000E4, "Member 'FGOP_ChurchTable::Talk_20' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_21) == 0x0000EC, "Member 'FGOP_ChurchTable::Talk_21' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_22) == 0x0000F4, "Member 'FGOP_ChurchTable::Talk_22' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_23) == 0x0000FC, "Member 'FGOP_ChurchTable::Talk_23' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_24) == 0x000104, "Member 'FGOP_ChurchTable::Talk_24' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_25) == 0x00010C, "Member 'FGOP_ChurchTable::Talk_25' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_26) == 0x000114, "Member 'FGOP_ChurchTable::Talk_26' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_27) == 0x00011C, "Member 'FGOP_ChurchTable::Talk_27' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_28) == 0x000124, "Member 'FGOP_ChurchTable::Talk_28' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_29) == 0x00012C, "Member 'FGOP_ChurchTable::Talk_29' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_30) == 0x000134, "Member 'FGOP_ChurchTable::Talk_30' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_31) == 0x00013C, "Member 'FGOP_ChurchTable::Talk_31' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_32) == 0x000144, "Member 'FGOP_ChurchTable::Talk_32' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_33) == 0x00014C, "Member 'FGOP_ChurchTable::Talk_33' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_34) == 0x000154, "Member 'FGOP_ChurchTable::Talk_34' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_35) == 0x00015C, "Member 'FGOP_ChurchTable::Talk_35' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_36) == 0x000164, "Member 'FGOP_ChurchTable::Talk_36' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_37) == 0x00016C, "Member 'FGOP_ChurchTable::Talk_37' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_38) == 0x000174, "Member 'FGOP_ChurchTable::Talk_38' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_39) == 0x00017C, "Member 'FGOP_ChurchTable::Talk_39' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_40) == 0x000184, "Member 'FGOP_ChurchTable::Talk_40' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_41) == 0x00018C, "Member 'FGOP_ChurchTable::Talk_41' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_42) == 0x000194, "Member 'FGOP_ChurchTable::Talk_42' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_43) == 0x00019C, "Member 'FGOP_ChurchTable::Talk_43' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_44) == 0x0001A4, "Member 'FGOP_ChurchTable::Talk_44' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_45) == 0x0001AC, "Member 'FGOP_ChurchTable::Talk_45' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_46) == 0x0001B4, "Member 'FGOP_ChurchTable::Talk_46' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_47) == 0x0001BC, "Member 'FGOP_ChurchTable::Talk_47' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_48) == 0x0001C4, "Member 'FGOP_ChurchTable::Talk_48' has a wrong offset!");
static_assert(offsetof(FGOP_ChurchTable, Talk_49) == 0x0001CC, "Member 'FGOP_ChurchTable::Talk_49' has a wrong offset!");

// ScriptStruct Nicola.GOP_CommonDummyDefine
// 0x0001 (0x0001 - 0x0000)
struct FGOP_CommonDummyDefine final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_CommonDummyDefine) == 0x000001, "Wrong alignment on FGOP_CommonDummyDefine");
static_assert(sizeof(FGOP_CommonDummyDefine) == 0x000001, "Wrong size on FGOP_CommonDummyDefine");

// ScriptStruct Nicola.SkillParamRangeValue
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSkillParamRangeValue final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillParamRangeValue) == 0x000004, "Wrong alignment on FSkillParamRangeValue");
static_assert(sizeof(FSkillParamRangeValue) == 0x00000C, "Wrong size on FSkillParamRangeValue");

// ScriptStruct Nicola.GOP_DlcTable
// 0x00E8 (0x00F0 - 0x0008)
struct FGOP_DlcTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDlcType                                      DlcType;                                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AppIDSwitch;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppIDXSX;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppIDSteam;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AppIDPS5JP;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppIDPS5NA;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppIDPS5EU;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppIDPS5ASIA;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DlcName;                                           // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item00;                                            // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum00;                                         // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item01;                                            // 0x0084(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum01;                                         // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item02;                                            // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum02;                                         // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item03;                                            // 0x009C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum03;                                         // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item04;                                            // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum04;                                         // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item05;                                            // 0x00B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum05;                                         // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item06;                                            // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum06;                                         // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item07;                                            // 0x00CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum07;                                         // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item08;                                            // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum08;                                         // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item09;                                            // 0x00E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum09;                                         // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_DlcTable) == 0x000008, "Wrong alignment on FGOP_DlcTable");
static_assert(sizeof(FGOP_DlcTable) == 0x0000F0, "Wrong size on FGOP_DlcTable");
static_assert(offsetof(FGOP_DlcTable, SelfId) == 0x000008, "Member 'FGOP_DlcTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, DlcType) == 0x000010, "Member 'FGOP_DlcTable::DlcType' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDSwitch) == 0x000014, "Member 'FGOP_DlcTable::AppIDSwitch' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDXSX) == 0x000018, "Member 'FGOP_DlcTable::AppIDXSX' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDSteam) == 0x000028, "Member 'FGOP_DlcTable::AppIDSteam' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDPS5JP) == 0x000030, "Member 'FGOP_DlcTable::AppIDPS5JP' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDPS5NA) == 0x000040, "Member 'FGOP_DlcTable::AppIDPS5NA' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDPS5EU) == 0x000050, "Member 'FGOP_DlcTable::AppIDPS5EU' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, AppIDPS5ASIA) == 0x000060, "Member 'FGOP_DlcTable::AppIDPS5ASIA' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, DlcName) == 0x000070, "Member 'FGOP_DlcTable::DlcName' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item00) == 0x000078, "Member 'FGOP_DlcTable::Item00' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum00) == 0x000080, "Member 'FGOP_DlcTable::ItemNum00' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item01) == 0x000084, "Member 'FGOP_DlcTable::Item01' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum01) == 0x00008C, "Member 'FGOP_DlcTable::ItemNum01' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item02) == 0x000090, "Member 'FGOP_DlcTable::Item02' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum02) == 0x000098, "Member 'FGOP_DlcTable::ItemNum02' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item03) == 0x00009C, "Member 'FGOP_DlcTable::Item03' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum03) == 0x0000A4, "Member 'FGOP_DlcTable::ItemNum03' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item04) == 0x0000A8, "Member 'FGOP_DlcTable::Item04' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum04) == 0x0000B0, "Member 'FGOP_DlcTable::ItemNum04' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item05) == 0x0000B4, "Member 'FGOP_DlcTable::Item05' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum05) == 0x0000BC, "Member 'FGOP_DlcTable::ItemNum05' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item06) == 0x0000C0, "Member 'FGOP_DlcTable::Item06' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum06) == 0x0000C8, "Member 'FGOP_DlcTable::ItemNum06' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item07) == 0x0000CC, "Member 'FGOP_DlcTable::Item07' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum07) == 0x0000D4, "Member 'FGOP_DlcTable::ItemNum07' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item08) == 0x0000D8, "Member 'FGOP_DlcTable::Item08' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum08) == 0x0000E0, "Member 'FGOP_DlcTable::ItemNum08' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, Item09) == 0x0000E4, "Member 'FGOP_DlcTable::Item09' has a wrong offset!");
static_assert(offsetof(FGOP_DlcTable, ItemNum09) == 0x0000EC, "Member 'FGOP_DlcTable::ItemNum09' has a wrong offset!");

// ScriptStruct Nicola.GOP_DoorListTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_DoorListTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldPosX;                                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldPosY;                                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EditUIPosX;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EditUIPosY;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumDoorType                              DoorUniqueId;                                      // 0x0028(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BoundsX;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoundsY;                                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_DoorListTable) == 0x000008, "Wrong alignment on FGOP_DoorListTable");
static_assert(sizeof(FGOP_DoorListTable) == 0x000038, "Wrong size on FGOP_DoorListTable");
static_assert(offsetof(FGOP_DoorListTable, SelfId) == 0x000008, "Member 'FGOP_DoorListTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, MapId) == 0x000010, "Member 'FGOP_DoorListTable::MapId' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, WorldPosX) == 0x000018, "Member 'FGOP_DoorListTable::WorldPosX' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, WorldPosY) == 0x00001C, "Member 'FGOP_DoorListTable::WorldPosY' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, EditUIPosX) == 0x000020, "Member 'FGOP_DoorListTable::EditUIPosX' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, EditUIPosY) == 0x000024, "Member 'FGOP_DoorListTable::EditUIPosY' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, DoorUniqueId) == 0x000028, "Member 'FGOP_DoorListTable::DoorUniqueId' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, BoundsX) == 0x00002C, "Member 'FGOP_DoorListTable::BoundsX' has a wrong offset!");
static_assert(offsetof(FGOP_DoorListTable, BoundsY) == 0x000030, "Member 'FGOP_DoorListTable::BoundsY' has a wrong offset!");

// ScriptStruct Nicola.FieldLevelManagerRequestParam
// 0x0018 (0x0018 - 0x0000)
struct FFieldLevelManagerRequestParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 symbol;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFieldLevelManagerRequestParam) == 0x000008, "Wrong alignment on FFieldLevelManagerRequestParam");
static_assert(sizeof(FFieldLevelManagerRequestParam) == 0x000018, "Wrong size on FFieldLevelManagerRequestParam");
static_assert(offsetof(FFieldLevelManagerRequestParam, symbol) == 0x000008, "Member 'FFieldLevelManagerRequestParam::symbol' has a wrong offset!");

// ScriptStruct Nicola.GOP_EchoFluteTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_EchoFluteTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorTag;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPrefixID;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrbColorType                                 OrbColor;                                          // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x1];                                       // 0x0031(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGOPEnumProgressType                          DispTriggerEventID;                                // 0x0032(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          CompleteTriggerEventID;                            // 0x0034(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_EchoFluteTable) == 0x000008, "Wrong alignment on FGOP_EchoFluteTable");
static_assert(sizeof(FGOP_EchoFluteTable) == 0x000038, "Wrong size on FGOP_EchoFluteTable");
static_assert(offsetof(FGOP_EchoFluteTable, SelfId) == 0x000008, "Member 'FGOP_EchoFluteTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_EchoFluteTable, ActorTag) == 0x000010, "Member 'FGOP_EchoFluteTable::ActorTag' has a wrong offset!");
static_assert(offsetof(FGOP_EchoFluteTable, MapPrefixID) == 0x000020, "Member 'FGOP_EchoFluteTable::MapPrefixID' has a wrong offset!");
static_assert(offsetof(FGOP_EchoFluteTable, OrbColor) == 0x000030, "Member 'FGOP_EchoFluteTable::OrbColor' has a wrong offset!");
static_assert(offsetof(FGOP_EchoFluteTable, DispTriggerEventID) == 0x000032, "Member 'FGOP_EchoFluteTable::DispTriggerEventID' has a wrong offset!");
static_assert(offsetof(FGOP_EchoFluteTable, CompleteTriggerEventID) == 0x000034, "Member 'FGOP_EchoFluteTable::CompleteTriggerEventID' has a wrong offset!");

// ScriptStruct Nicola.GOP_Effect_BattleTable
// 0x0058 (0x0060 - 0x0008)
struct FGOP_Effect_BattleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerSideEffectID;                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MonsterSideEffectID;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayUserSide;                                     // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttach;                                           // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CriticalEffectID;                                  // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitEffectID;                                       // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectLocationType                     PlayerSideEffectLocationType;                      // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectLocationType                     MonsterSideEffectLocationType;                     // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectType                             PlayerEffectType;                                  // 0x005A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectType                             MonsterEffectType;                                 // 0x005B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectLocationType                     PlayerSideStartEffectLocationType;                 // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectLocationType                     MonsterSideStartEffectLocationType;                // 0x005D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Effect_BattleTable) == 0x000008, "Wrong alignment on FGOP_Effect_BattleTable");
static_assert(sizeof(FGOP_Effect_BattleTable) == 0x000060, "Wrong size on FGOP_Effect_BattleTable");
static_assert(offsetof(FGOP_Effect_BattleTable, SelfId) == 0x000008, "Member 'FGOP_Effect_BattleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, PlayerSideEffectID) == 0x000010, "Member 'FGOP_Effect_BattleTable::PlayerSideEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, MonsterSideEffectID) == 0x000020, "Member 'FGOP_Effect_BattleTable::MonsterSideEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, bPlayUserSide) == 0x000030, "Member 'FGOP_Effect_BattleTable::bPlayUserSide' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, bAttach) == 0x000031, "Member 'FGOP_Effect_BattleTable::bAttach' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, CriticalEffectID) == 0x000038, "Member 'FGOP_Effect_BattleTable::CriticalEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, HitEffectID) == 0x000048, "Member 'FGOP_Effect_BattleTable::HitEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, PlayerSideEffectLocationType) == 0x000058, "Member 'FGOP_Effect_BattleTable::PlayerSideEffectLocationType' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, MonsterSideEffectLocationType) == 0x000059, "Member 'FGOP_Effect_BattleTable::MonsterSideEffectLocationType' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, PlayerEffectType) == 0x00005A, "Member 'FGOP_Effect_BattleTable::PlayerEffectType' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, MonsterEffectType) == 0x00005B, "Member 'FGOP_Effect_BattleTable::MonsterEffectType' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, PlayerSideStartEffectLocationType) == 0x00005C, "Member 'FGOP_Effect_BattleTable::PlayerSideStartEffectLocationType' has a wrong offset!");
static_assert(offsetof(FGOP_Effect_BattleTable, MonsterSideStartEffectLocationType) == 0x00005D, "Member 'FGOP_Effect_BattleTable::MonsterSideStartEffectLocationType' has a wrong offset!");

// ScriptStruct Nicola.FlipbookCacheKey
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FFlipbookCacheKey final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlipbookCacheKey) == 0x000008, "Wrong alignment on FFlipbookCacheKey");
static_assert(sizeof(FFlipbookCacheKey) == 0x000020, "Wrong size on FFlipbookCacheKey");

// ScriptStruct Nicola.GOP_Encounter_AreaTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Encounter_AreaTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncounterCommonID;                                 // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncounterTerrainID;                                // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Encounter_AreaTable) == 0x000008, "Wrong alignment on FGOP_Encounter_AreaTable");
static_assert(sizeof(FGOP_Encounter_AreaTable) == 0x000020, "Wrong size on FGOP_Encounter_AreaTable");
static_assert(offsetof(FGOP_Encounter_AreaTable, SelfId) == 0x000008, "Member 'FGOP_Encounter_AreaTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_AreaTable, EncounterCommonID) == 0x000010, "Member 'FGOP_Encounter_AreaTable::EncounterCommonID' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_AreaTable, EncounterTerrainID) == 0x000018, "Member 'FGOP_Encounter_AreaTable::EncounterTerrainID' has a wrong offset!");

// ScriptStruct Nicola.GOP_Encounter_Area_GridTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_Encounter_Area_GridTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperGroundID;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperSeaID;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnderGroundID;                                     // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Encounter_Area_GridTable) == 0x000008, "Wrong alignment on FGOP_Encounter_Area_GridTable");
static_assert(sizeof(FGOP_Encounter_Area_GridTable) == 0x000028, "Wrong size on FGOP_Encounter_Area_GridTable");
static_assert(offsetof(FGOP_Encounter_Area_GridTable, SelfId) == 0x000008, "Member 'FGOP_Encounter_Area_GridTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_GridTable, UpperGroundID) == 0x000010, "Member 'FGOP_Encounter_Area_GridTable::UpperGroundID' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_GridTable, UpperSeaID) == 0x000018, "Member 'FGOP_Encounter_Area_GridTable::UpperSeaID' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_GridTable, UnderGroundID) == 0x000020, "Member 'FGOP_Encounter_Area_GridTable::UnderGroundID' has a wrong offset!");

// ScriptStruct Nicola.NicolaCameraRestrictInfo
// 0x0018 (0x0018 - 0x0000)
struct FNicolaCameraRestrictInfo final
{
public:
	float                                         minYaw;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxYaw;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         minPitch;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaCameraRestrictInfo) == 0x000004, "Wrong alignment on FNicolaCameraRestrictInfo");
static_assert(sizeof(FNicolaCameraRestrictInfo) == 0x000018, "Wrong size on FNicolaCameraRestrictInfo");
static_assert(offsetof(FNicolaCameraRestrictInfo, minYaw) == 0x000000, "Member 'FNicolaCameraRestrictInfo::minYaw' has a wrong offset!");
static_assert(offsetof(FNicolaCameraRestrictInfo, maxYaw) == 0x000004, "Member 'FNicolaCameraRestrictInfo::maxYaw' has a wrong offset!");
static_assert(offsetof(FNicolaCameraRestrictInfo, minPitch) == 0x000008, "Member 'FNicolaCameraRestrictInfo::minPitch' has a wrong offset!");
static_assert(offsetof(FNicolaCameraRestrictInfo, MaxPitch) == 0x00000C, "Member 'FNicolaCameraRestrictInfo::MaxPitch' has a wrong offset!");
static_assert(offsetof(FNicolaCameraRestrictInfo, MinDistance) == 0x000010, "Member 'FNicolaCameraRestrictInfo::MinDistance' has a wrong offset!");
static_assert(offsetof(FNicolaCameraRestrictInfo, MaxDistance) == 0x000014, "Member 'FNicolaCameraRestrictInfo::MaxDistance' has a wrong offset!");

// ScriptStruct Nicola.GOP_Encounter_Area_SubTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_Encounter_Area_SubTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X0;                                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y0;                                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X1;                                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y1;                                                // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaID;                                            // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Encounter_Area_SubTable) == 0x000008, "Wrong alignment on FGOP_Encounter_Area_SubTable");
static_assert(sizeof(FGOP_Encounter_Area_SubTable) == 0x000030, "Wrong size on FGOP_Encounter_Area_SubTable");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, SelfId) == 0x000008, "Member 'FGOP_Encounter_Area_SubTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, X0) == 0x000010, "Member 'FGOP_Encounter_Area_SubTable::X0' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, Y0) == 0x000014, "Member 'FGOP_Encounter_Area_SubTable::Y0' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, X1) == 0x000018, "Member 'FGOP_Encounter_Area_SubTable::X1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, Y1) == 0x00001C, "Member 'FGOP_Encounter_Area_SubTable::Y1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, Priority) == 0x000020, "Member 'FGOP_Encounter_Area_SubTable::Priority' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_Area_SubTable, AreaID) == 0x000024, "Member 'FGOP_Encounter_Area_SubTable::AreaID' has a wrong offset!");

// ScriptStruct Nicola.GOP_Encounter_CommonTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_Encounter_CommonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPreemptive;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyPreemptive;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTime;                                           // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetTime;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaLevel;                                         // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EncounterTableSetID;                               // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Encounter_CommonTable) == 0x000008, "Wrong alignment on FGOP_Encounter_CommonTable");
static_assert(sizeof(FGOP_Encounter_CommonTable) == 0x000038, "Wrong size on FGOP_Encounter_CommonTable");
static_assert(offsetof(FGOP_Encounter_CommonTable, SelfId) == 0x000008, "Member 'FGOP_Encounter_CommonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, PlayerPreemptive) == 0x000010, "Member 'FGOP_Encounter_CommonTable::PlayerPreemptive' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, EnemyPreemptive) == 0x000014, "Member 'FGOP_Encounter_CommonTable::EnemyPreemptive' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, MinTime) == 0x000018, "Member 'FGOP_Encounter_CommonTable::MinTime' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, MaxTime) == 0x00001C, "Member 'FGOP_Encounter_CommonTable::MaxTime' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, OffsetTime) == 0x000020, "Member 'FGOP_Encounter_CommonTable::OffsetTime' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, AreaLevel) == 0x000024, "Member 'FGOP_Encounter_CommonTable::AreaLevel' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_CommonTable, EncounterTableSetID) == 0x000028, "Member 'FGOP_Encounter_CommonTable::EncounterTableSetID' has a wrong offset!");

// ScriptStruct Nicola.UITextureLoadParam
// 0x0058 (0x0058 - 0x0000)
struct FUITextureLoadParam final
{
public:
	TSoftObjectPtr<class UTexture2D>              SoftPtr;                                           // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUITextureLoadParam) == 0x000008, "Wrong alignment on FUITextureLoadParam");
static_assert(sizeof(FUITextureLoadParam) == 0x000058, "Wrong size on FUITextureLoadParam");
static_assert(offsetof(FUITextureLoadParam, SoftPtr) == 0x000000, "Member 'FUITextureLoadParam::SoftPtr' has a wrong offset!");
static_assert(offsetof(FUITextureLoadParam, Texture) == 0x000028, "Member 'FUITextureLoadParam::Texture' has a wrong offset!");

// ScriptStruct Nicola.UITextureGroupData
// 0x0050 (0x0050 - 0x0000)
struct FUITextureGroupData final
{
public:
	TMap<class FName, struct FUITextureLoadParam> LoadParams;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FUITextureGroupData) == 0x000008, "Wrong alignment on FUITextureGroupData");
static_assert(sizeof(FUITextureGroupData) == 0x000050, "Wrong size on FUITextureGroupData");
static_assert(offsetof(FUITextureGroupData, LoadParams) == 0x000000, "Member 'FUITextureGroupData::LoadParams' has a wrong offset!");

// ScriptStruct Nicola.GOP_Encounter_MonsterTable
// 0x0168 (0x0170 - 0x0008)
struct FGOP_Encounter_MonsterTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EncounterTableSetID;                               // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 TimeFrame;                                         // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterId1;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount1;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupMarginWidth1;                                 // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterId2;                                        // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount2;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupMarginWidth2;                                 // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterId3;                                        // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount3;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupMarginWidth3;                                 // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterId4;                                        // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount4;                                     // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupMarginWidth4;                                 // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterId5;                                        // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount5;                                     // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupMarginWidth5;                                 // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceMonsterId;                                    // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtOffsetX;                                     // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlacePartyId1;                                     // 0x0084(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlacePartyId2;                                     // 0x008C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlacePartyId3;                                     // 0x0094(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlacePartyId4;                                     // 0x009C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraId1;                                         // 0x00A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraId2;                                         // 0x00AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraId3;                                         // 0x00B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraId4;                                         // 0x00BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceDragonId1;                                    // 0x00C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceDragonId2;                                    // 0x00CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceDragonId3;                                    // 0x00D4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceDragonId4;                                    // 0x00DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceDragonCommonId;                               // 0x00E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceNoDragonCommonId;                             // 0x00EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraDragonId1;                                   // 0x00F4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraDragonId2;                                   // 0x00FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraDragonId3;                                   // 0x0104(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraDragonId4;                                   // 0x010C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraDragonCommonId;                              // 0x0114(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceBattleRoadStartMonsterId;                     // 0x011C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraBattleRoadStartMonsterId;                    // 0x0124(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceBattleRoadStartPartyIdS;                      // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceBattleRoadStartPartyIdM;                      // 0x0134(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceBattleRoadStartPartyIdL;                      // 0x013C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceBattleRoadStartPartyIdXL;                     // 0x0144(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraBattleRoadStartPartyIdS;                     // 0x014C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraBattleRoadStartPartyIdM;                     // 0x0154(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraBattleRoadStartPartyIdL;                     // 0x015C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraBattleRoadStartPartyIdXL;                    // 0x0164(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Encounter_MonsterTable) == 0x000008, "Wrong alignment on FGOP_Encounter_MonsterTable");
static_assert(sizeof(FGOP_Encounter_MonsterTable) == 0x000170, "Wrong size on FGOP_Encounter_MonsterTable");
static_assert(offsetof(FGOP_Encounter_MonsterTable, SelfId) == 0x000008, "Member 'FGOP_Encounter_MonsterTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, EncounterTableSetID) == 0x000010, "Member 'FGOP_Encounter_MonsterTable::EncounterTableSetID' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, TimeFrame) == 0x000020, "Member 'FGOP_Encounter_MonsterTable::TimeFrame' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, Weight) == 0x000024, "Member 'FGOP_Encounter_MonsterTable::Weight' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterId1) == 0x000028, "Member 'FGOP_Encounter_MonsterTable::MonsterId1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterCount1) == 0x000030, "Member 'FGOP_Encounter_MonsterTable::MonsterCount1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, GroupMarginWidth1) == 0x000034, "Member 'FGOP_Encounter_MonsterTable::GroupMarginWidth1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterId2) == 0x000038, "Member 'FGOP_Encounter_MonsterTable::MonsterId2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterCount2) == 0x000040, "Member 'FGOP_Encounter_MonsterTable::MonsterCount2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, GroupMarginWidth2) == 0x000044, "Member 'FGOP_Encounter_MonsterTable::GroupMarginWidth2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterId3) == 0x000048, "Member 'FGOP_Encounter_MonsterTable::MonsterId3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterCount3) == 0x000050, "Member 'FGOP_Encounter_MonsterTable::MonsterCount3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, GroupMarginWidth3) == 0x000054, "Member 'FGOP_Encounter_MonsterTable::GroupMarginWidth3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterId4) == 0x000058, "Member 'FGOP_Encounter_MonsterTable::MonsterId4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterCount4) == 0x000060, "Member 'FGOP_Encounter_MonsterTable::MonsterCount4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, GroupMarginWidth4) == 0x000064, "Member 'FGOP_Encounter_MonsterTable::GroupMarginWidth4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterId5) == 0x000068, "Member 'FGOP_Encounter_MonsterTable::MonsterId5' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, MonsterCount5) == 0x000070, "Member 'FGOP_Encounter_MonsterTable::MonsterCount5' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, GroupMarginWidth5) == 0x000074, "Member 'FGOP_Encounter_MonsterTable::GroupMarginWidth5' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceMonsterId) == 0x000078, "Member 'FGOP_Encounter_MonsterTable::PlaceMonsterId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, LookAtOffsetX) == 0x000080, "Member 'FGOP_Encounter_MonsterTable::LookAtOffsetX' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlacePartyId1) == 0x000084, "Member 'FGOP_Encounter_MonsterTable::PlacePartyId1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlacePartyId2) == 0x00008C, "Member 'FGOP_Encounter_MonsterTable::PlacePartyId2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlacePartyId3) == 0x000094, "Member 'FGOP_Encounter_MonsterTable::PlacePartyId3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlacePartyId4) == 0x00009C, "Member 'FGOP_Encounter_MonsterTable::PlacePartyId4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraId1) == 0x0000A4, "Member 'FGOP_Encounter_MonsterTable::CameraId1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraId2) == 0x0000AC, "Member 'FGOP_Encounter_MonsterTable::CameraId2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraId3) == 0x0000B4, "Member 'FGOP_Encounter_MonsterTable::CameraId3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraId4) == 0x0000BC, "Member 'FGOP_Encounter_MonsterTable::CameraId4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceDragonId1) == 0x0000C4, "Member 'FGOP_Encounter_MonsterTable::PlaceDragonId1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceDragonId2) == 0x0000CC, "Member 'FGOP_Encounter_MonsterTable::PlaceDragonId2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceDragonId3) == 0x0000D4, "Member 'FGOP_Encounter_MonsterTable::PlaceDragonId3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceDragonId4) == 0x0000DC, "Member 'FGOP_Encounter_MonsterTable::PlaceDragonId4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceDragonCommonId) == 0x0000E4, "Member 'FGOP_Encounter_MonsterTable::PlaceDragonCommonId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceNoDragonCommonId) == 0x0000EC, "Member 'FGOP_Encounter_MonsterTable::PlaceNoDragonCommonId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraDragonId1) == 0x0000F4, "Member 'FGOP_Encounter_MonsterTable::CameraDragonId1' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraDragonId2) == 0x0000FC, "Member 'FGOP_Encounter_MonsterTable::CameraDragonId2' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraDragonId3) == 0x000104, "Member 'FGOP_Encounter_MonsterTable::CameraDragonId3' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraDragonId4) == 0x00010C, "Member 'FGOP_Encounter_MonsterTable::CameraDragonId4' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraDragonCommonId) == 0x000114, "Member 'FGOP_Encounter_MonsterTable::CameraDragonCommonId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceBattleRoadStartMonsterId) == 0x00011C, "Member 'FGOP_Encounter_MonsterTable::PlaceBattleRoadStartMonsterId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraBattleRoadStartMonsterId) == 0x000124, "Member 'FGOP_Encounter_MonsterTable::CameraBattleRoadStartMonsterId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceBattleRoadStartPartyIdS) == 0x00012C, "Member 'FGOP_Encounter_MonsterTable::PlaceBattleRoadStartPartyIdS' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceBattleRoadStartPartyIdM) == 0x000134, "Member 'FGOP_Encounter_MonsterTable::PlaceBattleRoadStartPartyIdM' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceBattleRoadStartPartyIdL) == 0x00013C, "Member 'FGOP_Encounter_MonsterTable::PlaceBattleRoadStartPartyIdL' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, PlaceBattleRoadStartPartyIdXL) == 0x000144, "Member 'FGOP_Encounter_MonsterTable::PlaceBattleRoadStartPartyIdXL' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraBattleRoadStartPartyIdS) == 0x00014C, "Member 'FGOP_Encounter_MonsterTable::CameraBattleRoadStartPartyIdS' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraBattleRoadStartPartyIdM) == 0x000154, "Member 'FGOP_Encounter_MonsterTable::CameraBattleRoadStartPartyIdM' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraBattleRoadStartPartyIdL) == 0x00015C, "Member 'FGOP_Encounter_MonsterTable::CameraBattleRoadStartPartyIdL' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_MonsterTable, CameraBattleRoadStartPartyIdXL) == 0x000164, "Member 'FGOP_Encounter_MonsterTable::CameraBattleRoadStartPartyIdXL' has a wrong offset!");

// ScriptStruct Nicola.GOP_Encounter_TerrainTable
// 0x0060 (0x0068 - 0x0008)
struct FGOP_Encounter_TerrainTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Plain;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Bush;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Forest;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Mountain;                                    // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Sand;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_PoisonSwamp;                                 // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Road;                                        // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Snow;                                        // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Beach;                                       // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_River;                                       // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId_Sea;                                         // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Encounter_TerrainTable) == 0x000008, "Wrong alignment on FGOP_Encounter_TerrainTable");
static_assert(sizeof(FGOP_Encounter_TerrainTable) == 0x000068, "Wrong size on FGOP_Encounter_TerrainTable");
static_assert(offsetof(FGOP_Encounter_TerrainTable, SelfId) == 0x000008, "Member 'FGOP_Encounter_TerrainTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Plain) == 0x000010, "Member 'FGOP_Encounter_TerrainTable::MapId_Plain' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Bush) == 0x000018, "Member 'FGOP_Encounter_TerrainTable::MapId_Bush' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Forest) == 0x000020, "Member 'FGOP_Encounter_TerrainTable::MapId_Forest' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Mountain) == 0x000028, "Member 'FGOP_Encounter_TerrainTable::MapId_Mountain' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Sand) == 0x000030, "Member 'FGOP_Encounter_TerrainTable::MapId_Sand' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_PoisonSwamp) == 0x000038, "Member 'FGOP_Encounter_TerrainTable::MapId_PoisonSwamp' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Road) == 0x000040, "Member 'FGOP_Encounter_TerrainTable::MapId_Road' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Snow) == 0x000048, "Member 'FGOP_Encounter_TerrainTable::MapId_Snow' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Beach) == 0x000050, "Member 'FGOP_Encounter_TerrainTable::MapId_Beach' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_River) == 0x000058, "Member 'FGOP_Encounter_TerrainTable::MapId_River' has a wrong offset!");
static_assert(offsetof(FGOP_Encounter_TerrainTable, MapId_Sea) == 0x000060, "Member 'FGOP_Encounter_TerrainTable::MapId_Sea' has a wrong offset!");

// ScriptStruct Nicola.NotifyEventOverlap
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FNotifyEventOverlap final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotifyEventOverlap) == 0x000008, "Wrong alignment on FNotifyEventOverlap");
static_assert(sizeof(FNotifyEventOverlap) == 0x000038, "Wrong size on FNotifyEventOverlap");

// ScriptStruct Nicola.GOP_Event_CommonTable
// 0x0050 (0x0058 - 0x0008)
struct FGOP_Event_CommonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventID;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventTriggerType                             TriggerType;                                       // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TriggerID;                                         // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventPriority;                                     // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressLower;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressUpper;                                     // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartFlagName1;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTrueCondition1;                                  // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAndOperation;                                    // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartFlagName2;                                    // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTrueCondition2;                                  // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScenarioProgress;                                  // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Event_CommonTable) == 0x000008, "Wrong alignment on FGOP_Event_CommonTable");
static_assert(sizeof(FGOP_Event_CommonTable) == 0x000058, "Wrong size on FGOP_Event_CommonTable");
static_assert(offsetof(FGOP_Event_CommonTable, SelfId) == 0x000008, "Member 'FGOP_Event_CommonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, EventID) == 0x000010, "Member 'FGOP_Event_CommonTable::EventID' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, TriggerType) == 0x000020, "Member 'FGOP_Event_CommonTable::TriggerType' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, TriggerID) == 0x000024, "Member 'FGOP_Event_CommonTable::TriggerID' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, EventPriority) == 0x00002C, "Member 'FGOP_Event_CommonTable::EventPriority' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, ProgressLower) == 0x000030, "Member 'FGOP_Event_CommonTable::ProgressLower' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, ProgressUpper) == 0x000034, "Member 'FGOP_Event_CommonTable::ProgressUpper' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, StartFlagName1) == 0x000038, "Member 'FGOP_Event_CommonTable::StartFlagName1' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, IsTrueCondition1) == 0x000040, "Member 'FGOP_Event_CommonTable::IsTrueCondition1' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, IsAndOperation) == 0x000041, "Member 'FGOP_Event_CommonTable::IsAndOperation' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, StartFlagName2) == 0x000044, "Member 'FGOP_Event_CommonTable::StartFlagName2' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, IsTrueCondition2) == 0x00004C, "Member 'FGOP_Event_CommonTable::IsTrueCondition2' has a wrong offset!");
static_assert(offsetof(FGOP_Event_CommonTable, ScenarioProgress) == 0x000050, "Member 'FGOP_Event_CommonTable::ScenarioProgress' has a wrong offset!");

// ScriptStruct Nicola.GOP_Event_ObjectTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Event_ObjectTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectPath;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Event_ObjectTable) == 0x000008, "Wrong alignment on FGOP_Event_ObjectTable");
static_assert(sizeof(FGOP_Event_ObjectTable) == 0x000020, "Wrong size on FGOP_Event_ObjectTable");
static_assert(offsetof(FGOP_Event_ObjectTable, SelfId) == 0x000008, "Member 'FGOP_Event_ObjectTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Event_ObjectTable, ObjectPath) == 0x000010, "Member 'FGOP_Event_ObjectTable::ObjectPath' has a wrong offset!");

// ScriptStruct Nicola.GOP_EventDebugListTable
// 0x00A8 (0x00B0 - 0x0008)
struct FGOP_EventDebugListTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventDescriptionTextID;                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlagSetTrue;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlagSetFalse;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlagSetProgress;                                   // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlagSetTrueEtc;                                    // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ValueSetEtc;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrerequisiteEventDebugSettings;                    // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RequireItems;                                      // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RemoveItems;                                       // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId;                                             // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerStartTag;                                    // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 MapTime;                                           // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_EventDebugListTable) == 0x000008, "Wrong alignment on FGOP_EventDebugListTable");
static_assert(sizeof(FGOP_EventDebugListTable) == 0x0000B0, "Wrong size on FGOP_EventDebugListTable");
static_assert(offsetof(FGOP_EventDebugListTable, SelfId) == 0x000008, "Member 'FGOP_EventDebugListTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, EventDescriptionTextID) == 0x000010, "Member 'FGOP_EventDebugListTable::EventDescriptionTextID' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, FlagSetTrue) == 0x000018, "Member 'FGOP_EventDebugListTable::FlagSetTrue' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, FlagSetFalse) == 0x000028, "Member 'FGOP_EventDebugListTable::FlagSetFalse' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, FlagSetProgress) == 0x000038, "Member 'FGOP_EventDebugListTable::FlagSetProgress' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, FlagSetTrueEtc) == 0x000048, "Member 'FGOP_EventDebugListTable::FlagSetTrueEtc' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, ValueSetEtc) == 0x000058, "Member 'FGOP_EventDebugListTable::ValueSetEtc' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, PrerequisiteEventDebugSettings) == 0x000068, "Member 'FGOP_EventDebugListTable::PrerequisiteEventDebugSettings' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, RequireItems) == 0x000078, "Member 'FGOP_EventDebugListTable::RequireItems' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, RemoveItems) == 0x000088, "Member 'FGOP_EventDebugListTable::RemoveItems' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, MapId) == 0x000098, "Member 'FGOP_EventDebugListTable::MapId' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, PlayerStartTag) == 0x0000A0, "Member 'FGOP_EventDebugListTable::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_EventDebugListTable, MapTime) == 0x0000A8, "Member 'FGOP_EventDebugListTable::MapTime' has a wrong offset!");

// ScriptStruct Nicola.GOP_EventScreenShotTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_EventScreenShotTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MapImage;                                          // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_EventScreenShotTable) == 0x000008, "Wrong alignment on FGOP_EventScreenShotTable");
static_assert(sizeof(FGOP_EventScreenShotTable) == 0x000038, "Wrong size on FGOP_EventScreenShotTable");
static_assert(offsetof(FGOP_EventScreenShotTable, SelfId) == 0x000008, "Member 'FGOP_EventScreenShotTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_EventScreenShotTable, MapImage) == 0x000010, "Member 'FGOP_EventScreenShotTable::MapImage' has a wrong offset!");

// ScriptStruct Nicola.EventInfo
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FEventInfo final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventInfo) == 0x000008, "Wrong alignment on FEventInfo");
static_assert(sizeof(FEventInfo) == 0x000058, "Wrong size on FEventInfo");

// ScriptStruct Nicola.GOP_FieldEfx2DTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_FieldEfx2DTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneShot;                                          // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SEId;                                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_FieldEfx2DTable) == 0x000008, "Wrong alignment on FGOP_FieldEfx2DTable");
static_assert(sizeof(FGOP_FieldEfx2DTable) == 0x000020, "Wrong size on FGOP_FieldEfx2DTable");
static_assert(offsetof(FGOP_FieldEfx2DTable, SelfId) == 0x000008, "Member 'FGOP_FieldEfx2DTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_FieldEfx2DTable, ItemId) == 0x000010, "Member 'FGOP_FieldEfx2DTable::ItemId' has a wrong offset!");
static_assert(offsetof(FGOP_FieldEfx2DTable, bOneShot) == 0x000014, "Member 'FGOP_FieldEfx2DTable::bOneShot' has a wrong offset!");
static_assert(offsetof(FGOP_FieldEfx2DTable, SEId) == 0x000018, "Member 'FGOP_FieldEfx2DTable::SEId' has a wrong offset!");

// ScriptStruct Nicola.GOP_FieldSymbolListTable
// 0x0008 (0x0010 - 0x0008)
struct FGOP_FieldSymbolListTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_FieldSymbolListTable) == 0x000008, "Wrong alignment on FGOP_FieldSymbolListTable");
static_assert(sizeof(FGOP_FieldSymbolListTable) == 0x000010, "Wrong size on FGOP_FieldSymbolListTable");
static_assert(offsetof(FGOP_FieldSymbolListTable, SelfId) == 0x000008, "Member 'FGOP_FieldSymbolListTable::SelfId' has a wrong offset!");

// ScriptStruct Nicola.GOP_FontSizeDataTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_FontSizeDataTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlantinMTPro_24;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlantinMTPro_21;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlantinMTPro_18;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_FontSizeDataTable) == 0x000008, "Wrong alignment on FGOP_FontSizeDataTable");
static_assert(sizeof(FGOP_FontSizeDataTable) == 0x000020, "Wrong size on FGOP_FontSizeDataTable");
static_assert(offsetof(FGOP_FontSizeDataTable, SelfId) == 0x000008, "Member 'FGOP_FontSizeDataTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_FontSizeDataTable, PlantinMTPro_24) == 0x000010, "Member 'FGOP_FontSizeDataTable::PlantinMTPro_24' has a wrong offset!");
static_assert(offsetof(FGOP_FontSizeDataTable, PlantinMTPro_21) == 0x000014, "Member 'FGOP_FontSizeDataTable::PlantinMTPro_21' has a wrong offset!");
static_assert(offsetof(FGOP_FontSizeDataTable, PlantinMTPro_18) == 0x000018, "Member 'FGOP_FontSizeDataTable::PlantinMTPro_18' has a wrong offset!");

// ScriptStruct Nicola.GOP_GuideIconTable
// 0x0060 (0x0068 - 0x0008)
struct FGOP_GuideIconTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGuideIconType                                IconType;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DispProgressFlag;                                  // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HideProgressFlag;                                  // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerObject;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcTriggerActorIdDaytime;                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcTriggerActorIdNight;                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerWorldMap;                                    // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerTownDungeonID;                               // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MarkerTownDungeonPos;                              // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_GuideIconTable) == 0x000008, "Wrong alignment on FGOP_GuideIconTable");
static_assert(sizeof(FGOP_GuideIconTable) == 0x000068, "Wrong size on FGOP_GuideIconTable");
static_assert(offsetof(FGOP_GuideIconTable, SelfId) == 0x000008, "Member 'FGOP_GuideIconTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, IconType) == 0x000010, "Member 'FGOP_GuideIconTable::IconType' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, DispProgressFlag) == 0x000018, "Member 'FGOP_GuideIconTable::DispProgressFlag' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, HideProgressFlag) == 0x000028, "Member 'FGOP_GuideIconTable::HideProgressFlag' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, MarkerObject) == 0x000038, "Member 'FGOP_GuideIconTable::MarkerObject' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, NpcTriggerActorIdDaytime) == 0x000040, "Member 'FGOP_GuideIconTable::NpcTriggerActorIdDaytime' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, NpcTriggerActorIdNight) == 0x000048, "Member 'FGOP_GuideIconTable::NpcTriggerActorIdNight' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, MarkerWorldMap) == 0x000050, "Member 'FGOP_GuideIconTable::MarkerWorldMap' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, MarkerTownDungeonID) == 0x000058, "Member 'FGOP_GuideIconTable::MarkerTownDungeonID' has a wrong offset!");
static_assert(offsetof(FGOP_GuideIconTable, MarkerTownDungeonPos) == 0x000060, "Member 'FGOP_GuideIconTable::MarkerTownDungeonPos' has a wrong offset!");

// ScriptStruct Nicola.FlipbookComponentArray
// 0x0010 (0x0010 - 0x0000)
struct FFlipbookComponentArray final
{
public:
	TArray<class UNicolaPaperFlipbookComponent*>  FlipbookComponents;                                // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlipbookComponentArray) == 0x000008, "Wrong alignment on FFlipbookComponentArray");
static_assert(sizeof(FFlipbookComponentArray) == 0x000010, "Wrong size on FFlipbookComponentArray");
static_assert(offsetof(FFlipbookComponentArray, FlipbookComponents) == 0x000000, "Member 'FFlipbookComponentArray::FlipbookComponents' has a wrong offset!");

// ScriptStruct Nicola.GOP_HourTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_HourTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InGameHour;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 MapTimeFrame;                                      // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFieldTimeFrame                               FieldTimeFrame;                                    // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeUntilNextHour;                                 // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_HourTable) == 0x000008, "Wrong alignment on FGOP_HourTable");
static_assert(sizeof(FGOP_HourTable) == 0x000020, "Wrong size on FGOP_HourTable");
static_assert(offsetof(FGOP_HourTable, SelfId) == 0x000008, "Member 'FGOP_HourTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_HourTable, InGameHour) == 0x000010, "Member 'FGOP_HourTable::InGameHour' has a wrong offset!");
static_assert(offsetof(FGOP_HourTable, MapTimeFrame) == 0x000014, "Member 'FGOP_HourTable::MapTimeFrame' has a wrong offset!");
static_assert(offsetof(FGOP_HourTable, FieldTimeFrame) == 0x000015, "Member 'FGOP_HourTable::FieldTimeFrame' has a wrong offset!");
static_assert(offsetof(FGOP_HourTable, TimeUntilNextHour) == 0x000018, "Member 'FGOP_HourTable::TimeUntilNextHour' has a wrong offset!");

// ScriptStruct Nicola.GOP_Image_InformationTable
// 0x01C0 (0x01C8 - 0x0008)
struct FGOP_Image_InformationTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_JP;                                          // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_JP_Hir;                                      // 0x0038(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_EN;                                          // 0x0060(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_TW;                                          // 0x0088(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_CN;                                          // 0x00B0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_KO;                                          // 0x00D8(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_FR;                                          // 0x0100(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_IT;                                          // 0x0128(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_DE;                                          // 0x0150(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_ES;                                          // 0x0178(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image_ES_419;                                      // 0x01A0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Image_InformationTable) == 0x000008, "Wrong alignment on FGOP_Image_InformationTable");
static_assert(sizeof(FGOP_Image_InformationTable) == 0x0001C8, "Wrong size on FGOP_Image_InformationTable");
static_assert(offsetof(FGOP_Image_InformationTable, SelfId) == 0x000008, "Member 'FGOP_Image_InformationTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_JP) == 0x000010, "Member 'FGOP_Image_InformationTable::Image_JP' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_JP_Hir) == 0x000038, "Member 'FGOP_Image_InformationTable::Image_JP_Hir' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_EN) == 0x000060, "Member 'FGOP_Image_InformationTable::Image_EN' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_TW) == 0x000088, "Member 'FGOP_Image_InformationTable::Image_TW' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_CN) == 0x0000B0, "Member 'FGOP_Image_InformationTable::Image_CN' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_KO) == 0x0000D8, "Member 'FGOP_Image_InformationTable::Image_KO' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_FR) == 0x000100, "Member 'FGOP_Image_InformationTable::Image_FR' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_IT) == 0x000128, "Member 'FGOP_Image_InformationTable::Image_IT' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_DE) == 0x000150, "Member 'FGOP_Image_InformationTable::Image_DE' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_ES) == 0x000178, "Member 'FGOP_Image_InformationTable::Image_ES' has a wrong offset!");
static_assert(offsetof(FGOP_Image_InformationTable, Image_ES_419) == 0x0001A0, "Member 'FGOP_Image_InformationTable::Image_ES_419' has a wrong offset!");

// ScriptStruct Nicola.GOP_InformationTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_InformationTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InformationTitleId;                                // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InformationTextId;                                 // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTextSuffix_PS5;                               // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTextSuffix_XBOX;                              // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTextSuffix_STEAM;                             // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTextSuffix_MSPC;                              // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InformationImageId;                                // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispFlagName;                                      // 0x0030(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_InformationTable) == 0x000008, "Wrong alignment on FGOP_InformationTable");
static_assert(sizeof(FGOP_InformationTable) == 0x000038, "Wrong size on FGOP_InformationTable");
static_assert(offsetof(FGOP_InformationTable, SelfId) == 0x000008, "Member 'FGOP_InformationTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, SortOrder) == 0x000010, "Member 'FGOP_InformationTable::SortOrder' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, InformationTitleId) == 0x000014, "Member 'FGOP_InformationTable::InformationTitleId' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, InformationTextId) == 0x00001C, "Member 'FGOP_InformationTable::InformationTextId' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, bNeedTextSuffix_PS5) == 0x000024, "Member 'FGOP_InformationTable::bNeedTextSuffix_PS5' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, bNeedTextSuffix_XBOX) == 0x000025, "Member 'FGOP_InformationTable::bNeedTextSuffix_XBOX' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, bNeedTextSuffix_STEAM) == 0x000026, "Member 'FGOP_InformationTable::bNeedTextSuffix_STEAM' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, bNeedTextSuffix_MSPC) == 0x000027, "Member 'FGOP_InformationTable::bNeedTextSuffix_MSPC' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, InformationImageId) == 0x000028, "Member 'FGOP_InformationTable::InformationImageId' has a wrong offset!");
static_assert(offsetof(FGOP_InformationTable, DispFlagName) == 0x000030, "Member 'FGOP_InformationTable::DispFlagName' has a wrong offset!");

// ScriptStruct Nicola.GOP_InitialLogoTable
// 0x01D0 (0x01D8 - 0x0008)
struct FGOP_InitialLogoTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_JP;                                      // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_JP_HI;                                   // 0x0038(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_TW;                                      // 0x0060(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_CN;                                      // 0x0088(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_KO;                                      // 0x00B0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_EN;                                      // 0x00D8(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_FR;                                      // 0x0100(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_IT;                                      // 0x0128(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_DE;                                      // 0x0150(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_ES;                                      // 0x0178(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImagePath_ES_419;                                  // 0x01A0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x01C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispSec;                                           // 0x01CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoSkipSec;                                         // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSec;                                           // 0x01D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_InitialLogoTable) == 0x000008, "Wrong alignment on FGOP_InitialLogoTable");
static_assert(sizeof(FGOP_InitialLogoTable) == 0x0001D8, "Wrong size on FGOP_InitialLogoTable");
static_assert(offsetof(FGOP_InitialLogoTable, SelfId) == 0x000008, "Member 'FGOP_InitialLogoTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_JP) == 0x000010, "Member 'FGOP_InitialLogoTable::ImagePath_JP' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_JP_HI) == 0x000038, "Member 'FGOP_InitialLogoTable::ImagePath_JP_HI' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_TW) == 0x000060, "Member 'FGOP_InitialLogoTable::ImagePath_TW' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_CN) == 0x000088, "Member 'FGOP_InitialLogoTable::ImagePath_CN' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_KO) == 0x0000B0, "Member 'FGOP_InitialLogoTable::ImagePath_KO' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_EN) == 0x0000D8, "Member 'FGOP_InitialLogoTable::ImagePath_EN' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_FR) == 0x000100, "Member 'FGOP_InitialLogoTable::ImagePath_FR' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_IT) == 0x000128, "Member 'FGOP_InitialLogoTable::ImagePath_IT' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_DE) == 0x000150, "Member 'FGOP_InitialLogoTable::ImagePath_DE' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_ES) == 0x000178, "Member 'FGOP_InitialLogoTable::ImagePath_ES' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, ImagePath_ES_419) == 0x0001A0, "Member 'FGOP_InitialLogoTable::ImagePath_ES_419' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, bSkippable) == 0x0001C8, "Member 'FGOP_InitialLogoTable::bSkippable' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, DispSec) == 0x0001CC, "Member 'FGOP_InitialLogoTable::DispSec' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, NoSkipSec) == 0x0001D0, "Member 'FGOP_InitialLogoTable::NoSkipSec' has a wrong offset!");
static_assert(offsetof(FGOP_InitialLogoTable, FadeSec) == 0x0001D4, "Member 'FGOP_InitialLogoTable::FadeSec' has a wrong offset!");

// ScriptStruct Nicola.NicolaLightCorrectionParam
// 0x0028 (0x0028 - 0x0000)
struct FNicolaLightCorrectionParam final
{
public:
	uint8                                         correctFlag;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         lightIntensity;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           lightColor;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           skySphereOverallColor;                             // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaLightCorrectionParam) == 0x000004, "Wrong alignment on FNicolaLightCorrectionParam");
static_assert(sizeof(FNicolaLightCorrectionParam) == 0x000028, "Wrong size on FNicolaLightCorrectionParam");
static_assert(offsetof(FNicolaLightCorrectionParam, correctFlag) == 0x000000, "Member 'FNicolaLightCorrectionParam::correctFlag' has a wrong offset!");
static_assert(offsetof(FNicolaLightCorrectionParam, lightIntensity) == 0x000004, "Member 'FNicolaLightCorrectionParam::lightIntensity' has a wrong offset!");
static_assert(offsetof(FNicolaLightCorrectionParam, lightColor) == 0x000008, "Member 'FNicolaLightCorrectionParam::lightColor' has a wrong offset!");
static_assert(offsetof(FNicolaLightCorrectionParam, skySphereOverallColor) == 0x000018, "Member 'FNicolaLightCorrectionParam::skySphereOverallColor' has a wrong offset!");

// ScriptStruct Nicola.GOP_InnTable
// 0x00C0 (0x00C8 - 0x0008)
struct FGOP_InnTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanRest;                                           // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerStartTag;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterDir;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeaderDir;                                         // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SayFarewellNPCID_Daytime;                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SayFarewellNPCDir_Daytime;                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoResetSayFarewellNPCLocation_Daytime;             // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SayFarewellNPCID_Evening;                          // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SayFarewellNPCDir_Evening;                         // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoResetSayFarewellNPCLocation_Evening;             // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SayFarewellNPCID_Night;                            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SayFarewellNPCDir_Night;                           // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoResetSayFarewellNPCLocation_Night;               // 0x0074(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Talk_0;                                            // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_1;                                            // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_2;                                            // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_3;                                            // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_4;                                            // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_5;                                            // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_6;                                            // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_7;                                            // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_8;                                            // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_9;                                            // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_InnTable) == 0x000008, "Wrong alignment on FGOP_InnTable");
static_assert(sizeof(FGOP_InnTable) == 0x0000C8, "Wrong size on FGOP_InnTable");
static_assert(offsetof(FGOP_InnTable, SelfId) == 0x000008, "Member 'FGOP_InnTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Price) == 0x000010, "Member 'FGOP_InnTable::Price' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, CanRest) == 0x000014, "Member 'FGOP_InnTable::CanRest' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, PlayerStartTag) == 0x000018, "Member 'FGOP_InnTable::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, AfterDir) == 0x000028, "Member 'FGOP_InnTable::AfterDir' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, LeaderDir) == 0x00002C, "Member 'FGOP_InnTable::LeaderDir' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, SayFarewellNPCID_Daytime) == 0x000030, "Member 'FGOP_InnTable::SayFarewellNPCID_Daytime' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, SayFarewellNPCDir_Daytime) == 0x000040, "Member 'FGOP_InnTable::SayFarewellNPCDir_Daytime' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, DoResetSayFarewellNPCLocation_Daytime) == 0x000044, "Member 'FGOP_InnTable::DoResetSayFarewellNPCLocation_Daytime' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, SayFarewellNPCID_Evening) == 0x000048, "Member 'FGOP_InnTable::SayFarewellNPCID_Evening' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, SayFarewellNPCDir_Evening) == 0x000058, "Member 'FGOP_InnTable::SayFarewellNPCDir_Evening' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, DoResetSayFarewellNPCLocation_Evening) == 0x00005C, "Member 'FGOP_InnTable::DoResetSayFarewellNPCLocation_Evening' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, SayFarewellNPCID_Night) == 0x000060, "Member 'FGOP_InnTable::SayFarewellNPCID_Night' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, SayFarewellNPCDir_Night) == 0x000070, "Member 'FGOP_InnTable::SayFarewellNPCDir_Night' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, DoResetSayFarewellNPCLocation_Night) == 0x000074, "Member 'FGOP_InnTable::DoResetSayFarewellNPCLocation_Night' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_0) == 0x000078, "Member 'FGOP_InnTable::Talk_0' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_1) == 0x000080, "Member 'FGOP_InnTable::Talk_1' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_2) == 0x000088, "Member 'FGOP_InnTable::Talk_2' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_3) == 0x000090, "Member 'FGOP_InnTable::Talk_3' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_4) == 0x000098, "Member 'FGOP_InnTable::Talk_4' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_5) == 0x0000A0, "Member 'FGOP_InnTable::Talk_5' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_6) == 0x0000A8, "Member 'FGOP_InnTable::Talk_6' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_7) == 0x0000B0, "Member 'FGOP_InnTable::Talk_7' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_8) == 0x0000B8, "Member 'FGOP_InnTable::Talk_8' has a wrong offset!");
static_assert(offsetof(FGOP_InnTable, Talk_9) == 0x0000C0, "Member 'FGOP_InnTable::Talk_9' has a wrong offset!");

// ScriptStruct Nicola.GOP_ItemTable
// 0x0210 (0x0218 - 0x0008)
struct FGOP_ItemTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameTextId;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FlavorTextId;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KanteiTextId;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KanteiEffectTextId;                                // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KanteiUseCountTextId;                              // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KanteiEquipGenderTextId;                           // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KanteiEquipCurseTextId;                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseBattle;                                      // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BuyPrice;                                          // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RipoffPrice;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellPrice;                                         // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSell;                                            // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsThrow;                                           // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CanUse;                                            // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGenderType                               CanUseGenderType;                                  // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UseSpecId1;                                        // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseSpecId2;                                        // 0x006C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseSpecId3;                                        // 0x0074(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRare;                                            // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIIconNo;                                          // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GetIconPath;                                       // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBTTgtWindowDispType                        UIBTTgtWindowDispType;                             // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBTExtraType                                UIBTExtraType;                                     // 0x0099(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TypeSortNo;                                        // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_jp;                                      // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_tw;                                      // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_cn;                                      // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_ko;                                      // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_en;                                      // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_fr;                                      // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_it;                                      // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_de;                                      // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_es;                                      // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_es419;                                   // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTidy;                                            // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipParamType                               ParamType;                                         // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParamUpType                                  ParamUpType;                                       // 0x00CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParamValue;                                        // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemGenderType                               CanEquipGenderType;                                // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParamFighterDown;                                  // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CanEquip;                                          // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCurse;                                           // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EffectBattleId;                                    // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectBattleSEId;                                  // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SequenceBattleId;                                  // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttackEffectID;                                    // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CriticalEffectID;                                  // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitEffectID;                                       // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitEffectSEID;                                     // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleWeaponStyleID;                               // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlipbookDir;                                       // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LuaID;                                             // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectType                             EffectType;                                        // 0x0158(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CameraShakeID;                                     // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleCameraShakeID;                               // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId;                                           // 0x0178(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionSEType                           ActionSEType;                                      // 0x0180(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeType                                Attribute;                                         // 0x0181(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCritical;                                        // 0x0182(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSureHit;                                         // 0x0183(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHealSleep;                                       // 0x0184(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsManusa;                                          // 0x0185(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExcludeRental;                                   // 0x0186(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_187[0x1];                                      // 0x0187(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CriticalRate;                                      // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotBattleUseEffectiveTextId;                       // 0x018C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotBattleUseEffectiveSpecialTextId;                // 0x0194(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotBattleUseNoEffectTextId;                        // 0x019C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotBattleUseNoEffectDeadTextId;                    // 0x01A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotBattleUseNoEffectSpecialTextId;                 // 0x01AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseTextId;                                   // 0x01B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseTextId_2;                                 // 0x01BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseEffectiveTextId;                          // 0x01C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseDuplicationTextId;                        // 0x01CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseDuplicationFailedTextId;                  // 0x01D4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseMissTextId;                               // 0x01DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUsePerfectResistTextId;                      // 0x01E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleMpDorainSuccessTextId;                       // 0x01EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleMpDorainFailedTextId;                        // 0x01F4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleUseNoEffectTextId;                           // 0x01FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutOfEffectTextId;                                 // 0x0204(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BreakTextId;                                       // 0x020C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_ItemTable) == 0x000008, "Wrong alignment on FGOP_ItemTable");
static_assert(sizeof(FGOP_ItemTable) == 0x000218, "Wrong size on FGOP_ItemTable");
static_assert(offsetof(FGOP_ItemTable, SelfId) == 0x000008, "Member 'FGOP_ItemTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, NameTextId) == 0x000010, "Member 'FGOP_ItemTable::NameTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, FlavorTextId) == 0x000018, "Member 'FGOP_ItemTable::FlavorTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, KanteiTextId) == 0x000020, "Member 'FGOP_ItemTable::KanteiTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, KanteiEffectTextId) == 0x000028, "Member 'FGOP_ItemTable::KanteiEffectTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, KanteiUseCountTextId) == 0x000030, "Member 'FGOP_ItemTable::KanteiUseCountTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, KanteiEquipGenderTextId) == 0x000038, "Member 'FGOP_ItemTable::KanteiEquipGenderTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, KanteiEquipCurseTextId) == 0x000040, "Member 'FGOP_ItemTable::KanteiEquipCurseTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ItemType) == 0x000048, "Member 'FGOP_ItemTable::ItemType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, WeaponType) == 0x000049, "Member 'FGOP_ItemTable::WeaponType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CanUseBattle) == 0x00004A, "Member 'FGOP_ItemTable::CanUseBattle' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BuyPrice) == 0x00004C, "Member 'FGOP_ItemTable::BuyPrice' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, RipoffPrice) == 0x000050, "Member 'FGOP_ItemTable::RipoffPrice' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, SellPrice) == 0x000054, "Member 'FGOP_ItemTable::SellPrice' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsSell) == 0x000058, "Member 'FGOP_ItemTable::IsSell' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsThrow) == 0x000059, "Member 'FGOP_ItemTable::IsThrow' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CanUse) == 0x00005C, "Member 'FGOP_ItemTable::CanUse' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CanUseGenderType) == 0x000060, "Member 'FGOP_ItemTable::CanUseGenderType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, UseSpecId1) == 0x000064, "Member 'FGOP_ItemTable::UseSpecId1' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, UseSpecId2) == 0x00006C, "Member 'FGOP_ItemTable::UseSpecId2' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, UseSpecId3) == 0x000074, "Member 'FGOP_ItemTable::UseSpecId3' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsRare) == 0x00007C, "Member 'FGOP_ItemTable::IsRare' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, UIIconNo) == 0x000080, "Member 'FGOP_ItemTable::UIIconNo' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, GetIconPath) == 0x000088, "Member 'FGOP_ItemTable::GetIconPath' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, UIBTTgtWindowDispType) == 0x000098, "Member 'FGOP_ItemTable::UIBTTgtWindowDispType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, UIBTExtraType) == 0x000099, "Member 'FGOP_ItemTable::UIBTExtraType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, TypeSortNo) == 0x00009C, "Member 'FGOP_ItemTable::TypeSortNo' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_jp) == 0x0000A0, "Member 'FGOP_ItemTable::ABCOerder_jp' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_tw) == 0x0000A4, "Member 'FGOP_ItemTable::ABCOerder_tw' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_cn) == 0x0000A8, "Member 'FGOP_ItemTable::ABCOerder_cn' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_ko) == 0x0000AC, "Member 'FGOP_ItemTable::ABCOerder_ko' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_en) == 0x0000B0, "Member 'FGOP_ItemTable::ABCOerder_en' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_fr) == 0x0000B4, "Member 'FGOP_ItemTable::ABCOerder_fr' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_it) == 0x0000B8, "Member 'FGOP_ItemTable::ABCOerder_it' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_de) == 0x0000BC, "Member 'FGOP_ItemTable::ABCOerder_de' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_es) == 0x0000C0, "Member 'FGOP_ItemTable::ABCOerder_es' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ABCOerder_es419) == 0x0000C4, "Member 'FGOP_ItemTable::ABCOerder_es419' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsTidy) == 0x0000C8, "Member 'FGOP_ItemTable::IsTidy' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ParamType) == 0x0000C9, "Member 'FGOP_ItemTable::ParamType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ParamUpType) == 0x0000CA, "Member 'FGOP_ItemTable::ParamUpType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ParamValue) == 0x0000CC, "Member 'FGOP_ItemTable::ParamValue' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CanEquipGenderType) == 0x0000D0, "Member 'FGOP_ItemTable::CanEquipGenderType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ParamFighterDown) == 0x0000D4, "Member 'FGOP_ItemTable::ParamFighterDown' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CanEquip) == 0x0000D8, "Member 'FGOP_ItemTable::CanEquip' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsCurse) == 0x0000DC, "Member 'FGOP_ItemTable::IsCurse' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, EffectBattleId) == 0x0000E0, "Member 'FGOP_ItemTable::EffectBattleId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, EffectBattleSEId) == 0x0000E8, "Member 'FGOP_ItemTable::EffectBattleSEId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, SequenceBattleId) == 0x0000F0, "Member 'FGOP_ItemTable::SequenceBattleId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, AttackEffectID) == 0x0000F8, "Member 'FGOP_ItemTable::AttackEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CriticalEffectID) == 0x000108, "Member 'FGOP_ItemTable::CriticalEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, HitEffectID) == 0x000118, "Member 'FGOP_ItemTable::HitEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, HitEffectSEID) == 0x000128, "Member 'FGOP_ItemTable::HitEffectSEID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleWeaponStyleID) == 0x000130, "Member 'FGOP_ItemTable::BattleWeaponStyleID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, FlipbookDir) == 0x000138, "Member 'FGOP_ItemTable::FlipbookDir' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, LuaID) == 0x000148, "Member 'FGOP_ItemTable::LuaID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, EffectType) == 0x000158, "Member 'FGOP_ItemTable::EffectType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CameraShakeID) == 0x000160, "Member 'FGOP_ItemTable::CameraShakeID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleCameraShakeID) == 0x000170, "Member 'FGOP_ItemTable::BattleCameraShakeID' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, VoiceId) == 0x000178, "Member 'FGOP_ItemTable::VoiceId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, ActionSEType) == 0x000180, "Member 'FGOP_ItemTable::ActionSEType' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, Attribute) == 0x000181, "Member 'FGOP_ItemTable::Attribute' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsCritical) == 0x000182, "Member 'FGOP_ItemTable::IsCritical' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsSureHit) == 0x000183, "Member 'FGOP_ItemTable::IsSureHit' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsHealSleep) == 0x000184, "Member 'FGOP_ItemTable::IsHealSleep' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsManusa) == 0x000185, "Member 'FGOP_ItemTable::IsManusa' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, IsExcludeRental) == 0x000186, "Member 'FGOP_ItemTable::IsExcludeRental' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, CriticalRate) == 0x000188, "Member 'FGOP_ItemTable::CriticalRate' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, NotBattleUseEffectiveTextId) == 0x00018C, "Member 'FGOP_ItemTable::NotBattleUseEffectiveTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, NotBattleUseEffectiveSpecialTextId) == 0x000194, "Member 'FGOP_ItemTable::NotBattleUseEffectiveSpecialTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, NotBattleUseNoEffectTextId) == 0x00019C, "Member 'FGOP_ItemTable::NotBattleUseNoEffectTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, NotBattleUseNoEffectDeadTextId) == 0x0001A4, "Member 'FGOP_ItemTable::NotBattleUseNoEffectDeadTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, NotBattleUseNoEffectSpecialTextId) == 0x0001AC, "Member 'FGOP_ItemTable::NotBattleUseNoEffectSpecialTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseTextId) == 0x0001B4, "Member 'FGOP_ItemTable::BattleUseTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseTextId_2) == 0x0001BC, "Member 'FGOP_ItemTable::BattleUseTextId_2' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseEffectiveTextId) == 0x0001C4, "Member 'FGOP_ItemTable::BattleUseEffectiveTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseDuplicationTextId) == 0x0001CC, "Member 'FGOP_ItemTable::BattleUseDuplicationTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseDuplicationFailedTextId) == 0x0001D4, "Member 'FGOP_ItemTable::BattleUseDuplicationFailedTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseMissTextId) == 0x0001DC, "Member 'FGOP_ItemTable::BattleUseMissTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUsePerfectResistTextId) == 0x0001E4, "Member 'FGOP_ItemTable::BattleUsePerfectResistTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleMpDorainSuccessTextId) == 0x0001EC, "Member 'FGOP_ItemTable::BattleMpDorainSuccessTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleMpDorainFailedTextId) == 0x0001F4, "Member 'FGOP_ItemTable::BattleMpDorainFailedTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BattleUseNoEffectTextId) == 0x0001FC, "Member 'FGOP_ItemTable::BattleUseNoEffectTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, OutOfEffectTextId) == 0x000204, "Member 'FGOP_ItemTable::OutOfEffectTextId' has a wrong offset!");
static_assert(offsetof(FGOP_ItemTable, BreakTextId) == 0x00020C, "Member 'FGOP_ItemTable::BreakTextId' has a wrong offset!");

// ScriptStruct Nicola.RichTextStyleMapTable
// 0x0010 (0x0018 - 0x0008)
struct FRichTextStyleMapTable final : public FTableRowBase
{
public:
	class FName                                   TextStyleName;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StyleEndFlag;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceFlag;                                       // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRichTextStyleMapTable) == 0x000008, "Wrong alignment on FRichTextStyleMapTable");
static_assert(sizeof(FRichTextStyleMapTable) == 0x000018, "Wrong size on FRichTextStyleMapTable");
static_assert(offsetof(FRichTextStyleMapTable, TextStyleName) == 0x000008, "Member 'FRichTextStyleMapTable::TextStyleName' has a wrong offset!");
static_assert(offsetof(FRichTextStyleMapTable, StyleEndFlag) == 0x000010, "Member 'FRichTextStyleMapTable::StyleEndFlag' has a wrong offset!");
static_assert(offsetof(FRichTextStyleMapTable, ReplaceFlag) == 0x000011, "Member 'FRichTextStyleMapTable::ReplaceFlag' has a wrong offset!");

// ScriptStruct Nicola.GOP_Item_SpecTable
// 0x0058 (0x0060 - 0x0008)
struct FGOP_Item_SpecTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemEffectType                               EffectType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ValueStr1;                                         // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ValueStr2;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetType                                   TargetType;                                        // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetCampsType                              TargetCampsType;                                   // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TargetExceptNoAction;                              // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemUsableType                               UsableType;                                        // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleTargetDeadType                         TargetDeadType;                                    // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemConsumeType                              ConsumeType;                                       // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BreakRatio;                                        // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleKillType                               KillType;                                          // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBossNoEffect;                                    // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagicId;                                           // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChangePersonalityMale;                             // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChangePersonalityFemale;                           // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Item_SpecTable) == 0x000008, "Wrong alignment on FGOP_Item_SpecTable");
static_assert(sizeof(FGOP_Item_SpecTable) == 0x000060, "Wrong size on FGOP_Item_SpecTable");
static_assert(offsetof(FGOP_Item_SpecTable, SelfId) == 0x000008, "Member 'FGOP_Item_SpecTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, EffectType) == 0x000010, "Member 'FGOP_Item_SpecTable::EffectType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, ValueStr1) == 0x000018, "Member 'FGOP_Item_SpecTable::ValueStr1' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, ValueStr2) == 0x000028, "Member 'FGOP_Item_SpecTable::ValueStr2' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, TargetType) == 0x000038, "Member 'FGOP_Item_SpecTable::TargetType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, TargetCampsType) == 0x000039, "Member 'FGOP_Item_SpecTable::TargetCampsType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, TargetExceptNoAction) == 0x00003A, "Member 'FGOP_Item_SpecTable::TargetExceptNoAction' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, UsableType) == 0x00003B, "Member 'FGOP_Item_SpecTable::UsableType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, TargetDeadType) == 0x00003C, "Member 'FGOP_Item_SpecTable::TargetDeadType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, ConsumeType) == 0x00003D, "Member 'FGOP_Item_SpecTable::ConsumeType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, BreakRatio) == 0x000040, "Member 'FGOP_Item_SpecTable::BreakRatio' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, KillType) == 0x000044, "Member 'FGOP_Item_SpecTable::KillType' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, IsBossNoEffect) == 0x000045, "Member 'FGOP_Item_SpecTable::IsBossNoEffect' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, MagicId) == 0x000048, "Member 'FGOP_Item_SpecTable::MagicId' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, ChangePersonalityMale) == 0x000050, "Member 'FGOP_Item_SpecTable::ChangePersonalityMale' has a wrong offset!");
static_assert(offsetof(FGOP_Item_SpecTable, ChangePersonalityFemale) == 0x000058, "Member 'FGOP_Item_SpecTable::ChangePersonalityFemale' has a wrong offset!");

// ScriptStruct Nicola.GOP_JobTable
// 0x0040 (0x0048 - 0x0008)
struct FGOP_JobTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleTactics                                TacticsDef;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LooksDefM;                                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LooksDefF;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks0;                                // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks1;                                // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks2;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks3;                                // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks4;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks5;                                // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks6;                                // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColorDefLooks7;                                // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_JobTable) == 0x000008, "Wrong alignment on FGOP_JobTable");
static_assert(sizeof(FGOP_JobTable) == 0x000048, "Wrong size on FGOP_JobTable");
static_assert(offsetof(FGOP_JobTable, SelfId) == 0x000008, "Member 'FGOP_JobTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, NameId) == 0x000010, "Member 'FGOP_JobTable::NameId' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, TacticsDef) == 0x000018, "Member 'FGOP_JobTable::TacticsDef' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, LooksDefM) == 0x00001C, "Member 'FGOP_JobTable::LooksDefM' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, LooksDefF) == 0x000020, "Member 'FGOP_JobTable::LooksDefF' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks0) == 0x000024, "Member 'FGOP_JobTable::HairColorDefLooks0' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks1) == 0x000028, "Member 'FGOP_JobTable::HairColorDefLooks1' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks2) == 0x00002C, "Member 'FGOP_JobTable::HairColorDefLooks2' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks3) == 0x000030, "Member 'FGOP_JobTable::HairColorDefLooks3' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks4) == 0x000034, "Member 'FGOP_JobTable::HairColorDefLooks4' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks5) == 0x000038, "Member 'FGOP_JobTable::HairColorDefLooks5' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks6) == 0x00003C, "Member 'FGOP_JobTable::HairColorDefLooks6' has a wrong offset!");
static_assert(offsetof(FGOP_JobTable, HairColorDefLooks7) == 0x000040, "Member 'FGOP_JobTable::HairColorDefLooks7' has a wrong offset!");

// ScriptStruct Nicola.PlayerMovementParam
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FPlayerMovementParam final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerMovementParam) == 0x000004, "Wrong alignment on FPlayerMovementParam");
static_assert(sizeof(FPlayerMovementParam) == 0x000024, "Wrong size on FPlayerMovementParam");

// ScriptStruct Nicola.GOP_Job_AbilityLvTable
// 0x0090 (0x0098 - 0x0008)
struct FGOP_Job_AbilityLvTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroCriticalPercentRate;                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarriorCriticalPercentRate;                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FighterCriticalPercentRate;                        // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MageCriticalPercentRate;                           // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriestCriticalPercentRate;                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MerchantCriticalPercentRate;                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadaboutCriticalPercentRate;                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThiefCriticalPercentRate;                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SageCriticalPercentRate;                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreederCriticalPercentRate;                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BR_MonsterCriticalPercentRate;                     // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayPercentRate;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hero_Luck;                                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Warrior_Luck;                                      // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Fighter_Luck;                                      // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mage_Luck;                                         // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priest_Luck;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Merchant_Luck;                                     // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gadabout_Luck;                                     // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Thief_Luck;                                        // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sage_Luck;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Breeder_Luck;                                      // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BR_Monster_Luck;                                   // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hero_Intel;                                        // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Warrior_Intel;                                     // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Fighter_Intel;                                     // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mage_Intel;                                        // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priest_Intel;                                      // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Merchant_Intel;                                    // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gadabout_Intel;                                    // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Thief_Intel;                                       // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sage_Intel;                                        // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Breeder_Intel;                                     // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BR_Monster_Intel;                                  // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Job_AbilityLvTable) == 0x000008, "Wrong alignment on FGOP_Job_AbilityLvTable");
static_assert(sizeof(FGOP_Job_AbilityLvTable) == 0x000098, "Wrong size on FGOP_Job_AbilityLvTable");
static_assert(offsetof(FGOP_Job_AbilityLvTable, SelfId) == 0x000008, "Member 'FGOP_Job_AbilityLvTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, HeroCriticalPercentRate) == 0x000010, "Member 'FGOP_Job_AbilityLvTable::HeroCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, WarriorCriticalPercentRate) == 0x000014, "Member 'FGOP_Job_AbilityLvTable::WarriorCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, FighterCriticalPercentRate) == 0x000018, "Member 'FGOP_Job_AbilityLvTable::FighterCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, MageCriticalPercentRate) == 0x00001C, "Member 'FGOP_Job_AbilityLvTable::MageCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, PriestCriticalPercentRate) == 0x000020, "Member 'FGOP_Job_AbilityLvTable::PriestCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, MerchantCriticalPercentRate) == 0x000024, "Member 'FGOP_Job_AbilityLvTable::MerchantCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, GadaboutCriticalPercentRate) == 0x000028, "Member 'FGOP_Job_AbilityLvTable::GadaboutCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, ThiefCriticalPercentRate) == 0x00002C, "Member 'FGOP_Job_AbilityLvTable::ThiefCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, SageCriticalPercentRate) == 0x000030, "Member 'FGOP_Job_AbilityLvTable::SageCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, BreederCriticalPercentRate) == 0x000034, "Member 'FGOP_Job_AbilityLvTable::BreederCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, BR_MonsterCriticalPercentRate) == 0x000038, "Member 'FGOP_Job_AbilityLvTable::BR_MonsterCriticalPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, PlayPercentRate) == 0x00003C, "Member 'FGOP_Job_AbilityLvTable::PlayPercentRate' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Hero_Luck) == 0x000040, "Member 'FGOP_Job_AbilityLvTable::Hero_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Warrior_Luck) == 0x000044, "Member 'FGOP_Job_AbilityLvTable::Warrior_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Fighter_Luck) == 0x000048, "Member 'FGOP_Job_AbilityLvTable::Fighter_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Mage_Luck) == 0x00004C, "Member 'FGOP_Job_AbilityLvTable::Mage_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Priest_Luck) == 0x000050, "Member 'FGOP_Job_AbilityLvTable::Priest_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Merchant_Luck) == 0x000054, "Member 'FGOP_Job_AbilityLvTable::Merchant_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Gadabout_Luck) == 0x000058, "Member 'FGOP_Job_AbilityLvTable::Gadabout_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Thief_Luck) == 0x00005C, "Member 'FGOP_Job_AbilityLvTable::Thief_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Sage_Luck) == 0x000060, "Member 'FGOP_Job_AbilityLvTable::Sage_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Breeder_Luck) == 0x000064, "Member 'FGOP_Job_AbilityLvTable::Breeder_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, BR_Monster_Luck) == 0x000068, "Member 'FGOP_Job_AbilityLvTable::BR_Monster_Luck' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Hero_Intel) == 0x00006C, "Member 'FGOP_Job_AbilityLvTable::Hero_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Warrior_Intel) == 0x000070, "Member 'FGOP_Job_AbilityLvTable::Warrior_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Fighter_Intel) == 0x000074, "Member 'FGOP_Job_AbilityLvTable::Fighter_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Mage_Intel) == 0x000078, "Member 'FGOP_Job_AbilityLvTable::Mage_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Priest_Intel) == 0x00007C, "Member 'FGOP_Job_AbilityLvTable::Priest_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Merchant_Intel) == 0x000080, "Member 'FGOP_Job_AbilityLvTable::Merchant_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Gadabout_Intel) == 0x000084, "Member 'FGOP_Job_AbilityLvTable::Gadabout_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Thief_Intel) == 0x000088, "Member 'FGOP_Job_AbilityLvTable::Thief_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Sage_Intel) == 0x00008C, "Member 'FGOP_Job_AbilityLvTable::Sage_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, Breeder_Intel) == 0x000090, "Member 'FGOP_Job_AbilityLvTable::Breeder_Intel' has a wrong offset!");
static_assert(offsetof(FGOP_Job_AbilityLvTable, BR_Monster_Intel) == 0x000094, "Member 'FGOP_Job_AbilityLvTable::BR_Monster_Intel' has a wrong offset!");

// ScriptStruct Nicola.GOP_Job_PlayTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_Job_PlayTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillId;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillId_Female;                                    // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Job_PlayTable) == 0x000008, "Wrong alignment on FGOP_Job_PlayTable");
static_assert(sizeof(FGOP_Job_PlayTable) == 0x000028, "Wrong size on FGOP_Job_PlayTable");
static_assert(offsetof(FGOP_Job_PlayTable, SelfId) == 0x000008, "Member 'FGOP_Job_PlayTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Job_PlayTable, SkillId) == 0x000010, "Member 'FGOP_Job_PlayTable::SkillId' has a wrong offset!");
static_assert(offsetof(FGOP_Job_PlayTable, SkillId_Female) == 0x000018, "Member 'FGOP_Job_PlayTable::SkillId_Female' has a wrong offset!");
static_assert(offsetof(FGOP_Job_PlayTable, Level) == 0x000020, "Member 'FGOP_Job_PlayTable::Level' has a wrong offset!");
static_assert(offsetof(FGOP_Job_PlayTable, Weight) == 0x000024, "Member 'FGOP_Job_PlayTable::Weight' has a wrong offset!");

// ScriptStruct Nicola.SimpleListCursor
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FSimpleListCursor final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleListCursor) == 0x000004, "Wrong alignment on FSimpleListCursor");
static_assert(sizeof(FSimpleListCursor) == 0x000010, "Wrong size on FSimpleListCursor");

// ScriptStruct Nicola.GOP_JobChangeTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_JobChangeTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrRatio;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmRatio;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgiRatio;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VitRatio;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntRatio;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LucRatio;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpRatio;                                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MpRatio;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_JobChangeTable) == 0x000008, "Wrong alignment on FGOP_JobChangeTable");
static_assert(sizeof(FGOP_JobChangeTable) == 0x000030, "Wrong size on FGOP_JobChangeTable");
static_assert(offsetof(FGOP_JobChangeTable, SelfId) == 0x000008, "Member 'FGOP_JobChangeTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, StrRatio) == 0x000010, "Member 'FGOP_JobChangeTable::StrRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, ArmRatio) == 0x000014, "Member 'FGOP_JobChangeTable::ArmRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, AgiRatio) == 0x000018, "Member 'FGOP_JobChangeTable::AgiRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, VitRatio) == 0x00001C, "Member 'FGOP_JobChangeTable::VitRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, IntRatio) == 0x000020, "Member 'FGOP_JobChangeTable::IntRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, LucRatio) == 0x000024, "Member 'FGOP_JobChangeTable::LucRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, HpRatio) == 0x000028, "Member 'FGOP_JobChangeTable::HpRatio' has a wrong offset!");
static_assert(offsetof(FGOP_JobChangeTable, MpRatio) == 0x00002C, "Member 'FGOP_JobChangeTable::MpRatio' has a wrong offset!");

// ScriptStruct Nicola.GOP_LanternTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_LanternTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightColorR;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightColorG;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightColorB;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_LanternTable) == 0x000008, "Wrong alignment on FGOP_LanternTable");
static_assert(sizeof(FGOP_LanternTable) == 0x000028, "Wrong size on FGOP_LanternTable");
static_assert(offsetof(FGOP_LanternTable, SelfId) == 0x000008, "Member 'FGOP_LanternTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_LanternTable, CastShadow) == 0x000010, "Member 'FGOP_LanternTable::CastShadow' has a wrong offset!");
static_assert(offsetof(FGOP_LanternTable, Intensity) == 0x000014, "Member 'FGOP_LanternTable::Intensity' has a wrong offset!");
static_assert(offsetof(FGOP_LanternTable, Radius) == 0x000018, "Member 'FGOP_LanternTable::Radius' has a wrong offset!");
static_assert(offsetof(FGOP_LanternTable, LightColorR) == 0x00001C, "Member 'FGOP_LanternTable::LightColorR' has a wrong offset!");
static_assert(offsetof(FGOP_LanternTable, LightColorG) == 0x000020, "Member 'FGOP_LanternTable::LightColorG' has a wrong offset!");
static_assert(offsetof(FGOP_LanternTable, LightColorB) == 0x000024, "Member 'FGOP_LanternTable::LightColorB' has a wrong offset!");

// ScriptStruct Nicola.GOP_LearningTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_LearningTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillId;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lv_Possible;                                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lv_Certainty;                                      // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int_Possible;                                      // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int_Certainty;                                     // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoutNum;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_LearningTable) == 0x000008, "Wrong alignment on FGOP_LearningTable");
static_assert(sizeof(FGOP_LearningTable) == 0x000030, "Wrong size on FGOP_LearningTable");
static_assert(offsetof(FGOP_LearningTable, SelfId) == 0x000008, "Member 'FGOP_LearningTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_LearningTable, SkillId) == 0x000010, "Member 'FGOP_LearningTable::SkillId' has a wrong offset!");
static_assert(offsetof(FGOP_LearningTable, Lv_Possible) == 0x000018, "Member 'FGOP_LearningTable::Lv_Possible' has a wrong offset!");
static_assert(offsetof(FGOP_LearningTable, Lv_Certainty) == 0x00001C, "Member 'FGOP_LearningTable::Lv_Certainty' has a wrong offset!");
static_assert(offsetof(FGOP_LearningTable, Int_Possible) == 0x000020, "Member 'FGOP_LearningTable::Int_Possible' has a wrong offset!");
static_assert(offsetof(FGOP_LearningTable, Int_Certainty) == 0x000024, "Member 'FGOP_LearningTable::Int_Certainty' has a wrong offset!");
static_assert(offsetof(FGOP_LearningTable, ScoutNum) == 0x000028, "Member 'FGOP_LearningTable::ScoutNum' has a wrong offset!");

// ScriptStruct Nicola.GOP_LevelUpExpTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_LevelUpExpTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HERO;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Warrior;                                           // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Fighter;                                           // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mage;                                              // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priest;                                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MERCHANT;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gadabout;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Thief;                                             // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sage;                                              // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Breeder;                                           // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_LevelUpExpTable) == 0x000008, "Wrong alignment on FGOP_LevelUpExpTable");
static_assert(sizeof(FGOP_LevelUpExpTable) == 0x000038, "Wrong size on FGOP_LevelUpExpTable");
static_assert(offsetof(FGOP_LevelUpExpTable, SelfId) == 0x000008, "Member 'FGOP_LevelUpExpTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, HERO) == 0x000010, "Member 'FGOP_LevelUpExpTable::HERO' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Warrior) == 0x000014, "Member 'FGOP_LevelUpExpTable::Warrior' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Fighter) == 0x000018, "Member 'FGOP_LevelUpExpTable::Fighter' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Mage) == 0x00001C, "Member 'FGOP_LevelUpExpTable::Mage' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Priest) == 0x000020, "Member 'FGOP_LevelUpExpTable::Priest' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, MERCHANT) == 0x000024, "Member 'FGOP_LevelUpExpTable::MERCHANT' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Gadabout) == 0x000028, "Member 'FGOP_LevelUpExpTable::Gadabout' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Thief) == 0x00002C, "Member 'FGOP_LevelUpExpTable::Thief' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Sage) == 0x000030, "Member 'FGOP_LevelUpExpTable::Sage' has a wrong offset!");
static_assert(offsetof(FGOP_LevelUpExpTable, Breeder) == 0x000034, "Member 'FGOP_LevelUpExpTable::Breeder' has a wrong offset!");

// ScriptStruct Nicola.UIBattleDamageParam
// 0x0048 (0x0048 - 0x0000)
struct FUIBattleDamageParam final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           CanvasPanel;                                       // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x28];                                      // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleDamageParam) == 0x000008, "Wrong alignment on FUIBattleDamageParam");
static_assert(sizeof(FUIBattleDamageParam) == 0x000048, "Wrong size on FUIBattleDamageParam");
static_assert(offsetof(FUIBattleDamageParam, CanvasPanel) == 0x000018, "Member 'FUIBattleDamageParam::CanvasPanel' has a wrong offset!");

// ScriptStruct Nicola.GOP_MagicTable
// 0x01C0 (0x01C8 - 0x0008)
struct FGOP_MagicTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListNo;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameTextId;                                        // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FlavorTextId;                                      // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillType                                    SkillType;                                         // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillUser                                    SkillUser;                                         // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsumeMP;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseSpecId1;                                        // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseSpecId2;                                        // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseSpecId3;                                        // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeType                                Attribute1;                                        // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeType                                Attribute2;                                        // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeType                                Attribute3;                                        // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Action_Priority;                                   // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pierce_level_forEnemy;                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Piece_level_forPC;                                 // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSureHit;                                         // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsConfusedUse;                                     // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsConfusedUse_Single;                              // 0x0056(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCounterDamage;                                   // 0x0057(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNageki;                                          // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCopOut;                                          // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCoverUp;                                         // 0x005A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHealSleep;                                       // 0x005B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMahoton;                                         // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMahokanta;                                       // 0x005D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBreath;                                          // 0x005E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsManusa;                                          // 0x005F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBaikiruto;                                       // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPowerCharge;                                     // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCritical;                                        // 0x0062(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMagicAwake;                                      // 0x0063(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMultiAction;                                     // 0x0064(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMultiAttack;                                     // 0x0065(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMultiMagic;                                      // 0x0066(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExcludeRental;                                   // 0x0067(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalRate;                                      // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionEffectCategory                         ActionEffectCategory;                              // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIIconNo;                                          // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBTTgtWindowDispType                        UIBTTgtWindowDispType;                             // 0x0074(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBTExtraType                                UIBTExtraType;                                     // 0x0075(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LuaID;                                             // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectBattleId;                                    // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectBattleSEId;                                  // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SequenceBattleId;                                  // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerEffectID;                                    // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MonsterEffectID;                                   // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitEffectID;                                       // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEffectType                             EffectType;                                        // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CameraShakeID;                                     // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleCameraShakeID;                               // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId;                                           // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleActionSEType                           ActionSEType;                                      // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UseNoBattleSuccessTextId;                          // 0x00FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseNoBattleFailedTextId;                           // 0x0104(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseNoBattleRuraTextId;                             // 0x010C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseNoBattleSpecialTextId;                          // 0x0114(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseNoBattleDeadTextId;                             // 0x011C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseBattleTextId;                                   // 0x0124(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseBattleTextId_2;                                 // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseBattleTextId_Failure;                           // 0x0134(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleSuccessTextId;                               // 0x013C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleSuccessTextId_Enemy;                         // 0x0144(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleFailedTextId;                                // 0x014C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleFailedTextId_Enemy;                          // 0x0154(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleSpecialTextId;                               // 0x015C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleSpecialFailedTextId;                         // 0x0164(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattlePerfectResistTextId;                         // 0x016C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleDuplicationTextId;                           // 0x0174(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleDuplicationTextId_Enemy;                     // 0x017C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleDuplicationFailedTextId;                     // 0x0184(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleSelfDestructTextId;                          // 0x018C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutOfEffectTextId;                                 // 0x0194(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_jp;                                      // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_tw;                                      // 0x01A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_cn;                                      // 0x01A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_ko;                                      // 0x01A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_en;                                      // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_fr;                                      // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_it;                                      // 0x01B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_de;                                      // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_es;                                      // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_es419;                                   // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MagicTable) == 0x000008, "Wrong alignment on FGOP_MagicTable");
static_assert(sizeof(FGOP_MagicTable) == 0x0001C8, "Wrong size on FGOP_MagicTable");
static_assert(offsetof(FGOP_MagicTable, SelfId) == 0x000008, "Member 'FGOP_MagicTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ListNo) == 0x000010, "Member 'FGOP_MagicTable::ListNo' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, NameTextId) == 0x000014, "Member 'FGOP_MagicTable::NameTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, FlavorTextId) == 0x00001C, "Member 'FGOP_MagicTable::FlavorTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, SkillType) == 0x000024, "Member 'FGOP_MagicTable::SkillType' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, SkillUser) == 0x000025, "Member 'FGOP_MagicTable::SkillUser' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ConsumeMP) == 0x000028, "Member 'FGOP_MagicTable::ConsumeMP' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseSpecId1) == 0x00002C, "Member 'FGOP_MagicTable::UseSpecId1' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseSpecId2) == 0x000034, "Member 'FGOP_MagicTable::UseSpecId2' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseSpecId3) == 0x00003C, "Member 'FGOP_MagicTable::UseSpecId3' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, Attribute1) == 0x000044, "Member 'FGOP_MagicTable::Attribute1' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, Attribute2) == 0x000045, "Member 'FGOP_MagicTable::Attribute2' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, Attribute3) == 0x000046, "Member 'FGOP_MagicTable::Attribute3' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, Action_Priority) == 0x000048, "Member 'FGOP_MagicTable::Action_Priority' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, Pierce_level_forEnemy) == 0x00004C, "Member 'FGOP_MagicTable::Pierce_level_forEnemy' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, Piece_level_forPC) == 0x000050, "Member 'FGOP_MagicTable::Piece_level_forPC' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsSureHit) == 0x000054, "Member 'FGOP_MagicTable::IsSureHit' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsConfusedUse) == 0x000055, "Member 'FGOP_MagicTable::IsConfusedUse' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsConfusedUse_Single) == 0x000056, "Member 'FGOP_MagicTable::IsConfusedUse_Single' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsCounterDamage) == 0x000057, "Member 'FGOP_MagicTable::IsCounterDamage' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsNageki) == 0x000058, "Member 'FGOP_MagicTable::IsNageki' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsCopOut) == 0x000059, "Member 'FGOP_MagicTable::IsCopOut' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsCoverUp) == 0x00005A, "Member 'FGOP_MagicTable::IsCoverUp' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsHealSleep) == 0x00005B, "Member 'FGOP_MagicTable::IsHealSleep' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsMahoton) == 0x00005C, "Member 'FGOP_MagicTable::IsMahoton' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsMahokanta) == 0x00005D, "Member 'FGOP_MagicTable::IsMahokanta' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsBreath) == 0x00005E, "Member 'FGOP_MagicTable::IsBreath' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsManusa) == 0x00005F, "Member 'FGOP_MagicTable::IsManusa' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsBaikiruto) == 0x000060, "Member 'FGOP_MagicTable::IsBaikiruto' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsPowerCharge) == 0x000061, "Member 'FGOP_MagicTable::IsPowerCharge' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsCritical) == 0x000062, "Member 'FGOP_MagicTable::IsCritical' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsMagicAwake) == 0x000063, "Member 'FGOP_MagicTable::IsMagicAwake' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsMultiAction) == 0x000064, "Member 'FGOP_MagicTable::IsMultiAction' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsMultiAttack) == 0x000065, "Member 'FGOP_MagicTable::IsMultiAttack' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsMultiMagic) == 0x000066, "Member 'FGOP_MagicTable::IsMultiMagic' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, IsExcludeRental) == 0x000067, "Member 'FGOP_MagicTable::IsExcludeRental' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, CriticalRate) == 0x000068, "Member 'FGOP_MagicTable::CriticalRate' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ActionEffectCategory) == 0x00006C, "Member 'FGOP_MagicTable::ActionEffectCategory' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UIIconNo) == 0x000070, "Member 'FGOP_MagicTable::UIIconNo' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UIBTTgtWindowDispType) == 0x000074, "Member 'FGOP_MagicTable::UIBTTgtWindowDispType' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UIBTExtraType) == 0x000075, "Member 'FGOP_MagicTable::UIBTExtraType' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, LuaID) == 0x000078, "Member 'FGOP_MagicTable::LuaID' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, EffectBattleId) == 0x000088, "Member 'FGOP_MagicTable::EffectBattleId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, EffectBattleSEId) == 0x000090, "Member 'FGOP_MagicTable::EffectBattleSEId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, SequenceBattleId) == 0x000098, "Member 'FGOP_MagicTable::SequenceBattleId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, PlayerEffectID) == 0x0000A0, "Member 'FGOP_MagicTable::PlayerEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, MonsterEffectID) == 0x0000B0, "Member 'FGOP_MagicTable::MonsterEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, HitEffectID) == 0x0000C0, "Member 'FGOP_MagicTable::HitEffectID' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, EffectType) == 0x0000D0, "Member 'FGOP_MagicTable::EffectType' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, CameraShakeID) == 0x0000D8, "Member 'FGOP_MagicTable::CameraShakeID' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleCameraShakeID) == 0x0000E8, "Member 'FGOP_MagicTable::BattleCameraShakeID' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, VoiceId) == 0x0000F0, "Member 'FGOP_MagicTable::VoiceId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ActionSEType) == 0x0000F8, "Member 'FGOP_MagicTable::ActionSEType' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseNoBattleSuccessTextId) == 0x0000FC, "Member 'FGOP_MagicTable::UseNoBattleSuccessTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseNoBattleFailedTextId) == 0x000104, "Member 'FGOP_MagicTable::UseNoBattleFailedTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseNoBattleRuraTextId) == 0x00010C, "Member 'FGOP_MagicTable::UseNoBattleRuraTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseNoBattleSpecialTextId) == 0x000114, "Member 'FGOP_MagicTable::UseNoBattleSpecialTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseNoBattleDeadTextId) == 0x00011C, "Member 'FGOP_MagicTable::UseNoBattleDeadTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseBattleTextId) == 0x000124, "Member 'FGOP_MagicTable::UseBattleTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseBattleTextId_2) == 0x00012C, "Member 'FGOP_MagicTable::UseBattleTextId_2' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, UseBattleTextId_Failure) == 0x000134, "Member 'FGOP_MagicTable::UseBattleTextId_Failure' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleSuccessTextId) == 0x00013C, "Member 'FGOP_MagicTable::BattleSuccessTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleSuccessTextId_Enemy) == 0x000144, "Member 'FGOP_MagicTable::BattleSuccessTextId_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleFailedTextId) == 0x00014C, "Member 'FGOP_MagicTable::BattleFailedTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleFailedTextId_Enemy) == 0x000154, "Member 'FGOP_MagicTable::BattleFailedTextId_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleSpecialTextId) == 0x00015C, "Member 'FGOP_MagicTable::BattleSpecialTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleSpecialFailedTextId) == 0x000164, "Member 'FGOP_MagicTable::BattleSpecialFailedTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattlePerfectResistTextId) == 0x00016C, "Member 'FGOP_MagicTable::BattlePerfectResistTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleDuplicationTextId) == 0x000174, "Member 'FGOP_MagicTable::BattleDuplicationTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleDuplicationTextId_Enemy) == 0x00017C, "Member 'FGOP_MagicTable::BattleDuplicationTextId_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleDuplicationFailedTextId) == 0x000184, "Member 'FGOP_MagicTable::BattleDuplicationFailedTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, BattleSelfDestructTextId) == 0x00018C, "Member 'FGOP_MagicTable::BattleSelfDestructTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, OutOfEffectTextId) == 0x000194, "Member 'FGOP_MagicTable::OutOfEffectTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_jp) == 0x00019C, "Member 'FGOP_MagicTable::ABCOerder_jp' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_tw) == 0x0001A0, "Member 'FGOP_MagicTable::ABCOerder_tw' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_cn) == 0x0001A4, "Member 'FGOP_MagicTable::ABCOerder_cn' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_ko) == 0x0001A8, "Member 'FGOP_MagicTable::ABCOerder_ko' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_en) == 0x0001AC, "Member 'FGOP_MagicTable::ABCOerder_en' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_fr) == 0x0001B0, "Member 'FGOP_MagicTable::ABCOerder_fr' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_it) == 0x0001B4, "Member 'FGOP_MagicTable::ABCOerder_it' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_de) == 0x0001B8, "Member 'FGOP_MagicTable::ABCOerder_de' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_es) == 0x0001BC, "Member 'FGOP_MagicTable::ABCOerder_es' has a wrong offset!");
static_assert(offsetof(FGOP_MagicTable, ABCOerder_es419) == 0x0001C0, "Member 'FGOP_MagicTable::ABCOerder_es419' has a wrong offset!");

// ScriptStruct Nicola.GOP_Magic_RandomTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_Magic_RandomTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERandomMagicType                              MagicType;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagicId;                                           // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableBoss;                                      // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectRatioNormal;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectRatioBoss;                                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Magic_RandomTable) == 0x000008, "Wrong alignment on FGOP_Magic_RandomTable");
static_assert(sizeof(FGOP_Magic_RandomTable) == 0x000028, "Wrong size on FGOP_Magic_RandomTable");
static_assert(offsetof(FGOP_Magic_RandomTable, SelfId) == 0x000008, "Member 'FGOP_Magic_RandomTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_RandomTable, MagicType) == 0x000010, "Member 'FGOP_Magic_RandomTable::MagicType' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_RandomTable, MagicId) == 0x000014, "Member 'FGOP_Magic_RandomTable::MagicId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_RandomTable, IsEnableBoss) == 0x00001C, "Member 'FGOP_Magic_RandomTable::IsEnableBoss' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_RandomTable, SelectRatioNormal) == 0x000020, "Member 'FGOP_Magic_RandomTable::SelectRatioNormal' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_RandomTable, SelectRatioBoss) == 0x000024, "Member 'FGOP_Magic_RandomTable::SelectRatioBoss' has a wrong offset!");

// ScriptStruct Nicola.RichTextButtonIconData
// 0x0178 (0x0178 - 0x0000)
struct alignas(0x08) FRichTextButtonIconData final
{
public:
	uint8                                         Pad_0[0x178];                                      // 0x0000(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRichTextButtonIconData) == 0x000008, "Wrong alignment on FRichTextButtonIconData");
static_assert(sizeof(FRichTextButtonIconData) == 0x000178, "Wrong size on FRichTextButtonIconData");

// ScriptStruct Nicola.GOP_Magic_SpecTable
// 0x0038 (0x0040 - 0x0008)
struct FGOP_Magic_SpecTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicEffectType                              EffectType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ValueStr1;                                         // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ValueStr2;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetType                                   TargetType_Party;                                  // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetType                                   TargetType_Enemy;                                  // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetCampsType                              TargetCampsType;                                   // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TargetExceptNoAction;                              // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemUsableType                               EnableTymingType;                                  // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBossNoEffect;                                    // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleTargetDeadType                         TargetDeadType;                                    // 0x003E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleKillType                               KillType;                                          // 0x003F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Magic_SpecTable) == 0x000008, "Wrong alignment on FGOP_Magic_SpecTable");
static_assert(sizeof(FGOP_Magic_SpecTable) == 0x000040, "Wrong size on FGOP_Magic_SpecTable");
static_assert(offsetof(FGOP_Magic_SpecTable, SelfId) == 0x000008, "Member 'FGOP_Magic_SpecTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, EffectType) == 0x000010, "Member 'FGOP_Magic_SpecTable::EffectType' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, ValueStr1) == 0x000018, "Member 'FGOP_Magic_SpecTable::ValueStr1' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, ValueStr2) == 0x000028, "Member 'FGOP_Magic_SpecTable::ValueStr2' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, TargetType_Party) == 0x000038, "Member 'FGOP_Magic_SpecTable::TargetType_Party' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, TargetType_Enemy) == 0x000039, "Member 'FGOP_Magic_SpecTable::TargetType_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, TargetCampsType) == 0x00003A, "Member 'FGOP_Magic_SpecTable::TargetCampsType' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, TargetExceptNoAction) == 0x00003B, "Member 'FGOP_Magic_SpecTable::TargetExceptNoAction' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, EnableTymingType) == 0x00003C, "Member 'FGOP_Magic_SpecTable::EnableTymingType' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, IsBossNoEffect) == 0x00003D, "Member 'FGOP_Magic_SpecTable::IsBossNoEffect' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, TargetDeadType) == 0x00003E, "Member 'FGOP_Magic_SpecTable::TargetDeadType' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_SpecTable, KillType) == 0x00003F, "Member 'FGOP_Magic_SpecTable::KillType' has a wrong offset!");

// ScriptStruct Nicola.GOP_Magic_Text_SetTable
// 0x0048 (0x0050 - 0x0008)
struct FGOP_Magic_Text_SetTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicEffectType                              EffectType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SuccessTextId;                                     // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SuccessTextId_Enemy;                               // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailureTextId;                                     // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailureTextId_Enemy;                               // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DuplicationTextId;                                 // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DuplicationTextId_Enemy;                           // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpecialTextId;                                     // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Magic_Text_SetTable) == 0x000008, "Wrong alignment on FGOP_Magic_Text_SetTable");
static_assert(sizeof(FGOP_Magic_Text_SetTable) == 0x000050, "Wrong size on FGOP_Magic_Text_SetTable");
static_assert(offsetof(FGOP_Magic_Text_SetTable, SelfId) == 0x000008, "Member 'FGOP_Magic_Text_SetTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, EffectType) == 0x000010, "Member 'FGOP_Magic_Text_SetTable::EffectType' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, SuccessTextId) == 0x000014, "Member 'FGOP_Magic_Text_SetTable::SuccessTextId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, SuccessTextId_Enemy) == 0x00001C, "Member 'FGOP_Magic_Text_SetTable::SuccessTextId_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, FailureTextId) == 0x000024, "Member 'FGOP_Magic_Text_SetTable::FailureTextId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, FailureTextId_Enemy) == 0x00002C, "Member 'FGOP_Magic_Text_SetTable::FailureTextId_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, DuplicationTextId) == 0x000034, "Member 'FGOP_Magic_Text_SetTable::DuplicationTextId' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, DuplicationTextId_Enemy) == 0x00003C, "Member 'FGOP_Magic_Text_SetTable::DuplicationTextId_Enemy' has a wrong offset!");
static_assert(offsetof(FGOP_Magic_Text_SetTable, SpecialTextId) == 0x000044, "Member 'FGOP_Magic_Text_SetTable::SpecialTextId' has a wrong offset!");

// ScriptStruct Nicola.GOP_Map_PerformanceTable
// 0x0048 (0x0050 - 0x0008)
struct FGOP_Map_PerformanceTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxResSwitchTV;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinResSwitchTV;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFPSSwitchTV;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryScreenPercentageGameViewportSwitchTV;     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SSAOTV;                                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeparateTranslucencyTV;                            // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSeparateTranslucencyResSwitchTV;                // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MipMapLODBiasTV;                                   // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxResSwitchHH;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinResSwitchHH;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFPSSwitchHH;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryScreenPercentageGameViewportSwitchHH;     // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SSAOHH;                                            // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeparateTranslucencyHH;                            // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSeparateTranslucencyResSwitchHH;                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MipMapLODBiasHH;                                   // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Map_PerformanceTable) == 0x000008, "Wrong alignment on FGOP_Map_PerformanceTable");
static_assert(sizeof(FGOP_Map_PerformanceTable) == 0x000050, "Wrong size on FGOP_Map_PerformanceTable");
static_assert(offsetof(FGOP_Map_PerformanceTable, SelfId) == 0x000008, "Member 'FGOP_Map_PerformanceTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MaxResSwitchTV) == 0x000010, "Member 'FGOP_Map_PerformanceTable::MaxResSwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MinResSwitchTV) == 0x000014, "Member 'FGOP_Map_PerformanceTable::MinResSwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MinFPSSwitchTV) == 0x000018, "Member 'FGOP_Map_PerformanceTable::MinFPSSwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, SecondaryScreenPercentageGameViewportSwitchTV) == 0x00001C, "Member 'FGOP_Map_PerformanceTable::SecondaryScreenPercentageGameViewportSwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, SSAOTV) == 0x000020, "Member 'FGOP_Map_PerformanceTable::SSAOTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, SeparateTranslucencyTV) == 0x000024, "Member 'FGOP_Map_PerformanceTable::SeparateTranslucencyTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MinSeparateTranslucencyResSwitchTV) == 0x000028, "Member 'FGOP_Map_PerformanceTable::MinSeparateTranslucencyResSwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MipMapLODBiasTV) == 0x00002C, "Member 'FGOP_Map_PerformanceTable::MipMapLODBiasTV' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MaxResSwitchHH) == 0x000030, "Member 'FGOP_Map_PerformanceTable::MaxResSwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MinResSwitchHH) == 0x000034, "Member 'FGOP_Map_PerformanceTable::MinResSwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MinFPSSwitchHH) == 0x000038, "Member 'FGOP_Map_PerformanceTable::MinFPSSwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, SecondaryScreenPercentageGameViewportSwitchHH) == 0x00003C, "Member 'FGOP_Map_PerformanceTable::SecondaryScreenPercentageGameViewportSwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, SSAOHH) == 0x000040, "Member 'FGOP_Map_PerformanceTable::SSAOHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, SeparateTranslucencyHH) == 0x000044, "Member 'FGOP_Map_PerformanceTable::SeparateTranslucencyHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MinSeparateTranslucencyResSwitchHH) == 0x000048, "Member 'FGOP_Map_PerformanceTable::MinSeparateTranslucencyResSwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_Map_PerformanceTable, MipMapLODBiasHH) == 0x00004C, "Member 'FGOP_Map_PerformanceTable::MipMapLODBiasHH' has a wrong offset!");

// ScriptStruct Nicola.GOP_Map_SpotIconTable
// 0x00C8 (0x00D0 - 0x0008)
struct FGOP_Map_SpotIconTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_01;                                       // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_01;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_01;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_01;                           // 0x001C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_01;                           // 0x001E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_02;                                       // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_02;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_02;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_02;                           // 0x002C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_02;                           // 0x002E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_03;                                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_03;                                  // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_03;                                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_03;                           // 0x003C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_03;                           // 0x003E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_04;                                       // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_04;                                  // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_04;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_04;                           // 0x004C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_04;                           // 0x004E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_05;                                       // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_05;                                  // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_05;                                  // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_05;                           // 0x005C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_05;                           // 0x005E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_06;                                       // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_06;                                  // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_06;                                  // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_06;                           // 0x006C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_06;                           // 0x006E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_07;                                       // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_07;                                  // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_07;                                  // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_07;                           // 0x007C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_07;                           // 0x007E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_08;                                       // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_08;                                  // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_08;                                  // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_08;                           // 0x008C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_08;                           // 0x008E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_09;                                       // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_09;                                  // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_09;                                  // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_09;                           // 0x009C(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_09;                           // 0x009E(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_10;                                       // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_10;                                  // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_10;                                  // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_10;                           // 0x00AC(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_10;                           // 0x00AE(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_11;                                       // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_11;                                  // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_11;                                  // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_11;                           // 0x00BC(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_11;                           // 0x00BE(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSpotType                                  SpotType_12;                                       // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispPositionX_12;                                  // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispPositionY_12;                                  // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispProfressFlagName_12;                           // 0x00CC(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideProgressFlagName_12;                           // 0x00CE(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Map_SpotIconTable) == 0x000008, "Wrong alignment on FGOP_Map_SpotIconTable");
static_assert(sizeof(FGOP_Map_SpotIconTable) == 0x0000D0, "Wrong size on FGOP_Map_SpotIconTable");
static_assert(offsetof(FGOP_Map_SpotIconTable, SelfId) == 0x000008, "Member 'FGOP_Map_SpotIconTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_01) == 0x000010, "Member 'FGOP_Map_SpotIconTable::SpotType_01' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_01) == 0x000014, "Member 'FGOP_Map_SpotIconTable::DispPositionX_01' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_01) == 0x000018, "Member 'FGOP_Map_SpotIconTable::DispPositionY_01' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_01) == 0x00001C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_01' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_01) == 0x00001E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_01' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_02) == 0x000020, "Member 'FGOP_Map_SpotIconTable::SpotType_02' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_02) == 0x000024, "Member 'FGOP_Map_SpotIconTable::DispPositionX_02' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_02) == 0x000028, "Member 'FGOP_Map_SpotIconTable::DispPositionY_02' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_02) == 0x00002C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_02' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_02) == 0x00002E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_02' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_03) == 0x000030, "Member 'FGOP_Map_SpotIconTable::SpotType_03' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_03) == 0x000034, "Member 'FGOP_Map_SpotIconTable::DispPositionX_03' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_03) == 0x000038, "Member 'FGOP_Map_SpotIconTable::DispPositionY_03' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_03) == 0x00003C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_03' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_03) == 0x00003E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_03' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_04) == 0x000040, "Member 'FGOP_Map_SpotIconTable::SpotType_04' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_04) == 0x000044, "Member 'FGOP_Map_SpotIconTable::DispPositionX_04' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_04) == 0x000048, "Member 'FGOP_Map_SpotIconTable::DispPositionY_04' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_04) == 0x00004C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_04' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_04) == 0x00004E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_04' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_05) == 0x000050, "Member 'FGOP_Map_SpotIconTable::SpotType_05' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_05) == 0x000054, "Member 'FGOP_Map_SpotIconTable::DispPositionX_05' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_05) == 0x000058, "Member 'FGOP_Map_SpotIconTable::DispPositionY_05' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_05) == 0x00005C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_05' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_05) == 0x00005E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_05' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_06) == 0x000060, "Member 'FGOP_Map_SpotIconTable::SpotType_06' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_06) == 0x000064, "Member 'FGOP_Map_SpotIconTable::DispPositionX_06' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_06) == 0x000068, "Member 'FGOP_Map_SpotIconTable::DispPositionY_06' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_06) == 0x00006C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_06' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_06) == 0x00006E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_06' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_07) == 0x000070, "Member 'FGOP_Map_SpotIconTable::SpotType_07' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_07) == 0x000074, "Member 'FGOP_Map_SpotIconTable::DispPositionX_07' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_07) == 0x000078, "Member 'FGOP_Map_SpotIconTable::DispPositionY_07' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_07) == 0x00007C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_07' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_07) == 0x00007E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_07' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_08) == 0x000080, "Member 'FGOP_Map_SpotIconTable::SpotType_08' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_08) == 0x000084, "Member 'FGOP_Map_SpotIconTable::DispPositionX_08' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_08) == 0x000088, "Member 'FGOP_Map_SpotIconTable::DispPositionY_08' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_08) == 0x00008C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_08' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_08) == 0x00008E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_08' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_09) == 0x000090, "Member 'FGOP_Map_SpotIconTable::SpotType_09' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_09) == 0x000094, "Member 'FGOP_Map_SpotIconTable::DispPositionX_09' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_09) == 0x000098, "Member 'FGOP_Map_SpotIconTable::DispPositionY_09' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_09) == 0x00009C, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_09' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_09) == 0x00009E, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_09' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_10) == 0x0000A0, "Member 'FGOP_Map_SpotIconTable::SpotType_10' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_10) == 0x0000A4, "Member 'FGOP_Map_SpotIconTable::DispPositionX_10' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_10) == 0x0000A8, "Member 'FGOP_Map_SpotIconTable::DispPositionY_10' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_10) == 0x0000AC, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_10' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_10) == 0x0000AE, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_10' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_11) == 0x0000B0, "Member 'FGOP_Map_SpotIconTable::SpotType_11' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_11) == 0x0000B4, "Member 'FGOP_Map_SpotIconTable::DispPositionX_11' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_11) == 0x0000B8, "Member 'FGOP_Map_SpotIconTable::DispPositionY_11' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_11) == 0x0000BC, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_11' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_11) == 0x0000BE, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_11' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, SpotType_12) == 0x0000C0, "Member 'FGOP_Map_SpotIconTable::SpotType_12' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionX_12) == 0x0000C4, "Member 'FGOP_Map_SpotIconTable::DispPositionX_12' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispPositionY_12) == 0x0000C8, "Member 'FGOP_Map_SpotIconTable::DispPositionY_12' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, DispProfressFlagName_12) == 0x0000CC, "Member 'FGOP_Map_SpotIconTable::DispProfressFlagName_12' has a wrong offset!");
static_assert(offsetof(FGOP_Map_SpotIconTable, HideProgressFlagName_12) == 0x0000CE, "Member 'FGOP_Map_SpotIconTable::HideProgressFlagName_12' has a wrong offset!");

// ScriptStruct Nicola.MasteredSkillInfo
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FMasteredSkillInfo final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMasteredSkillInfo) == 0x000004, "Wrong alignment on FMasteredSkillInfo");
static_assert(sizeof(FMasteredSkillInfo) == 0x000024, "Wrong size on FMasteredSkillInfo");

// ScriptStruct Nicola.GOP_MapAttributeTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_MapAttributeTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanWalk;                                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSwim;                                           // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanLanding;                                        // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EncountRate;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastWalkRate;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         damage;                                            // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageSteps;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFootStep;                                    // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Effect;                                            // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFieldBGType                                  BGType;                                            // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MapAttributeTable) == 0x000008, "Wrong alignment on FGOP_MapAttributeTable");
static_assert(sizeof(FGOP_MapAttributeTable) == 0x000028, "Wrong size on FGOP_MapAttributeTable");
static_assert(offsetof(FGOP_MapAttributeTable, SelfId) == 0x000008, "Member 'FGOP_MapAttributeTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, CanWalk) == 0x000010, "Member 'FGOP_MapAttributeTable::CanWalk' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, CanSwim) == 0x000011, "Member 'FGOP_MapAttributeTable::CanSwim' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, CanLanding) == 0x000012, "Member 'FGOP_MapAttributeTable::CanLanding' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, EncountRate) == 0x000014, "Member 'FGOP_MapAttributeTable::EncountRate' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, FastWalkRate) == 0x000018, "Member 'FGOP_MapAttributeTable::FastWalkRate' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, damage) == 0x00001C, "Member 'FGOP_MapAttributeTable::damage' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, DamageSteps) == 0x000020, "Member 'FGOP_MapAttributeTable::DamageSteps' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, EnableFootStep) == 0x000024, "Member 'FGOP_MapAttributeTable::EnableFootStep' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, Effect) == 0x000025, "Member 'FGOP_MapAttributeTable::Effect' has a wrong offset!");
static_assert(offsetof(FGOP_MapAttributeTable, BGType) == 0x000026, "Member 'FGOP_MapAttributeTable::BGType' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapCameraTable
// 0x0098 (0x00A0 - 0x0008)
struct FGOP_MapCameraTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraAngleElevation;                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraTargetLength;                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraTargetLength_Near;                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraTargetLength_Far;                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialCameraOffset;                               // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         forwardOffset;                                     // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         backOffset;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         lag;                                               // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         interpolationTime;                                 // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         returnToOriginTime;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         deadZoneAngleY;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          shouldReturnToOrigin;                              // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialFocalLength;                                // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMinFStop;                                   // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMaxFStop;                                   // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture;                                   // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_Near;                              // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_Far;                               // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurAmount;                            // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurRadius;                            // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDiaphragmBladeCount;                        // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialNearDOFPower;                               // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_SwitchTV;                          // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_Near_SwitchTV;                     // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_Far_SwitchTV;                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurAmount_SwitchTV;                   // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurRadius_SwitchTV;                   // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDiaphragmBladeCount_SwitchTV;               // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialNearDOFPower_SwitchTV;                      // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_SwitchHH;                          // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_Near_SwitchHH;                     // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAperture_Far_SwitchHH;                      // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurAmount_SwitchHH;                   // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDepthBlurRadius_SwitchHH;                   // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDiaphragmBladeCount_SwitchHH;               // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialNearDOFPower_SwitchHH;                      // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_MapCameraTable) == 0x000008, "Wrong alignment on FGOP_MapCameraTable");
static_assert(sizeof(FGOP_MapCameraTable) == 0x0000A0, "Wrong size on FGOP_MapCameraTable");
static_assert(offsetof(FGOP_MapCameraTable, SelfId) == 0x000008, "Member 'FGOP_MapCameraTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialCameraAngleElevation) == 0x000010, "Member 'FGOP_MapCameraTable::InitialCameraAngleElevation' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialCameraTargetLength) == 0x000014, "Member 'FGOP_MapCameraTable::InitialCameraTargetLength' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialCameraTargetLength_Near) == 0x000018, "Member 'FGOP_MapCameraTable::InitialCameraTargetLength_Near' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialCameraTargetLength_Far) == 0x00001C, "Member 'FGOP_MapCameraTable::InitialCameraTargetLength_Far' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialCameraOffset) == 0x000020, "Member 'FGOP_MapCameraTable::InitialCameraOffset' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, forwardOffset) == 0x000024, "Member 'FGOP_MapCameraTable::forwardOffset' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, backOffset) == 0x000028, "Member 'FGOP_MapCameraTable::backOffset' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, lag) == 0x00002C, "Member 'FGOP_MapCameraTable::lag' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, interpolationTime) == 0x000030, "Member 'FGOP_MapCameraTable::interpolationTime' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, returnToOriginTime) == 0x000034, "Member 'FGOP_MapCameraTable::returnToOriginTime' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, deadZoneAngleY) == 0x000038, "Member 'FGOP_MapCameraTable::deadZoneAngleY' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, shouldReturnToOrigin) == 0x00003C, "Member 'FGOP_MapCameraTable::shouldReturnToOrigin' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialFocalLength) == 0x000040, "Member 'FGOP_MapCameraTable::InitialFocalLength' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialMinFStop) == 0x000044, "Member 'FGOP_MapCameraTable::InitialMinFStop' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialMaxFStop) == 0x000048, "Member 'FGOP_MapCameraTable::InitialMaxFStop' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture) == 0x00004C, "Member 'FGOP_MapCameraTable::InitialAperture' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_Near) == 0x000050, "Member 'FGOP_MapCameraTable::InitialAperture_Near' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_Far) == 0x000054, "Member 'FGOP_MapCameraTable::InitialAperture_Far' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDepthBlurAmount) == 0x000058, "Member 'FGOP_MapCameraTable::InitialDepthBlurAmount' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDepthBlurRadius) == 0x00005C, "Member 'FGOP_MapCameraTable::InitialDepthBlurRadius' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDiaphragmBladeCount) == 0x000060, "Member 'FGOP_MapCameraTable::InitialDiaphragmBladeCount' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialNearDOFPower) == 0x000064, "Member 'FGOP_MapCameraTable::InitialNearDOFPower' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_SwitchTV) == 0x000068, "Member 'FGOP_MapCameraTable::InitialAperture_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_Near_SwitchTV) == 0x00006C, "Member 'FGOP_MapCameraTable::InitialAperture_Near_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_Far_SwitchTV) == 0x000070, "Member 'FGOP_MapCameraTable::InitialAperture_Far_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDepthBlurAmount_SwitchTV) == 0x000074, "Member 'FGOP_MapCameraTable::InitialDepthBlurAmount_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDepthBlurRadius_SwitchTV) == 0x000078, "Member 'FGOP_MapCameraTable::InitialDepthBlurRadius_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDiaphragmBladeCount_SwitchTV) == 0x00007C, "Member 'FGOP_MapCameraTable::InitialDiaphragmBladeCount_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialNearDOFPower_SwitchTV) == 0x000080, "Member 'FGOP_MapCameraTable::InitialNearDOFPower_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_SwitchHH) == 0x000084, "Member 'FGOP_MapCameraTable::InitialAperture_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_Near_SwitchHH) == 0x000088, "Member 'FGOP_MapCameraTable::InitialAperture_Near_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialAperture_Far_SwitchHH) == 0x00008C, "Member 'FGOP_MapCameraTable::InitialAperture_Far_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDepthBlurAmount_SwitchHH) == 0x000090, "Member 'FGOP_MapCameraTable::InitialDepthBlurAmount_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDepthBlurRadius_SwitchHH) == 0x000094, "Member 'FGOP_MapCameraTable::InitialDepthBlurRadius_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialDiaphragmBladeCount_SwitchHH) == 0x000098, "Member 'FGOP_MapCameraTable::InitialDiaphragmBladeCount_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_MapCameraTable, InitialNearDOFPower_SwitchHH) == 0x00009C, "Member 'FGOP_MapCameraTable::InitialNearDOFPower_SwitchHH' has a wrong offset!");

// ScriptStruct Nicola.NicolaActionKeyInfo
// 0x0020 (0x0020 - 0x0000)
struct FNicolaActionKeyInfo final
{
public:
	bool                                          developmentOnly;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ENicolaButton>                         buttons;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ENicolaButtonOp                               opCode;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         pushSec;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaActionKeyInfo) == 0x000008, "Wrong alignment on FNicolaActionKeyInfo");
static_assert(sizeof(FNicolaActionKeyInfo) == 0x000020, "Wrong size on FNicolaActionKeyInfo");
static_assert(offsetof(FNicolaActionKeyInfo, developmentOnly) == 0x000000, "Member 'FNicolaActionKeyInfo::developmentOnly' has a wrong offset!");
static_assert(offsetof(FNicolaActionKeyInfo, buttons) == 0x000008, "Member 'FNicolaActionKeyInfo::buttons' has a wrong offset!");
static_assert(offsetof(FNicolaActionKeyInfo, opCode) == 0x000018, "Member 'FNicolaActionKeyInfo::opCode' has a wrong offset!");
static_assert(offsetof(FNicolaActionKeyInfo, pushSec) == 0x00001C, "Member 'FNicolaActionKeyInfo::pushSec' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapChangeGroupTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_MapChangeGroupTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapChangeGroupType                           MapChangeGroup;                                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapListID;                                         // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraID;                                            // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChurchID;                                          // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MapChangeGroupTable) == 0x000008, "Wrong alignment on FGOP_MapChangeGroupTable");
static_assert(sizeof(FGOP_MapChangeGroupTable) == 0x000030, "Wrong size on FGOP_MapChangeGroupTable");
static_assert(offsetof(FGOP_MapChangeGroupTable, SelfId) == 0x000008, "Member 'FGOP_MapChangeGroupTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapChangeGroupTable, MapChangeGroup) == 0x000010, "Member 'FGOP_MapChangeGroupTable::MapChangeGroup' has a wrong offset!");
static_assert(offsetof(FGOP_MapChangeGroupTable, MapListID) == 0x000014, "Member 'FGOP_MapChangeGroupTable::MapListID' has a wrong offset!");
static_assert(offsetof(FGOP_MapChangeGroupTable, RuraID) == 0x00001C, "Member 'FGOP_MapChangeGroupTable::RuraID' has a wrong offset!");
static_assert(offsetof(FGOP_MapChangeGroupTable, ChurchID) == 0x000024, "Member 'FGOP_MapChangeGroupTable::ChurchID' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapGuideTable
// 0x00B0 (0x00B8 - 0x0008)
struct FGOP_MapGuideTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetMain;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub00;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub01;                                       // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub02;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub03;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub04;                                       // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub05;                                       // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub06;                                       // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub07;                                       // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub08;                                       // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub09;                                       // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub10;                                       // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub11;                                       // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub12;                                       // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub13;                                       // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub14;                                       // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub15;                                       // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub16;                                       // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub17;                                       // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub18;                                       // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSub19;                                       // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_MapGuideTable) == 0x000008, "Wrong alignment on FGOP_MapGuideTable");
static_assert(sizeof(FGOP_MapGuideTable) == 0x0000B8, "Wrong size on FGOP_MapGuideTable");
static_assert(offsetof(FGOP_MapGuideTable, SelfId) == 0x000008, "Member 'FGOP_MapGuideTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetMain) == 0x000010, "Member 'FGOP_MapGuideTable::TargetMain' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub00) == 0x000018, "Member 'FGOP_MapGuideTable::TargetSub00' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub01) == 0x000020, "Member 'FGOP_MapGuideTable::TargetSub01' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub02) == 0x000028, "Member 'FGOP_MapGuideTable::TargetSub02' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub03) == 0x000030, "Member 'FGOP_MapGuideTable::TargetSub03' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub04) == 0x000038, "Member 'FGOP_MapGuideTable::TargetSub04' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub05) == 0x000040, "Member 'FGOP_MapGuideTable::TargetSub05' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub06) == 0x000048, "Member 'FGOP_MapGuideTable::TargetSub06' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub07) == 0x000050, "Member 'FGOP_MapGuideTable::TargetSub07' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub08) == 0x000058, "Member 'FGOP_MapGuideTable::TargetSub08' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub09) == 0x000060, "Member 'FGOP_MapGuideTable::TargetSub09' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub10) == 0x000068, "Member 'FGOP_MapGuideTable::TargetSub10' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub11) == 0x000070, "Member 'FGOP_MapGuideTable::TargetSub11' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub12) == 0x000078, "Member 'FGOP_MapGuideTable::TargetSub12' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub13) == 0x000080, "Member 'FGOP_MapGuideTable::TargetSub13' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub14) == 0x000088, "Member 'FGOP_MapGuideTable::TargetSub14' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub15) == 0x000090, "Member 'FGOP_MapGuideTable::TargetSub15' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub16) == 0x000098, "Member 'FGOP_MapGuideTable::TargetSub16' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub17) == 0x0000A0, "Member 'FGOP_MapGuideTable::TargetSub17' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub18) == 0x0000A8, "Member 'FGOP_MapGuideTable::TargetSub18' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideTable, TargetSub19) == 0x0000B0, "Member 'FGOP_MapGuideTable::TargetSub19' has a wrong offset!");

// ScriptStruct Nicola.StartPointInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FStartPointInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartPointInfo) == 0x000010, "Wrong alignment on FStartPointInfo");
static_assert(sizeof(FStartPointInfo) == 0x000050, "Wrong size on FStartPointInfo");

// ScriptStruct Nicola.GOP_MapGuideDataTable
// 0x01C8 (0x01D0 - 0x0008)
struct FGOP_MapGuideDataTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DispTriggerEventID;                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompleteTriggerEventID;                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextMapGuideID;                                    // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageTextID;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap00;                                // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap01;                                // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap02;                                // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap03;                                // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap04;                                // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap05;                                // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap06;                                // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap07;                                // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap08;                                // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap09;                                // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap10;                                // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap11;                                // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap12;                                // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap13;                                // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap14;                                // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap15;                                // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap16;                                // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap17;                                // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap18;                                // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDWorldMap19;                                // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon00;                             // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon01;                             // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon02;                             // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon03;                             // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon04;                             // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon05;                             // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon06;                             // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon07;                             // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon08;                             // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon09;                             // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon10;                             // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon11;                             // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon12;                             // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon13;                             // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon14;                             // 0x0150(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon15;                             // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon16;                             // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon17;                             // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon18;                             // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon19;                             // 0x0178(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon20;                             // 0x0180(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon21;                             // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon22;                             // 0x0190(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon23;                             // 0x0198(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon24;                             // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon25;                             // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon26;                             // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon27;                             // 0x01B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon28;                             // 0x01C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerIDTownDungeon29;                             // 0x01C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_MapGuideDataTable) == 0x000008, "Wrong alignment on FGOP_MapGuideDataTable");
static_assert(sizeof(FGOP_MapGuideDataTable) == 0x0001D0, "Wrong size on FGOP_MapGuideDataTable");
static_assert(offsetof(FGOP_MapGuideDataTable, SelfId) == 0x000008, "Member 'FGOP_MapGuideDataTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, DispTriggerEventID) == 0x000010, "Member 'FGOP_MapGuideDataTable::DispTriggerEventID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, CompleteTriggerEventID) == 0x000020, "Member 'FGOP_MapGuideDataTable::CompleteTriggerEventID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, NextMapGuideID) == 0x000030, "Member 'FGOP_MapGuideDataTable::NextMapGuideID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MessageTextID) == 0x000038, "Member 'FGOP_MapGuideDataTable::MessageTextID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap00) == 0x000040, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap00' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap01) == 0x000048, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap01' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap02) == 0x000050, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap02' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap03) == 0x000058, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap03' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap04) == 0x000060, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap04' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap05) == 0x000068, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap05' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap06) == 0x000070, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap06' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap07) == 0x000078, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap07' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap08) == 0x000080, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap08' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap09) == 0x000088, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap09' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap10) == 0x000090, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap10' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap11) == 0x000098, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap11' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap12) == 0x0000A0, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap12' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap13) == 0x0000A8, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap13' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap14) == 0x0000B0, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap14' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap15) == 0x0000B8, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap15' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap16) == 0x0000C0, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap16' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap17) == 0x0000C8, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap17' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap18) == 0x0000D0, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap18' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDWorldMap19) == 0x0000D8, "Member 'FGOP_MapGuideDataTable::MarkerIDWorldMap19' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon00) == 0x0000E0, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon00' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon01) == 0x0000E8, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon01' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon02) == 0x0000F0, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon02' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon03) == 0x0000F8, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon03' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon04) == 0x000100, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon04' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon05) == 0x000108, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon05' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon06) == 0x000110, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon06' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon07) == 0x000118, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon07' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon08) == 0x000120, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon08' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon09) == 0x000128, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon09' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon10) == 0x000130, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon10' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon11) == 0x000138, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon11' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon12) == 0x000140, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon12' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon13) == 0x000148, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon13' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon14) == 0x000150, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon14' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon15) == 0x000158, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon15' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon16) == 0x000160, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon16' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon17) == 0x000168, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon17' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon18) == 0x000170, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon18' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon19) == 0x000178, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon19' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon20) == 0x000180, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon20' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon21) == 0x000188, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon21' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon22) == 0x000190, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon22' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon23) == 0x000198, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon23' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon24) == 0x0001A0, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon24' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon25) == 0x0001A8, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon25' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon26) == 0x0001B0, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon26' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon27) == 0x0001B8, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon27' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon28) == 0x0001C0, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon28' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideDataTable, MarkerIDTownDungeon29) == 0x0001C8, "Member 'FGOP_MapGuideDataTable::MarkerIDTownDungeon29' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapGuideMarkerTable
// 0x0040 (0x0048 - 0x0008)
struct FGOP_MapGuideMarkerTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DispTriggerProgressID;                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HideTriggerProgressID;                             // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldMapLocationID;                                // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TownDungeonLocationID;                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TownDungeonPosition;                               // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_MapGuideMarkerTable) == 0x000008, "Wrong alignment on FGOP_MapGuideMarkerTable");
static_assert(sizeof(FGOP_MapGuideMarkerTable) == 0x000048, "Wrong size on FGOP_MapGuideMarkerTable");
static_assert(offsetof(FGOP_MapGuideMarkerTable, SelfId) == 0x000008, "Member 'FGOP_MapGuideMarkerTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideMarkerTable, DispTriggerProgressID) == 0x000010, "Member 'FGOP_MapGuideMarkerTable::DispTriggerProgressID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideMarkerTable, HideTriggerProgressID) == 0x000020, "Member 'FGOP_MapGuideMarkerTable::HideTriggerProgressID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideMarkerTable, WorldMapLocationID) == 0x000030, "Member 'FGOP_MapGuideMarkerTable::WorldMapLocationID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideMarkerTable, TownDungeonLocationID) == 0x000038, "Member 'FGOP_MapGuideMarkerTable::TownDungeonLocationID' has a wrong offset!");
static_assert(offsetof(FGOP_MapGuideMarkerTable, TownDungeonPosition) == 0x000040, "Member 'FGOP_MapGuideMarkerTable::TownDungeonPosition' has a wrong offset!");

// ScriptStruct Nicola.EffectSocketDatas
// 0x0050 (0x0050 - 0x0000)
struct FEffectSocketDatas final
{
public:
	TMap<EEffectSocketType, struct FVector>       SocketOffsets;                                     // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectSocketDatas) == 0x000008, "Wrong alignment on FEffectSocketDatas");
static_assert(sizeof(FEffectSocketDatas) == 0x000050, "Wrong size on FEffectSocketDatas");
static_assert(offsetof(FEffectSocketDatas, SocketOffsets) == 0x000000, "Member 'FEffectSocketDatas::SocketOffsets' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapImageOverlayTable
// 0x0038 (0x0040 - 0x0008)
struct FGOP_MapImageOverlayTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MapImage;                                          // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DispTriggerProgressID;                             // 0x0038(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          HideTriggerProgressID;                             // 0x003A(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MapImageOverlayTable) == 0x000008, "Wrong alignment on FGOP_MapImageOverlayTable");
static_assert(sizeof(FGOP_MapImageOverlayTable) == 0x000040, "Wrong size on FGOP_MapImageOverlayTable");
static_assert(offsetof(FGOP_MapImageOverlayTable, SelfId) == 0x000008, "Member 'FGOP_MapImageOverlayTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapImageOverlayTable, MapImage) == 0x000010, "Member 'FGOP_MapImageOverlayTable::MapImage' has a wrong offset!");
static_assert(offsetof(FGOP_MapImageOverlayTable, DispTriggerProgressID) == 0x000038, "Member 'FGOP_MapImageOverlayTable::DispTriggerProgressID' has a wrong offset!");
static_assert(offsetof(FGOP_MapImageOverlayTable, HideTriggerProgressID) == 0x00003A, "Member 'FGOP_MapImageOverlayTable::HideTriggerProgressID' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapListTable
// 0x0178 (0x0180 - 0x0008)
struct FGOP_MapListTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrefixId;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SuffixId;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapId;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DispLandName;                                      // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEvac;                                           // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseZoom;                                           // 0x0042(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMagic;                                          // 0x0043(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCallShop;                                       // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDigAHole;                                       // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStunbeat;                                        // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOrdealA;                                         // 0x0047(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOrdealB;                                         // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ZoomMovingID;                                      // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameTextId;                                        // 0x0054(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmID_Day;                                         // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmID_Night;                                       // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GOPEnumMapBgmType01;                               // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmID01_Day;                                       // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmID01_Night;                                     // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GOPEnumMapBgmType02;                               // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmID02_Day;                                       // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmID02_Night;                                     // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightOnLantern                               LightOnLantern;                                    // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LanternParamId;                                    // 0x00B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwayAnimationType                            ESwayAnimType;                                     // 0x00BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraSettingID;                                   // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallSpeed;                                         // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallTime;                                          // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleMapID;                                       // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncounterID;                                       // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRate;                                     // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastWalkRate;                                      // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneStepCoeff;                                      // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDOF;                                         // 0x00EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              MapImage;                                          // 0x00F0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapScale;                                          // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapMagnification;                                  // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiniMapScale;                                      // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapSpotIconDayTimeID;                              // 0x0124(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapSpotIconNightID;                                // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapSpotIconIndex;                                  // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapOriginalPos;                                    // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapSize;                                           // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapFloorGroup;                                     // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapFloorSortNum;                                   // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepEffectFloorGroup;                              // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoutMonsterFloorGroup;                            // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FieldSymbolId;                                     // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnderground;                                     // 0x0160(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MemoryPlaceSortOrder;                              // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TownTelopTextID;                                   // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETownTelopColorType                           TownTelopColorType;                                // 0x0170(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MemoryID;                                          // 0x0174(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MapListTable) == 0x000008, "Wrong alignment on FGOP_MapListTable");
static_assert(sizeof(FGOP_MapListTable) == 0x000180, "Wrong size on FGOP_MapListTable");
static_assert(offsetof(FGOP_MapListTable, SelfId) == 0x000008, "Member 'FGOP_MapListTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, PrefixId) == 0x000010, "Member 'FGOP_MapListTable::PrefixId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, SuffixId) == 0x000020, "Member 'FGOP_MapListTable::SuffixId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapId) == 0x000030, "Member 'FGOP_MapListTable::MapId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, DispLandName) == 0x000040, "Member 'FGOP_MapListTable::DispLandName' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, UseEvac) == 0x000041, "Member 'FGOP_MapListTable::UseEvac' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, UseZoom) == 0x000042, "Member 'FGOP_MapListTable::UseZoom' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, UseMagic) == 0x000043, "Member 'FGOP_MapListTable::UseMagic' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, UseCallShop) == 0x000044, "Member 'FGOP_MapListTable::UseCallShop' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, UseDigAHole) == 0x000045, "Member 'FGOP_MapListTable::UseDigAHole' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, IsStunbeat) == 0x000046, "Member 'FGOP_MapListTable::IsStunbeat' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, IsOrdealA) == 0x000047, "Member 'FGOP_MapListTable::IsOrdealA' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, IsOrdealB) == 0x000048, "Member 'FGOP_MapListTable::IsOrdealB' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, ZoomMovingID) == 0x00004C, "Member 'FGOP_MapListTable::ZoomMovingID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, NameTextId) == 0x000054, "Member 'FGOP_MapListTable::NameTextId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BgmID_Day) == 0x00005C, "Member 'FGOP_MapListTable::BgmID_Day' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BgmID_Night) == 0x000064, "Member 'FGOP_MapListTable::BgmID_Night' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, GOPEnumMapBgmType01) == 0x000070, "Member 'FGOP_MapListTable::GOPEnumMapBgmType01' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BgmID01_Day) == 0x000080, "Member 'FGOP_MapListTable::BgmID01_Day' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BgmID01_Night) == 0x000088, "Member 'FGOP_MapListTable::BgmID01_Night' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, GOPEnumMapBgmType02) == 0x000090, "Member 'FGOP_MapListTable::GOPEnumMapBgmType02' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BgmID02_Day) == 0x0000A0, "Member 'FGOP_MapListTable::BgmID02_Day' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BgmID02_Night) == 0x0000A8, "Member 'FGOP_MapListTable::BgmID02_Night' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, LightOnLantern) == 0x0000B0, "Member 'FGOP_MapListTable::LightOnLantern' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, LanternParamId) == 0x0000B4, "Member 'FGOP_MapListTable::LanternParamId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, CastShadow) == 0x0000BC, "Member 'FGOP_MapListTable::CastShadow' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, ESwayAnimType) == 0x0000BD, "Member 'FGOP_MapListTable::ESwayAnimType' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, CameraSettingID) == 0x0000C0, "Member 'FGOP_MapListTable::CameraSettingID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, FallSpeed) == 0x0000C8, "Member 'FGOP_MapListTable::FallSpeed' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, FallTime) == 0x0000CC, "Member 'FGOP_MapListTable::FallTime' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, BattleMapID) == 0x0000D0, "Member 'FGOP_MapListTable::BattleMapID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, EncounterID) == 0x0000D8, "Member 'FGOP_MapListTable::EncounterID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, EncounterRate) == 0x0000E0, "Member 'FGOP_MapListTable::EncounterRate' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, FastWalkRate) == 0x0000E4, "Member 'FGOP_MapListTable::FastWalkRate' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, OneStepCoeff) == 0x0000E8, "Member 'FGOP_MapListTable::OneStepCoeff' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, EnableDOF) == 0x0000EC, "Member 'FGOP_MapListTable::EnableDOF' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapImage) == 0x0000F0, "Member 'FGOP_MapListTable::MapImage' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapScale) == 0x000118, "Member 'FGOP_MapListTable::MapScale' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapMagnification) == 0x00011C, "Member 'FGOP_MapListTable::MapMagnification' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MiniMapScale) == 0x000120, "Member 'FGOP_MapListTable::MiniMapScale' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapSpotIconDayTimeID) == 0x000124, "Member 'FGOP_MapListTable::MapSpotIconDayTimeID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapSpotIconNightID) == 0x00012C, "Member 'FGOP_MapListTable::MapSpotIconNightID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapSpotIconIndex) == 0x000134, "Member 'FGOP_MapListTable::MapSpotIconIndex' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapOriginalPos) == 0x000138, "Member 'FGOP_MapListTable::MapOriginalPos' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapSize) == 0x000140, "Member 'FGOP_MapListTable::MapSize' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapFloorGroup) == 0x000148, "Member 'FGOP_MapListTable::MapFloorGroup' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MapFloorSortNum) == 0x00014C, "Member 'FGOP_MapListTable::MapFloorSortNum' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, KeepEffectFloorGroup) == 0x000150, "Member 'FGOP_MapListTable::KeepEffectFloorGroup' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, ScoutMonsterFloorGroup) == 0x000154, "Member 'FGOP_MapListTable::ScoutMonsterFloorGroup' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, FieldSymbolId) == 0x000158, "Member 'FGOP_MapListTable::FieldSymbolId' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, IsUnderground) == 0x000160, "Member 'FGOP_MapListTable::IsUnderground' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MemoryPlaceSortOrder) == 0x000164, "Member 'FGOP_MapListTable::MemoryPlaceSortOrder' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, TownTelopTextID) == 0x000168, "Member 'FGOP_MapListTable::TownTelopTextID' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, TownTelopColorType) == 0x000170, "Member 'FGOP_MapListTable::TownTelopColorType' has a wrong offset!");
static_assert(offsetof(FGOP_MapListTable, MemoryID) == 0x000174, "Member 'FGOP_MapListTable::MemoryID' has a wrong offset!");

// ScriptStruct Nicola.SkipSequenceSoundProcess
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSkipSequenceSoundProcess final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkipSequenceSoundProcess) == 0x000004, "Wrong alignment on FSkipSequenceSoundProcess");
static_assert(sizeof(FSkipSequenceSoundProcess) == 0x00000C, "Wrong size on FSkipSequenceSoundProcess");

// ScriptStruct Nicola.GOP_MapList_BattleTable
// 0x0038 (0x0040 - 0x0008)
struct FGOP_MapList_BattleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapId;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwayAnimationType                            ESwayAnimType;                                     // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionCameraPostProcessId;                         // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommandCameraPostProcessId;                        // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommandCameraDragonPostProcessId;                  // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoProhibitChangingLightIntensity;                  // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MapList_BattleTable) == 0x000008, "Wrong alignment on FGOP_MapList_BattleTable");
static_assert(sizeof(FGOP_MapList_BattleTable) == 0x000040, "Wrong size on FGOP_MapList_BattleTable");
static_assert(offsetof(FGOP_MapList_BattleTable, SelfId) == 0x000008, "Member 'FGOP_MapList_BattleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_BattleTable, MapId) == 0x000010, "Member 'FGOP_MapList_BattleTable::MapId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_BattleTable, ESwayAnimType) == 0x000020, "Member 'FGOP_MapList_BattleTable::ESwayAnimType' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_BattleTable, ActionCameraPostProcessId) == 0x000024, "Member 'FGOP_MapList_BattleTable::ActionCameraPostProcessId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_BattleTable, CommandCameraPostProcessId) == 0x00002C, "Member 'FGOP_MapList_BattleTable::CommandCameraPostProcessId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_BattleTable, CommandCameraDragonPostProcessId) == 0x000034, "Member 'FGOP_MapList_BattleTable::CommandCameraDragonPostProcessId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_BattleTable, DoProhibitChangingLightIntensity) == 0x00003C, "Member 'FGOP_MapList_BattleTable::DoProhibitChangingLightIntensity' has a wrong offset!");

// ScriptStruct Nicola.GOP_MapList_Battle_SubLevelTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_MapList_Battle_SubLevelTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sublevel;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 UseTimeFrame;                                      // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MapList_Battle_SubLevelTable) == 0x000008, "Wrong alignment on FGOP_MapList_Battle_SubLevelTable");
static_assert(sizeof(FGOP_MapList_Battle_SubLevelTable) == 0x000030, "Wrong size on FGOP_MapList_Battle_SubLevelTable");
static_assert(offsetof(FGOP_MapList_Battle_SubLevelTable, SelfId) == 0x000008, "Member 'FGOP_MapList_Battle_SubLevelTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_Battle_SubLevelTable, MapId) == 0x000010, "Member 'FGOP_MapList_Battle_SubLevelTable::MapId' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_Battle_SubLevelTable, Sublevel) == 0x000018, "Member 'FGOP_MapList_Battle_SubLevelTable::Sublevel' has a wrong offset!");
static_assert(offsetof(FGOP_MapList_Battle_SubLevelTable, UseTimeFrame) == 0x000028, "Member 'FGOP_MapList_Battle_SubLevelTable::UseTimeFrame' has a wrong offset!");

// ScriptStruct Nicola.FadeEffectInfo
// 0x0020 (0x0020 - 0x0000)
struct FFadeEffectInfo final
{
public:
	class UFXSystemComponent*                     fxComp;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFadeEffectInfo) == 0x000008, "Wrong alignment on FFadeEffectInfo");
static_assert(sizeof(FFadeEffectInfo) == 0x000020, "Wrong size on FFadeEffectInfo");
static_assert(offsetof(FFadeEffectInfo, fxComp) == 0x000000, "Member 'FFadeEffectInfo::fxComp' has a wrong offset!");

// ScriptStruct Nicola.GOP_MedalTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_MedalTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequireMedal;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_0;                                         // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MedalTable) == 0x000008, "Wrong alignment on FGOP_MedalTable");
static_assert(sizeof(FGOP_MedalTable) == 0x000020, "Wrong size on FGOP_MedalTable");
static_assert(offsetof(FGOP_MedalTable, SelfId) == 0x000008, "Member 'FGOP_MedalTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MedalTable, RequireMedal) == 0x000010, "Member 'FGOP_MedalTable::RequireMedal' has a wrong offset!");
static_assert(offsetof(FGOP_MedalTable, Product_0) == 0x000014, "Member 'FGOP_MedalTable::Product_0' has a wrong offset!");

// ScriptStruct Nicola.GOP_Member_InitTable
// 0x0048 (0x0050 - 0x0008)
struct FGOP_Member_InitTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameTextId;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitClassType                                ClassType;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitGenderType                               GenderType;                                        // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Looks;                                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairColor;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Voice;                                             // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersonalityId;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMP;                                             // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         STR;                                               // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ARM;                                               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AGI;                                               // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VIT;                                               // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         INT;                                               // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LUC;                                               // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Member_InitTable) == 0x000008, "Wrong alignment on FGOP_Member_InitTable");
static_assert(sizeof(FGOP_Member_InitTable) == 0x000050, "Wrong size on FGOP_Member_InitTable");
static_assert(offsetof(FGOP_Member_InitTable, SelfId) == 0x000008, "Member 'FGOP_Member_InitTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, NameTextId) == 0x000010, "Member 'FGOP_Member_InitTable::NameTextId' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, ClassType) == 0x000018, "Member 'FGOP_Member_InitTable::ClassType' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, GenderType) == 0x000019, "Member 'FGOP_Member_InitTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, Looks) == 0x00001C, "Member 'FGOP_Member_InitTable::Looks' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, HairColor) == 0x000020, "Member 'FGOP_Member_InitTable::HairColor' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, Voice) == 0x000024, "Member 'FGOP_Member_InitTable::Voice' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, PersonalityId) == 0x000028, "Member 'FGOP_Member_InitTable::PersonalityId' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, MaxHP) == 0x000030, "Member 'FGOP_Member_InitTable::MaxHP' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, MaxMP) == 0x000034, "Member 'FGOP_Member_InitTable::MaxMP' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, STR) == 0x000038, "Member 'FGOP_Member_InitTable::STR' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, ARM) == 0x00003C, "Member 'FGOP_Member_InitTable::ARM' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, AGI) == 0x000040, "Member 'FGOP_Member_InitTable::AGI' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, VIT) == 0x000044, "Member 'FGOP_Member_InitTable::VIT' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, INT) == 0x000048, "Member 'FGOP_Member_InitTable::INT' has a wrong offset!");
static_assert(offsetof(FGOP_Member_InitTable, LUC) == 0x00004C, "Member 'FGOP_Member_InitTable::LUC' has a wrong offset!");

// ScriptStruct Nicola.UIMBRMagicInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FUIMBRMagicInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMBRMagicInfo) == 0x000004, "Wrong alignment on FUIMBRMagicInfo");
static_assert(sizeof(FUIMBRMagicInfo) == 0x000018, "Wrong size on FUIMBRMagicInfo");

// ScriptStruct Nicola.GOP_MemoryTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_MemoryTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaNameId;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortNum;                                           // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MemoryTable) == 0x000008, "Wrong alignment on FGOP_MemoryTable");
static_assert(sizeof(FGOP_MemoryTable) == 0x000020, "Wrong size on FGOP_MemoryTable");
static_assert(offsetof(FGOP_MemoryTable, SelfId) == 0x000008, "Member 'FGOP_MemoryTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MemoryTable, AreaNameId) == 0x000010, "Member 'FGOP_MemoryTable::AreaNameId' has a wrong offset!");
static_assert(offsetof(FGOP_MemoryTable, SortNum) == 0x000018, "Member 'FGOP_MemoryTable::SortNum' has a wrong offset!");

// ScriptStruct Nicola.GOP_MonsterTable
// 0x00B0 (0x00B8 - 0x0008)
struct FGOP_MonsterTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Monster_ActionList;                                // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Monster_ConfuseActionList;                         // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min_Actions;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Actions;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_HP;                                            // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_MP;                                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack;                                            // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Defense;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Intelligence;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Luck;                                              // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntelligenceLevel;                                 // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Avoidance_Probability;                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Drop_Item;                                         // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drop_Probability;                                  // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Dragon;                                         // 0x0064(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Zombie;                                         // 0x0065(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Metal;                                          // 0x0066(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Kaijin;                                         // 0x0067(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Beast;                                          // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Insect;                                         // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Auto_Heal_Base_Num;                                // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Auto_Heal_Add_Num;                                 // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Appear;                                        // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Fly;                                            // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MotionCurve_Battleidle;                            // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Battle_Resist;                                     // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Boss;                                           // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_RollAttacker;                                   // 0x0099(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_RollHealer;                                     // 0x009A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_RollSupporter;                                  // 0x009B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Shade;                                          // 0x009C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Damage_PC_Cure;                                 // 0x009D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Magnification_Effect_Size;                         // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_Effect_Scale;                                  // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battle_Size_Width;                                 // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battle_Size_Height;                                // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECallFriendAppearDirectionType                CallFriendAppearDirectionType;                     // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_MonsterTable) == 0x000008, "Wrong alignment on FGOP_MonsterTable");
static_assert(sizeof(FGOP_MonsterTable) == 0x0000B8, "Wrong size on FGOP_MonsterTable");
static_assert(offsetof(FGOP_MonsterTable, SelfId) == 0x000008, "Member 'FGOP_MonsterTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Level) == 0x000010, "Member 'FGOP_MonsterTable::Level' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Monster_ActionList) == 0x000014, "Member 'FGOP_MonsterTable::Monster_ActionList' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Monster_ConfuseActionList) == 0x00001C, "Member 'FGOP_MonsterTable::Monster_ConfuseActionList' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Min_Actions) == 0x000024, "Member 'FGOP_MonsterTable::Min_Actions' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Max_Actions) == 0x000028, "Member 'FGOP_MonsterTable::Max_Actions' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Max_HP) == 0x00002C, "Member 'FGOP_MonsterTable::Max_HP' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Max_MP) == 0x000030, "Member 'FGOP_MonsterTable::Max_MP' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Attack) == 0x000034, "Member 'FGOP_MonsterTable::Attack' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Defense) == 0x000038, "Member 'FGOP_MonsterTable::Defense' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Speed) == 0x00003C, "Member 'FGOP_MonsterTable::Speed' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Intelligence) == 0x000040, "Member 'FGOP_MonsterTable::Intelligence' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Luck) == 0x000044, "Member 'FGOP_MonsterTable::Luck' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, IntelligenceLevel) == 0x000048, "Member 'FGOP_MonsterTable::IntelligenceLevel' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Avoidance_Probability) == 0x00004C, "Member 'FGOP_MonsterTable::Avoidance_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Exp) == 0x000050, "Member 'FGOP_MonsterTable::Exp' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Gold) == 0x000054, "Member 'FGOP_MonsterTable::Gold' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Drop_Item) == 0x000058, "Member 'FGOP_MonsterTable::Drop_Item' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Drop_Probability) == 0x000060, "Member 'FGOP_MonsterTable::Drop_Probability' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Dragon) == 0x000064, "Member 'FGOP_MonsterTable::Is_Dragon' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Zombie) == 0x000065, "Member 'FGOP_MonsterTable::Is_Zombie' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Metal) == 0x000066, "Member 'FGOP_MonsterTable::Is_Metal' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Kaijin) == 0x000067, "Member 'FGOP_MonsterTable::Is_Kaijin' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Beast) == 0x000068, "Member 'FGOP_MonsterTable::Is_Beast' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Insect) == 0x000069, "Member 'FGOP_MonsterTable::Is_Insect' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Auto_Heal_Base_Num) == 0x00006C, "Member 'FGOP_MonsterTable::Auto_Heal_Base_Num' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Auto_Heal_Add_Num) == 0x000070, "Member 'FGOP_MonsterTable::Auto_Heal_Add_Num' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Max_Appear) == 0x000074, "Member 'FGOP_MonsterTable::Max_Appear' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Fly) == 0x000078, "Member 'FGOP_MonsterTable::Is_Fly' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, MotionCurve_Battleidle) == 0x000080, "Member 'FGOP_MonsterTable::MotionCurve_Battleidle' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Battle_Resist) == 0x000090, "Member 'FGOP_MonsterTable::Battle_Resist' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Boss) == 0x000098, "Member 'FGOP_MonsterTable::Is_Boss' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_RollAttacker) == 0x000099, "Member 'FGOP_MonsterTable::Is_RollAttacker' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_RollHealer) == 0x00009A, "Member 'FGOP_MonsterTable::Is_RollHealer' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_RollSupporter) == 0x00009B, "Member 'FGOP_MonsterTable::Is_RollSupporter' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Shade) == 0x00009C, "Member 'FGOP_MonsterTable::Is_Shade' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Is_Damage_PC_Cure) == 0x00009D, "Member 'FGOP_MonsterTable::Is_Damage_PC_Cure' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Magnification_Effect_Size) == 0x0000A0, "Member 'FGOP_MonsterTable::Magnification_Effect_Size' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Max_Effect_Scale) == 0x0000A4, "Member 'FGOP_MonsterTable::Max_Effect_Scale' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Battle_Size_Width) == 0x0000A8, "Member 'FGOP_MonsterTable::Battle_Size_Width' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, Battle_Size_Height) == 0x0000AC, "Member 'FGOP_MonsterTable::Battle_Size_Height' has a wrong offset!");
static_assert(offsetof(FGOP_MonsterTable, CallFriendAppearDirectionType) == 0x0000B0, "Member 'FGOP_MonsterTable::CallFriendAppearDirectionType' has a wrong offset!");

// ScriptStruct Nicola.EventConditionInfo
// 0x0038 (0x0038 - 0x0000)
struct FEventConditionInfo final
{
public:
	int32                                         EventPriority;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventID;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressLower;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressUpper;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlagConditionData                     FlagData1;                                         // 0x0020(0x0004)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFlagConditionData                     FlagData2;                                         // 0x0024(0x0004)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EFlagOperator                                 FlagOperator;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopId;                                             // 0x002C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventConditionInfo) == 0x000008, "Wrong alignment on FEventConditionInfo");
static_assert(sizeof(FEventConditionInfo) == 0x000038, "Wrong size on FEventConditionInfo");
static_assert(offsetof(FEventConditionInfo, EventPriority) == 0x000000, "Member 'FEventConditionInfo::EventPriority' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, EventID) == 0x000008, "Member 'FEventConditionInfo::EventID' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, ProgressLower) == 0x000018, "Member 'FEventConditionInfo::ProgressLower' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, ProgressUpper) == 0x00001C, "Member 'FEventConditionInfo::ProgressUpper' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, FlagData1) == 0x000020, "Member 'FEventConditionInfo::FlagData1' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, FlagData2) == 0x000024, "Member 'FEventConditionInfo::FlagData2' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, FlagOperator) == 0x000028, "Member 'FEventConditionInfo::FlagOperator' has a wrong offset!");
static_assert(offsetof(FEventConditionInfo, GopId) == 0x00002C, "Member 'FEventConditionInfo::GopId' has a wrong offset!");

// ScriptStruct Nicola.GOP_Monster_LibraryTable
// 0x0070 (0x0078 - 0x0008)
struct FGOP_Monster_LibraryTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdUnitMaster;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdMonster;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TypeSortNo;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_jp;                                      // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_tw;                                      // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_cn;                                      // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_ko;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_en;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_fr;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_it;                                      // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_de;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_es;                                      // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ABCOerder_es419;                                   // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleFlipbook;                                     // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FlipbookOffset;                                    // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdHabitat1;                                     // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdHabitat2;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMoreHabitat;                                     // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopIdTrivia;                                       // 0x006C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Monster_LibraryTable) == 0x000008, "Wrong alignment on FGOP_Monster_LibraryTable");
static_assert(sizeof(FGOP_Monster_LibraryTable) == 0x000078, "Wrong size on FGOP_Monster_LibraryTable");
static_assert(offsetof(FGOP_Monster_LibraryTable, SelfId) == 0x000008, "Member 'FGOP_Monster_LibraryTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, GopIdUnitMaster) == 0x000010, "Member 'FGOP_Monster_LibraryTable::GopIdUnitMaster' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, GopIdMonster) == 0x000018, "Member 'FGOP_Monster_LibraryTable::GopIdMonster' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, TypeSortNo) == 0x000020, "Member 'FGOP_Monster_LibraryTable::TypeSortNo' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_jp) == 0x000024, "Member 'FGOP_Monster_LibraryTable::ABCOerder_jp' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_tw) == 0x000028, "Member 'FGOP_Monster_LibraryTable::ABCOerder_tw' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_cn) == 0x00002C, "Member 'FGOP_Monster_LibraryTable::ABCOerder_cn' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_ko) == 0x000030, "Member 'FGOP_Monster_LibraryTable::ABCOerder_ko' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_en) == 0x000034, "Member 'FGOP_Monster_LibraryTable::ABCOerder_en' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_fr) == 0x000038, "Member 'FGOP_Monster_LibraryTable::ABCOerder_fr' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_it) == 0x00003C, "Member 'FGOP_Monster_LibraryTable::ABCOerder_it' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_de) == 0x000040, "Member 'FGOP_Monster_LibraryTable::ABCOerder_de' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_es) == 0x000044, "Member 'FGOP_Monster_LibraryTable::ABCOerder_es' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ABCOerder_es419) == 0x000048, "Member 'FGOP_Monster_LibraryTable::ABCOerder_es419' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, ScaleFlipbook) == 0x00004C, "Member 'FGOP_Monster_LibraryTable::ScaleFlipbook' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, FlipbookOffset) == 0x000050, "Member 'FGOP_Monster_LibraryTable::FlipbookOffset' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, GopIdHabitat1) == 0x000058, "Member 'FGOP_Monster_LibraryTable::GopIdHabitat1' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, GopIdHabitat2) == 0x000060, "Member 'FGOP_Monster_LibraryTable::GopIdHabitat2' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, IsMoreHabitat) == 0x000068, "Member 'FGOP_Monster_LibraryTable::IsMoreHabitat' has a wrong offset!");
static_assert(offsetof(FGOP_Monster_LibraryTable, GopIdTrivia) == 0x00006C, "Member 'FGOP_Monster_LibraryTable::GopIdTrivia' has a wrong offset!");

// ScriptStruct Nicola.GOP_NG_NameListTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_NG_NameListTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextNPCNameID;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_NG_NameListTable) == 0x000008, "Wrong alignment on FGOP_NG_NameListTable");
static_assert(sizeof(FGOP_NG_NameListTable) == 0x000018, "Wrong size on FGOP_NG_NameListTable");
static_assert(offsetof(FGOP_NG_NameListTable, SelfId) == 0x000008, "Member 'FGOP_NG_NameListTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_NG_NameListTable, TextNPCNameID) == 0x000010, "Member 'FGOP_NG_NameListTable::TextNPCNameID' has a wrong offset!");

// ScriptStruct Nicola.SequenceBattleAssetTable
// 0x0030 (0x0038 - 0x0008)
struct FSequenceBattleAssetTable final : public FTableRowBase
{
public:
	TSoftObjectPtr<class ULevelSequence>          Sequence;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Disposable;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSequenceBattleAssetTable) == 0x000008, "Wrong alignment on FSequenceBattleAssetTable");
static_assert(sizeof(FSequenceBattleAssetTable) == 0x000038, "Wrong size on FSequenceBattleAssetTable");
static_assert(offsetof(FSequenceBattleAssetTable, Sequence) == 0x000008, "Member 'FSequenceBattleAssetTable::Sequence' has a wrong offset!");
static_assert(offsetof(FSequenceBattleAssetTable, Disposable) == 0x000030, "Member 'FSequenceBattleAssetTable::Disposable' has a wrong offset!");

// ScriptStruct Nicola.GOP_NPC_Talk_CommonTable
// 0x0048 (0x0050 - 0x0008)
struct FGOP_NPC_Talk_CommonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNpcName;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NpcNameId;                                         // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageId;                                         // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNextMessage;                                  // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VoiceId;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PopopoId;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePopopoSE;                                  // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NextTalkId;                                        // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RootTalkId;                                        // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MainFlag;                                          // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFlag;                                        // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotForget;                                         // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenshotProcessType                        ScreenshotType;                                    // 0x004F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_NPC_Talk_CommonTable) == 0x000008, "Wrong alignment on FGOP_NPC_Talk_CommonTable");
static_assert(sizeof(FGOP_NPC_Talk_CommonTable) == 0x000050, "Wrong size on FGOP_NPC_Talk_CommonTable");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, SelfId) == 0x000008, "Member 'FGOP_NPC_Talk_CommonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, bShowNpcName) == 0x000010, "Member 'FGOP_NPC_Talk_CommonTable::bShowNpcName' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, NpcNameId) == 0x000014, "Member 'FGOP_NPC_Talk_CommonTable::NpcNameId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, MessageId) == 0x00001C, "Member 'FGOP_NPC_Talk_CommonTable::MessageId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, bShowNextMessage) == 0x000024, "Member 'FGOP_NPC_Talk_CommonTable::bShowNextMessage' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, VoiceId) == 0x000028, "Member 'FGOP_NPC_Talk_CommonTable::VoiceId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, PopopoId) == 0x000030, "Member 'FGOP_NPC_Talk_CommonTable::PopopoId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, bDisablePopopoSE) == 0x000038, "Member 'FGOP_NPC_Talk_CommonTable::bDisablePopopoSE' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, NextTalkId) == 0x00003C, "Member 'FGOP_NPC_Talk_CommonTable::NextTalkId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, RootTalkId) == 0x000044, "Member 'FGOP_NPC_Talk_CommonTable::RootTalkId' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, MainFlag) == 0x00004C, "Member 'FGOP_NPC_Talk_CommonTable::MainFlag' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, IgnoreFlag) == 0x00004D, "Member 'FGOP_NPC_Talk_CommonTable::IgnoreFlag' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, NotForget) == 0x00004E, "Member 'FGOP_NPC_Talk_CommonTable::NotForget' has a wrong offset!");
static_assert(offsetof(FGOP_NPC_Talk_CommonTable, ScreenshotType) == 0x00004F, "Member 'FGOP_NPC_Talk_CommonTable::ScreenshotType' has a wrong offset!");

// ScriptStruct Nicola.GOP_OperationGuideTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_OperationGuideTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonIcon;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonIcon2;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GuideTextID;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_OperationGuideTable) == 0x000008, "Wrong alignment on FGOP_OperationGuideTable");
static_assert(sizeof(FGOP_OperationGuideTable) == 0x000038, "Wrong size on FGOP_OperationGuideTable");
static_assert(offsetof(FGOP_OperationGuideTable, SelfId) == 0x000008, "Member 'FGOP_OperationGuideTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_OperationGuideTable, ButtonIcon) == 0x000010, "Member 'FGOP_OperationGuideTable::ButtonIcon' has a wrong offset!");
static_assert(offsetof(FGOP_OperationGuideTable, ButtonIcon2) == 0x000020, "Member 'FGOP_OperationGuideTable::ButtonIcon2' has a wrong offset!");
static_assert(offsetof(FGOP_OperationGuideTable, GuideTextID) == 0x000030, "Member 'FGOP_OperationGuideTable::GuideTextID' has a wrong offset!");

// ScriptStruct Nicola.UIEndingStaffRollMenuImageRowData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FUIEndingStaffRollMenuImageRowData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIEndingStaffRollMenuImageRowData) == 0x000004, "Wrong alignment on FUIEndingStaffRollMenuImageRowData");
static_assert(sizeof(FUIEndingStaffRollMenuImageRowData) == 0x000018, "Wrong size on FUIEndingStaffRollMenuImageRowData");

// ScriptStruct Nicola.GOP_PersonalityTable
// 0x0050 (0x0058 - 0x0008)
struct FGOP_PersonalityTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayNameId;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DicideTextPattern;                                 // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeWarriorTextPattern;                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeFighterTextPattern;                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangePriestTextPattern;                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeMageTextPattern;                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeSageTextPattern;                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeMerchantTextPattern;                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeGadaboutTextPattern;                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeThiefTextPattern;                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JobChangeBreederTextPattern;                       // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Correct_Str;                                       // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Correct_Arm;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Correct_Agi;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Correct_Vit;                                       // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Correct_Int;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Correct_Luc;                                       // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_PersonalityTable) == 0x000008, "Wrong alignment on FGOP_PersonalityTable");
static_assert(sizeof(FGOP_PersonalityTable) == 0x000058, "Wrong size on FGOP_PersonalityTable");
static_assert(offsetof(FGOP_PersonalityTable, SelfId) == 0x000008, "Member 'FGOP_PersonalityTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, DisplayNameId) == 0x000010, "Member 'FGOP_PersonalityTable::DisplayNameId' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, DicideTextPattern) == 0x000018, "Member 'FGOP_PersonalityTable::DicideTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeWarriorTextPattern) == 0x00001C, "Member 'FGOP_PersonalityTable::JobChangeWarriorTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeFighterTextPattern) == 0x000020, "Member 'FGOP_PersonalityTable::JobChangeFighterTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangePriestTextPattern) == 0x000024, "Member 'FGOP_PersonalityTable::JobChangePriestTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeMageTextPattern) == 0x000028, "Member 'FGOP_PersonalityTable::JobChangeMageTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeSageTextPattern) == 0x00002C, "Member 'FGOP_PersonalityTable::JobChangeSageTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeMerchantTextPattern) == 0x000030, "Member 'FGOP_PersonalityTable::JobChangeMerchantTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeGadaboutTextPattern) == 0x000034, "Member 'FGOP_PersonalityTable::JobChangeGadaboutTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeThiefTextPattern) == 0x000038, "Member 'FGOP_PersonalityTable::JobChangeThiefTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, JobChangeBreederTextPattern) == 0x00003C, "Member 'FGOP_PersonalityTable::JobChangeBreederTextPattern' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, Correct_Str) == 0x000040, "Member 'FGOP_PersonalityTable::Correct_Str' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, Correct_Arm) == 0x000044, "Member 'FGOP_PersonalityTable::Correct_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, Correct_Agi) == 0x000048, "Member 'FGOP_PersonalityTable::Correct_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, Correct_Vit) == 0x00004C, "Member 'FGOP_PersonalityTable::Correct_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, Correct_Int) == 0x000050, "Member 'FGOP_PersonalityTable::Correct_Int' has a wrong offset!");
static_assert(offsetof(FGOP_PersonalityTable, Correct_Luc) == 0x000054, "Member 'FGOP_PersonalityTable::Correct_Luc' has a wrong offset!");

// ScriptStruct Nicola.GOP_Personality_CandidateTable
// 0x0058 (0x0060 - 0x0008)
struct FGOP_Personality_CandidateTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitClassType                                ClassType;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusType                                   MaxIncrementalStatus;                              // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IncrementRangeMin;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncrementRangeMax;                                 // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusType                                   SubIncrementalStatus_0;                            // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusType                                   SubIncrementalStatus_1;                            // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusType                                   SubIncrementalStatus_2;                            // 0x001E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Personality_0;                                     // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_1;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_2;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_3;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_4;                                     // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_5;                                     // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_6;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Personality_7;                                     // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Personality_CandidateTable) == 0x000008, "Wrong alignment on FGOP_Personality_CandidateTable");
static_assert(sizeof(FGOP_Personality_CandidateTable) == 0x000060, "Wrong size on FGOP_Personality_CandidateTable");
static_assert(offsetof(FGOP_Personality_CandidateTable, SelfId) == 0x000008, "Member 'FGOP_Personality_CandidateTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, ClassType) == 0x000010, "Member 'FGOP_Personality_CandidateTable::ClassType' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, MaxIncrementalStatus) == 0x000011, "Member 'FGOP_Personality_CandidateTable::MaxIncrementalStatus' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, IncrementRangeMin) == 0x000014, "Member 'FGOP_Personality_CandidateTable::IncrementRangeMin' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, IncrementRangeMax) == 0x000018, "Member 'FGOP_Personality_CandidateTable::IncrementRangeMax' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, SubIncrementalStatus_0) == 0x00001C, "Member 'FGOP_Personality_CandidateTable::SubIncrementalStatus_0' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, SubIncrementalStatus_1) == 0x00001D, "Member 'FGOP_Personality_CandidateTable::SubIncrementalStatus_1' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, SubIncrementalStatus_2) == 0x00001E, "Member 'FGOP_Personality_CandidateTable::SubIncrementalStatus_2' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_0) == 0x000020, "Member 'FGOP_Personality_CandidateTable::Personality_0' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_1) == 0x000028, "Member 'FGOP_Personality_CandidateTable::Personality_1' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_2) == 0x000030, "Member 'FGOP_Personality_CandidateTable::Personality_2' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_3) == 0x000038, "Member 'FGOP_Personality_CandidateTable::Personality_3' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_4) == 0x000040, "Member 'FGOP_Personality_CandidateTable::Personality_4' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_5) == 0x000048, "Member 'FGOP_Personality_CandidateTable::Personality_5' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_6) == 0x000050, "Member 'FGOP_Personality_CandidateTable::Personality_6' has a wrong offset!");
static_assert(offsetof(FGOP_Personality_CandidateTable, Personality_7) == 0x000058, "Member 'FGOP_Personality_CandidateTable::Personality_7' has a wrong offset!");

// ScriptStruct Nicola.UIBattleItemInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FUIBattleItemInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleItemInfo) == 0x000008, "Wrong alignment on FUIBattleItemInfo");
static_assert(sizeof(FUIBattleItemInfo) == 0x000050, "Wrong size on FUIBattleItemInfo");

// ScriptStruct Nicola.GOP_PostProcess_BattleTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_PostProcess_BattleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aperture;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aperture_SwitchTV;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aperture_SwitchHH;                                 // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurAmount;                                   // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurAmount_SwitchTV;                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurAmount_SwitchHH;                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurRadius;                                   // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurRadius_SwitchTV;                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurRadius_SwitchHH;                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusOffsetX;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_PostProcess_BattleTable) == 0x000008, "Wrong alignment on FGOP_PostProcess_BattleTable");
static_assert(sizeof(FGOP_PostProcess_BattleTable) == 0x000038, "Wrong size on FGOP_PostProcess_BattleTable");
static_assert(offsetof(FGOP_PostProcess_BattleTable, SelfId) == 0x000008, "Member 'FGOP_PostProcess_BattleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, Aperture) == 0x000010, "Member 'FGOP_PostProcess_BattleTable::Aperture' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, Aperture_SwitchTV) == 0x000014, "Member 'FGOP_PostProcess_BattleTable::Aperture_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, Aperture_SwitchHH) == 0x000018, "Member 'FGOP_PostProcess_BattleTable::Aperture_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, DepthBlurAmount) == 0x00001C, "Member 'FGOP_PostProcess_BattleTable::DepthBlurAmount' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, DepthBlurAmount_SwitchTV) == 0x000020, "Member 'FGOP_PostProcess_BattleTable::DepthBlurAmount_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, DepthBlurAmount_SwitchHH) == 0x000024, "Member 'FGOP_PostProcess_BattleTable::DepthBlurAmount_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, DepthBlurRadius) == 0x000028, "Member 'FGOP_PostProcess_BattleTable::DepthBlurRadius' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, DepthBlurRadius_SwitchTV) == 0x00002C, "Member 'FGOP_PostProcess_BattleTable::DepthBlurRadius_SwitchTV' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, DepthBlurRadius_SwitchHH) == 0x000030, "Member 'FGOP_PostProcess_BattleTable::DepthBlurRadius_SwitchHH' has a wrong offset!");
static_assert(offsetof(FGOP_PostProcess_BattleTable, FocusOffsetX) == 0x000034, "Member 'FGOP_PostProcess_BattleTable::FocusOffsetX' has a wrong offset!");

// ScriptStruct Nicola.GOP_PS5_ActivityTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_PS5_ActivityTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartTriggerEventID;                               // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndTriggerEventID;                                 // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_PS5_ActivityTable) == 0x000008, "Wrong alignment on FGOP_PS5_ActivityTable");
static_assert(sizeof(FGOP_PS5_ActivityTable) == 0x000030, "Wrong size on FGOP_PS5_ActivityTable");
static_assert(offsetof(FGOP_PS5_ActivityTable, SelfId) == 0x000008, "Member 'FGOP_PS5_ActivityTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_PS5_ActivityTable, StartTriggerEventID) == 0x000010, "Member 'FGOP_PS5_ActivityTable::StartTriggerEventID' has a wrong offset!");
static_assert(offsetof(FGOP_PS5_ActivityTable, EndTriggerEventID) == 0x000020, "Member 'FGOP_PS5_ActivityTable::EndTriggerEventID' has a wrong offset!");

// ScriptStruct Nicola.UIKeyboardStorage
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FUIKeyboardStorage final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIKeyboardStorage) == 0x000008, "Wrong alignment on FUIKeyboardStorage");
static_assert(sizeof(FUIKeyboardStorage) == 0x000018, "Wrong size on FUIKeyboardStorage");

// ScriptStruct Nicola.GOP_RiremitoDataTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_RiremitoDataTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloorID;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerStartTag;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_RiremitoDataTable) == 0x000008, "Wrong alignment on FGOP_RiremitoDataTable");
static_assert(sizeof(FGOP_RiremitoDataTable) == 0x000028, "Wrong size on FGOP_RiremitoDataTable");
static_assert(offsetof(FGOP_RiremitoDataTable, SelfId) == 0x000008, "Member 'FGOP_RiremitoDataTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_RiremitoDataTable, FloorID) == 0x000010, "Member 'FGOP_RiremitoDataTable::FloorID' has a wrong offset!");
static_assert(offsetof(FGOP_RiremitoDataTable, PlayerStartTag) == 0x000018, "Member 'FGOP_RiremitoDataTable::PlayerStartTag' has a wrong offset!");

// ScriptStruct Nicola.GOP_Rura_RiremitoTable
// 0x00A8 (0x00B0 - 0x0008)
struct FGOP_Rura_RiremitoTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaNameId;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapLocationIconType                          MapLocationIconType;                               // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapLocationCategoryType                      MapLocationCategoryType;                           // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FloorID;                                           // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerStartOutTag;                                 // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerStartInTag;                                  // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LamiaStartTag;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShipStartTag;                                      // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapIconPlayerStartTag;                             // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RuraCursorPlayerStartTag;                          // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraMapSpotIconDaytime;                            // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraMapSpotIconNight;                              // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortNum;                                           // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllSortNum;                                        // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRiremitoUsePlayerStartInTag;                     // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RiremitoId;                                        // 0x00A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          EnableRuraProgressFlag;                            // 0x00AC(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumProgressType                          DisableRuraProgressFlag;                           // 0x00AE(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Rura_RiremitoTable) == 0x000008, "Wrong alignment on FGOP_Rura_RiremitoTable");
static_assert(sizeof(FGOP_Rura_RiremitoTable) == 0x0000B0, "Wrong size on FGOP_Rura_RiremitoTable");
static_assert(offsetof(FGOP_Rura_RiremitoTable, SelfId) == 0x000008, "Member 'FGOP_Rura_RiremitoTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, AreaNameId) == 0x000010, "Member 'FGOP_Rura_RiremitoTable::AreaNameId' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, MapLocationIconType) == 0x000018, "Member 'FGOP_Rura_RiremitoTable::MapLocationIconType' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, MapLocationCategoryType) == 0x000019, "Member 'FGOP_Rura_RiremitoTable::MapLocationCategoryType' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, FloorID) == 0x00001C, "Member 'FGOP_Rura_RiremitoTable::FloorID' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, PlayerStartOutTag) == 0x000028, "Member 'FGOP_Rura_RiremitoTable::PlayerStartOutTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, PlayerStartInTag) == 0x000038, "Member 'FGOP_Rura_RiremitoTable::PlayerStartInTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, LamiaStartTag) == 0x000048, "Member 'FGOP_Rura_RiremitoTable::LamiaStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, ShipStartTag) == 0x000058, "Member 'FGOP_Rura_RiremitoTable::ShipStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, MapIconPlayerStartTag) == 0x000068, "Member 'FGOP_Rura_RiremitoTable::MapIconPlayerStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, RuraCursorPlayerStartTag) == 0x000078, "Member 'FGOP_Rura_RiremitoTable::RuraCursorPlayerStartTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, RuraMapSpotIconDaytime) == 0x000088, "Member 'FGOP_Rura_RiremitoTable::RuraMapSpotIconDaytime' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, RuraMapSpotIconNight) == 0x000090, "Member 'FGOP_Rura_RiremitoTable::RuraMapSpotIconNight' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, SortNum) == 0x000098, "Member 'FGOP_Rura_RiremitoTable::SortNum' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, AllSortNum) == 0x00009C, "Member 'FGOP_Rura_RiremitoTable::AllSortNum' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, IsRiremitoUsePlayerStartInTag) == 0x0000A0, "Member 'FGOP_Rura_RiremitoTable::IsRiremitoUsePlayerStartInTag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, RiremitoId) == 0x0000A4, "Member 'FGOP_Rura_RiremitoTable::RiremitoId' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, EnableRuraProgressFlag) == 0x0000AC, "Member 'FGOP_Rura_RiremitoTable::EnableRuraProgressFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Rura_RiremitoTable, DisableRuraProgressFlag) == 0x0000AE, "Member 'FGOP_Rura_RiremitoTable::DisableRuraProgressFlag' has a wrong offset!");

// ScriptStruct Nicola.GOP_SE_Action_MonsterTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_SE_Action_MonsterTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SEId0;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SEId1;                                             // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SEId2;                                             // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_SE_Action_MonsterTable) == 0x000008, "Wrong alignment on FGOP_SE_Action_MonsterTable");
static_assert(sizeof(FGOP_SE_Action_MonsterTable) == 0x000028, "Wrong size on FGOP_SE_Action_MonsterTable");
static_assert(offsetof(FGOP_SE_Action_MonsterTable, SelfId) == 0x000008, "Member 'FGOP_SE_Action_MonsterTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_Action_MonsterTable, SEId0) == 0x000010, "Member 'FGOP_SE_Action_MonsterTable::SEId0' has a wrong offset!");
static_assert(offsetof(FGOP_SE_Action_MonsterTable, SEId1) == 0x000018, "Member 'FGOP_SE_Action_MonsterTable::SEId1' has a wrong offset!");
static_assert(offsetof(FGOP_SE_Action_MonsterTable, SEId2) == 0x000020, "Member 'FGOP_SE_Action_MonsterTable::SEId2' has a wrong offset!");

// ScriptStruct Nicola.GOP_SE_EventTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_SE_EventTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SEId;                                              // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_SE_EventTable) == 0x000008, "Wrong alignment on FGOP_SE_EventTable");
static_assert(sizeof(FGOP_SE_EventTable) == 0x000018, "Wrong size on FGOP_SE_EventTable");
static_assert(offsetof(FGOP_SE_EventTable, SelfId) == 0x000008, "Member 'FGOP_SE_EventTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_EventTable, SEId) == 0x000010, "Member 'FGOP_SE_EventTable::SEId' has a wrong offset!");

// ScriptStruct Nicola.UIMessageTagStorage
// 0x0208 (0x0208 - 0x0000)
struct alignas(0x08) FUIMessageTagStorage final
{
public:
	uint8                                         Pad_0[0x208];                                      // 0x0000(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMessageTagStorage) == 0x000008, "Wrong alignment on FUIMessageTagStorage");
static_assert(sizeof(FUIMessageTagStorage) == 0x000208, "Wrong size on FUIMessageTagStorage");

// ScriptStruct Nicola.GOP_SE_FieldTable
// 0x0048 (0x0050 - 0x0008)
struct FGOP_SE_FieldTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_MidNight;                                  // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_EarlyMorning;                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_Morning;                                   // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_Noon;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_AfterNoon;                                 // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_Evening;                                   // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_Night;                                     // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSE_AfterGameClear;                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_SE_FieldTable) == 0x000008, "Wrong alignment on FGOP_SE_FieldTable");
static_assert(sizeof(FGOP_SE_FieldTable) == 0x000050, "Wrong size on FGOP_SE_FieldTable");
static_assert(offsetof(FGOP_SE_FieldTable, SelfId) == 0x000008, "Member 'FGOP_SE_FieldTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_MidNight) == 0x000010, "Member 'FGOP_SE_FieldTable::GopIdSE_MidNight' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_EarlyMorning) == 0x000018, "Member 'FGOP_SE_FieldTable::GopIdSE_EarlyMorning' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_Morning) == 0x000020, "Member 'FGOP_SE_FieldTable::GopIdSE_Morning' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_Noon) == 0x000028, "Member 'FGOP_SE_FieldTable::GopIdSE_Noon' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_AfterNoon) == 0x000030, "Member 'FGOP_SE_FieldTable::GopIdSE_AfterNoon' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_Evening) == 0x000038, "Member 'FGOP_SE_FieldTable::GopIdSE_Evening' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_Night) == 0x000040, "Member 'FGOP_SE_FieldTable::GopIdSE_Night' has a wrong offset!");
static_assert(offsetof(FGOP_SE_FieldTable, GopIdSE_AfterGameClear) == 0x000048, "Member 'FGOP_SE_FieldTable::GopIdSE_AfterGameClear' has a wrong offset!");

// ScriptStruct Nicola.GOP_SE_MagicTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_SE_MagicTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SEId;                                              // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_SE_MagicTable) == 0x000008, "Wrong alignment on FGOP_SE_MagicTable");
static_assert(sizeof(FGOP_SE_MagicTable) == 0x000018, "Wrong size on FGOP_SE_MagicTable");
static_assert(offsetof(FGOP_SE_MagicTable, SelfId) == 0x000008, "Member 'FGOP_SE_MagicTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_MagicTable, SEId) == 0x000010, "Member 'FGOP_SE_MagicTable::SEId' has a wrong offset!");

// ScriptStruct Nicola.UIDLCItem
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FUIDLCItem final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIDLCItem) == 0x000004, "Wrong alignment on FUIDLCItem");
static_assert(sizeof(FUIDLCItem) == 0x000018, "Wrong size on FUIDLCItem");

// ScriptStruct Nicola.UIDLCInfo
// 0x0020 (0x0020 - 0x0000)
struct FUIDLCInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDLCItem>                     Items;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDLCInfo) == 0x000008, "Wrong alignment on FUIDLCInfo");
static_assert(sizeof(FUIDLCInfo) == 0x000020, "Wrong size on FUIDLCInfo");
static_assert(offsetof(FUIDLCInfo, Items) == 0x000010, "Member 'FUIDLCInfo::Items' has a wrong offset!");

// ScriptStruct Nicola.GOP_SE_ProgressAmbientTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_SE_ProgressAmbientTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GOPEnumProgressPlayable;                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GOPEnumProgressUnplayable;                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnNoFlagOn;                               // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnAllFlagOn;                              // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_SE_ProgressAmbientTable) == 0x000008, "Wrong alignment on FGOP_SE_ProgressAmbientTable");
static_assert(sizeof(FGOP_SE_ProgressAmbientTable) == 0x000038, "Wrong size on FGOP_SE_ProgressAmbientTable");
static_assert(offsetof(FGOP_SE_ProgressAmbientTable, SelfId) == 0x000008, "Member 'FGOP_SE_ProgressAmbientTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_ProgressAmbientTable, GOPEnumProgressPlayable) == 0x000010, "Member 'FGOP_SE_ProgressAmbientTable::GOPEnumProgressPlayable' has a wrong offset!");
static_assert(offsetof(FGOP_SE_ProgressAmbientTable, GOPEnumProgressUnplayable) == 0x000020, "Member 'FGOP_SE_ProgressAmbientTable::GOPEnumProgressUnplayable' has a wrong offset!");
static_assert(offsetof(FGOP_SE_ProgressAmbientTable, bPlayableOnNoFlagOn) == 0x000030, "Member 'FGOP_SE_ProgressAmbientTable::bPlayableOnNoFlagOn' has a wrong offset!");
static_assert(offsetof(FGOP_SE_ProgressAmbientTable, bPlayableOnAllFlagOn) == 0x000031, "Member 'FGOP_SE_ProgressAmbientTable::bPlayableOnAllFlagOn' has a wrong offset!");

// ScriptStruct Nicola.GOP_SE_SystemTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_SE_SystemTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SEId;                                              // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_SE_SystemTable) == 0x000008, "Wrong alignment on FGOP_SE_SystemTable");
static_assert(sizeof(FGOP_SE_SystemTable) == 0x000018, "Wrong size on FGOP_SE_SystemTable");
static_assert(offsetof(FGOP_SE_SystemTable, SelfId) == 0x000008, "Member 'FGOP_SE_SystemTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_SystemTable, SEId) == 0x000010, "Member 'FGOP_SE_SystemTable::SEId' has a wrong offset!");

// ScriptStruct Nicola.UISelectItemStorage
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FUISelectItemStorage final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUISelectItemStorage) == 0x000008, "Wrong alignment on FUISelectItemStorage");
static_assert(sizeof(FUISelectItemStorage) == 0x000060, "Wrong size on FUISelectItemStorage");

// ScriptStruct Nicola.GOP_SE_WeaponTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_SE_WeaponTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdSoundSe;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_SE_WeaponTable) == 0x000008, "Wrong alignment on FGOP_SE_WeaponTable");
static_assert(sizeof(FGOP_SE_WeaponTable) == 0x000018, "Wrong size on FGOP_SE_WeaponTable");
static_assert(offsetof(FGOP_SE_WeaponTable, SelfId) == 0x000008, "Member 'FGOP_SE_WeaponTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SE_WeaponTable, GopIdSoundSe) == 0x000010, "Member 'FGOP_SE_WeaponTable::GopIdSoundSe' has a wrong offset!");

// ScriptStruct Nicola.GOP_SearchObject_CommonTable
// 0x0040 (0x0048 - 0x0008)
struct FGOP_SearchObject_CommonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchObjectType                             ObjectType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyId;                                           // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRemirama;                                       // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverrideScriptName;                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumSearchType                            FlagName;                                          // 0x0040(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_SearchObject_CommonTable) == 0x000008, "Wrong alignment on FGOP_SearchObject_CommonTable");
static_assert(sizeof(FGOP_SearchObject_CommonTable) == 0x000048, "Wrong size on FGOP_SearchObject_CommonTable");
static_assert(offsetof(FGOP_SearchObject_CommonTable, SelfId) == 0x000008, "Member 'FGOP_SearchObject_CommonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, ObjectType) == 0x000010, "Member 'FGOP_SearchObject_CommonTable::ObjectType' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, ItemId) == 0x000014, "Member 'FGOP_SearchObject_CommonTable::ItemId' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, ItemNum) == 0x00001C, "Member 'FGOP_SearchObject_CommonTable::ItemNum' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, Gold) == 0x000020, "Member 'FGOP_SearchObject_CommonTable::Gold' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, EnemyId) == 0x000024, "Member 'FGOP_SearchObject_CommonTable::EnemyId' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, bIsRemirama) == 0x00002C, "Member 'FGOP_SearchObject_CommonTable::bIsRemirama' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, OverrideScriptName) == 0x000030, "Member 'FGOP_SearchObject_CommonTable::OverrideScriptName' has a wrong offset!");
static_assert(offsetof(FGOP_SearchObject_CommonTable, FlagName) == 0x000040, "Member 'FGOP_SearchObject_CommonTable::FlagName' has a wrong offset!");

// ScriptStruct Nicola.UIBattlePlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FUIBattlePlayerInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattlePlayerInfo) == 0x000008, "Wrong alignment on FUIBattlePlayerInfo");
static_assert(sizeof(FUIBattlePlayerInfo) == 0x000038, "Wrong size on FUIBattlePlayerInfo");

// ScriptStruct Nicola.UIBattlePlayerBook
// 0x0018 (0x0018 - 0x0000)
struct FUIBattlePlayerBook final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIBattlePlayerInfo>            Infos;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBattlePlayerBook) == 0x000008, "Wrong alignment on FUIBattlePlayerBook");
static_assert(sizeof(FUIBattlePlayerBook) == 0x000018, "Wrong size on FUIBattlePlayerBook");
static_assert(offsetof(FUIBattlePlayerBook, Infos) == 0x000008, "Member 'FUIBattlePlayerBook::Infos' has a wrong offset!");

// ScriptStruct Nicola.GOP_Sequence_BattleTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_Sequence_BattleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SequenceBattleIDPlayer;                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SequenceBattleIDMonster;                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Sequence_BattleTable) == 0x000008, "Wrong alignment on FGOP_Sequence_BattleTable");
static_assert(sizeof(FGOP_Sequence_BattleTable) == 0x000030, "Wrong size on FGOP_Sequence_BattleTable");
static_assert(offsetof(FGOP_Sequence_BattleTable, SelfId) == 0x000008, "Member 'FGOP_Sequence_BattleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Sequence_BattleTable, SequenceBattleIDPlayer) == 0x000010, "Member 'FGOP_Sequence_BattleTable::SequenceBattleIDPlayer' has a wrong offset!");
static_assert(offsetof(FGOP_Sequence_BattleTable, SequenceBattleIDMonster) == 0x000020, "Member 'FGOP_Sequence_BattleTable::SequenceBattleIDMonster' has a wrong offset!");

// ScriptStruct Nicola.GOP_ShineSearchObjectTable
// 0x0058 (0x0060 - 0x0008)
struct FGOP_ShineSearchObjectTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchObjectType                             ObjectType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId1;                                           // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum1;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold1;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId2;                                           // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum2;                                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold2;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId3;                                           // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum3;                                          // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gold3;                                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ScriptName;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGOPEnumSearchType                            FlagName;                                          // 0x0058(0x0002)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_ShineSearchObjectTable) == 0x000008, "Wrong alignment on FGOP_ShineSearchObjectTable");
static_assert(sizeof(FGOP_ShineSearchObjectTable) == 0x000060, "Wrong size on FGOP_ShineSearchObjectTable");
static_assert(offsetof(FGOP_ShineSearchObjectTable, SelfId) == 0x000008, "Member 'FGOP_ShineSearchObjectTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ObjectType) == 0x000010, "Member 'FGOP_ShineSearchObjectTable::ObjectType' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ItemId1) == 0x000014, "Member 'FGOP_ShineSearchObjectTable::ItemId1' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ItemNum1) == 0x00001C, "Member 'FGOP_ShineSearchObjectTable::ItemNum1' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, Gold1) == 0x000020, "Member 'FGOP_ShineSearchObjectTable::Gold1' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ItemId2) == 0x000024, "Member 'FGOP_ShineSearchObjectTable::ItemId2' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ItemNum2) == 0x00002C, "Member 'FGOP_ShineSearchObjectTable::ItemNum2' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, Gold2) == 0x000030, "Member 'FGOP_ShineSearchObjectTable::Gold2' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ItemId3) == 0x000034, "Member 'FGOP_ShineSearchObjectTable::ItemId3' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ItemNum3) == 0x00003C, "Member 'FGOP_ShineSearchObjectTable::ItemNum3' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, Gold3) == 0x000040, "Member 'FGOP_ShineSearchObjectTable::Gold3' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, ScriptName) == 0x000048, "Member 'FGOP_ShineSearchObjectTable::ScriptName' has a wrong offset!");
static_assert(offsetof(FGOP_ShineSearchObjectTable, FlagName) == 0x000058, "Member 'FGOP_ShineSearchObjectTable::FlagName' has a wrong offset!");

// ScriptStruct Nicola.GOP_ShopTable
// 0x0240 (0x0248 - 0x0008)
struct FGOP_ShopTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCall;                                            // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRipOff;                                          // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Product_0;                                         // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_1;                                         // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_2;                                         // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_3;                                         // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_4;                                         // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_5;                                         // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_6;                                         // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_7;                                         // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_8;                                         // 0x0054(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_9;                                         // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_10;                                        // 0x0064(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_11;                                        // 0x006C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_12;                                        // 0x0074(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_13;                                        // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_14;                                        // 0x0084(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_15;                                        // 0x008C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_16;                                        // 0x0094(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_17;                                        // 0x009C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_18;                                        // 0x00A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Product_19;                                        // 0x00AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_0;                                            // 0x00B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_1;                                            // 0x00BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_2;                                            // 0x00C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_3;                                            // 0x00CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_4;                                            // 0x00D4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_5;                                            // 0x00DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_6;                                            // 0x00E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_7;                                            // 0x00EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_8;                                            // 0x00F4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_9;                                            // 0x00FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_10;                                           // 0x0104(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_11;                                           // 0x010C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_12;                                           // 0x0114(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_13;                                           // 0x011C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_14;                                           // 0x0124(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_15;                                           // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_16;                                           // 0x0134(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_17;                                           // 0x013C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_18;                                           // 0x0144(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_19;                                           // 0x014C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_20;                                           // 0x0154(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_21;                                           // 0x015C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_22;                                           // 0x0164(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_23;                                           // 0x016C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_24;                                           // 0x0174(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_25;                                           // 0x017C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_26;                                           // 0x0184(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_27;                                           // 0x018C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_28;                                           // 0x0194(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_29;                                           // 0x019C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_30;                                           // 0x01A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_31;                                           // 0x01AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_32;                                           // 0x01B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_33;                                           // 0x01BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_34;                                           // 0x01C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_35;                                           // 0x01CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_36;                                           // 0x01D4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_37;                                           // 0x01DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_38;                                           // 0x01E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_39;                                           // 0x01EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_40;                                           // 0x01F4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_41;                                           // 0x01FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_42;                                           // 0x0204(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_43;                                           // 0x020C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_44;                                           // 0x0214(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_45;                                           // 0x021C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_46;                                           // 0x0224(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_47;                                           // 0x022C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_48;                                           // 0x0234(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_49;                                           // 0x023C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_ShopTable) == 0x000008, "Wrong alignment on FGOP_ShopTable");
static_assert(sizeof(FGOP_ShopTable) == 0x000248, "Wrong size on FGOP_ShopTable");
static_assert(offsetof(FGOP_ShopTable, SelfId) == 0x000008, "Member 'FGOP_ShopTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, IsCall) == 0x000010, "Member 'FGOP_ShopTable::IsCall' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, IsRipOff) == 0x000011, "Member 'FGOP_ShopTable::IsRipOff' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_0) == 0x000014, "Member 'FGOP_ShopTable::Product_0' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_1) == 0x00001C, "Member 'FGOP_ShopTable::Product_1' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_2) == 0x000024, "Member 'FGOP_ShopTable::Product_2' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_3) == 0x00002C, "Member 'FGOP_ShopTable::Product_3' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_4) == 0x000034, "Member 'FGOP_ShopTable::Product_4' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_5) == 0x00003C, "Member 'FGOP_ShopTable::Product_5' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_6) == 0x000044, "Member 'FGOP_ShopTable::Product_6' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_7) == 0x00004C, "Member 'FGOP_ShopTable::Product_7' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_8) == 0x000054, "Member 'FGOP_ShopTable::Product_8' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_9) == 0x00005C, "Member 'FGOP_ShopTable::Product_9' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_10) == 0x000064, "Member 'FGOP_ShopTable::Product_10' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_11) == 0x00006C, "Member 'FGOP_ShopTable::Product_11' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_12) == 0x000074, "Member 'FGOP_ShopTable::Product_12' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_13) == 0x00007C, "Member 'FGOP_ShopTable::Product_13' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_14) == 0x000084, "Member 'FGOP_ShopTable::Product_14' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_15) == 0x00008C, "Member 'FGOP_ShopTable::Product_15' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_16) == 0x000094, "Member 'FGOP_ShopTable::Product_16' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_17) == 0x00009C, "Member 'FGOP_ShopTable::Product_17' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_18) == 0x0000A4, "Member 'FGOP_ShopTable::Product_18' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Product_19) == 0x0000AC, "Member 'FGOP_ShopTable::Product_19' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_0) == 0x0000B4, "Member 'FGOP_ShopTable::Talk_0' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_1) == 0x0000BC, "Member 'FGOP_ShopTable::Talk_1' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_2) == 0x0000C4, "Member 'FGOP_ShopTable::Talk_2' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_3) == 0x0000CC, "Member 'FGOP_ShopTable::Talk_3' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_4) == 0x0000D4, "Member 'FGOP_ShopTable::Talk_4' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_5) == 0x0000DC, "Member 'FGOP_ShopTable::Talk_5' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_6) == 0x0000E4, "Member 'FGOP_ShopTable::Talk_6' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_7) == 0x0000EC, "Member 'FGOP_ShopTable::Talk_7' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_8) == 0x0000F4, "Member 'FGOP_ShopTable::Talk_8' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_9) == 0x0000FC, "Member 'FGOP_ShopTable::Talk_9' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_10) == 0x000104, "Member 'FGOP_ShopTable::Talk_10' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_11) == 0x00010C, "Member 'FGOP_ShopTable::Talk_11' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_12) == 0x000114, "Member 'FGOP_ShopTable::Talk_12' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_13) == 0x00011C, "Member 'FGOP_ShopTable::Talk_13' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_14) == 0x000124, "Member 'FGOP_ShopTable::Talk_14' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_15) == 0x00012C, "Member 'FGOP_ShopTable::Talk_15' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_16) == 0x000134, "Member 'FGOP_ShopTable::Talk_16' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_17) == 0x00013C, "Member 'FGOP_ShopTable::Talk_17' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_18) == 0x000144, "Member 'FGOP_ShopTable::Talk_18' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_19) == 0x00014C, "Member 'FGOP_ShopTable::Talk_19' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_20) == 0x000154, "Member 'FGOP_ShopTable::Talk_20' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_21) == 0x00015C, "Member 'FGOP_ShopTable::Talk_21' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_22) == 0x000164, "Member 'FGOP_ShopTable::Talk_22' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_23) == 0x00016C, "Member 'FGOP_ShopTable::Talk_23' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_24) == 0x000174, "Member 'FGOP_ShopTable::Talk_24' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_25) == 0x00017C, "Member 'FGOP_ShopTable::Talk_25' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_26) == 0x000184, "Member 'FGOP_ShopTable::Talk_26' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_27) == 0x00018C, "Member 'FGOP_ShopTable::Talk_27' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_28) == 0x000194, "Member 'FGOP_ShopTable::Talk_28' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_29) == 0x00019C, "Member 'FGOP_ShopTable::Talk_29' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_30) == 0x0001A4, "Member 'FGOP_ShopTable::Talk_30' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_31) == 0x0001AC, "Member 'FGOP_ShopTable::Talk_31' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_32) == 0x0001B4, "Member 'FGOP_ShopTable::Talk_32' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_33) == 0x0001BC, "Member 'FGOP_ShopTable::Talk_33' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_34) == 0x0001C4, "Member 'FGOP_ShopTable::Talk_34' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_35) == 0x0001CC, "Member 'FGOP_ShopTable::Talk_35' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_36) == 0x0001D4, "Member 'FGOP_ShopTable::Talk_36' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_37) == 0x0001DC, "Member 'FGOP_ShopTable::Talk_37' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_38) == 0x0001E4, "Member 'FGOP_ShopTable::Talk_38' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_39) == 0x0001EC, "Member 'FGOP_ShopTable::Talk_39' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_40) == 0x0001F4, "Member 'FGOP_ShopTable::Talk_40' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_41) == 0x0001FC, "Member 'FGOP_ShopTable::Talk_41' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_42) == 0x000204, "Member 'FGOP_ShopTable::Talk_42' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_43) == 0x00020C, "Member 'FGOP_ShopTable::Talk_43' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_44) == 0x000214, "Member 'FGOP_ShopTable::Talk_44' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_45) == 0x00021C, "Member 'FGOP_ShopTable::Talk_45' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_46) == 0x000224, "Member 'FGOP_ShopTable::Talk_46' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_47) == 0x00022C, "Member 'FGOP_ShopTable::Talk_47' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_48) == 0x000234, "Member 'FGOP_ShopTable::Talk_48' has a wrong offset!");
static_assert(offsetof(FGOP_ShopTable, Talk_49) == 0x00023C, "Member 'FGOP_ShopTable::Talk_49' has a wrong offset!");

// ScriptStruct Nicola.GOP_StaffRollTable
// 0x0060 (0x0068 - 0x0008)
struct FGOP_StaffRollTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Style;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Layout;                                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Alignment;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Elem1;                                             // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Elem2;                                             // 0x004C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Elem3;                                             // 0x0054(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformSwitch;                                   // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformPs5;                                      // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformXbox;                                     // 0x0062(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformSteam;                                    // 0x0063(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformWinGdk;                                   // 0x0064(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_StaffRollTable) == 0x000008, "Wrong alignment on FGOP_StaffRollTable");
static_assert(sizeof(FGOP_StaffRollTable) == 0x000068, "Wrong size on FGOP_StaffRollTable");
static_assert(offsetof(FGOP_StaffRollTable, SelfId) == 0x000008, "Member 'FGOP_StaffRollTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Style) == 0x000010, "Member 'FGOP_StaffRollTable::Style' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Layout) == 0x000020, "Member 'FGOP_StaffRollTable::Layout' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Alignment) == 0x000030, "Member 'FGOP_StaffRollTable::Alignment' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Column) == 0x000040, "Member 'FGOP_StaffRollTable::Column' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Elem1) == 0x000044, "Member 'FGOP_StaffRollTable::Elem1' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Elem2) == 0x00004C, "Member 'FGOP_StaffRollTable::Elem2' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, Elem3) == 0x000054, "Member 'FGOP_StaffRollTable::Elem3' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, StartTime) == 0x00005C, "Member 'FGOP_StaffRollTable::StartTime' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, bPlatformSwitch) == 0x000060, "Member 'FGOP_StaffRollTable::bPlatformSwitch' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, bPlatformPs5) == 0x000061, "Member 'FGOP_StaffRollTable::bPlatformPs5' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, bPlatformXbox) == 0x000062, "Member 'FGOP_StaffRollTable::bPlatformXbox' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, bPlatformSteam) == 0x000063, "Member 'FGOP_StaffRollTable::bPlatformSteam' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRollTable, bPlatformWinGdk) == 0x000064, "Member 'FGOP_StaffRollTable::bPlatformWinGdk' has a wrong offset!");

// ScriptStruct Nicola.Map2LocationIconData
// 0x0028 (0x0028 - 0x0000)
struct FMap2LocationIconData final
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMap2LocationIconData) == 0x000008, "Wrong alignment on FMap2LocationIconData");
static_assert(sizeof(FMap2LocationIconData) == 0x000028, "Wrong size on FMap2LocationIconData");
static_assert(offsetof(FMap2LocationIconData, ImageIcon) == 0x000000, "Member 'FMap2LocationIconData::ImageIcon' has a wrong offset!");

// ScriptStruct Nicola.GOP_StaffRoll_ImageTable
// 0x0068 (0x0070 - 0x0008)
struct FGOP_StaffRoll_ImageTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                ResourcePath;                                      // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovie;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProgressFlagId;                                    // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WidgetId;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ImageSize;                                         // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmId;                                             // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_StaffRoll_ImageTable) == 0x000008, "Wrong alignment on FGOP_StaffRoll_ImageTable");
static_assert(sizeof(FGOP_StaffRoll_ImageTable) == 0x000070, "Wrong size on FGOP_StaffRoll_ImageTable");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, SelfId) == 0x000008, "Member 'FGOP_StaffRoll_ImageTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, ResourcePath) == 0x000010, "Member 'FGOP_StaffRoll_ImageTable::ResourcePath' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, bIsMovie) == 0x000038, "Member 'FGOP_StaffRoll_ImageTable::bIsMovie' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, ProgressFlagId) == 0x00003C, "Member 'FGOP_StaffRoll_ImageTable::ProgressFlagId' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, StartTime) == 0x000044, "Member 'FGOP_StaffRoll_ImageTable::StartTime' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, EndTime) == 0x000048, "Member 'FGOP_StaffRoll_ImageTable::EndTime' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, WidgetId) == 0x000050, "Member 'FGOP_StaffRoll_ImageTable::WidgetId' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, ImageSize) == 0x000060, "Member 'FGOP_StaffRoll_ImageTable::ImageSize' has a wrong offset!");
static_assert(offsetof(FGOP_StaffRoll_ImageTable, BgmId) == 0x000068, "Member 'FGOP_StaffRoll_ImageTable::BgmId' has a wrong offset!");

// ScriptStruct Nicola.GOP_StatusUpTable
// 0x0100 (0x0108 - 0x0008)
struct FGOP_StatusUpTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitGenderType                               GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Hero_Str;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hero_Arm;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hero_Agi;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hero_Vit;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hero_Int;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hero_Luc;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warrior_Str;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warrior_Arm;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warrior_Agi;                                       // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warrior_Vit;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warrior_Int;                                       // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warrior_Luc;                                       // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fighter_Str;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fighter_Arm;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fighter_Agi;                                       // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fighter_Vit;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fighter_Int;                                       // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fighter_Luc;                                       // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mage_Str;                                          // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mage_Arm;                                          // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mage_Agi;                                          // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mage_Vit;                                          // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mage_Int;                                          // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mage_Luc;                                          // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priest_Str;                                        // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priest_Arm;                                        // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priest_Agi;                                        // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priest_Vit;                                        // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priest_Int;                                        // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priest_Luc;                                        // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Merchant_Str;                                      // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Merchant_Arm;                                      // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Merchant_Agi;                                      // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Merchant_Vit;                                      // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Merchant_Int;                                      // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Merchant_Luc;                                      // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gadabout_Str;                                      // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gadabout_Arm;                                      // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gadabout_Agi;                                      // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gadabout_Vit;                                      // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gadabout_Int;                                      // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gadabout_Luc;                                      // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thief_Str;                                         // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thief_Arm;                                         // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thief_Agi;                                         // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thief_Vit;                                         // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thief_Int;                                         // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thief_Luc;                                         // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sage_Str;                                          // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sage_Arm;                                          // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sage_Agi;                                          // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sage_Vit;                                          // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sage_Int;                                          // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sage_Luc;                                          // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breeder_Str;                                       // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breeder_Arm;                                       // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breeder_Agi;                                       // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breeder_Vit;                                       // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breeder_Int;                                       // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breeder_Luc;                                       // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_StatusUpTable) == 0x000008, "Wrong alignment on FGOP_StatusUpTable");
static_assert(sizeof(FGOP_StatusUpTable) == 0x000108, "Wrong size on FGOP_StatusUpTable");
static_assert(offsetof(FGOP_StatusUpTable, SelfId) == 0x000008, "Member 'FGOP_StatusUpTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, GenderType) == 0x000010, "Member 'FGOP_StatusUpTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Hero_Str) == 0x000014, "Member 'FGOP_StatusUpTable::Hero_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Hero_Arm) == 0x000018, "Member 'FGOP_StatusUpTable::Hero_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Hero_Agi) == 0x00001C, "Member 'FGOP_StatusUpTable::Hero_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Hero_Vit) == 0x000020, "Member 'FGOP_StatusUpTable::Hero_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Hero_Int) == 0x000024, "Member 'FGOP_StatusUpTable::Hero_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Hero_Luc) == 0x000028, "Member 'FGOP_StatusUpTable::Hero_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Warrior_Str) == 0x00002C, "Member 'FGOP_StatusUpTable::Warrior_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Warrior_Arm) == 0x000030, "Member 'FGOP_StatusUpTable::Warrior_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Warrior_Agi) == 0x000034, "Member 'FGOP_StatusUpTable::Warrior_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Warrior_Vit) == 0x000038, "Member 'FGOP_StatusUpTable::Warrior_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Warrior_Int) == 0x00003C, "Member 'FGOP_StatusUpTable::Warrior_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Warrior_Luc) == 0x000040, "Member 'FGOP_StatusUpTable::Warrior_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Fighter_Str) == 0x000044, "Member 'FGOP_StatusUpTable::Fighter_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Fighter_Arm) == 0x000048, "Member 'FGOP_StatusUpTable::Fighter_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Fighter_Agi) == 0x00004C, "Member 'FGOP_StatusUpTable::Fighter_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Fighter_Vit) == 0x000050, "Member 'FGOP_StatusUpTable::Fighter_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Fighter_Int) == 0x000054, "Member 'FGOP_StatusUpTable::Fighter_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Fighter_Luc) == 0x000058, "Member 'FGOP_StatusUpTable::Fighter_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Mage_Str) == 0x00005C, "Member 'FGOP_StatusUpTable::Mage_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Mage_Arm) == 0x000060, "Member 'FGOP_StatusUpTable::Mage_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Mage_Agi) == 0x000064, "Member 'FGOP_StatusUpTable::Mage_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Mage_Vit) == 0x000068, "Member 'FGOP_StatusUpTable::Mage_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Mage_Int) == 0x00006C, "Member 'FGOP_StatusUpTable::Mage_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Mage_Luc) == 0x000070, "Member 'FGOP_StatusUpTable::Mage_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Priest_Str) == 0x000074, "Member 'FGOP_StatusUpTable::Priest_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Priest_Arm) == 0x000078, "Member 'FGOP_StatusUpTable::Priest_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Priest_Agi) == 0x00007C, "Member 'FGOP_StatusUpTable::Priest_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Priest_Vit) == 0x000080, "Member 'FGOP_StatusUpTable::Priest_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Priest_Int) == 0x000084, "Member 'FGOP_StatusUpTable::Priest_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Priest_Luc) == 0x000088, "Member 'FGOP_StatusUpTable::Priest_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Merchant_Str) == 0x00008C, "Member 'FGOP_StatusUpTable::Merchant_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Merchant_Arm) == 0x000090, "Member 'FGOP_StatusUpTable::Merchant_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Merchant_Agi) == 0x000094, "Member 'FGOP_StatusUpTable::Merchant_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Merchant_Vit) == 0x000098, "Member 'FGOP_StatusUpTable::Merchant_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Merchant_Int) == 0x00009C, "Member 'FGOP_StatusUpTable::Merchant_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Merchant_Luc) == 0x0000A0, "Member 'FGOP_StatusUpTable::Merchant_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Gadabout_Str) == 0x0000A4, "Member 'FGOP_StatusUpTable::Gadabout_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Gadabout_Arm) == 0x0000A8, "Member 'FGOP_StatusUpTable::Gadabout_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Gadabout_Agi) == 0x0000AC, "Member 'FGOP_StatusUpTable::Gadabout_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Gadabout_Vit) == 0x0000B0, "Member 'FGOP_StatusUpTable::Gadabout_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Gadabout_Int) == 0x0000B4, "Member 'FGOP_StatusUpTable::Gadabout_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Gadabout_Luc) == 0x0000B8, "Member 'FGOP_StatusUpTable::Gadabout_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Thief_Str) == 0x0000BC, "Member 'FGOP_StatusUpTable::Thief_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Thief_Arm) == 0x0000C0, "Member 'FGOP_StatusUpTable::Thief_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Thief_Agi) == 0x0000C4, "Member 'FGOP_StatusUpTable::Thief_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Thief_Vit) == 0x0000C8, "Member 'FGOP_StatusUpTable::Thief_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Thief_Int) == 0x0000CC, "Member 'FGOP_StatusUpTable::Thief_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Thief_Luc) == 0x0000D0, "Member 'FGOP_StatusUpTable::Thief_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Sage_Str) == 0x0000D4, "Member 'FGOP_StatusUpTable::Sage_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Sage_Arm) == 0x0000D8, "Member 'FGOP_StatusUpTable::Sage_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Sage_Agi) == 0x0000DC, "Member 'FGOP_StatusUpTable::Sage_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Sage_Vit) == 0x0000E0, "Member 'FGOP_StatusUpTable::Sage_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Sage_Int) == 0x0000E4, "Member 'FGOP_StatusUpTable::Sage_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Sage_Luc) == 0x0000E8, "Member 'FGOP_StatusUpTable::Sage_Luc' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Breeder_Str) == 0x0000EC, "Member 'FGOP_StatusUpTable::Breeder_Str' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Breeder_Arm) == 0x0000F0, "Member 'FGOP_StatusUpTable::Breeder_Arm' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Breeder_Agi) == 0x0000F4, "Member 'FGOP_StatusUpTable::Breeder_Agi' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Breeder_Vit) == 0x0000F8, "Member 'FGOP_StatusUpTable::Breeder_Vit' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Breeder_Int) == 0x0000FC, "Member 'FGOP_StatusUpTable::Breeder_Int' has a wrong offset!");
static_assert(offsetof(FGOP_StatusUpTable, Breeder_Luc) == 0x000100, "Member 'FGOP_StatusUpTable::Breeder_Luc' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_CommonTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Text_CommonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_CommonTable) == 0x000008, "Wrong alignment on FGOP_Text_CommonTable");
static_assert(sizeof(FGOP_Text_CommonTable) == 0x000020, "Wrong size on FGOP_Text_CommonTable");
static_assert(offsetof(FGOP_Text_CommonTable, SelfId) == 0x000008, "Member 'FGOP_Text_CommonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_CommonTable, Text) == 0x000010, "Member 'FGOP_Text_CommonTable::Text' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_CHINESETable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Text_Noun_CHINESETable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_CHINESETable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_CHINESETable");
static_assert(sizeof(FGOP_Text_Noun_CHINESETable) == 0x000020, "Wrong size on FGOP_Text_Noun_CHINESETable");
static_assert(offsetof(FGOP_Text_Noun_CHINESETable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_CHINESETable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_CHINESETable, Text) == 0x000010, "Member 'FGOP_Text_Noun_CHINESETable::Text' has a wrong offset!");

// ScriptStruct Nicola.UIBattleGroupInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FUIBattleGroupInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleGroupInfo) == 0x000008, "Wrong alignment on FUIBattleGroupInfo");
static_assert(sizeof(FUIBattleGroupInfo) == 0x000028, "Wrong size on FUIBattleGroupInfo");

// ScriptStruct Nicola.UIBattleGroupBook
// 0x0010 (0x0010 - 0x0000)
struct FUIBattleGroupBook final
{
public:
	TArray<struct FUIBattleGroupInfo>             Infos;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBattleGroupBook) == 0x000008, "Wrong alignment on FUIBattleGroupBook");
static_assert(sizeof(FUIBattleGroupBook) == 0x000010, "Wrong size on FUIBattleGroupBook");
static_assert(offsetof(FUIBattleGroupBook, Infos) == 0x000000, "Member 'FUIBattleGroupBook::Infos' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_ENGLISHTable
// 0x0088 (0x0090 - 0x0008)
struct FGOP_Text_Noun_ENGLISHTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizeGenderType                           GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SingularDef;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SingularIndef;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleDef;                                       // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleNoun;                                      // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlrNounFlag;                                       // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProperNounFlag;                                    // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListNoun;                                          // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_ENGLISHTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_ENGLISHTable");
static_assert(sizeof(FGOP_Text_Noun_ENGLISHTable) == 0x000090, "Wrong size on FGOP_Text_Noun_ENGLISHTable");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_ENGLISHTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, GenderType) == 0x000010, "Member 'FGOP_Text_Noun_ENGLISHTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, SingularDef) == 0x000018, "Member 'FGOP_Text_Noun_ENGLISHTable::SingularDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, SingularIndef) == 0x000028, "Member 'FGOP_Text_Noun_ENGLISHTable::SingularIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, SinglarNoun) == 0x000038, "Member 'FGOP_Text_Noun_ENGLISHTable::SinglarNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, MultipleDef) == 0x000048, "Member 'FGOP_Text_Noun_ENGLISHTable::MultipleDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, MultipleIndef) == 0x000058, "Member 'FGOP_Text_Noun_ENGLISHTable::MultipleIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, MultipleNoun) == 0x000068, "Member 'FGOP_Text_Noun_ENGLISHTable::MultipleNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, PlrNounFlag) == 0x000078, "Member 'FGOP_Text_Noun_ENGLISHTable::PlrNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, ProperNounFlag) == 0x000079, "Member 'FGOP_Text_Noun_ENGLISHTable::ProperNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ENGLISHTable, ListNoun) == 0x000080, "Member 'FGOP_Text_Noun_ENGLISHTable::ListNoun' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_FRENCHTable
// 0x00D8 (0x00E0 - 0x0008)
struct FGOP_Text_Noun_FRENCHTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizeGenderType                           GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SingularDef;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SingularIndef;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_M;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_F;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_N;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleDef;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef2;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleNoun;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultipleNounFlag;                                  // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProperNounFlag;                                    // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VowelFlag;                                         // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastSFlag;                                         // 0x00AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListNoun_M;                                        // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_F;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_N;                                        // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_FRENCHTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_FRENCHTable");
static_assert(sizeof(FGOP_Text_Noun_FRENCHTable) == 0x0000E0, "Wrong size on FGOP_Text_Noun_FRENCHTable");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_FRENCHTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, GenderType) == 0x000010, "Member 'FGOP_Text_Noun_FRENCHTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, SingularDef) == 0x000018, "Member 'FGOP_Text_Noun_FRENCHTable::SingularDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, SingularIndef) == 0x000028, "Member 'FGOP_Text_Noun_FRENCHTable::SingularIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, SinglarNoun_M) == 0x000038, "Member 'FGOP_Text_Noun_FRENCHTable::SinglarNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, SinglarNoun_F) == 0x000048, "Member 'FGOP_Text_Noun_FRENCHTable::SinglarNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, SinglarNoun_N) == 0x000058, "Member 'FGOP_Text_Noun_FRENCHTable::SinglarNoun_N' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, MultipleDef) == 0x000068, "Member 'FGOP_Text_Noun_FRENCHTable::MultipleDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, MultipleIndef) == 0x000078, "Member 'FGOP_Text_Noun_FRENCHTable::MultipleIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, MultipleIndef2) == 0x000088, "Member 'FGOP_Text_Noun_FRENCHTable::MultipleIndef2' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, MultipleNoun) == 0x000098, "Member 'FGOP_Text_Noun_FRENCHTable::MultipleNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, MultipleNounFlag) == 0x0000A8, "Member 'FGOP_Text_Noun_FRENCHTable::MultipleNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, ProperNounFlag) == 0x0000A9, "Member 'FGOP_Text_Noun_FRENCHTable::ProperNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, VowelFlag) == 0x0000AA, "Member 'FGOP_Text_Noun_FRENCHTable::VowelFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, LastSFlag) == 0x0000AB, "Member 'FGOP_Text_Noun_FRENCHTable::LastSFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, ListNoun_M) == 0x0000B0, "Member 'FGOP_Text_Noun_FRENCHTable::ListNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, ListNoun_F) == 0x0000C0, "Member 'FGOP_Text_Noun_FRENCHTable::ListNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_FRENCHTable, ListNoun_N) == 0x0000D0, "Member 'FGOP_Text_Noun_FRENCHTable::ListNoun_N' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_GERMANTable
// 0x00D8 (0x00E0 - 0x0008)
struct FGOP_Text_Noun_GERMANTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizeGenderType                           GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SingularDef;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SingularIndef;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_M;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_F;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_N;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleDef;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef2;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleNoun;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultipleNounFlag;                                  // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProperNounFlag;                                    // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VowelFlag;                                         // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastSFlag;                                         // 0x00AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListNoun_M;                                        // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_F;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_N;                                        // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_GERMANTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_GERMANTable");
static_assert(sizeof(FGOP_Text_Noun_GERMANTable) == 0x0000E0, "Wrong size on FGOP_Text_Noun_GERMANTable");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_GERMANTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, GenderType) == 0x000010, "Member 'FGOP_Text_Noun_GERMANTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, SingularDef) == 0x000018, "Member 'FGOP_Text_Noun_GERMANTable::SingularDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, SingularIndef) == 0x000028, "Member 'FGOP_Text_Noun_GERMANTable::SingularIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, SinglarNoun_M) == 0x000038, "Member 'FGOP_Text_Noun_GERMANTable::SinglarNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, SinglarNoun_F) == 0x000048, "Member 'FGOP_Text_Noun_GERMANTable::SinglarNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, SinglarNoun_N) == 0x000058, "Member 'FGOP_Text_Noun_GERMANTable::SinglarNoun_N' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, MultipleDef) == 0x000068, "Member 'FGOP_Text_Noun_GERMANTable::MultipleDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, MultipleIndef) == 0x000078, "Member 'FGOP_Text_Noun_GERMANTable::MultipleIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, MultipleIndef2) == 0x000088, "Member 'FGOP_Text_Noun_GERMANTable::MultipleIndef2' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, MultipleNoun) == 0x000098, "Member 'FGOP_Text_Noun_GERMANTable::MultipleNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, MultipleNounFlag) == 0x0000A8, "Member 'FGOP_Text_Noun_GERMANTable::MultipleNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, ProperNounFlag) == 0x0000A9, "Member 'FGOP_Text_Noun_GERMANTable::ProperNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, VowelFlag) == 0x0000AA, "Member 'FGOP_Text_Noun_GERMANTable::VowelFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, LastSFlag) == 0x0000AB, "Member 'FGOP_Text_Noun_GERMANTable::LastSFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, ListNoun_M) == 0x0000B0, "Member 'FGOP_Text_Noun_GERMANTable::ListNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, ListNoun_F) == 0x0000C0, "Member 'FGOP_Text_Noun_GERMANTable::ListNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMANTable, ListNoun_N) == 0x0000D0, "Member 'FGOP_Text_Noun_GERMANTable::ListNoun_N' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_GERMAN_MacroArticleTable
// 0x0088 (0x0090 - 0x0008)
struct FGOP_Text_Noun_GERMAN_MacroArticleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_ART_NOM;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_ART_GEN;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_ART_DAT;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_ART_ACC;                                       // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_ART_NOM;                                     // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_ART_GEN;                                     // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_ART_DAT;                                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_ART_ACC;                                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_GERMAN_MacroArticleTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_GERMAN_MacroArticleTable");
static_assert(sizeof(FGOP_Text_Noun_GERMAN_MacroArticleTable) == 0x000090, "Wrong size on FGOP_Text_Noun_GERMAN_MacroArticleTable");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, DEF_ART_NOM) == 0x000010, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::DEF_ART_NOM' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, DEF_ART_GEN) == 0x000020, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::DEF_ART_GEN' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, DEF_ART_DAT) == 0x000030, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::DEF_ART_DAT' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, DEF_ART_ACC) == 0x000040, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::DEF_ART_ACC' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, INDEF_ART_NOM) == 0x000050, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::INDEF_ART_NOM' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, INDEF_ART_GEN) == 0x000060, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::INDEF_ART_GEN' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, INDEF_ART_DAT) == 0x000070, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::INDEF_ART_DAT' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroArticleTable, INDEF_ART_ACC) == 0x000080, "Member 'FGOP_Text_Noun_GERMAN_MacroArticleTable::INDEF_ART_ACC' has a wrong offset!");

// ScriptStruct Nicola.UITitleMenuStorage
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FUITitleMenuStorage final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUITitleMenuStorage) == 0x000004, "Wrong alignment on FUITitleMenuStorage");
static_assert(sizeof(FUITitleMenuStorage) == 0x00000C, "Wrong size on FUITitleMenuStorage");

// ScriptStruct Nicola.GOP_Text_Noun_GERMAN_MacroNounTable
// 0x0088 (0x0090 - 0x0008)
struct FGOP_Text_Noun_GERMAN_MacroNounTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_NOM;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_GEN;                                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_DAT;                                           // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DEF_ACC;                                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_NOM;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_GEN;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_DAT;                                         // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 INDEF_ACC;                                         // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_GERMAN_MacroNounTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_GERMAN_MacroNounTable");
static_assert(sizeof(FGOP_Text_Noun_GERMAN_MacroNounTable) == 0x000090, "Wrong size on FGOP_Text_Noun_GERMAN_MacroNounTable");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, DEF_NOM) == 0x000010, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::DEF_NOM' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, DEF_GEN) == 0x000020, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::DEF_GEN' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, DEF_DAT) == 0x000030, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::DEF_DAT' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, DEF_ACC) == 0x000040, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::DEF_ACC' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, INDEF_NOM) == 0x000050, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::INDEF_NOM' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, INDEF_GEN) == 0x000060, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::INDEF_GEN' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, INDEF_DAT) == 0x000070, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::INDEF_DAT' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_GERMAN_MacroNounTable, INDEF_ACC) == 0x000080, "Member 'FGOP_Text_Noun_GERMAN_MacroNounTable::INDEF_ACC' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_ITALIANTable
// 0x00D8 (0x00E0 - 0x0008)
struct FGOP_Text_Noun_ITALIANTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizeGenderType                           GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SingularDef;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SingularIndef;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_M;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_F;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_N;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleDef;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef2;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleNoun;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultipleNounFlag;                                  // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProperNounFlag;                                    // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VowelFlag;                                         // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastSFlag;                                         // 0x00AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListNoun_M;                                        // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_F;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_N;                                        // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_ITALIANTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_ITALIANTable");
static_assert(sizeof(FGOP_Text_Noun_ITALIANTable) == 0x0000E0, "Wrong size on FGOP_Text_Noun_ITALIANTable");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_ITALIANTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, GenderType) == 0x000010, "Member 'FGOP_Text_Noun_ITALIANTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, SingularDef) == 0x000018, "Member 'FGOP_Text_Noun_ITALIANTable::SingularDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, SingularIndef) == 0x000028, "Member 'FGOP_Text_Noun_ITALIANTable::SingularIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, SinglarNoun_M) == 0x000038, "Member 'FGOP_Text_Noun_ITALIANTable::SinglarNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, SinglarNoun_F) == 0x000048, "Member 'FGOP_Text_Noun_ITALIANTable::SinglarNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, SinglarNoun_N) == 0x000058, "Member 'FGOP_Text_Noun_ITALIANTable::SinglarNoun_N' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, MultipleDef) == 0x000068, "Member 'FGOP_Text_Noun_ITALIANTable::MultipleDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, MultipleIndef) == 0x000078, "Member 'FGOP_Text_Noun_ITALIANTable::MultipleIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, MultipleIndef2) == 0x000088, "Member 'FGOP_Text_Noun_ITALIANTable::MultipleIndef2' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, MultipleNoun) == 0x000098, "Member 'FGOP_Text_Noun_ITALIANTable::MultipleNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, MultipleNounFlag) == 0x0000A8, "Member 'FGOP_Text_Noun_ITALIANTable::MultipleNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, ProperNounFlag) == 0x0000A9, "Member 'FGOP_Text_Noun_ITALIANTable::ProperNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, VowelFlag) == 0x0000AA, "Member 'FGOP_Text_Noun_ITALIANTable::VowelFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, LastSFlag) == 0x0000AB, "Member 'FGOP_Text_Noun_ITALIANTable::LastSFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, ListNoun_M) == 0x0000B0, "Member 'FGOP_Text_Noun_ITALIANTable::ListNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, ListNoun_F) == 0x0000C0, "Member 'FGOP_Text_Noun_ITALIANTable::ListNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_ITALIANTable, ListNoun_N) == 0x0000D0, "Member 'FGOP_Text_Noun_ITALIANTable::ListNoun_N' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_JAPANESETable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_Text_Noun_JAPANESETable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RubyText;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_JAPANESETable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_JAPANESETable");
static_assert(sizeof(FGOP_Text_Noun_JAPANESETable) == 0x000030, "Wrong size on FGOP_Text_Noun_JAPANESETable");
static_assert(offsetof(FGOP_Text_Noun_JAPANESETable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_JAPANESETable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_JAPANESETable, Text) == 0x000010, "Member 'FGOP_Text_Noun_JAPANESETable::Text' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_JAPANESETable, RubyText) == 0x000020, "Member 'FGOP_Text_Noun_JAPANESETable::RubyText' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_JAPANESE_HITable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Text_Noun_JAPANESE_HITable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_JAPANESE_HITable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_JAPANESE_HITable");
static_assert(sizeof(FGOP_Text_Noun_JAPANESE_HITable) == 0x000020, "Wrong size on FGOP_Text_Noun_JAPANESE_HITable");
static_assert(offsetof(FGOP_Text_Noun_JAPANESE_HITable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_JAPANESE_HITable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_JAPANESE_HITable, Text) == 0x000010, "Member 'FGOP_Text_Noun_JAPANESE_HITable::Text' has a wrong offset!");

// ScriptStruct Nicola.UIFieldMagicSkillMenuStorage
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FUIFieldMagicSkillMenuStorage final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIFieldMagicSkillMenuStorage) == 0x000004, "Wrong alignment on FUIFieldMagicSkillMenuStorage");
static_assert(sizeof(FUIFieldMagicSkillMenuStorage) == 0x00001C, "Wrong size on FUIFieldMagicSkillMenuStorage");

// ScriptStruct Nicola.GOP_Text_Noun_KOREANTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Text_Noun_KOREANTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_KOREANTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_KOREANTable");
static_assert(sizeof(FGOP_Text_Noun_KOREANTable) == 0x000020, "Wrong size on FGOP_Text_Noun_KOREANTable");
static_assert(offsetof(FGOP_Text_Noun_KOREANTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_KOREANTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_KOREANTable, Text) == 0x000010, "Member 'FGOP_Text_Noun_KOREANTable::Text' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_NEUTRALSPANISHTable
// 0x00D8 (0x00E0 - 0x0008)
struct FGOP_Text_Noun_NEUTRALSPANISHTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizeGenderType                           GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SingularDef;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SingularIndef;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_M;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_F;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_N;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleDef;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef2;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleNoun;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultipleNounFlag;                                  // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProperNounFlag;                                    // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VowelFlag;                                         // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastSFlag;                                         // 0x00AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListNoun_M;                                        // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_F;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_N;                                        // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_NEUTRALSPANISHTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_NEUTRALSPANISHTable");
static_assert(sizeof(FGOP_Text_Noun_NEUTRALSPANISHTable) == 0x0000E0, "Wrong size on FGOP_Text_Noun_NEUTRALSPANISHTable");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, GenderType) == 0x000010, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, SingularDef) == 0x000018, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::SingularDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, SingularIndef) == 0x000028, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::SingularIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, SinglarNoun_M) == 0x000038, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::SinglarNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, SinglarNoun_F) == 0x000048, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::SinglarNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, SinglarNoun_N) == 0x000058, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::SinglarNoun_N' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, MultipleDef) == 0x000068, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::MultipleDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, MultipleIndef) == 0x000078, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::MultipleIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, MultipleIndef2) == 0x000088, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::MultipleIndef2' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, MultipleNoun) == 0x000098, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::MultipleNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, MultipleNounFlag) == 0x0000A8, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::MultipleNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, ProperNounFlag) == 0x0000A9, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::ProperNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, VowelFlag) == 0x0000AA, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::VowelFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, LastSFlag) == 0x0000AB, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::LastSFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, ListNoun_M) == 0x0000B0, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::ListNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, ListNoun_F) == 0x0000C0, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::ListNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_NEUTRALSPANISHTable, ListNoun_N) == 0x0000D0, "Member 'FGOP_Text_Noun_NEUTRALSPANISHTable::ListNoun_N' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_SPANISHTable
// 0x00D8 (0x00E0 - 0x0008)
struct FGOP_Text_Noun_SPANISHTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizeGenderType                           GenderType;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SingularDef;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SingularIndef;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_M;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_F;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SinglarNoun_N;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleDef;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleIndef2;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultipleNoun;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultipleNounFlag;                                  // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProperNounFlag;                                    // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VowelFlag;                                         // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastSFlag;                                         // 0x00AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListNoun_M;                                        // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_F;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListNoun_N;                                        // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_SPANISHTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_SPANISHTable");
static_assert(sizeof(FGOP_Text_Noun_SPANISHTable) == 0x0000E0, "Wrong size on FGOP_Text_Noun_SPANISHTable");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_SPANISHTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, GenderType) == 0x000010, "Member 'FGOP_Text_Noun_SPANISHTable::GenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, SingularDef) == 0x000018, "Member 'FGOP_Text_Noun_SPANISHTable::SingularDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, SingularIndef) == 0x000028, "Member 'FGOP_Text_Noun_SPANISHTable::SingularIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, SinglarNoun_M) == 0x000038, "Member 'FGOP_Text_Noun_SPANISHTable::SinglarNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, SinglarNoun_F) == 0x000048, "Member 'FGOP_Text_Noun_SPANISHTable::SinglarNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, SinglarNoun_N) == 0x000058, "Member 'FGOP_Text_Noun_SPANISHTable::SinglarNoun_N' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, MultipleDef) == 0x000068, "Member 'FGOP_Text_Noun_SPANISHTable::MultipleDef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, MultipleIndef) == 0x000078, "Member 'FGOP_Text_Noun_SPANISHTable::MultipleIndef' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, MultipleIndef2) == 0x000088, "Member 'FGOP_Text_Noun_SPANISHTable::MultipleIndef2' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, MultipleNoun) == 0x000098, "Member 'FGOP_Text_Noun_SPANISHTable::MultipleNoun' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, MultipleNounFlag) == 0x0000A8, "Member 'FGOP_Text_Noun_SPANISHTable::MultipleNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, ProperNounFlag) == 0x0000A9, "Member 'FGOP_Text_Noun_SPANISHTable::ProperNounFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, VowelFlag) == 0x0000AA, "Member 'FGOP_Text_Noun_SPANISHTable::VowelFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, LastSFlag) == 0x0000AB, "Member 'FGOP_Text_Noun_SPANISHTable::LastSFlag' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, ListNoun_M) == 0x0000B0, "Member 'FGOP_Text_Noun_SPANISHTable::ListNoun_M' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, ListNoun_F) == 0x0000C0, "Member 'FGOP_Text_Noun_SPANISHTable::ListNoun_F' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_SPANISHTable, ListNoun_N) == 0x0000D0, "Member 'FGOP_Text_Noun_SPANISHTable::ListNoun_N' has a wrong offset!");

// ScriptStruct Nicola.GOP_Text_Noun_TAIWANTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_Text_Noun_TAIWANTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Text_Noun_TAIWANTable) == 0x000008, "Wrong alignment on FGOP_Text_Noun_TAIWANTable");
static_assert(sizeof(FGOP_Text_Noun_TAIWANTable) == 0x000020, "Wrong size on FGOP_Text_Noun_TAIWANTable");
static_assert(offsetof(FGOP_Text_Noun_TAIWANTable, SelfId) == 0x000008, "Member 'FGOP_Text_Noun_TAIWANTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Text_Noun_TAIWANTable, Text) == 0x000010, "Member 'FGOP_Text_Noun_TAIWANTable::Text' has a wrong offset!");

// ScriptStruct Nicola.GOP_TitleDemoTable
// 0x0040 (0x0048 - 0x0008)
struct FGOP_TitleDemoTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressFlag;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                AssetPath;                                         // 0x0018(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_TitleDemoTable) == 0x000008, "Wrong alignment on FGOP_TitleDemoTable");
static_assert(sizeof(FGOP_TitleDemoTable) == 0x000048, "Wrong size on FGOP_TitleDemoTable");
static_assert(offsetof(FGOP_TitleDemoTable, SelfId) == 0x000008, "Member 'FGOP_TitleDemoTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_TitleDemoTable, ProgressFlag) == 0x000010, "Member 'FGOP_TitleDemoTable::ProgressFlag' has a wrong offset!");
static_assert(offsetof(FGOP_TitleDemoTable, AssetPath) == 0x000018, "Member 'FGOP_TitleDemoTable::AssetPath' has a wrong offset!");
static_assert(offsetof(FGOP_TitleDemoTable, Priority) == 0x000040, "Member 'FGOP_TitleDemoTable::Priority' has a wrong offset!");
static_assert(offsetof(FGOP_TitleDemoTable, StartTime) == 0x000044, "Member 'FGOP_TitleDemoTable::StartTime' has a wrong offset!");

// ScriptStruct Nicola.GOP_TownDungeonTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_TownDungeonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapId;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sublevel;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 UseTimeFrame;                                      // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Disposable;                                        // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_TownDungeonTable) == 0x000008, "Wrong alignment on FGOP_TownDungeonTable");
static_assert(sizeof(FGOP_TownDungeonTable) == 0x000030, "Wrong size on FGOP_TownDungeonTable");
static_assert(offsetof(FGOP_TownDungeonTable, SelfId) == 0x000008, "Member 'FGOP_TownDungeonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_TownDungeonTable, MapId) == 0x000010, "Member 'FGOP_TownDungeonTable::MapId' has a wrong offset!");
static_assert(offsetof(FGOP_TownDungeonTable, Sublevel) == 0x000018, "Member 'FGOP_TownDungeonTable::Sublevel' has a wrong offset!");
static_assert(offsetof(FGOP_TownDungeonTable, UseTimeFrame) == 0x000028, "Member 'FGOP_TownDungeonTable::UseTimeFrame' has a wrong offset!");
static_assert(offsetof(FGOP_TownDungeonTable, Disposable) == 0x000029, "Member 'FGOP_TownDungeonTable::Disposable' has a wrong offset!");

// ScriptStruct Nicola.GOP_UI_ConstParamTable
// 0x0018 (0x0020 - 0x0008)
struct FGOP_UI_ConstParamTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ParamBool;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParamInt;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamFloat;                                        // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_UI_ConstParamTable) == 0x000008, "Wrong alignment on FGOP_UI_ConstParamTable");
static_assert(sizeof(FGOP_UI_ConstParamTable) == 0x000020, "Wrong size on FGOP_UI_ConstParamTable");
static_assert(offsetof(FGOP_UI_ConstParamTable, SelfId) == 0x000008, "Member 'FGOP_UI_ConstParamTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_UI_ConstParamTable, ParamBool) == 0x000010, "Member 'FGOP_UI_ConstParamTable::ParamBool' has a wrong offset!");
static_assert(offsetof(FGOP_UI_ConstParamTable, ParamInt) == 0x000014, "Member 'FGOP_UI_ConstParamTable::ParamInt' has a wrong offset!");
static_assert(offsetof(FGOP_UI_ConstParamTable, ParamFloat) == 0x000018, "Member 'FGOP_UI_ConstParamTable::ParamFloat' has a wrong offset!");

// ScriptStruct Nicola.GOP_Unit_ColorTable
// 0x0120 (0x0128 - 0x0008)
struct FGOP_Unit_ColorTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR1;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG1;                                           // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB1;                                           // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower1;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower1;                                    // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR2;                                           // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG2;                                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB2;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower2;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower2;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR3;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG3;                                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB3;                                           // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower3;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower3;                                    // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR4;                                           // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG4;                                           // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB4;                                           // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower4;                                       // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower4;                                    // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR5;                                           // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG5;                                           // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB5;                                           // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower5;                                       // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower5;                                    // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR6;                                           // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG6;                                           // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB6;                                           // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower6;                                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower6;                                    // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR7;                                           // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG7;                                           // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB7;                                           // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower7;                                       // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower7;                                    // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR8;                                           // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG8;                                           // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB8;                                           // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower8;                                       // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower8;                                    // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR9;                                           // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG9;                                           // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB9;                                           // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower9;                                       // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower9;                                    // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR10;                                          // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG10;                                          // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB10;                                          // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower10;                                      // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower10;                                   // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR11;                                          // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG11;                                          // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB11;                                          // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower11;                                      // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower11;                                   // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR12;                                          // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG12;                                          // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB12;                                          // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower12;                                      // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower12;                                   // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR13;                                          // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG13;                                          // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB13;                                          // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower13;                                      // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower13;                                   // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorR14;                                          // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorG14;                                          // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorB14;                                          // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorPower14;                                      // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetallicPower14;                                   // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Unit_ColorTable) == 0x000008, "Wrong alignment on FGOP_Unit_ColorTable");
static_assert(sizeof(FGOP_Unit_ColorTable) == 0x000128, "Wrong size on FGOP_Unit_ColorTable");
static_assert(offsetof(FGOP_Unit_ColorTable, SelfId) == 0x000008, "Member 'FGOP_Unit_ColorTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR1) == 0x000010, "Member 'FGOP_Unit_ColorTable::ColorR1' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG1) == 0x000014, "Member 'FGOP_Unit_ColorTable::ColorG1' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB1) == 0x000018, "Member 'FGOP_Unit_ColorTable::ColorB1' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower1) == 0x00001C, "Member 'FGOP_Unit_ColorTable::ColorPower1' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower1) == 0x000020, "Member 'FGOP_Unit_ColorTable::MetallicPower1' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR2) == 0x000024, "Member 'FGOP_Unit_ColorTable::ColorR2' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG2) == 0x000028, "Member 'FGOP_Unit_ColorTable::ColorG2' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB2) == 0x00002C, "Member 'FGOP_Unit_ColorTable::ColorB2' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower2) == 0x000030, "Member 'FGOP_Unit_ColorTable::ColorPower2' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower2) == 0x000034, "Member 'FGOP_Unit_ColorTable::MetallicPower2' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR3) == 0x000038, "Member 'FGOP_Unit_ColorTable::ColorR3' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG3) == 0x00003C, "Member 'FGOP_Unit_ColorTable::ColorG3' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB3) == 0x000040, "Member 'FGOP_Unit_ColorTable::ColorB3' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower3) == 0x000044, "Member 'FGOP_Unit_ColorTable::ColorPower3' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower3) == 0x000048, "Member 'FGOP_Unit_ColorTable::MetallicPower3' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR4) == 0x00004C, "Member 'FGOP_Unit_ColorTable::ColorR4' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG4) == 0x000050, "Member 'FGOP_Unit_ColorTable::ColorG4' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB4) == 0x000054, "Member 'FGOP_Unit_ColorTable::ColorB4' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower4) == 0x000058, "Member 'FGOP_Unit_ColorTable::ColorPower4' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower4) == 0x00005C, "Member 'FGOP_Unit_ColorTable::MetallicPower4' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR5) == 0x000060, "Member 'FGOP_Unit_ColorTable::ColorR5' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG5) == 0x000064, "Member 'FGOP_Unit_ColorTable::ColorG5' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB5) == 0x000068, "Member 'FGOP_Unit_ColorTable::ColorB5' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower5) == 0x00006C, "Member 'FGOP_Unit_ColorTable::ColorPower5' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower5) == 0x000070, "Member 'FGOP_Unit_ColorTable::MetallicPower5' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR6) == 0x000074, "Member 'FGOP_Unit_ColorTable::ColorR6' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG6) == 0x000078, "Member 'FGOP_Unit_ColorTable::ColorG6' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB6) == 0x00007C, "Member 'FGOP_Unit_ColorTable::ColorB6' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower6) == 0x000080, "Member 'FGOP_Unit_ColorTable::ColorPower6' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower6) == 0x000084, "Member 'FGOP_Unit_ColorTable::MetallicPower6' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR7) == 0x000088, "Member 'FGOP_Unit_ColorTable::ColorR7' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG7) == 0x00008C, "Member 'FGOP_Unit_ColorTable::ColorG7' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB7) == 0x000090, "Member 'FGOP_Unit_ColorTable::ColorB7' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower7) == 0x000094, "Member 'FGOP_Unit_ColorTable::ColorPower7' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower7) == 0x000098, "Member 'FGOP_Unit_ColorTable::MetallicPower7' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR8) == 0x00009C, "Member 'FGOP_Unit_ColorTable::ColorR8' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG8) == 0x0000A0, "Member 'FGOP_Unit_ColorTable::ColorG8' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB8) == 0x0000A4, "Member 'FGOP_Unit_ColorTable::ColorB8' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower8) == 0x0000A8, "Member 'FGOP_Unit_ColorTable::ColorPower8' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower8) == 0x0000AC, "Member 'FGOP_Unit_ColorTable::MetallicPower8' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR9) == 0x0000B0, "Member 'FGOP_Unit_ColorTable::ColorR9' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG9) == 0x0000B4, "Member 'FGOP_Unit_ColorTable::ColorG9' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB9) == 0x0000B8, "Member 'FGOP_Unit_ColorTable::ColorB9' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower9) == 0x0000BC, "Member 'FGOP_Unit_ColorTable::ColorPower9' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower9) == 0x0000C0, "Member 'FGOP_Unit_ColorTable::MetallicPower9' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR10) == 0x0000C4, "Member 'FGOP_Unit_ColorTable::ColorR10' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG10) == 0x0000C8, "Member 'FGOP_Unit_ColorTable::ColorG10' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB10) == 0x0000CC, "Member 'FGOP_Unit_ColorTable::ColorB10' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower10) == 0x0000D0, "Member 'FGOP_Unit_ColorTable::ColorPower10' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower10) == 0x0000D4, "Member 'FGOP_Unit_ColorTable::MetallicPower10' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR11) == 0x0000D8, "Member 'FGOP_Unit_ColorTable::ColorR11' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG11) == 0x0000DC, "Member 'FGOP_Unit_ColorTable::ColorG11' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB11) == 0x0000E0, "Member 'FGOP_Unit_ColorTable::ColorB11' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower11) == 0x0000E4, "Member 'FGOP_Unit_ColorTable::ColorPower11' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower11) == 0x0000E8, "Member 'FGOP_Unit_ColorTable::MetallicPower11' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR12) == 0x0000EC, "Member 'FGOP_Unit_ColorTable::ColorR12' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG12) == 0x0000F0, "Member 'FGOP_Unit_ColorTable::ColorG12' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB12) == 0x0000F4, "Member 'FGOP_Unit_ColorTable::ColorB12' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower12) == 0x0000F8, "Member 'FGOP_Unit_ColorTable::ColorPower12' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower12) == 0x0000FC, "Member 'FGOP_Unit_ColorTable::MetallicPower12' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR13) == 0x000100, "Member 'FGOP_Unit_ColorTable::ColorR13' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG13) == 0x000104, "Member 'FGOP_Unit_ColorTable::ColorG13' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB13) == 0x000108, "Member 'FGOP_Unit_ColorTable::ColorB13' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower13) == 0x00010C, "Member 'FGOP_Unit_ColorTable::ColorPower13' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower13) == 0x000110, "Member 'FGOP_Unit_ColorTable::MetallicPower13' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorR14) == 0x000114, "Member 'FGOP_Unit_ColorTable::ColorR14' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorG14) == 0x000118, "Member 'FGOP_Unit_ColorTable::ColorG14' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorB14) == 0x00011C, "Member 'FGOP_Unit_ColorTable::ColorB14' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, ColorPower14) == 0x000120, "Member 'FGOP_Unit_ColorTable::ColorPower14' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ColorTable, MetallicPower14) == 0x000124, "Member 'FGOP_Unit_ColorTable::MetallicPower14' has a wrong offset!");

// ScriptStruct Nicola.SkillUseParam
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSkillUseParam final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillUseParam) == 0x000008, "Wrong alignment on FSkillUseParam");
static_assert(sizeof(FSkillUseParam) == 0x000030, "Wrong size on FSkillUseParam");

// ScriptStruct Nicola.GOP_Unit_CommonTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_Unit_CommonTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterNameGopIdText;                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Unit_CommonTable) == 0x000008, "Wrong alignment on FGOP_Unit_CommonTable");
static_assert(sizeof(FGOP_Unit_CommonTable) == 0x000018, "Wrong size on FGOP_Unit_CommonTable");
static_assert(offsetof(FGOP_Unit_CommonTable, SelfId) == 0x000008, "Member 'FGOP_Unit_CommonTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_CommonTable, CharacterNameGopIdText) == 0x000010, "Member 'FGOP_Unit_CommonTable::CharacterNameGopIdText' has a wrong offset!");

// ScriptStruct Nicola.GOP_Unit_ItemBagTable
// 0x0028 (0x0030 - 0x0008)
struct FGOP_Unit_ItemBagTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitStockNum;                                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStackSameItem;                              // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopIdItem1;                                        // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdItem2;                                        // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdItem3;                                        // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Unit_ItemBagTable) == 0x000008, "Wrong alignment on FGOP_Unit_ItemBagTable");
static_assert(sizeof(FGOP_Unit_ItemBagTable) == 0x000030, "Wrong size on FGOP_Unit_ItemBagTable");
static_assert(offsetof(FGOP_Unit_ItemBagTable, SelfId) == 0x000008, "Member 'FGOP_Unit_ItemBagTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ItemBagTable, bLimitStockNum) == 0x000010, "Member 'FGOP_Unit_ItemBagTable::bLimitStockNum' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ItemBagTable, bEnableStackSameItem) == 0x000011, "Member 'FGOP_Unit_ItemBagTable::bEnableStackSameItem' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ItemBagTable, GopIdItem1) == 0x000014, "Member 'FGOP_Unit_ItemBagTable::GopIdItem1' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ItemBagTable, GopIdItem2) == 0x00001C, "Member 'FGOP_Unit_ItemBagTable::GopIdItem2' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ItemBagTable, GopIdItem3) == 0x000024, "Member 'FGOP_Unit_ItemBagTable::GopIdItem3' has a wrong offset!");

// ScriptStruct Nicola.GOP_Unit_LooksTable
// 0x00A8 (0x00B0 - 0x0008)
struct FGOP_Unit_LooksTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleBattle;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleField;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleTownDungeon;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetBattle;                                // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetField;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetTownDungeon;                           // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleDecalPosX;                                   // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleDecalPosY;                                   // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleDecalPosZ;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleDecalSizeX;                                  // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleDecalSizeY;                                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleDecalSizeZ;                                  // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TownDecalPosX;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TownDecalPosY;                                     // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TownDecalPosZ;                                     // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TownDecalSizeX;                                    // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TownDecalSizeY;                                    // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TownDecalSizeZ;                                    // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDecalPosX;                                    // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDecalPosY;                                    // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDecalPosZ;                                    // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDecalSizeX;                                   // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDecalSizeY;                                   // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDecalSizeZ;                                   // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcType;                                           // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorId;                                           // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIColorId;                                         // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwayAnimationType                            SwayAnimType;                                      // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSwayAnimTypeFromMap;                           // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideManpuOffsetDefault;                        // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetDefaultRight;                   // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetBed;                            // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetBedRight;                       // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetFloor;                          // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetFloorRight;                     // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetSit;                            // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideManpuOffsetSitRight;                       // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLanternShadow;                                    // 0x00AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftHandLantern;                                  // 0x00AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Unit_LooksTable) == 0x000008, "Wrong alignment on FGOP_Unit_LooksTable");
static_assert(sizeof(FGOP_Unit_LooksTable) == 0x0000B0, "Wrong size on FGOP_Unit_LooksTable");
static_assert(offsetof(FGOP_Unit_LooksTable, SelfId) == 0x000008, "Member 'FGOP_Unit_LooksTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, ScaleBattle) == 0x000010, "Member 'FGOP_Unit_LooksTable::ScaleBattle' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, ScaleField) == 0x000014, "Member 'FGOP_Unit_LooksTable::ScaleField' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, ScaleTownDungeon) == 0x000018, "Member 'FGOP_Unit_LooksTable::ScaleTownDungeon' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, HeightOffsetBattle) == 0x00001C, "Member 'FGOP_Unit_LooksTable::HeightOffsetBattle' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, HeightOffsetField) == 0x000020, "Member 'FGOP_Unit_LooksTable::HeightOffsetField' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, HeightOffsetTownDungeon) == 0x000024, "Member 'FGOP_Unit_LooksTable::HeightOffsetTownDungeon' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, BattleDecalPosX) == 0x000028, "Member 'FGOP_Unit_LooksTable::BattleDecalPosX' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, BattleDecalPosY) == 0x00002C, "Member 'FGOP_Unit_LooksTable::BattleDecalPosY' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, BattleDecalPosZ) == 0x000030, "Member 'FGOP_Unit_LooksTable::BattleDecalPosZ' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, BattleDecalSizeX) == 0x000034, "Member 'FGOP_Unit_LooksTable::BattleDecalSizeX' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, BattleDecalSizeY) == 0x000038, "Member 'FGOP_Unit_LooksTable::BattleDecalSizeY' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, BattleDecalSizeZ) == 0x00003C, "Member 'FGOP_Unit_LooksTable::BattleDecalSizeZ' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, TownDecalPosX) == 0x000040, "Member 'FGOP_Unit_LooksTable::TownDecalPosX' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, TownDecalPosY) == 0x000044, "Member 'FGOP_Unit_LooksTable::TownDecalPosY' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, TownDecalPosZ) == 0x000048, "Member 'FGOP_Unit_LooksTable::TownDecalPosZ' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, TownDecalSizeX) == 0x00004C, "Member 'FGOP_Unit_LooksTable::TownDecalSizeX' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, TownDecalSizeY) == 0x000050, "Member 'FGOP_Unit_LooksTable::TownDecalSizeY' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, TownDecalSizeZ) == 0x000054, "Member 'FGOP_Unit_LooksTable::TownDecalSizeZ' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, FieldDecalPosX) == 0x000058, "Member 'FGOP_Unit_LooksTable::FieldDecalPosX' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, FieldDecalPosY) == 0x00005C, "Member 'FGOP_Unit_LooksTable::FieldDecalPosY' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, FieldDecalPosZ) == 0x000060, "Member 'FGOP_Unit_LooksTable::FieldDecalPosZ' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, FieldDecalSizeX) == 0x000064, "Member 'FGOP_Unit_LooksTable::FieldDecalSizeX' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, FieldDecalSizeY) == 0x000068, "Member 'FGOP_Unit_LooksTable::FieldDecalSizeY' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, FieldDecalSizeZ) == 0x00006C, "Member 'FGOP_Unit_LooksTable::FieldDecalSizeZ' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, NpcType) == 0x000070, "Member 'FGOP_Unit_LooksTable::NpcType' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, ColorId) == 0x000078, "Member 'FGOP_Unit_LooksTable::ColorId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, UIColorId) == 0x000080, "Member 'FGOP_Unit_LooksTable::UIColorId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, SwayAnimType) == 0x000088, "Member 'FGOP_Unit_LooksTable::SwayAnimType' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, bUseSwayAnimTypeFromMap) == 0x000089, "Member 'FGOP_Unit_LooksTable::bUseSwayAnimTypeFromMap' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetDefault) == 0x00008C, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetDefault' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetDefaultRight) == 0x000090, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetDefaultRight' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetBed) == 0x000094, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetBed' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetBedRight) == 0x000098, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetBedRight' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetFloor) == 0x00009C, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetFloor' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetFloorRight) == 0x0000A0, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetFloorRight' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetSit) == 0x0000A4, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetSit' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, OverrideManpuOffsetSitRight) == 0x0000A8, "Member 'FGOP_Unit_LooksTable::OverrideManpuOffsetSitRight' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, bLanternShadow) == 0x0000AC, "Member 'FGOP_Unit_LooksTable::bLanternShadow' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_LooksTable, bLeftHandLantern) == 0x0000AD, "Member 'FGOP_Unit_LooksTable::bLeftHandLantern' has a wrong offset!");

// ScriptStruct Nicola.GOP_Unit_MasterTable
// 0x0030 (0x0038 - 0x0008)
struct FGOP_Unit_MasterTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdUnitCommon;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdUnitLooks;                                    // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdUnitBattle;                                   // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdMonster;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdUnitItemBag;                                  // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Unit_MasterTable) == 0x000008, "Wrong alignment on FGOP_Unit_MasterTable");
static_assert(sizeof(FGOP_Unit_MasterTable) == 0x000038, "Wrong size on FGOP_Unit_MasterTable");
static_assert(offsetof(FGOP_Unit_MasterTable, SelfId) == 0x000008, "Member 'FGOP_Unit_MasterTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_MasterTable, GopIdUnitCommon) == 0x000010, "Member 'FGOP_Unit_MasterTable::GopIdUnitCommon' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_MasterTable, GopIdUnitLooks) == 0x000018, "Member 'FGOP_Unit_MasterTable::GopIdUnitLooks' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_MasterTable, GopIdUnitBattle) == 0x000020, "Member 'FGOP_Unit_MasterTable::GopIdUnitBattle' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_MasterTable, GopIdMonster) == 0x000028, "Member 'FGOP_Unit_MasterTable::GopIdMonster' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_MasterTable, GopIdUnitItemBag) == 0x000030, "Member 'FGOP_Unit_MasterTable::GopIdUnitItemBag' has a wrong offset!");

// ScriptStruct Nicola.GOP_Unit_NpcTypeTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_Unit_NpcTypeTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PopopoSeId;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcMoveSpeed                                 MoveSpeed;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcMoveWaitTime                              MoveWait;                                          // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultNpcNameId;                                  // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Unit_NpcTypeTable) == 0x000008, "Wrong alignment on FGOP_Unit_NpcTypeTable");
static_assert(sizeof(FGOP_Unit_NpcTypeTable) == 0x000028, "Wrong size on FGOP_Unit_NpcTypeTable");
static_assert(offsetof(FGOP_Unit_NpcTypeTable, SelfId) == 0x000008, "Member 'FGOP_Unit_NpcTypeTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_NpcTypeTable, PopopoSeId) == 0x000010, "Member 'FGOP_Unit_NpcTypeTable::PopopoSeId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_NpcTypeTable, MoveSpeed) == 0x000018, "Member 'FGOP_Unit_NpcTypeTable::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_NpcTypeTable, MoveWait) == 0x000019, "Member 'FGOP_Unit_NpcTypeTable::MoveWait' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_NpcTypeTable, DefaultNpcNameId) == 0x00001C, "Member 'FGOP_Unit_NpcTypeTable::DefaultNpcNameId' has a wrong offset!");

// ScriptStruct Nicola.GOP_Unit_ResidentTable
// 0x0020 (0x0028 - 0x0008)
struct FGOP_Unit_ResidentTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopIdUnitMaster;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitClassType                                UnitClassType;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitGenderType                               UnitGenderType;                                    // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GopIdPersonality;                                  // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Unit_ResidentTable) == 0x000008, "Wrong alignment on FGOP_Unit_ResidentTable");
static_assert(sizeof(FGOP_Unit_ResidentTable) == 0x000028, "Wrong size on FGOP_Unit_ResidentTable");
static_assert(offsetof(FGOP_Unit_ResidentTable, SelfId) == 0x000008, "Member 'FGOP_Unit_ResidentTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ResidentTable, GopIdUnitMaster) == 0x000010, "Member 'FGOP_Unit_ResidentTable::GopIdUnitMaster' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ResidentTable, UnitClassType) == 0x000018, "Member 'FGOP_Unit_ResidentTable::UnitClassType' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ResidentTable, UnitGenderType) == 0x000019, "Member 'FGOP_Unit_ResidentTable::UnitGenderType' has a wrong offset!");
static_assert(offsetof(FGOP_Unit_ResidentTable, GopIdPersonality) == 0x00001C, "Member 'FGOP_Unit_ResidentTable::GopIdPersonality' has a wrong offset!");

// ScriptStruct Nicola.GOP_Voice_BattleTable
// 0x0088 (0x0090 - 0x0008)
struct FGOP_Voice_BattleTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId0;                                          // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio0;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId1;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio1;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId2;                                          // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio2;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId3;                                          // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio3;                                        // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId4;                                          // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio4;                                        // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId5;                                          // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio5;                                        // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId6;                                          // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio6;                                        // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId7;                                          // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio7;                                        // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId8;                                          // 0x0074(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio8;                                        // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId9;                                          // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayRatio9;                                        // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGOP_Voice_BattleTable) == 0x000008, "Wrong alignment on FGOP_Voice_BattleTable");
static_assert(sizeof(FGOP_Voice_BattleTable) == 0x000090, "Wrong size on FGOP_Voice_BattleTable");
static_assert(offsetof(FGOP_Voice_BattleTable, SelfId) == 0x000008, "Member 'FGOP_Voice_BattleTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, Priority) == 0x000010, "Member 'FGOP_Voice_BattleTable::Priority' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId0) == 0x000014, "Member 'FGOP_Voice_BattleTable::VoiceId0' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio0) == 0x00001C, "Member 'FGOP_Voice_BattleTable::PlayRatio0' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId1) == 0x000020, "Member 'FGOP_Voice_BattleTable::VoiceId1' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio1) == 0x000028, "Member 'FGOP_Voice_BattleTable::PlayRatio1' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId2) == 0x00002C, "Member 'FGOP_Voice_BattleTable::VoiceId2' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio2) == 0x000034, "Member 'FGOP_Voice_BattleTable::PlayRatio2' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId3) == 0x000038, "Member 'FGOP_Voice_BattleTable::VoiceId3' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio3) == 0x000040, "Member 'FGOP_Voice_BattleTable::PlayRatio3' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId4) == 0x000044, "Member 'FGOP_Voice_BattleTable::VoiceId4' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio4) == 0x00004C, "Member 'FGOP_Voice_BattleTable::PlayRatio4' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId5) == 0x000050, "Member 'FGOP_Voice_BattleTable::VoiceId5' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio5) == 0x000058, "Member 'FGOP_Voice_BattleTable::PlayRatio5' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId6) == 0x00005C, "Member 'FGOP_Voice_BattleTable::VoiceId6' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio6) == 0x000064, "Member 'FGOP_Voice_BattleTable::PlayRatio6' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId7) == 0x000068, "Member 'FGOP_Voice_BattleTable::VoiceId7' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio7) == 0x000070, "Member 'FGOP_Voice_BattleTable::PlayRatio7' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId8) == 0x000074, "Member 'FGOP_Voice_BattleTable::VoiceId8' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio8) == 0x00007C, "Member 'FGOP_Voice_BattleTable::PlayRatio8' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, VoiceId9) == 0x000080, "Member 'FGOP_Voice_BattleTable::VoiceId9' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_BattleTable, PlayRatio9) == 0x000088, "Member 'FGOP_Voice_BattleTable::PlayRatio9' has a wrong offset!");

// ScriptStruct Nicola.GOP_Voice_RegistrationTable
// 0x0058 (0x0060 - 0x0008)
struct FGOP_Voice_RegistrationTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId1;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId2;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId3;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId4;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId5;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId6;                                          // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId7;                                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId8;                                          // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId9;                                          // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId10;                                         // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Voice_RegistrationTable) == 0x000008, "Wrong alignment on FGOP_Voice_RegistrationTable");
static_assert(sizeof(FGOP_Voice_RegistrationTable) == 0x000060, "Wrong size on FGOP_Voice_RegistrationTable");
static_assert(offsetof(FGOP_Voice_RegistrationTable, SelfId) == 0x000008, "Member 'FGOP_Voice_RegistrationTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId1) == 0x000010, "Member 'FGOP_Voice_RegistrationTable::VoiceId1' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId2) == 0x000018, "Member 'FGOP_Voice_RegistrationTable::VoiceId2' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId3) == 0x000020, "Member 'FGOP_Voice_RegistrationTable::VoiceId3' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId4) == 0x000028, "Member 'FGOP_Voice_RegistrationTable::VoiceId4' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId5) == 0x000030, "Member 'FGOP_Voice_RegistrationTable::VoiceId5' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId6) == 0x000038, "Member 'FGOP_Voice_RegistrationTable::VoiceId6' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId7) == 0x000040, "Member 'FGOP_Voice_RegistrationTable::VoiceId7' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId8) == 0x000048, "Member 'FGOP_Voice_RegistrationTable::VoiceId8' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId9) == 0x000050, "Member 'FGOP_Voice_RegistrationTable::VoiceId9' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_RegistrationTable, VoiceId10) == 0x000058, "Member 'FGOP_Voice_RegistrationTable::VoiceId10' has a wrong offset!");

// ScriptStruct Nicola.TitleBackImage
// 0x0040 (0x0040 - 0x0000)
struct FTitleBackImage final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              TexturePtr;                                        // 0x0010(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image;                                             // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTitleBackImage) == 0x000008, "Wrong alignment on FTitleBackImage");
static_assert(sizeof(FTitleBackImage) == 0x000040, "Wrong size on FTitleBackImage");
static_assert(offsetof(FTitleBackImage, TexturePtr) == 0x000010, "Member 'FTitleBackImage::TexturePtr' has a wrong offset!");
static_assert(offsetof(FTitleBackImage, Image) == 0x000038, "Member 'FTitleBackImage::Image' has a wrong offset!");

// ScriptStruct Nicola.GOP_Voice_ScenarioTable
// 0x0010 (0x0018 - 0x0008)
struct FGOP_Voice_ScenarioTable final : public FTableRowBase
{
public:
	class FName                                   SelfId;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceId;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGOP_Voice_ScenarioTable) == 0x000008, "Wrong alignment on FGOP_Voice_ScenarioTable");
static_assert(sizeof(FGOP_Voice_ScenarioTable) == 0x000018, "Wrong size on FGOP_Voice_ScenarioTable");
static_assert(offsetof(FGOP_Voice_ScenarioTable, SelfId) == 0x000008, "Member 'FGOP_Voice_ScenarioTable::SelfId' has a wrong offset!");
static_assert(offsetof(FGOP_Voice_ScenarioTable, VoiceId) == 0x000010, "Member 'FGOP_Voice_ScenarioTable::VoiceId' has a wrong offset!");

// ScriptStruct Nicola.NicolaActionButtonMap
// 0x0018 (0x0020 - 0x0008)
struct FNicolaActionButtonMap final : public FTableRowBase
{
public:
	ENicolaKeyConfigType                          configType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENicolaInputMode                              inputMode;                                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ENicolaAction>                         actions;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaActionButtonMap) == 0x000008, "Wrong alignment on FNicolaActionButtonMap");
static_assert(sizeof(FNicolaActionButtonMap) == 0x000020, "Wrong size on FNicolaActionButtonMap");
static_assert(offsetof(FNicolaActionButtonMap, configType) == 0x000008, "Member 'FNicolaActionButtonMap::configType' has a wrong offset!");
static_assert(offsetof(FNicolaActionButtonMap, inputMode) == 0x000009, "Member 'FNicolaActionButtonMap::inputMode' has a wrong offset!");
static_assert(offsetof(FNicolaActionButtonMap, actions) == 0x000010, "Member 'FNicolaActionButtonMap::actions' has a wrong offset!");

// ScriptStruct Nicola.UIBattleMessageParam
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FUIBattleMessageParam final
{
public:
	uint8                                         Pad_0[0x98];                                       // 0x0000(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleMessageParam) == 0x000008, "Wrong alignment on FUIBattleMessageParam");
static_assert(sizeof(FUIBattleMessageParam) == 0x000098, "Wrong size on FUIBattleMessageParam");

// ScriptStruct Nicola.NicolaActionButtonInfo
// 0x0020 (0x0028 - 0x0008)
struct FNicolaActionButtonInfo final : public FTableRowBase
{
public:
	ENicolaAction                                 action;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          developmentOnly;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ENicolaButton>                         buttons;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ENicolaButtonOp                               opCode;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         pushSec;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaActionButtonInfo) == 0x000008, "Wrong alignment on FNicolaActionButtonInfo");
static_assert(sizeof(FNicolaActionButtonInfo) == 0x000028, "Wrong size on FNicolaActionButtonInfo");
static_assert(offsetof(FNicolaActionButtonInfo, action) == 0x000008, "Member 'FNicolaActionButtonInfo::action' has a wrong offset!");
static_assert(offsetof(FNicolaActionButtonInfo, developmentOnly) == 0x000009, "Member 'FNicolaActionButtonInfo::developmentOnly' has a wrong offset!");
static_assert(offsetof(FNicolaActionButtonInfo, buttons) == 0x000010, "Member 'FNicolaActionButtonInfo::buttons' has a wrong offset!");
static_assert(offsetof(FNicolaActionButtonInfo, opCode) == 0x000020, "Member 'FNicolaActionButtonInfo::opCode' has a wrong offset!");
static_assert(offsetof(FNicolaActionButtonInfo, pushSec) == 0x000024, "Member 'FNicolaActionButtonInfo::pushSec' has a wrong offset!");

// ScriptStruct Nicola.MapTimeFlag
// 0x0004 (0x0004 - 0x0000)
struct FMapTimeFlag final
{
public:
	uint32                                        flag;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMapTimeFlag) == 0x000004, "Wrong alignment on FMapTimeFlag");
static_assert(sizeof(FMapTimeFlag) == 0x000004, "Wrong size on FMapTimeFlag");
static_assert(offsetof(FMapTimeFlag, flag) == 0x000000, "Member 'FMapTimeFlag::flag' has a wrong offset!");

// ScriptStruct Nicola.SubLevelInfo
// 0x0030 (0x0030 - 0x0000)
struct FSubLevelInfo final
{
public:
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapTimeFlag                           timeFlag;                                          // 0x0028(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Disposable;                                        // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubLevelInfo) == 0x000008, "Wrong alignment on FSubLevelInfo");
static_assert(sizeof(FSubLevelInfo) == 0x000030, "Wrong size on FSubLevelInfo");
static_assert(offsetof(FSubLevelInfo, Level) == 0x000000, "Member 'FSubLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FSubLevelInfo, timeFlag) == 0x000028, "Member 'FSubLevelInfo::timeFlag' has a wrong offset!");
static_assert(offsetof(FSubLevelInfo, Disposable) == 0x00002C, "Member 'FSubLevelInfo::Disposable' has a wrong offset!");

// ScriptStruct Nicola.LevelLoadingRequest
// 0x0020 (0x0020 - 0x0000)
struct FLevelLoadingRequest final
{
public:
	class FName                                   MapId;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          battleMap;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubLevelInfo>                  loadLevels;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelLoadingRequest) == 0x000008, "Wrong alignment on FLevelLoadingRequest");
static_assert(sizeof(FLevelLoadingRequest) == 0x000020, "Wrong size on FLevelLoadingRequest");
static_assert(offsetof(FLevelLoadingRequest, MapId) == 0x000000, "Member 'FLevelLoadingRequest::MapId' has a wrong offset!");
static_assert(offsetof(FLevelLoadingRequest, battleMap) == 0x000008, "Member 'FLevelLoadingRequest::battleMap' has a wrong offset!");
static_assert(offsetof(FLevelLoadingRequest, loadLevels) == 0x000010, "Member 'FLevelLoadingRequest::loadLevels' has a wrong offset!");

// ScriptStruct Nicola.UIBattleStatusData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FUIBattleStatusData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleStatusData) == 0x000004, "Wrong alignment on FUIBattleStatusData");
static_assert(sizeof(FUIBattleStatusData) == 0x000008, "Wrong size on FUIBattleStatusData");

// ScriptStruct Nicola.SubLevelInfoArray
// 0x0010 (0x0010 - 0x0000)
struct FSubLevelInfoArray final
{
public:
	TArray<struct FSubLevelInfo>                  infoArray;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubLevelInfoArray) == 0x000008, "Wrong alignment on FSubLevelInfoArray");
static_assert(sizeof(FSubLevelInfoArray) == 0x000010, "Wrong size on FSubLevelInfoArray");
static_assert(offsetof(FSubLevelInfoArray, infoArray) == 0x000000, "Member 'FSubLevelInfoArray::infoArray' has a wrong offset!");

// ScriptStruct Nicola.LevelStreamingInfo
// 0x0010 (0x0010 - 0x0000)
struct FLevelStreamingInfo final
{
public:
	class ULevelStreaming*                        LevelStreaming;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapTimeFlag                           timeFlag;                                          // 0x0008(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Disposable;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          visibled;                                          // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelStreamingInfo) == 0x000008, "Wrong alignment on FLevelStreamingInfo");
static_assert(sizeof(FLevelStreamingInfo) == 0x000010, "Wrong size on FLevelStreamingInfo");
static_assert(offsetof(FLevelStreamingInfo, LevelStreaming) == 0x000000, "Member 'FLevelStreamingInfo::LevelStreaming' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, timeFlag) == 0x000008, "Member 'FLevelStreamingInfo::timeFlag' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, Disposable) == 0x00000C, "Member 'FLevelStreamingInfo::Disposable' has a wrong offset!");
static_assert(offsetof(FLevelStreamingInfo, visibled) == 0x00000D, "Member 'FLevelStreamingInfo::visibled' has a wrong offset!");

// ScriptStruct Nicola.MapLevelInfo
// 0x0020 (0x0020 - 0x0000)
struct FMapLevelInfo final
{
public:
	class FName                                   MapId;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          battleMap;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         loadingSectionNumber;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelStreamingInfo>            levelStreamings;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapLevelInfo) == 0x000008, "Wrong alignment on FMapLevelInfo");
static_assert(sizeof(FMapLevelInfo) == 0x000020, "Wrong size on FMapLevelInfo");
static_assert(offsetof(FMapLevelInfo, MapId) == 0x000000, "Member 'FMapLevelInfo::MapId' has a wrong offset!");
static_assert(offsetof(FMapLevelInfo, battleMap) == 0x000008, "Member 'FMapLevelInfo::battleMap' has a wrong offset!");
static_assert(offsetof(FMapLevelInfo, loadingSectionNumber) == 0x00000C, "Member 'FMapLevelInfo::loadingSectionNumber' has a wrong offset!");
static_assert(offsetof(FMapLevelInfo, levelStreamings) == 0x000010, "Member 'FMapLevelInfo::levelStreamings' has a wrong offset!");

// ScriptStruct Nicola.MapDebugInfo
// 0x0040 (0x0040 - 0x0000)
struct FMapDebugInfo final
{
public:
	double                                        loadStartTime;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        loadEndTime;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        loadingTime;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        visibleStartTime;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        visibleEndTime;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        visibleTime;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapDebugInfo) == 0x000008, "Wrong alignment on FMapDebugInfo");
static_assert(sizeof(FMapDebugInfo) == 0x000040, "Wrong size on FMapDebugInfo");
static_assert(offsetof(FMapDebugInfo, loadStartTime) == 0x000000, "Member 'FMapDebugInfo::loadStartTime' has a wrong offset!");
static_assert(offsetof(FMapDebugInfo, loadEndTime) == 0x000008, "Member 'FMapDebugInfo::loadEndTime' has a wrong offset!");
static_assert(offsetof(FMapDebugInfo, loadingTime) == 0x000010, "Member 'FMapDebugInfo::loadingTime' has a wrong offset!");
static_assert(offsetof(FMapDebugInfo, visibleStartTime) == 0x000018, "Member 'FMapDebugInfo::visibleStartTime' has a wrong offset!");
static_assert(offsetof(FMapDebugInfo, visibleEndTime) == 0x000020, "Member 'FMapDebugInfo::visibleEndTime' has a wrong offset!");
static_assert(offsetof(FMapDebugInfo, visibleTime) == 0x000028, "Member 'FMapDebugInfo::visibleTime' has a wrong offset!");

// ScriptStruct Nicola.UIBattleMagicInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FUIBattleMagicInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleMagicInfo) == 0x000004, "Wrong alignment on FUIBattleMagicInfo");
static_assert(sizeof(FUIBattleMagicInfo) == 0x000030, "Wrong size on FUIBattleMagicInfo");

// ScriptStruct Nicola.UIBattleMagicBook
// 0x0020 (0x0020 - 0x0000)
struct FUIBattleMagicBook final
{
public:
	TArray<struct FUIBattleMagicInfo>             MagicInfos;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUIBattleMagicInfo>             SkillInfos;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUIBattleMagicBook) == 0x000008, "Wrong alignment on FUIBattleMagicBook");
static_assert(sizeof(FUIBattleMagicBook) == 0x000020, "Wrong size on FUIBattleMagicBook");
static_assert(offsetof(FUIBattleMagicBook, MagicInfos) == 0x000000, "Member 'FUIBattleMagicBook::MagicInfos' has a wrong offset!");
static_assert(offsetof(FUIBattleMagicBook, SkillInfos) == 0x000010, "Member 'FUIBattleMagicBook::SkillInfos' has a wrong offset!");

// ScriptStruct Nicola.LoopSoundInfo
// 0x0018 (0x0018 - 0x0000)
struct FLoopSoundInfo final
{
public:
	struct FADSoundPlaybackId                     PlaybackId;                                        // 0x0000(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GopSoundId;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeRestTime;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoopSoundInfo) == 0x000004, "Wrong alignment on FLoopSoundInfo");
static_assert(sizeof(FLoopSoundInfo) == 0x000018, "Wrong size on FLoopSoundInfo");
static_assert(offsetof(FLoopSoundInfo, PlaybackId) == 0x000000, "Member 'FLoopSoundInfo::PlaybackId' has a wrong offset!");
static_assert(offsetof(FLoopSoundInfo, SocketName) == 0x000004, "Member 'FLoopSoundInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FLoopSoundInfo, GopSoundId) == 0x00000C, "Member 'FLoopSoundInfo::GopSoundId' has a wrong offset!");
static_assert(offsetof(FLoopSoundInfo, LifeRestTime) == 0x000014, "Member 'FLoopSoundInfo::LifeRestTime' has a wrong offset!");

// ScriptStruct Nicola.LoopSoundInfos
// 0x0018 (0x0018 - 0x0000)
struct FLoopSoundInfos final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLoopSoundInfo>                 Infos;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoopSoundInfos) == 0x000008, "Wrong alignment on FLoopSoundInfos");
static_assert(sizeof(FLoopSoundInfos) == 0x000018, "Wrong size on FLoopSoundInfos");
static_assert(offsetof(FLoopSoundInfos, Owner) == 0x000000, "Member 'FLoopSoundInfos::Owner' has a wrong offset!");
static_assert(offsetof(FLoopSoundInfos, Infos) == 0x000008, "Member 'FLoopSoundInfos::Infos' has a wrong offset!");

// ScriptStruct Nicola.TransitionRuraDesc
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FTransitionRuraDesc final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransitionRuraDesc) == 0x000004, "Wrong alignment on FTransitionRuraDesc");
static_assert(sizeof(FTransitionRuraDesc) == 0x00001C, "Wrong size on FTransitionRuraDesc");

// ScriptStruct Nicola.UIBattleTacticsInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FUIBattleTacticsInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleTacticsInfo) == 0x000008, "Wrong alignment on FUIBattleTacticsInfo");
static_assert(sizeof(FUIBattleTacticsInfo) == 0x000018, "Wrong size on FUIBattleTacticsInfo");

// ScriptStruct Nicola.UIBattleTacticsBook
// 0x0018 (0x0018 - 0x0000)
struct FUIBattleTacticsBook final
{
public:
	TArray<struct FUIBattleTacticsInfo>           Infos;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleTacticsBook) == 0x000008, "Wrong alignment on FUIBattleTacticsBook");
static_assert(sizeof(FUIBattleTacticsBook) == 0x000018, "Wrong size on FUIBattleTacticsBook");
static_assert(offsetof(FUIBattleTacticsBook, Infos) == 0x000000, "Member 'FUIBattleTacticsBook::Infos' has a wrong offset!");

// ScriptStruct Nicola.TransitionDesc
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FTransitionDesc final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransitionDesc) == 0x000004, "Wrong alignment on FTransitionDesc");
static_assert(sizeof(FTransitionDesc) == 0x00003C, "Wrong size on FTransitionDesc");

// ScriptStruct Nicola.TownDungeonMapParameterInfo
// 0x0024 (0x0024 - 0x0000)
struct FTownDungeonMapParameterInfo final
{
public:
	float                                         Time_EmissivePower;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Time_EmissiveColor;                                // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Time_RimEmissive;                                  // 0x0014(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTownDungeonMapParameterInfo) == 0x000004, "Wrong alignment on FTownDungeonMapParameterInfo");
static_assert(sizeof(FTownDungeonMapParameterInfo) == 0x000024, "Wrong size on FTownDungeonMapParameterInfo");
static_assert(offsetof(FTownDungeonMapParameterInfo, Time_EmissivePower) == 0x000000, "Member 'FTownDungeonMapParameterInfo::Time_EmissivePower' has a wrong offset!");
static_assert(offsetof(FTownDungeonMapParameterInfo, Time_EmissiveColor) == 0x000004, "Member 'FTownDungeonMapParameterInfo::Time_EmissiveColor' has a wrong offset!");
static_assert(offsetof(FTownDungeonMapParameterInfo, Time_RimEmissive) == 0x000014, "Member 'FTownDungeonMapParameterInfo::Time_RimEmissive' has a wrong offset!");

// ScriptStruct Nicola.MapTimeForBP
// 0x0008 (0x0008 - 0x0000)
struct FMapTimeForBP final
{
public:
	int32                                         hour;                                              // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         minute;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTimeForBP) == 0x000004, "Wrong alignment on FMapTimeForBP");
static_assert(sizeof(FMapTimeForBP) == 0x000008, "Wrong size on FMapTimeForBP");
static_assert(offsetof(FMapTimeForBP, hour) == 0x000000, "Member 'FMapTimeForBP::hour' has a wrong offset!");
static_assert(offsetof(FMapTimeForBP, minute) == 0x000004, "Member 'FMapTimeForBP::minute' has a wrong offset!");

// ScriptStruct Nicola.NicolaActionMap
// 0x0050 (0x0050 - 0x0000)
struct FNicolaActionMap final
{
public:
	TMap<ENicolaAction, struct FNicolaActionKeyInfo> actionKeyInfoMap;                                  // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaActionMap) == 0x000008, "Wrong alignment on FNicolaActionMap");
static_assert(sizeof(FNicolaActionMap) == 0x000050, "Wrong size on FNicolaActionMap");
static_assert(offsetof(FNicolaActionMap, actionKeyInfoMap) == 0x000000, "Member 'FNicolaActionMap::actionKeyInfoMap' has a wrong offset!");

// ScriptStruct Nicola.NicolaActionButtonMapByInputMode
// 0x0050 (0x0050 - 0x0000)
struct FNicolaActionButtonMapByInputMode final
{
public:
	TMap<ENicolaInputMode, struct FNicolaActionMap> actionButtonMap;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaActionButtonMapByInputMode) == 0x000008, "Wrong alignment on FNicolaActionButtonMapByInputMode");
static_assert(sizeof(FNicolaActionButtonMapByInputMode) == 0x000050, "Wrong size on FNicolaActionButtonMapByInputMode");
static_assert(offsetof(FNicolaActionButtonMapByInputMode, actionButtonMap) == 0x000000, "Member 'FNicolaActionButtonMapByInputMode::actionButtonMap' has a wrong offset!");

// ScriptStruct Nicola.NicolaAnimationDataInner
// 0x0008 (0x0008 - 0x0000)
struct FNicolaAnimationDataInner final
{
public:
	class UPaperFlipbook*                         flipbook;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaAnimationDataInner) == 0x000008, "Wrong alignment on FNicolaAnimationDataInner");
static_assert(sizeof(FNicolaAnimationDataInner) == 0x000008, "Wrong size on FNicolaAnimationDataInner");
static_assert(offsetof(FNicolaAnimationDataInner, flipbook) == 0x000000, "Member 'FNicolaAnimationDataInner::flipbook' has a wrong offset!");

// ScriptStruct Nicola.CameraActorViewParam
// 0x0014 (0x0014 - 0x0000)
struct FCameraActorViewParam final
{
public:
	float                                         CameraYawAngle;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraAngleElevation;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTargetLength;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFieldOfView;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraOffset;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraActorViewParam) == 0x000004, "Wrong alignment on FCameraActorViewParam");
static_assert(sizeof(FCameraActorViewParam) == 0x000014, "Wrong size on FCameraActorViewParam");
static_assert(offsetof(FCameraActorViewParam, CameraYawAngle) == 0x000000, "Member 'FCameraActorViewParam::CameraYawAngle' has a wrong offset!");
static_assert(offsetof(FCameraActorViewParam, CameraAngleElevation) == 0x000004, "Member 'FCameraActorViewParam::CameraAngleElevation' has a wrong offset!");
static_assert(offsetof(FCameraActorViewParam, CameraTargetLength) == 0x000008, "Member 'FCameraActorViewParam::CameraTargetLength' has a wrong offset!");
static_assert(offsetof(FCameraActorViewParam, CameraFieldOfView) == 0x00000C, "Member 'FCameraActorViewParam::CameraFieldOfView' has a wrong offset!");
static_assert(offsetof(FCameraActorViewParam, CameraOffset) == 0x000010, "Member 'FCameraActorViewParam::CameraOffset' has a wrong offset!");

// ScriptStruct Nicola.SlidMoveParam
// 0x0030 (0x0030 - 0x0000)
struct FSlidMoveParam final
{
public:
	struct FVector                                SlideMoveDirection;                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideMoveScale;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurveSlideMove;                                    // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpFloat*                           InterpSlideMoveT;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlidMoveParam) == 0x000008, "Wrong alignment on FSlidMoveParam");
static_assert(sizeof(FSlidMoveParam) == 0x000030, "Wrong size on FSlidMoveParam");
static_assert(offsetof(FSlidMoveParam, SlideMoveDirection) == 0x000000, "Member 'FSlidMoveParam::SlideMoveDirection' has a wrong offset!");
static_assert(offsetof(FSlidMoveParam, SlideMoveScale) == 0x00000C, "Member 'FSlidMoveParam::SlideMoveScale' has a wrong offset!");
static_assert(offsetof(FSlidMoveParam, CurveSlideMove) == 0x000010, "Member 'FSlidMoveParam::CurveSlideMove' has a wrong offset!");
static_assert(offsetof(FSlidMoveParam, InterpSlideMoveT) == 0x000018, "Member 'FSlidMoveParam::InterpSlideMoveT' has a wrong offset!");

// ScriptStruct Nicola.NicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage
// 0x0050 (0x0050 - 0x0000)
struct FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage final
{
public:
	TMap<ENicolaLanguageVoice, TSoftObjectPtr<class USoundAtomCueSheet>> CueSheets;                                         // 0x0000(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage) == 0x000008, "Wrong alignment on FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage");
static_assert(sizeof(FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage) == 0x000050, "Wrong size on FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage");
static_assert(offsetof(FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage, CueSheets) == 0x000000, "Member 'FNicolaDataAssetSoundCommonCueSheetTypeVoiceLanguage::CueSheets' has a wrong offset!");

// ScriptStruct Nicola.RestoreDataAfterEvent
// 0x0010 (0x0010 - 0x0000)
struct FRestoreDataAfterEvent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRestoreDataAfterEvent) == 0x000008, "Wrong alignment on FRestoreDataAfterEvent");
static_assert(sizeof(FRestoreDataAfterEvent) == 0x000010, "Wrong size on FRestoreDataAfterEvent");
static_assert(offsetof(FRestoreDataAfterEvent, Actor) == 0x000000, "Member 'FRestoreDataAfterEvent::Actor' has a wrong offset!");

// ScriptStruct Nicola.TriggerEventInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTriggerEventInfo final
{
public:
	class FName                                   TriggerID;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriggerEventInfo) == 0x000008, "Wrong alignment on FTriggerEventInfo");
static_assert(sizeof(FTriggerEventInfo) == 0x000018, "Wrong size on FTriggerEventInfo");
static_assert(offsetof(FTriggerEventInfo, TriggerID) == 0x000000, "Member 'FTriggerEventInfo::TriggerID' has a wrong offset!");

// ScriptStruct Nicola.NicolaFieldLevelStreamingInfo
// 0x000C (0x000C - 0x0000)
struct FNicolaFieldLevelStreamingInfo final
{
public:
	class FName                                   levelName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoLoadWithEditorOnly;                             // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaFieldLevelStreamingInfo) == 0x000004, "Wrong alignment on FNicolaFieldLevelStreamingInfo");
static_assert(sizeof(FNicolaFieldLevelStreamingInfo) == 0x00000C, "Wrong size on FNicolaFieldLevelStreamingInfo");
static_assert(offsetof(FNicolaFieldLevelStreamingInfo, levelName) == 0x000000, "Member 'FNicolaFieldLevelStreamingInfo::levelName' has a wrong offset!");
static_assert(offsetof(FNicolaFieldLevelStreamingInfo, bDoLoadWithEditorOnly) == 0x000008, "Member 'FNicolaFieldLevelStreamingInfo::bDoLoadWithEditorOnly' has a wrong offset!");

// ScriptStruct Nicola.FieldGridData
// 0x0030 (0x0030 - 0x0000)
struct FFieldGridData final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AProgressSpawnManagementActorForField*> symbols;                                           // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFieldGridData) == 0x000008, "Wrong alignment on FFieldGridData");
static_assert(sizeof(FFieldGridData) == 0x000030, "Wrong size on FFieldGridData");
static_assert(offsetof(FFieldGridData, Actors) == 0x000000, "Member 'FFieldGridData::Actors' has a wrong offset!");
static_assert(offsetof(FFieldGridData, symbols) == 0x000010, "Member 'FFieldGridData::symbols' has a wrong offset!");

// ScriptStruct Nicola.GuideIconData
// 0x0038 (0x0038 - 0x0000)
struct FGuideIconData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuideIconData) == 0x000008, "Wrong alignment on FGuideIconData");
static_assert(sizeof(FGuideIconData) == 0x000038, "Wrong size on FGuideIconData");
static_assert(offsetof(FGuideIconData, TargetActor) == 0x000030, "Member 'FGuideIconData::TargetActor' has a wrong offset!");

// ScriptStruct Nicola.DirectionalLightParameterInfo
// 0x008C (0x008C - 0x0000)
struct FDirectionalLightParameterInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DynamicShadowDistance_Switch;                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Low;                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Mid;                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_High;                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistance_Epic;                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Switch;                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Low;                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Mid;                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_High;                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDynamicShadowCascades_Epic;                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Switch;                // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Low;                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Mid;                   // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_High;                  // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent_Epic;                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Switch;                  // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Low;                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Mid;                     // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_High;                    // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction_Epic;                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Switch;              // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Low;                 // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Mid;                 // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_High;                // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction_Epic;                // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Switch;                  // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Low;                     // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Mid;                     // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_High;                    // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance_Epic;                    // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionalLightParameterInfo) == 0x000004, "Wrong alignment on FDirectionalLightParameterInfo");
static_assert(sizeof(FDirectionalLightParameterInfo) == 0x00008C, "Wrong size on FDirectionalLightParameterInfo");
static_assert(offsetof(FDirectionalLightParameterInfo, DynamicShadowDistance_Switch) == 0x000014, "Member 'FDirectionalLightParameterInfo::DynamicShadowDistance_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, DynamicShadowDistance_Low) == 0x000018, "Member 'FDirectionalLightParameterInfo::DynamicShadowDistance_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, DynamicShadowDistance_Mid) == 0x00001C, "Member 'FDirectionalLightParameterInfo::DynamicShadowDistance_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, DynamicShadowDistance_High) == 0x000020, "Member 'FDirectionalLightParameterInfo::DynamicShadowDistance_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, DynamicShadowDistance_Epic) == 0x000024, "Member 'FDirectionalLightParameterInfo::DynamicShadowDistance_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, NumDynamicShadowCascades_Switch) == 0x000028, "Member 'FDirectionalLightParameterInfo::NumDynamicShadowCascades_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, NumDynamicShadowCascades_Low) == 0x00002C, "Member 'FDirectionalLightParameterInfo::NumDynamicShadowCascades_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, NumDynamicShadowCascades_Mid) == 0x000030, "Member 'FDirectionalLightParameterInfo::NumDynamicShadowCascades_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, NumDynamicShadowCascades_High) == 0x000034, "Member 'FDirectionalLightParameterInfo::NumDynamicShadowCascades_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, NumDynamicShadowCascades_Epic) == 0x000038, "Member 'FDirectionalLightParameterInfo::NumDynamicShadowCascades_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeDistributionExponent_Switch) == 0x00003C, "Member 'FDirectionalLightParameterInfo::CascadeDistributionExponent_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeDistributionExponent_Low) == 0x000040, "Member 'FDirectionalLightParameterInfo::CascadeDistributionExponent_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeDistributionExponent_Mid) == 0x000044, "Member 'FDirectionalLightParameterInfo::CascadeDistributionExponent_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeDistributionExponent_High) == 0x000048, "Member 'FDirectionalLightParameterInfo::CascadeDistributionExponent_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeDistributionExponent_Epic) == 0x00004C, "Member 'FDirectionalLightParameterInfo::CascadeDistributionExponent_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeTransitionFraction_Switch) == 0x000050, "Member 'FDirectionalLightParameterInfo::CascadeTransitionFraction_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeTransitionFraction_Low) == 0x000054, "Member 'FDirectionalLightParameterInfo::CascadeTransitionFraction_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeTransitionFraction_Mid) == 0x000058, "Member 'FDirectionalLightParameterInfo::CascadeTransitionFraction_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeTransitionFraction_High) == 0x00005C, "Member 'FDirectionalLightParameterInfo::CascadeTransitionFraction_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, CascadeTransitionFraction_Epic) == 0x000060, "Member 'FDirectionalLightParameterInfo::CascadeTransitionFraction_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, ShadowDistanceFadeoutFraction_Switch) == 0x000064, "Member 'FDirectionalLightParameterInfo::ShadowDistanceFadeoutFraction_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, ShadowDistanceFadeoutFraction_Low) == 0x000068, "Member 'FDirectionalLightParameterInfo::ShadowDistanceFadeoutFraction_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, ShadowDistanceFadeoutFraction_Mid) == 0x00006C, "Member 'FDirectionalLightParameterInfo::ShadowDistanceFadeoutFraction_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, ShadowDistanceFadeoutFraction_High) == 0x000070, "Member 'FDirectionalLightParameterInfo::ShadowDistanceFadeoutFraction_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, ShadowDistanceFadeoutFraction_Epic) == 0x000074, "Member 'FDirectionalLightParameterInfo::ShadowDistanceFadeoutFraction_Epic' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, LightFunctionFadeDistance_Switch) == 0x000078, "Member 'FDirectionalLightParameterInfo::LightFunctionFadeDistance_Switch' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, LightFunctionFadeDistance_Low) == 0x00007C, "Member 'FDirectionalLightParameterInfo::LightFunctionFadeDistance_Low' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, LightFunctionFadeDistance_Mid) == 0x000080, "Member 'FDirectionalLightParameterInfo::LightFunctionFadeDistance_Mid' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, LightFunctionFadeDistance_High) == 0x000084, "Member 'FDirectionalLightParameterInfo::LightFunctionFadeDistance_High' has a wrong offset!");
static_assert(offsetof(FDirectionalLightParameterInfo, LightFunctionFadeDistance_Epic) == 0x000088, "Member 'FDirectionalLightParameterInfo::LightFunctionFadeDistance_Epic' has a wrong offset!");

// ScriptStruct Nicola.NicolaInputReceiverInfo
// 0x0010 (0x0010 - 0x0000)
struct FNicolaInputReceiverInfo final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaInputReceiverInfo) == 0x000008, "Wrong alignment on FNicolaInputReceiverInfo");
static_assert(sizeof(FNicolaInputReceiverInfo) == 0x000010, "Wrong size on FNicolaInputReceiverInfo");
static_assert(offsetof(FNicolaInputReceiverInfo, Object) == 0x000000, "Member 'FNicolaInputReceiverInfo::Object' has a wrong offset!");

// ScriptStruct Nicola.SkillParamValue
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSkillParamValue final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillParamValue) == 0x000004, "Wrong alignment on FSkillParamValue");
static_assert(sizeof(FSkillParamValue) == 0x00000C, "Wrong size on FSkillParamValue");

// ScriptStruct Nicola.SkillResult
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSkillResult final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillResult) == 0x000008, "Wrong alignment on FSkillResult");
static_assert(sizeof(FSkillResult) == 0x000020, "Wrong size on FSkillResult");

// ScriptStruct Nicola.NicolaSpriteManagerComponentMimicData
// 0x0018 (0x0018 - 0x0000)
struct FNicolaSpriteManagerComponentMimicData final
{
public:
	class UNicolaSpriteManagerComponent*          TargetDefaultObject;                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaSpriteManagerComponentMimicData) == 0x000008, "Wrong alignment on FNicolaSpriteManagerComponentMimicData");
static_assert(sizeof(FNicolaSpriteManagerComponentMimicData) == 0x000018, "Wrong size on FNicolaSpriteManagerComponentMimicData");
static_assert(offsetof(FNicolaSpriteManagerComponentMimicData, TargetDefaultObject) == 0x000000, "Member 'FNicolaSpriteManagerComponentMimicData::TargetDefaultObject' has a wrong offset!");

// ScriptStruct Nicola.NicolaFlipbookOverrideData
// 0x00B0 (0x00B0 - 0x0000)
struct FNicolaFlipbookOverrideData final
{
public:
	class FString                                 SubTypeIdString;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimationType, TSoftObjectPtr<class UNicolaAnimationData>> AnimationDatas;                                    // 0x0010(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EAnimationType, class UNicolaAnimationData*> AnimationDataCaches;                               // 0x0060(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNicolaFlipbookOverrideData) == 0x000008, "Wrong alignment on FNicolaFlipbookOverrideData");
static_assert(sizeof(FNicolaFlipbookOverrideData) == 0x0000B0, "Wrong size on FNicolaFlipbookOverrideData");
static_assert(offsetof(FNicolaFlipbookOverrideData, SubTypeIdString) == 0x000000, "Member 'FNicolaFlipbookOverrideData::SubTypeIdString' has a wrong offset!");
static_assert(offsetof(FNicolaFlipbookOverrideData, AnimationDatas) == 0x000010, "Member 'FNicolaFlipbookOverrideData::AnimationDatas' has a wrong offset!");
static_assert(offsetof(FNicolaFlipbookOverrideData, AnimationDataCaches) == 0x000060, "Member 'FNicolaFlipbookOverrideData::AnimationDataCaches' has a wrong offset!");

// ScriptStruct Nicola.NicolaUniqueId
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNicolaUniqueId final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNicolaUniqueId) == 0x000008, "Wrong alignment on FNicolaUniqueId");
static_assert(sizeof(FNicolaUniqueId) == 0x000010, "Wrong size on FNicolaUniqueId");

// ScriptStruct Nicola.LevelUpResultInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FLevelUpResultInfo final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelUpResultInfo) == 0x000008, "Wrong alignment on FLevelUpResultInfo");
static_assert(sizeof(FLevelUpResultInfo) == 0x000060, "Wrong size on FLevelUpResultInfo");

// ScriptStruct Nicola.CharaMakeInfo
// 0x001C (0x001C - 0x0000)
struct FCharaMakeInfo final
{
public:
	class FName                                   CharaName;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitClassType                                ClassType;                                         // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitGenderType                               GenderType;                                        // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitVoicePattern                             VoicePattern;                                      // 0x000A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0xF];                                        // 0x000B(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	EDebugCharaMakeOption                         Option;                                            // 0x001A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaMakeInfo) == 0x000004, "Wrong alignment on FCharaMakeInfo");
static_assert(sizeof(FCharaMakeInfo) == 0x00001C, "Wrong size on FCharaMakeInfo");
static_assert(offsetof(FCharaMakeInfo, CharaName) == 0x000000, "Member 'FCharaMakeInfo::CharaName' has a wrong offset!");
static_assert(offsetof(FCharaMakeInfo, ClassType) == 0x000008, "Member 'FCharaMakeInfo::ClassType' has a wrong offset!");
static_assert(offsetof(FCharaMakeInfo, GenderType) == 0x000009, "Member 'FCharaMakeInfo::GenderType' has a wrong offset!");
static_assert(offsetof(FCharaMakeInfo, VoicePattern) == 0x00000A, "Member 'FCharaMakeInfo::VoicePattern' has a wrong offset!");
static_assert(offsetof(FCharaMakeInfo, Option) == 0x00001A, "Member 'FCharaMakeInfo::Option' has a wrong offset!");

// ScriptStruct Nicola.PageListCursorUDFeed
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FPageListCursorUDFeed final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPageListCursorUDFeed) == 0x000004, "Wrong alignment on FPageListCursorUDFeed");
static_assert(sizeof(FPageListCursorUDFeed) == 0x00001C, "Wrong size on FPageListCursorUDFeed");

// ScriptStruct Nicola.GimmickAlignData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x04) FGimmickAlignData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGimmickAlignData) == 0x000004, "Wrong alignment on FGimmickAlignData");
static_assert(sizeof(FGimmickAlignData) == 0x000050, "Wrong size on FGimmickAlignData");

// ScriptStruct Nicola.MessageTask
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FMessageTask final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMessageTask) == 0x000004, "Wrong alignment on FMessageTask");
static_assert(sizeof(FMessageTask) == 0x00000C, "Wrong size on FMessageTask");

// ScriptStruct Nicola.RichTextButtonIconBrush
// 0x00A8 (0x00A8 - 0x0000)
struct FRichTextButtonIconBrush final
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0000(0x0088)(NativeAccessSpecifierPublic)
	class UObject*                                ResourceObject;                                    // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Owner;                                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRichTextButtonIconBrush) == 0x000008, "Wrong alignment on FRichTextButtonIconBrush");
static_assert(sizeof(FRichTextButtonIconBrush) == 0x0000A8, "Wrong size on FRichTextButtonIconBrush");
static_assert(offsetof(FRichTextButtonIconBrush, Brush) == 0x000000, "Member 'FRichTextButtonIconBrush::Brush' has a wrong offset!");
static_assert(offsetof(FRichTextButtonIconBrush, ResourceObject) == 0x000088, "Member 'FRichTextButtonIconBrush::ResourceObject' has a wrong offset!");
static_assert(offsetof(FRichTextButtonIconBrush, Owner) == 0x000090, "Member 'FRichTextButtonIconBrush::Owner' has a wrong offset!");

// ScriptStruct Nicola.SelectListCursor
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FSelectListCursor final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectListCursor) == 0x000004, "Wrong alignment on FSelectListCursor");
static_assert(sizeof(FSelectListCursor) == 0x000010, "Wrong size on FSelectListCursor");

// ScriptStruct Nicola.ShipMaterialOverrideParam
// 0x0018 (0x0018 - 0x0000)
struct FShipMaterialOverrideParam final
{
public:
	class UMaterialInterface*                     original;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 waveTimes;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShipMaterialOverrideParam) == 0x000008, "Wrong alignment on FShipMaterialOverrideParam");
static_assert(sizeof(FShipMaterialOverrideParam) == 0x000018, "Wrong size on FShipMaterialOverrideParam");
static_assert(offsetof(FShipMaterialOverrideParam, original) == 0x000000, "Member 'FShipMaterialOverrideParam::original' has a wrong offset!");
static_assert(offsetof(FShipMaterialOverrideParam, waveTimes) == 0x000008, "Member 'FShipMaterialOverrideParam::waveTimes' has a wrong offset!");

// ScriptStruct Nicola.ProgressSpawnInfo
// 0x0030 (0x0030 - 0x0000)
struct FProgressSpawnInfo final
{
public:
	EGOPEnumProgressType                          FlagInfo;                                          // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorSoftClassPtr;                                 // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressSpawnInfo) == 0x000008, "Wrong alignment on FProgressSpawnInfo");
static_assert(sizeof(FProgressSpawnInfo) == 0x000030, "Wrong size on FProgressSpawnInfo");
static_assert(offsetof(FProgressSpawnInfo, FlagInfo) == 0x000000, "Member 'FProgressSpawnInfo::FlagInfo' has a wrong offset!");
static_assert(offsetof(FProgressSpawnInfo, ActorSoftClassPtr) == 0x000008, "Member 'FProgressSpawnInfo::ActorSoftClassPtr' has a wrong offset!");

// ScriptStruct Nicola.TownDungeonMapParameterTable
// 0x0030 (0x0038 - 0x0008)
struct FTownDungeonMapParameterTable final : public FTableRowBase
{
public:
	class FName                                   MapId;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapTimeFrame                                 UseTimeFrame;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time_EmissivePower;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Time_EmissiveColor;                                // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Time_RimEmissive;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTownDungeonMapParameterTable) == 0x000008, "Wrong alignment on FTownDungeonMapParameterTable");
static_assert(sizeof(FTownDungeonMapParameterTable) == 0x000038, "Wrong size on FTownDungeonMapParameterTable");
static_assert(offsetof(FTownDungeonMapParameterTable, MapId) == 0x000008, "Member 'FTownDungeonMapParameterTable::MapId' has a wrong offset!");
static_assert(offsetof(FTownDungeonMapParameterTable, UseTimeFrame) == 0x000010, "Member 'FTownDungeonMapParameterTable::UseTimeFrame' has a wrong offset!");
static_assert(offsetof(FTownDungeonMapParameterTable, Time_EmissivePower) == 0x000014, "Member 'FTownDungeonMapParameterTable::Time_EmissivePower' has a wrong offset!");
static_assert(offsetof(FTownDungeonMapParameterTable, Time_EmissiveColor) == 0x000018, "Member 'FTownDungeonMapParameterTable::Time_EmissiveColor' has a wrong offset!");
static_assert(offsetof(FTownDungeonMapParameterTable, Time_RimEmissive) == 0x000028, "Member 'FTownDungeonMapParameterTable::Time_RimEmissive' has a wrong offset!");

// ScriptStruct Nicola.UIBattleMonsterNameCheck
// 0x0050 (0x0050 - 0x0000)
struct FUIBattleMonsterNameCheck final
{
public:
	class UImage*                                 ImageRange1;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageRange2;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIBattleMonsterNameItem*               Item;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x38];                                      // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleMonsterNameCheck) == 0x000008, "Wrong alignment on FUIBattleMonsterNameCheck");
static_assert(sizeof(FUIBattleMonsterNameCheck) == 0x000050, "Wrong size on FUIBattleMonsterNameCheck");
static_assert(offsetof(FUIBattleMonsterNameCheck, ImageRange1) == 0x000000, "Member 'FUIBattleMonsterNameCheck::ImageRange1' has a wrong offset!");
static_assert(offsetof(FUIBattleMonsterNameCheck, ImageRange2) == 0x000008, "Member 'FUIBattleMonsterNameCheck::ImageRange2' has a wrong offset!");
static_assert(offsetof(FUIBattleMonsterNameCheck, Item) == 0x000010, "Member 'FUIBattleMonsterNameCheck::Item' has a wrong offset!");

// ScriptStruct Nicola.UIBattleStorage
// 0x01F0 (0x01F0 - 0x0000)
struct FUIBattleStorage final
{
public:
	uint8                                         Pad_0[0x1E8];                                      // 0x0000(0x01E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TextureRetryCapture;                               // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBattleStorage) == 0x000008, "Wrong alignment on FUIBattleStorage");
static_assert(sizeof(FUIBattleStorage) == 0x0001F0, "Wrong size on FUIBattleStorage");
static_assert(offsetof(FUIBattleStorage, TextureRetryCapture) == 0x0001E8, "Member 'FUIBattleStorage::TextureRetryCapture' has a wrong offset!");

// ScriptStruct Nicola.UIBattleMessageParamOption
// 0x0004 (0x0004 - 0x0000)
struct FUIBattleMessageParamOption final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBattleMessageParamOption) == 0x000001, "Wrong alignment on FUIBattleMessageParamOption");
static_assert(sizeof(FUIBattleMessageParamOption) == 0x000004, "Wrong size on FUIBattleMessageParamOption");

// ScriptStruct Nicola.UIBattleEquipBook
// 0x0018 (0x0018 - 0x0000)
struct FUIBattleEquipBook final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIBattleItemInfo>              Infos;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBattleEquipBook) == 0x000008, "Wrong alignment on FUIBattleEquipBook");
static_assert(sizeof(FUIBattleEquipBook) == 0x000018, "Wrong size on FUIBattleEquipBook");
static_assert(offsetof(FUIBattleEquipBook, Infos) == 0x000008, "Member 'FUIBattleEquipBook::Infos' has a wrong offset!");

// ScriptStruct Nicola.UIBattleItemBook
// 0x0010 (0x0010 - 0x0000)
struct FUIBattleItemBook final
{
public:
	TArray<struct FUIBattleItemInfo>              Infos;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBattleItemBook) == 0x000008, "Wrong alignment on FUIBattleItemBook");
static_assert(sizeof(FUIBattleItemBook) == 0x000010, "Wrong size on FUIBattleItemBook");
static_assert(offsetof(FUIBattleItemBook, Infos) == 0x000000, "Member 'FUIBattleItemBook::Infos' has a wrong offset!");

// ScriptStruct Nicola.UIEndingStaffRollMenuRowData
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FUIEndingStaffRollMenuRowData final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIEndingStaffRollMenuRowData) == 0x000004, "Wrong alignment on FUIEndingStaffRollMenuRowData");
static_assert(sizeof(FUIEndingStaffRollMenuRowData) == 0x000014, "Wrong size on FUIEndingStaffRollMenuRowData");

// ScriptStruct Nicola.UIInitialLogoData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FUIInitialLogoData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIInitialLogoData) == 0x000004, "Wrong alignment on FUIInitialLogoData");
static_assert(sizeof(FUIInitialLogoData) == 0x000018, "Wrong size on FUIInitialLogoData");

// ScriptStruct Nicola.UILoadableTexture
// 0x0018 (0x0018 - 0x0000)
struct FUILoadableTexture final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUILoadableTexture) == 0x000008, "Wrong alignment on FUILoadableTexture");
static_assert(sizeof(FUILoadableTexture) == 0x000018, "Wrong size on FUILoadableTexture");
static_assert(offsetof(FUILoadableTexture, Texture) == 0x000010, "Member 'FUILoadableTexture::Texture' has a wrong offset!");

// ScriptStruct Nicola.UIMapMenuStorage
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FUIMapMenuStorage final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMapMenuStorage) == 0x000008, "Wrong alignment on FUIMapMenuStorage");
static_assert(sizeof(FUIMapMenuStorage) == 0x000020, "Wrong size on FUIMapMenuStorage");

// ScriptStruct Nicola.UIMessageTagData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FUIMessageTagData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMessageTagData) == 0x000008, "Wrong alignment on FUIMessageTagData");
static_assert(sizeof(FUIMessageTagData) == 0x000028, "Wrong size on FUIMessageTagData");

// ScriptStruct Nicola.MiniMapDrawIconData
// 0x0048 (0x0048 - 0x0000)
struct FMiniMapDrawIconData final
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniMapDrawIconData) == 0x000008, "Wrong alignment on FMiniMapDrawIconData");
static_assert(sizeof(FMiniMapDrawIconData) == 0x000048, "Wrong size on FMiniMapDrawIconData");
static_assert(offsetof(FMiniMapDrawIconData, ImageIcon) == 0x000000, "Member 'FMiniMapDrawIconData::ImageIcon' has a wrong offset!");
static_assert(offsetof(FMiniMapDrawIconData, TargetActor) == 0x000030, "Member 'FMiniMapDrawIconData::TargetActor' has a wrong offset!");

// ScriptStruct Nicola.UISaveLoadStorage
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FUISaveLoadStorage final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUISaveLoadStorage) == 0x000008, "Wrong alignment on FUISaveLoadStorage");
static_assert(sizeof(FUISaveLoadStorage) == 0x000090, "Wrong size on FUISaveLoadStorage");

// ScriptStruct Nicola.UIStorage
// 0x0678 (0x0678 - 0x0000)
struct FUIStorage final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIBattleStorage                       Battle;                                            // 0x0038(0x01F0)(NativeAccessSpecifierPublic)
	struct FUIBattleRoadStorage                   BattleRoad;                                        // 0x0228(0x0098)(NativeAccessSpecifierPublic)
	struct FUISelectItemStorage                   SelectItem;                                        // 0x02C0(0x0060)(NativeAccessSpecifierPublic)
	struct FUIMessageTagStorage                   MessageTag;                                        // 0x0320(0x0208)(NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUISaveLoadStorage                     SaveLoad;                                          // 0x0530(0x0090)(NativeAccessSpecifierPublic)
	struct FUITitleMenuStorage                    title;                                             // 0x05C0(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMapMenuStorage                      MapMenu;                                           // 0x05D0(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIKeyboardStorage                     Keyboard;                                          // 0x05F8(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0xC];                                      // 0x0610(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIFieldMagicSkillMenuStorage          FieldMagicSkill;                                   // 0x061C(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x40];                                     // 0x0638(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIStorage) == 0x000008, "Wrong alignment on FUIStorage");
static_assert(sizeof(FUIStorage) == 0x000678, "Wrong size on FUIStorage");
static_assert(offsetof(FUIStorage, Battle) == 0x000038, "Member 'FUIStorage::Battle' has a wrong offset!");
static_assert(offsetof(FUIStorage, BattleRoad) == 0x000228, "Member 'FUIStorage::BattleRoad' has a wrong offset!");
static_assert(offsetof(FUIStorage, SelectItem) == 0x0002C0, "Member 'FUIStorage::SelectItem' has a wrong offset!");
static_assert(offsetof(FUIStorage, MessageTag) == 0x000320, "Member 'FUIStorage::MessageTag' has a wrong offset!");
static_assert(offsetof(FUIStorage, SaveLoad) == 0x000530, "Member 'FUIStorage::SaveLoad' has a wrong offset!");
static_assert(offsetof(FUIStorage, title) == 0x0005C0, "Member 'FUIStorage::title' has a wrong offset!");
static_assert(offsetof(FUIStorage, MapMenu) == 0x0005D0, "Member 'FUIStorage::MapMenu' has a wrong offset!");
static_assert(offsetof(FUIStorage, Keyboard) == 0x0005F8, "Member 'FUIStorage::Keyboard' has a wrong offset!");
static_assert(offsetof(FUIStorage, FieldMagicSkill) == 0x00061C, "Member 'FUIStorage::FieldMagicSkill' has a wrong offset!");

// ScriptStruct Nicola.TitleSublevelInfo
// 0x0030 (0x0030 - 0x0000)
struct FTitleSublevelInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDynamic*                 Streaming;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTitleSublevelInfo) == 0x000008, "Wrong alignment on FTitleSublevelInfo");
static_assert(sizeof(FTitleSublevelInfo) == 0x000030, "Wrong size on FTitleSublevelInfo");
static_assert(offsetof(FTitleSublevelInfo, Streaming) == 0x000028, "Member 'FTitleSublevelInfo::Streaming' has a wrong offset!");

// ScriptStruct Nicola.ObjectFlagVisibleInfo
// 0x0020 (0x0020 - 0x0000)
struct FObjectFlagVisibleInfo final
{
public:
	TArray<struct FFlagConditionData>             FlagConditionList;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EFlagOperator                                 FlagOperator;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlagEnableType                               FlagEnableType;                                    // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectFlagVisibleInfo) == 0x000008, "Wrong alignment on FObjectFlagVisibleInfo");
static_assert(sizeof(FObjectFlagVisibleInfo) == 0x000020, "Wrong size on FObjectFlagVisibleInfo");
static_assert(offsetof(FObjectFlagVisibleInfo, FlagConditionList) == 0x000000, "Member 'FObjectFlagVisibleInfo::FlagConditionList' has a wrong offset!");
static_assert(offsetof(FObjectFlagVisibleInfo, FlagOperator) == 0x000010, "Member 'FObjectFlagVisibleInfo::FlagOperator' has a wrong offset!");
static_assert(offsetof(FObjectFlagVisibleInfo, FlagEnableType) == 0x000011, "Member 'FObjectFlagVisibleInfo::FlagEnableType' has a wrong offset!");
static_assert(offsetof(FObjectFlagVisibleInfo, Tag) == 0x000014, "Member 'FObjectFlagVisibleInfo::Tag' has a wrong offset!");

}

