#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SequenceCamera

#include "Basic.hpp"

#include "SequenceCamera_classes.hpp"
#include "SequenceCamera_parameters.hpp"


namespace SDK
{

// Function SequenceCamera.SequenceCameraManager.MakeSequenceCameraTargetInfoByActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           targetActor_                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSequenceCameraTargetInfo        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSequenceCameraTargetInfo ASequenceCameraManager::MakeSequenceCameraTargetInfoByActor(class AActor* targetActor_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequenceCameraManager", "MakeSequenceCameraTargetInfoByActor");

	Params::SequenceCameraManager_MakeSequenceCameraTargetInfoByActor Parms{};

	Parms.targetActor_ = targetActor_;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequenceCamera.SequenceCameraManager.MakeSequenceCameraTargetInfoByTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          targetLocation_                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          targetForward_                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   targetRadius_                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSequenceCameraTargetInfo        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSequenceCameraTargetInfo ASequenceCameraManager::MakeSequenceCameraTargetInfoByTransform(const struct FVector& targetLocation_, const struct FVector& targetForward_, float targetRadius_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequenceCameraManager", "MakeSequenceCameraTargetInfoByTransform");

	Params::SequenceCameraManager_MakeSequenceCameraTargetInfoByTransform Parms{};

	Parms.targetLocation_ = std::move(targetLocation_);
	Parms.targetForward_ = std::move(targetForward_);
	Parms.targetRadius_ = targetRadius_;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequenceCamera.SequenceCameraManager.Blend
// (Native, Public, BlueprintCallable)

void ASequenceCameraManager::Blend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "Blend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.BlendIn
// (Native, Public, BlueprintCallable)

void ASequenceCameraManager::BlendIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "BlendIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.BlendInWithParam
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FViewTargetTransitionParams      InBlendParam_                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASequenceCameraManager::BlendInWithParam(const struct FViewTargetTransitionParams& InBlendParam_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "BlendInWithParam");

	Params::SequenceCameraManager_BlendInWithParam Parms{};

	Parms.InBlendParam_ = std::move(InBlendParam_);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.BlendOut
// (Native, Public, BlueprintCallable)

void ASequenceCameraManager::BlendOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "BlendOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.BlendOutWithParam
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FViewTargetTransitionParams      OutBlendParam_                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASequenceCameraManager::BlendOutWithParam(const struct FViewTargetTransitionParams& OutBlendParam_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "BlendOutWithParam");

	Params::SequenceCameraManager_BlendOutWithParam Parms{};

	Parms.OutBlendParam_ = std::move(OutBlendParam_);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.BlendWithParam
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FViewTargetTransitionParams      InBlendParam_                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FViewTargetTransitionParams      OutBlendParam_                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASequenceCameraManager::BlendWithParam(const struct FViewTargetTransitionParams& InBlendParam_, const struct FViewTargetTransitionParams& OutBlendParam_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "BlendWithParam");

	Params::SequenceCameraManager_BlendWithParam Parms{};

	Parms.InBlendParam_ = std::move(InBlendParam_);
	Parms.OutBlendParam_ = std::move(OutBlendParam_);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.EndSequence
// (Native, Public)

void ASequenceCameraManager::EndSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "EndSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.GetEventReceivers
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ASequenceCameraManager::GetEventReceivers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "GetEventReceivers");

	Params::SequenceCameraManager_GetEventReceivers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequenceCamera.SequenceCameraManager.OnCameraCut
// (Native, Public)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceCameraManager::OnCameraCut(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "OnCameraCut");

	Params::SequenceCameraManager_OnCameraCut Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.Pause
// (Native, Public, BlueprintCallable)

void ASequenceCameraManager::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.PauseSequence
// (Final, Native, Public, BlueprintCallable)

void ASequenceCameraManager::PauseSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "PauseSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.ResumeSequence
// (Final, Native, Public, BlueprintCallable)

void ASequenceCameraManager::ResumeSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "ResumeSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.StartSequence
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequenceCameraInfo              info_                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASequenceCameraManager::StartSequence(const struct FSequenceCameraInfo& info_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "StartSequence");

	Params::SequenceCameraManager_StartSequence Parms{};

	Parms.info_ = std::move(info_);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.StopSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   OutBlendTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceCameraManager::StopSequence(float OutBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "StopSequence");

	Params::SequenceCameraManager_StopSequence Parms{};

	Parms.OutBlendTime = OutBlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraManager.CheckInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSequenceCameraInfo              info_                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASequenceCameraManager::CheckInfo(const struct FSequenceCameraInfo& info_) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "CheckInfo");

	Params::SequenceCameraManager_CheckInfo Parms{};

	Parms.info_ = std::move(info_);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequenceCamera.SequenceCameraManager.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASequenceCameraManager::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraManager", "IsPlaying");

	Params::SequenceCameraManager_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequenceCamera.CameraModifier_BlendAroundActor.BlendIn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InBaseActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FViewTargetTransitionParams      TransitionParams                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EBlendCoordinate                        EBlendCoordinate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModifier_BlendAroundActor::BlendIn(class AActor* InBaseActor, const struct FViewTargetTransitionParams& TransitionParams, EBlendCoordinate EBlendCoordinate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModifier_BlendAroundActor", "BlendIn");

	Params::CameraModifier_BlendAroundActor_BlendIn Parms{};

	Parms.InBaseActor = InBaseActor;
	Parms.TransitionParams = std::move(TransitionParams);
	Parms.EBlendCoordinate = EBlendCoordinate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.CameraModifier_BlendAroundActor.BlendOut
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InBaseActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherCameraActor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FViewTargetTransitionParams      TransitionParams                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EBlendCoordinate                        EBlendCoordinate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModifier_BlendAroundActor::BlendOut(class AActor* InBaseActor, class AActor* InOtherCameraActor, const struct FViewTargetTransitionParams& TransitionParams, EBlendCoordinate EBlendCoordinate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModifier_BlendAroundActor", "BlendOut");

	Params::CameraModifier_BlendAroundActor_BlendOut Parms{};

	Parms.InBaseActor = InBaseActor;
	Parms.InOtherCameraActor = InOtherCameraActor;
	Parms.TransitionParams = std::move(TransitionParams);
	Parms.EBlendCoordinate = EBlendCoordinate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.NotifyCameraCutInterface.NotifyCameraCut
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void INotifyCameraCutInterface::NotifyCameraCut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotifyCameraCutInterface", "NotifyCameraCut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraBaseActor.BeginTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASequenceCameraManager*           man                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceCameraBaseActor::BeginTransform(class ASequenceCameraManager* man)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraBaseActor", "BeginTransform");

	Params::SequenceCameraBaseActor_BeginTransform Parms{};

	Parms.man = man;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraBaseActor.EndTransform
// (Final, Native, Public, BlueprintCallable)

void ASequenceCameraBaseActor::EndTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraBaseActor", "EndTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraBaseActor.SetTargetActorInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceCameraBaseActor::SetTargetActorInEditor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraBaseActor", "SetTargetActorInEditor");

	Params::SequenceCameraBaseActor_SetTargetActorInEditor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequenceCamera.SequenceCameraCenterBaseActor.SetCenterRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASequenceCameraCenterBaseActor::SetCenterRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequenceCameraCenterBaseActor", "SetCenterRate");

	Params::SequenceCameraCenterBaseActor_SetCenterRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

